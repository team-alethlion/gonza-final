{"version":3,"sources":["../../../../src/components/ui/input.tsx","../../../../prisma/db.ts","../../../../src/app/actions/auth.ts","../../../../src/components/auth/AuthProvider.tsx","../../../../src/hooks/use-toast.ts","../../../../src/app/actions/business.ts","../../../../src/hooks/useBusinessPassword.ts","../../../../src/contexts/BusinessContext.tsx"],"sourcesContent":["\r\nimport * as React from \"react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\r\n  ({ className, type, ...props }, ref) => {\r\n    // Add an onWheel event handler to prevent scrolling from changing the value\r\n    const handleWheel = (e: React.WheelEvent<HTMLInputElement>) => {\r\n      // Prevent the default behavior only for number inputs\r\n      if (type === 'number') {\r\n        e.currentTarget.blur(); // Remove focus to prevent scroll changes\r\n      }\r\n    };\r\n\r\n    return (\r\n      <input\r\n        type={type}\r\n        className={cn(\r\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\r\n          // Add specific styling to remove spinner arrows from number inputs\r\n          type === 'number' && \"[appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none\",\r\n          className\r\n        )}\r\n        onWheel={type === 'number' ? handleWheel : undefined}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    )\r\n  }\r\n)\r\nInput.displayName = \"Input\"\r\n\r\nexport { Input }\r\n","\r\nimport { \r\n  PrismaClient, \r\n  Prisma,\r\n  BranchType, \r\n  SaleSource, \r\n  PaymentStatus, \r\n  DiscountType, \r\n  ProductHistoryType, \r\n  TransferStatus, \r\n  RequisitionStatus, \r\n  TaskPriority, \r\n  TaskStatus, \r\n  RecurrenceType, \r\n  ActivityType, \r\n  ActivityModule,\r\n  // Models\r\n  User, \r\n  Role, \r\n  BranchSettings, \r\n  Task, \r\n  ActivityHistory, \r\n  Sale, \r\n  SaleItem, \r\n  Expense, \r\n  ExpenseCategory, \r\n  CashAccount, \r\n  CashTransaction,\r\n  Branch,\r\n  Product,\r\n  Customer,\r\n  Campaign,\r\n  Message,\r\n  MessageTemplate,\r\n  WhatsAppSession,\r\n  Transaction,\r\n  Category,\r\n  Supplier,\r\n  SaleCategory,\r\n  StockTransfer,\r\n  StockTransferItem,\r\n  Requisition,\r\n  RequisitionItem,\r\n  TaskCategory,\r\n  InstallmentPayment,\r\n  RefreshToken,\r\n  Permission,\r\n  Account,\r\n  ProductHistory,\r\n  PasswordResetToken\r\n} from '@prisma/client';\r\nimport { Pool } from 'pg';\r\nimport { PrismaPg } from '@prisma/adapter-pg';\r\nimport 'dotenv/config';\r\n\r\nconst connectionString = process.env.DATABASE_URL;\r\n\r\nconst pool = new Pool({ connectionString });\r\nconst adapter = new PrismaPg(pool);\r\n\r\nconst globalForPrisma = global as unknown as { prisma?: PrismaClient };\r\n\r\n// Force re-initialization if new models like 'branch' or 'productHistory' are missing from the cached instance\r\nconst isStale = globalForPrisma.prisma && (!('branch' in globalForPrisma.prisma) || !('productHistory' in globalForPrisma.prisma));\r\n\r\nexport const db =\r\n  (globalForPrisma.prisma && !isStale) ?\r\n    globalForPrisma.prisma :\r\n    new PrismaClient({\r\n      adapter,\r\n      log: ['error', 'warn'],\r\n    });\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  globalForPrisma.prisma = db;\r\n}\r\n\r\nexport { \r\n  PrismaClient, \r\n  Prisma,\r\n  BranchType, \r\n  SaleSource, \r\n  PaymentStatus, \r\n  DiscountType, \r\n  ProductHistoryType, \r\n  TransferStatus, \r\n  RequisitionStatus, \r\n  TaskPriority, \r\n  TaskStatus, \r\n  RecurrenceType, \r\n  ActivityType, \r\n  ActivityModule \r\n};\r\n\r\nexport type { \r\n  User, \r\n  Role, \r\n  BranchSettings, \r\n  Task, \r\n  ActivityHistory, \r\n  Sale, \r\n  SaleItem, \r\n  Expense, \r\n  ExpenseCategory, \r\n  CashAccount, \r\n  CashTransaction,\r\n  Branch,\r\n  Product,\r\n  Customer,\r\n  Campaign,\r\n  Message,\r\n  MessageTemplate,\r\n  WhatsAppSession,\r\n  Transaction,\r\n  Category,\r\n  Supplier,\r\n  SaleCategory,\r\n  StockTransfer,\r\n  StockTransferItem,\r\n  Requisition,\r\n  RequisitionItem,\r\n  TaskCategory,\r\n  InstallmentPayment,\r\n  RefreshToken,\r\n  Permission,\r\n  Account,\r\n  ProductHistory,\r\n  PasswordResetToken\r\n};","'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { hash, compare } from 'bcryptjs';\r\n\r\nexport async function signUpAction(data: any) {\r\n    try {\r\n        const { email, password, name } = data;\r\n\r\n        // Check if user already exists\r\n        const existingUser = await db.user.findUnique({\r\n            where: { email }\r\n        });\r\n\r\n        if (existingUser) {\r\n            return { success: false, error: \"User already exists\" };\r\n        }\r\n\r\n        const hashedPassword = await hash(password, 10);\r\n\r\n        // Find or create a default role (assuming \"Admin\" for the first user or similar)\r\n        let role = await db.role.findFirst({\r\n            where: { name: \"Admin\" }\r\n        });\r\n\r\n        if (!role) {\r\n            role = await db.role.create({\r\n                data: { name: \"Admin\", description: \"Default Admin Role\" }\r\n            });\r\n        }\r\n\r\n        const user = await db.user.create({\r\n            data: {\r\n                email,\r\n                password: hashedPassword,\r\n                name,\r\n                roleId: role.id\r\n            }\r\n        });\r\n\r\n        return { success: true, user: { id: user.id, email: user.email } };\r\n    } catch (error: any) {\r\n        console.error('Error in signUpAction:', error);\r\n        return { success: false, error: error.message || 'Failed to sign up' };\r\n    }\r\n}\r\n\r\nexport async function signInAction(email: string, password: string) {\r\n    try {\r\n        const user = await db.user.findUnique({\r\n            where: { email },\r\n            include: { role: true }\r\n        });\r\n\r\n        if (!user || !user.password) {\r\n            return { success: false, error: \"Invalid email or password\" };\r\n        }\r\n\r\n        const isPasswordValid = await compare(password, user.password);\r\n\r\n        if (!isPasswordValid) {\r\n            return { success: false, error: \"Invalid email or password\" };\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            user: {\r\n                id: user.id,\r\n                email: user.email,\r\n                name: user.name,\r\n                role: user.role?.name\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error in signInAction:', error);\r\n        return { success: false, error: error.message || 'Failed to sign in' };\r\n    }\r\n}\r\n\r\nexport async function resetPasswordAction(newPassword: string, resetToken?: string) {\r\n    try {\r\n        if (!resetToken) {\r\n            return { success: false, error: \"Reset token is missing or invalid\" };\r\n        }\r\n\r\n        // Ideally here you'd verify the resetToken against a secure token store \r\n        // For the sake of this migration, we are bypassing token verification logic \r\n        // to focus on Prisma replacement for Supabase. This logic MUST be updated.\r\n        const userId = \"extract-from-token\";\r\n\r\n        // Hash the new password before storing it\r\n        const hashedPassword = await hash(newPassword, 10);\r\n\r\n        // Update the password in database\r\n        // await db.user.update({\r\n        //     where: { id: userId },\r\n        //     data: {\r\n        //         password: hashedPassword // Assuming you add a password field to the User model\r\n        //     }\r\n        // });\r\n\r\n        // Note: For actual proper authentication you'd integrate this closely with NextAuth\r\n        // and its reset password flow (which usually involves sending a new verification token \r\n        // and updating credentials).\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error resetting password:', error);\r\n        return { success: false, error: error.message || 'Failed to reset password' };\r\n    }\r\n}\r\n\r\nexport async function signOutAction() {\r\n    // With NextAuth, signing out is handled by the `signOut` function from `next-auth/react`\r\n    // on the client side. We don't strictly need a server action for this if we use NextAuth. \r\n    // Adding a dummy action here to satisfy the `ResetPassword` component's import.\r\n    console.log(\"signOutAction called. If using NextAuth, call client-side signOut() instead.\");\r\n    return { success: true };\r\n}\r\n","import * as React from 'react';\r\nimport { useState, useContext, createContext, useEffect } from 'react';\r\nimport { toast } from 'sonner';\r\n\r\nimport { signInAction, signUpAction } from '@/app/actions/auth';\r\n\r\n// Simplified type declarations for our mock\r\ninterface User {\r\n  id: string;\r\n  email?: string;\r\n}\r\n\r\ninterface AuthContextType {\r\n  user: User | null;\r\n  loading: boolean;\r\n  signIn: (email: string, password: string) => Promise<void>;\r\n  signInWithGoogle: () => Promise<void>;\r\n  signUp: (email: string, password: string, options?: { data?: Record<string, any> }) => Promise<{ error: Error | null; user?: User | null }>;\r\n  signOut: () => Promise<void>;\r\n  resetPassword: (email: string) => Promise<void>;\r\n}\r\n\r\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\r\n\r\nexport const AuthProvider = ({ children }: { children: React.ReactNode }) => {\r\n  const [user, setUser] = useState<User | null>(null);\r\n  const [loading, setLoading] = useState(true);\r\n\r\n  // Auto-login for development while migrating\r\n  useEffect(() => {\r\n    // Check if user is logged in\r\n    const storedUser = localStorage.getItem('gonza_user');\r\n    if (storedUser) {\r\n      setUser(JSON.parse(storedUser));\r\n    }\r\n    setLoading(false);\r\n  }, []);\r\n\r\n  const signIn = async (email: string, password: string) => {\r\n    const result = await signInAction(email, password);\r\n    if (result.success && result.user) {\r\n      const userData = { id: result.user.id, email: result.user.email };\r\n      setUser(userData);\r\n      localStorage.setItem('gonza_user', JSON.stringify(userData));\r\n      toast.success('Signed in successfully');\r\n    } else {\r\n      throw new Error(result.error || 'Login failed');\r\n    }\r\n  };\r\n\r\n  const signInWithGoogle = async () => {\r\n    // Mock for now, will integrate with actual OAuth later\r\n    toast.error('Google sign-in not yet implemented with Prisma');\r\n  };\r\n\r\n  const signUp = async (email: string, password: string, options?: { data?: Record<string, any> }) => {\r\n    const result = await signUpAction({ email, password, name: options?.data?.name });\r\n    if (result.success && result.user) {\r\n      toast.success('Account created successfully. Please sign in.');\r\n      return { error: null, user: result.user };\r\n    } else {\r\n      return { error: new Error(result.error || 'Sign up failed'), user: null };\r\n    }\r\n  };\r\n\r\n  const signOut = async () => {\r\n    setUser(null);\r\n    localStorage.removeItem('gonza_user');\r\n    toast.success('Successfully signed out');\r\n  };\r\n\r\n  const resetPassword = async (email: string) => {\r\n    toast.success('Password reset email sent');\r\n  };\r\n\r\n  return (\r\n    <AuthContext.Provider value={{\r\n      user,\r\n      loading,\r\n      signIn,\r\n      signInWithGoogle,\r\n      signUp,\r\n      signOut,\r\n      resetPassword\r\n    }}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useAuth = () => {\r\n  const context = useContext(AuthContext);\r\n  if (context === undefined) {\r\n    throw new Error('useAuth must be used within an AuthProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n","\"use client\"\r\n\r\nimport * as React from \"react\"\r\n\r\nimport type {\r\n  ToastActionElement,\r\n  ToastProps,\r\n} from \"@/components/ui/toast\"\r\n\r\nconst TOAST_LIMIT = 1\r\nconst TOAST_REMOVE_DELAY = 1000000\r\n\r\ntype ToasterToast = ToastProps & {\r\n  id: string\r\n  title?: React.ReactNode\r\n  description?: React.ReactNode\r\n  action?: ToastActionElement\r\n}\r\n\r\nconst actionTypes = {\r\n  ADD_TOAST: \"ADD_TOAST\",\r\n  UPDATE_TOAST: \"UPDATE_TOAST\",\r\n  DISMISS_TOAST: \"DISMISS_TOAST\",\r\n  REMOVE_TOAST: \"REMOVE_TOAST\",\r\n} as const\r\n\r\nlet count = 0\r\n\r\nfunction genId() {\r\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\r\n  return count.toString()\r\n}\r\n\r\ntype ActionType = typeof actionTypes\r\n\r\ntype Action =\r\n  | {\r\n    type: ActionType[\"ADD_TOAST\"]\r\n    toast: ToasterToast\r\n  }\r\n  | {\r\n    type: ActionType[\"UPDATE_TOAST\"]\r\n    toast: Partial<ToasterToast>\r\n  }\r\n  | {\r\n    type: ActionType[\"DISMISS_TOAST\"]\r\n    toastId?: ToasterToast[\"id\"]\r\n  }\r\n  | {\r\n    type: ActionType[\"REMOVE_TOAST\"]\r\n    toastId?: ToasterToast[\"id\"]\r\n  }\r\n\r\ninterface State {\r\n  toasts: ToasterToast[]\r\n}\r\n\r\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\r\n\r\nconst addToRemoveQueue = (toastId: string) => {\r\n  if (toastTimeouts.has(toastId)) {\r\n    return\r\n  }\r\n\r\n  const timeout = setTimeout(() => {\r\n    toastTimeouts.delete(toastId)\r\n    dispatch({\r\n      type: \"REMOVE_TOAST\",\r\n      toastId: toastId,\r\n    })\r\n  }, TOAST_REMOVE_DELAY)\r\n\r\n  toastTimeouts.set(toastId, timeout)\r\n}\r\n\r\nexport const reducer = (state: State, action: Action): State => {\r\n  switch (action.type) {\r\n    case \"ADD_TOAST\":\r\n      return {\r\n        ...state,\r\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\r\n      }\r\n\r\n    case \"UPDATE_TOAST\":\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.map((t) =>\r\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\r\n        ),\r\n      }\r\n\r\n    case \"DISMISS_TOAST\": {\r\n      const { toastId } = action\r\n\r\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\r\n      // but I'll keep it here for simplicity\r\n      if (toastId) {\r\n        addToRemoveQueue(toastId)\r\n      } else {\r\n        state.toasts.forEach((toast) => {\r\n          addToRemoveQueue(toast.id)\r\n        })\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.map((t) =>\r\n          t.id === toastId || toastId === undefined\r\n            ? {\r\n              ...t,\r\n              open: false,\r\n            }\r\n            : t\r\n        ),\r\n      }\r\n    }\r\n    case \"REMOVE_TOAST\":\r\n      if (action.toastId === undefined) {\r\n        return {\r\n          ...state,\r\n          toasts: [],\r\n        }\r\n      }\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\r\n      }\r\n  }\r\n}\r\n\r\nconst listeners: Array<(state: State) => void> = []\r\n\r\nlet memoryState: State = { toasts: [] }\r\n\r\nfunction dispatch(action: Action) {\r\n  memoryState = reducer(memoryState, action)\r\n  listeners.forEach((listener) => {\r\n    listener(memoryState)\r\n  })\r\n}\r\n\r\ntype Toast = Omit<ToasterToast, \"id\">\r\n\r\nfunction toast({ ...props }: Toast) {\r\n  const id = genId()\r\n\r\n  const update = (props: ToasterToast) =>\r\n    dispatch({\r\n      type: \"UPDATE_TOAST\",\r\n      toast: { ...props, id },\r\n    })\r\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\r\n\r\n  dispatch({\r\n    type: \"ADD_TOAST\",\r\n    toast: {\r\n      ...props,\r\n      id,\r\n      open: true,\r\n      onOpenChange: (open) => {\r\n        if (!open) dismiss()\r\n      },\r\n    },\r\n  })\r\n\r\n  return {\r\n    id: id,\r\n    dismiss,\r\n    update,\r\n  }\r\n}\r\n\r\nfunction useToast() {\r\n  const [state, setState] = React.useState<State>(memoryState)\r\n\r\n  React.useEffect(() => {\r\n    listeners.push(setState)\r\n    return () => {\r\n      const index = listeners.indexOf(setState)\r\n      if (index > -1) {\r\n        listeners.splice(index, 1)\r\n      }\r\n    }\r\n  }, [state])\r\n\r\n  return {\r\n    ...state,\r\n    toast,\r\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\r\n  }\r\n}\r\n\r\nexport { useToast, toast }\r\n","'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessLocationsAction(userId: string) {\r\n    try {\r\n        const branches = await db.branch.findMany({\r\n            where: {\r\n                adminId: userId\r\n            },\r\n            orderBy: [\r\n                {\r\n                    createdAt: 'desc'\r\n                },\r\n                {\r\n                    name: 'asc'\r\n                }\r\n            ]\r\n        });\r\n\r\n        // The previous context expected an is_default field, but it's not in the model.\r\n        // We will make the first branch the default if is_default is missing.\r\n        return branches.map((b: any, index: number) => ({\r\n            id: b.id,\r\n            name: b.name,\r\n            user_id: b.adminId,\r\n            is_default: index === 0, // Mocking is_default\r\n            created_at: b.createdAt.toISOString(),\r\n            updated_at: b.updatedAt.toISOString(),\r\n            switch_password_hash: b.accessPassword\r\n        }));\r\n    } catch (error) {\r\n        console.error('Error fetching business locations:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function createBusinessAction(userId: string, name: string) {\r\n    try {\r\n        const branch = await db.branch.create({\r\n            data: {\r\n                name: name,\r\n                location: 'Main Location', // Default location\r\n                adminId: userId\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: branch.id,\r\n                name: branch.name,\r\n                user_id: branch.adminId,\r\n                is_default: false,\r\n                created_at: branch.createdAt.toISOString(),\r\n                updated_at: branch.updatedAt.toISOString(),\r\n                switch_password_hash: branch.accessPassword\r\n            }\r\n        };\r\n    } catch (error) {\r\n        console.error('Error creating business:', error);\r\n        return { success: false, error: 'Failed to create business' };\r\n    }\r\n}\r\n\r\nexport async function updateBusinessAction(id: string, userId: string, name: string) {\r\n    try {\r\n        const branch = await db.branch.update({\r\n            where: {\r\n                id: id,\r\n                adminId: userId\r\n            },\r\n            data: {\r\n                name: name\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: branch.id,\r\n                name: branch.name,\r\n                user_id: branch.adminId,\r\n                is_default: false, // Update logic handles defaultness elsewhere\r\n                created_at: branch.createdAt.toISOString(),\r\n                updated_at: branch.updatedAt.toISOString(),\r\n                switch_password_hash: branch.accessPassword\r\n            }\r\n        };\r\n    } catch (error) {\r\n        console.error('Error updating business:', error);\r\n        return { success: false, error: 'Failed to update business' };\r\n    }\r\n}\r\n\r\nexport async function deleteBusinessAction(id: string, userId: string) {\r\n    try {\r\n        await db.branch.delete({\r\n            where: {\r\n                id: id,\r\n                adminId: userId\r\n            }\r\n        });\r\n\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error('Error deleting business:', error);\r\n        return { success: false, error: 'Failed to delete business' };\r\n    }\r\n}\r\n\r\n// --- BUSINESS RESET ---\r\n\r\nexport async function resetBusinessAction(id: string, userId: string) {\r\n    try {\r\n        // Delete all business data in a transaction (products, sales, stock history, etc.)\r\n        await db.$transaction(async (tx: any) => {\r\n            // Delete stock history first (references products)\r\n            await tx.productHistory.deleteMany({ where: { locationId: id } });\r\n            // Delete sale items related data\r\n            await tx.sale.deleteMany({ where: { branchId: id } });\r\n            // Delete products\r\n            await tx.product.deleteMany({ where: { branchId: id } });\r\n            // Delete customers\r\n            await tx.customer.deleteMany({ where: { branchId: id } });\r\n            // Delete activity history\r\n            await tx.activityHistory.deleteMany({ where: { branchId: id } });\r\n        });\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error resetting business:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- BUSINESS PASSWORD ---\r\n\r\nimport bcrypt from 'bcryptjs';\r\n\r\nexport async function setBusinessPasswordAction(businessId: string, password: string) {\r\n    try {\r\n        const hash = await bcrypt.hash(password, 10);\r\n        await db.branch.update({\r\n            where: { id: businessId },\r\n            data: { accessPassword: hash }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error setting business password:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function verifyBusinessPasswordAction(businessId: string, password: string) {\r\n    try {\r\n        const branch = await db.branch.findUnique({\r\n            where: { id: businessId },\r\n            select: { accessPassword: true }\r\n        });\r\n\r\n        if (!branch?.accessPassword) {\r\n            return { success: true, verified: true }; // No password set\r\n        }\r\n\r\n        const verified = await bcrypt.compare(password, branch.accessPassword);\r\n        return { success: true, verified };\r\n    } catch (error: any) {\r\n        console.error('Error verifying business password:', error);\r\n        return { success: false, verified: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function removeBusinessPasswordAction(businessId: string) {\r\n    try {\r\n        await db.branch.update({\r\n            where: { id: businessId },\r\n            data: { accessPassword: null }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error removing business password:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n","\r\nimport { useState } from 'react';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { setBusinessPasswordAction, verifyBusinessPasswordAction, removeBusinessPasswordAction } from '@/app/actions/business';\r\n\r\nexport const useBusinessPassword = () => {\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const { toast } = useToast();\r\n\r\n  const VERIFIED_BUSINESSES_KEY = 'verified_businesses';\r\n\r\n  const getVerifiedBusinesses = (): Set<string> => {\r\n    try {\r\n      const stored = sessionStorage.getItem(VERIFIED_BUSINESSES_KEY);\r\n      return stored ? new Set(JSON.parse(stored)) : new Set();\r\n    } catch {\r\n      return new Set();\r\n    }\r\n  };\r\n\r\n  const setBusinessVerified = (businessId: string) => {\r\n    try {\r\n      const verified = getVerifiedBusinesses();\r\n      verified.add(businessId);\r\n      sessionStorage.setItem(VERIFIED_BUSINESSES_KEY, JSON.stringify(Array.from(verified)));\r\n    } catch (error) {\r\n      console.error('Error storing verified business:', error);\r\n    }\r\n  };\r\n\r\n  const isBusinessVerified = (businessId: string): boolean => {\r\n    return getVerifiedBusinesses().has(businessId);\r\n  };\r\n\r\n  const clearVerifiedBusinesses = () => {\r\n    try {\r\n      sessionStorage.removeItem(VERIFIED_BUSINESSES_KEY);\r\n    } catch (error) {\r\n      console.error('Error clearing verified businesses:', error);\r\n    }\r\n  };\r\n\r\n  const setBusinessPassword = async (businessId: string, password: string): Promise<boolean> => {\r\n    setIsLoading(true);\r\n    try {\r\n      const result = await setBusinessPasswordAction(businessId, password);\r\n      if (result.success) {\r\n        toast({ title: 'Password Set Successfully', description: 'Your business is now password protected.' });\r\n        return true;\r\n      } else {\r\n        toast({ title: 'Failed to Set Password', description: result.error || 'Please try again later.', variant: 'destructive' });\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error setting business password:', error);\r\n      toast({ title: 'Failed to Set Password', description: 'An unexpected error occurred.', variant: 'destructive' });\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const verifyBusinessPassword = async (businessId: string, password: string): Promise<boolean> => {\r\n    setIsLoading(true);\r\n    try {\r\n      const result = await verifyBusinessPasswordAction(businessId, password);\r\n      if (result.success && result.verified) {\r\n        setBusinessVerified(businessId);\r\n        return true;\r\n      } else {\r\n        toast({ title: 'Incorrect Password', description: 'The password you entered is incorrect.', variant: 'destructive' });\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error verifying business password:', error);\r\n      toast({ title: 'Verification Error', description: 'An unexpected error occurred.', variant: 'destructive' });\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const removeBusinessPassword = async (businessId: string): Promise<boolean> => {\r\n    setIsLoading(true);\r\n    try {\r\n      const result = await removeBusinessPasswordAction(businessId);\r\n      if (result.success) {\r\n        const verified = getVerifiedBusinesses();\r\n        verified.delete(businessId);\r\n        sessionStorage.setItem(VERIFIED_BUSINESSES_KEY, JSON.stringify(Array.from(verified)));\r\n        return true;\r\n      } else {\r\n        toast({ title: 'Failed to Remove Password', description: result.error || 'Please try again later.', variant: 'destructive' });\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error removing business password:', error);\r\n      toast({ title: 'Failed to Remove Password', description: 'Please try again later.', variant: 'destructive' });\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  return {\r\n    isLoading,\r\n    setBusinessPassword,\r\n    verifyBusinessPassword,\r\n    removeBusinessPassword,\r\n    isBusinessVerified,\r\n    setBusinessVerified,\r\n    clearVerifiedBusinesses,\r\n  };\r\n};","import React, { createContext, useContext, useState, useEffect } from 'react';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusinessPassword } from '@/hooks/useBusinessPassword';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { toast } from '@/hooks/use-toast';\r\nimport { getBusinessLocationsAction, createBusinessAction, updateBusinessAction, deleteBusinessAction, resetBusinessAction } from '@/app/actions/business';\r\n\r\n\r\nexport interface BusinessLocation {\r\n  id: string;\r\n  name: string;\r\n  is_default: boolean;\r\n  created_at: string;\r\n  updated_at: string;\r\n  switch_password_hash?: string;\r\n}\r\n\r\ninterface BusinessContextType {\r\n  currentBusiness: BusinessLocation | null;\r\n  businessLocations: BusinessLocation[];\r\n  switchBusiness: (businessId: string, onPasswordPrompt?: (businessId: string, businessName: string, onVerified: () => void) => void) => void;\r\n  loadBusinessLocations: () => Promise<void>;\r\n  createBusiness: (name: string) => Promise<BusinessLocation | null>;\r\n  updateBusiness: (id: string, name: string) => Promise<boolean>;\r\n  deleteBusiness: (id: string) => Promise<boolean>;\r\n  resetBusiness: (id: string) => Promise<boolean>;\r\n  isLoading: boolean;\r\n  error: string | null;\r\n  locationLimit: number;\r\n}\r\n\r\nconst BusinessContext = createContext<BusinessContextType | undefined>(undefined);\r\n\r\nexport const useBusiness = () => {\r\n  const context = useContext(BusinessContext);\r\n  if (context === undefined) {\r\n    throw new Error('useBusiness must be used within a BusinessProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\nexport const BusinessProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\r\n  const { user } = useAuth();\r\n  const [currentBusiness, setCurrentBusiness] = useState<BusinessLocation | null>(null);\r\n  const [businessLocations, setBusinessLocations] = useState<BusinessLocation[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const { isBusinessVerified } = useBusinessPassword();\r\n\r\n  // Static default â€“ limit can be driven from Prisma user profile if needed.\r\n  const locationLimit = 3;\r\n\r\n\r\n  const loadBusinessLocations = async () => {\r\n    if (!user) {\r\n      setIsLoading(false);\r\n      setError(null);\r\n      setCurrentBusiness(null);\r\n      setBusinessLocations([]);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      const data = await getBusinessLocationsAction(user.id);\r\n\r\n      if (!data) {\r\n        throw new Error('Failed to load locations');\r\n      }\r\n\r\n      setBusinessLocations((data as any) || []);\r\n\r\n      // Always try to set a current business if we have locations\r\n      if (data && data.length > 0) {\r\n        // First check localStorage for saved business\r\n        const savedBusinessId = localStorage.getItem('currentBusinessId');\r\n        let businessToSet = (data as any[]).find(b => b.id === savedBusinessId);\r\n\r\n        // If no saved business or saved business not found, use default or first\r\n        if (!businessToSet) {\r\n          businessToSet = (data as any[]).find(b => b.is_default) || data[0];\r\n        }\r\n\r\n        if (businessToSet) {\r\n          setCurrentBusiness(businessToSet);\r\n          localStorage.setItem('currentBusinessId', businessToSet.id);\r\n        }\r\n      } else {\r\n        // No business locations found, clear current business\r\n        setCurrentBusiness(null);\r\n        localStorage.removeItem('currentBusinessId');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading business locations:', error);\r\n      setError('Failed to load business data');\r\n      setCurrentBusiness(null);\r\n      setBusinessLocations([]);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const switchBusiness = (businessId: string, onPasswordPrompt?: (businessId: string, businessName: string, onVerified: () => void) => void) => {\r\n    const business = businessLocations.find(b => b.id === businessId);\r\n    if (!business) {\r\n      console.error('Business not found:', businessId);\r\n      return;\r\n    }\r\n\r\n    // If business has password protection and is not verified in this session\r\n    if (business.switch_password_hash && !isBusinessVerified(businessId)) {\r\n      if (onPasswordPrompt) {\r\n        onPasswordPrompt(businessId, business.name, () => {\r\n          // This callback is called after successful password verification\r\n          setCurrentBusiness(business);\r\n          localStorage.setItem('currentBusinessId', business.id);\r\n        });\r\n        return;\r\n      } else {\r\n        console.warn('Password required but no prompt handler provided');\r\n        return;\r\n      }\r\n    }\r\n\r\n    // No password protection or already verified\r\n    setCurrentBusiness(business);\r\n    localStorage.setItem('currentBusinessId', business.id);\r\n  };\r\n\r\n  const createBusiness = async (name: string): Promise<BusinessLocation | null> => {\r\n    if (!user) {\r\n      console.error('No user found when creating business');\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      // Check location limit\r\n      if (businessLocations.length >= locationLimit) {\r\n        toast({\r\n          title: \"Limit Reached\",\r\n          description: `You have reached the maximum allowed limit of ${locationLimit} locations. Please contact support to increase your limit.`,\r\n          variant: \"destructive\"\r\n        });\r\n        return null;\r\n      }\r\n\r\n      const response = await createBusinessAction(user.id, name.trim());\r\n\r\n      if (!response.success || !response.data) {\r\n        console.error('Error creating business:', response.error);\r\n        throw new Error(response.error || 'Unknown error');\r\n      }\r\n\r\n      const data = response.data;\r\n\r\n      if (data) {\r\n        const newBusiness: BusinessLocation = {\r\n          id: (data as any).id,\r\n          name: (data as any).name,\r\n          is_default: (data as any).is_default,\r\n          created_at: (data as any).created_at,\r\n          updated_at: (data as any).updated_at,\r\n          switch_password_hash: (data as any).switch_password_hash\r\n        };\r\n\r\n        setBusinessLocations(prev => [...prev, newBusiness]);\r\n\r\n        // If this is the first business or it's set as default, make it current\r\n        if (businessLocations.length === 0 || newBusiness.is_default) {\r\n          setCurrentBusiness(newBusiness);\r\n          localStorage.setItem('currentBusinessId', newBusiness.id);\r\n        }\r\n\r\n        return newBusiness;\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error creating business:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updateBusiness = async (id: string, name: string): Promise<boolean> => {\r\n    if (!user) return false;\r\n\r\n    try {\r\n      const response = await updateBusinessAction(id, user.id, name);\r\n\r\n      if (!response.success) {\r\n        throw new Error(response.error);\r\n      }\r\n\r\n      const data = response.data;\r\n\r\n      if (data) {\r\n        const updatedBusiness: BusinessLocation = {\r\n          id: (data as any).id,\r\n          name: (data as any).name,\r\n          is_default: (data as any).is_default,\r\n          created_at: (data as any).created_at,\r\n          updated_at: (data as any).updated_at,\r\n          switch_password_hash: (data as any).switch_password_hash\r\n        };\r\n\r\n        setBusinessLocations(prev => prev.map(b => b.id === id ? updatedBusiness : b));\r\n\r\n        if (currentBusiness?.id === id) {\r\n          setCurrentBusiness(updatedBusiness);\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    } catch (error) {\r\n      console.error('Error updating business:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteBusiness = async (id: string): Promise<boolean> => {\r\n    if (!user) return false;\r\n\r\n    try {\r\n      const response = await deleteBusinessAction(id, user.id);\r\n\r\n      if (!response.success) throw new Error(response.error);\r\n\r\n      setBusinessLocations(prev => prev.filter(b => b.id !== id));\r\n\r\n      // If deleted business was current, switch to default or first available\r\n      if (currentBusiness?.id === id) {\r\n        const remaining = businessLocations.filter(b => b.id !== id);\r\n        const defaultBusiness = remaining.find(b => b.is_default);\r\n        const nextBusiness = defaultBusiness || remaining[0] || null;\r\n\r\n        setCurrentBusiness(nextBusiness);\r\n        if (nextBusiness) {\r\n          localStorage.setItem('currentBusinessId', nextBusiness.id);\r\n        } else {\r\n          localStorage.removeItem('currentBusinessId');\r\n        }\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting business:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const resetBusiness = async (id: string): Promise<boolean> => {\r\n    if (!user) {\r\n      console.error('No user found when resetting business');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const response = await resetBusinessAction(id, user.id);\r\n      if (!response.success) throw new Error(response.error);\r\n\r\n      // Reload business locations to refresh the data\r\n      await loadBusinessLocations();\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error resetting business:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (user) {\r\n      loadBusinessLocations();\r\n    } else {\r\n      setCurrentBusiness(null);\r\n      setBusinessLocations([]);\r\n      setIsLoading(false);\r\n      setError(null);\r\n      localStorage.removeItem('currentBusinessId');\r\n    }\r\n  }, [user?.id]);\r\n\r\n  return (\r\n    <BusinessContext.Provider\r\n      value={{\r\n        currentBusiness,\r\n        businessLocations,\r\n        switchBusiness,\r\n        loadBusinessLocations,\r\n        createBusiness,\r\n        updateBusiness,\r\n        deleteBusiness,\r\n        resetBusiness,\r\n        isLoading,\r\n        error,\r\n        locationLimit\r\n      }}\r\n    >\r\n      {children}\r\n    </BusinessContext.Provider>\r\n  );\r\n};\r\n"],"names":[],"mappings":"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"}