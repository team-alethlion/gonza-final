{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoXsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,8DAAA"}},
    {"offset": {"line": 18, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAyYsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 32, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA2ZsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0asB,yBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useCategories.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\nimport { ProductCategory } from '@/types';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport {\r\n  getProductCategoriesAction,\r\n  createProductCategoryAction,\r\n  updateProductCategoryAction,\r\n  deleteProductCategoryAction\r\n} from '@/app/actions/products';\r\n\r\nexport const useCategories = (userId: string | undefined) => {\r\n  const [categories, setCategories] = useState<ProductCategory[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const loadCategories = useCallback(async () => {\r\n    try {\r\n      if (!currentBusiness?.id) {\r\n        setCategories([]);\r\n        setIsLoading(false);\r\n        return;\r\n      }\r\n\r\n      setIsLoading(true);\r\n      const result = await getProductCategoriesAction(currentBusiness.id);\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error || 'Failed to fetch categories');\r\n      }\r\n\r\n      const formattedCategories: ProductCategory[] = result.data.map((item: any) => ({\r\n        id: item.id,\r\n        name: item.name,\r\n        createdAt: item.createdAt ? new Date(item.createdAt) : (item.created_at ? new Date(item.created_at) : undefined)\r\n      }));\r\n\r\n      setCategories(formattedCategories);\r\n    } catch (error) {\r\n      console.error('Error loading categories:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load product categories.\",\r\n        variant: \"destructive\"\r\n      });\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [currentBusiness?.id, toast]);\r\n\r\n  useEffect(() => {\r\n    loadCategories();\r\n  }, [loadCategories]);\r\n\r\n  const createCategory = async (name: string) => {\r\n    try {\r\n      if (!userId || !currentBusiness?.id) return null;\r\n\r\n      // Check if category already exists\r\n      const existingCategory = categories.find(\r\n        cat => cat.name.toLowerCase() === name.toLowerCase()\r\n      );\r\n\r\n      if (existingCategory) {\r\n        toast({\r\n          title: \"Category exists\",\r\n          description: \"This category already exists.\",\r\n        });\r\n        return existingCategory;\r\n      }\r\n\r\n      const result = await createProductCategoryAction(currentBusiness.id, userId, name);\r\n\r\n      if (!result.success || !result.data) throw new Error(result.error);\r\n\r\n      const newCategory: ProductCategory = {\r\n        id: result.data.id,\r\n        name: result.data.name,\r\n        createdAt: new Date(result.data.createdAt)\r\n      };\r\n\r\n      setCategories(prev => [...prev, newCategory]);\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Category created successfully\"\r\n      });\r\n      return newCategory;\r\n    } catch (error) {\r\n      console.error('Error creating category:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to create category.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updateCategory = async (id: string, name: string) => {\r\n    try {\r\n      // Check if another category with this name exists\r\n      const existingCategory = categories.find(\r\n        cat => cat.name.toLowerCase() === name.toLowerCase() && cat.id !== id\r\n      );\r\n\r\n      if (existingCategory) {\r\n        toast({\r\n          title: \"Category exists\",\r\n          description: \"Another category with this name already exists.\",\r\n        });\r\n        return false;\r\n      }\r\n\r\n      const result = await updateProductCategoryAction(id, name);\r\n\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      setCategories(prev => prev.map(c => c.id === id ? { ...c, name } : c));\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Category updated successfully\"\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating category:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update category.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteCategory = async (id: string) => {\r\n    try {\r\n      const result = await deleteProductCategoryAction(id);\r\n\r\n      if (!result.success) {\r\n        toast({\r\n          title: \"Cannot delete category\",\r\n          description: result.error || \"Failed to delete category.\",\r\n          variant: \"destructive\"\r\n        });\r\n        return false;\r\n      }\r\n\r\n      setCategories(prev => prev.filter(c => c.id !== id));\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Category deleted successfully\"\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting category:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete category.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  return {\r\n    categories,\r\n    isLoading,\r\n    loadCategories,\r\n    createCategory,\r\n    updateCategory,\r\n    deleteCategory\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 227, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/alert-dialog.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\nimport { buttonVariants } from \"@/components/ui/button\"\r\n\r\nconst AlertDialog = AlertDialogPrimitive.Root\r\n\r\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\r\n\r\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\r\n\r\nconst AlertDialogOverlay = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Overlay\r\n    className={cn(\r\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\r\n      className\r\n    )}\r\n    {...props}\r\n    ref={ref}\r\n  />\r\n))\r\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\r\n\r\nconst AlertDialogContent = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPortal>\r\n    <AlertDialogOverlay />\r\n    <AlertDialogPrimitive.Content\r\n      ref={ref}\r\n      className={cn(\r\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\r\n        className\r\n      )}\r\n      {...props}\r\n    />\r\n  </AlertDialogPortal>\r\n))\r\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\r\n\r\nconst AlertDialogHeader = ({\r\n  className,\r\n  ...props\r\n}: React.HTMLAttributes<HTMLDivElement>) => (\r\n  <div\r\n    className={cn(\r\n      \"flex flex-col space-y-2 text-center sm:text-left\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n)\r\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\r\n\r\nconst AlertDialogFooter = ({\r\n  className,\r\n  ...props\r\n}: React.HTMLAttributes<HTMLDivElement>) => (\r\n  <div\r\n    className={cn(\r\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n)\r\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\r\n\r\nconst AlertDialogTitle = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Title\r\n    ref={ref}\r\n    className={cn(\"text-lg font-semibold\", className)}\r\n    {...props}\r\n  />\r\n))\r\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\r\n\r\nconst AlertDialogDescription = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Description\r\n    ref={ref}\r\n    className={cn(\"text-sm text-muted-foreground\", className)}\r\n    {...props}\r\n  />\r\n))\r\nAlertDialogDescription.displayName =\r\n  AlertDialogPrimitive.Description.displayName\r\n\r\nconst AlertDialogAction = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Action\r\n    ref={ref}\r\n    className={cn(buttonVariants(), className)}\r\n    {...props}\r\n  />\r\n))\r\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\r\n\r\nconst AlertDialogCancel = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Cancel\r\n    ref={ref}\r\n    className={cn(\r\n      buttonVariants({ variant: \"outline\" }),\r\n      \"mt-2 sm:mt-0\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\r\n\r\nexport {\r\n  AlertDialog,\r\n  AlertDialogPortal,\r\n  AlertDialogOverlay,\r\n  AlertDialogTrigger,\r\n  AlertDialogContent,\r\n  AlertDialogHeader,\r\n  AlertDialogFooter,\r\n  AlertDialogTitle,\r\n  AlertDialogDescription,\r\n  AlertDialogAction,\r\n  AlertDialogCancel,\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;;;;;;AAEA,MAAM,cAAc,mLAAyB;AAE7C,MAAM,qBAAqB,sLAA4B;AAEvD,MAAM,oBAAoB,qLAA2B;AAErD,MAAM,mCAAqB,mNAAgB,CAGzC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,sLAA4B;QAC3B,WAAW,IAAA,yHAAE,EACX,2JACA;QAED,GAAG,KAAK;QACT,KAAK;;;;;;AAGT,mBAAmB,WAAW,GAAG,sLAA4B,CAAC,WAAW;AAEzE,MAAM,mCAAqB,mNAAgB,CAGzC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;;0BACC,8OAAC;;;;;0BACD,8OAAC,sLAA4B;gBAC3B,KAAK;gBACL,WAAW,IAAA,yHAAE,EACX,+fACA;gBAED,GAAG,KAAK;;;;;;;;;;;;AAIf,mBAAmB,WAAW,GAAG,sLAA4B,CAAC,WAAW;AAEzE,MAAM,oBAAoB,CAAC,EACzB,SAAS,EACT,GAAG,OACkC,iBACrC,8OAAC;QACC,WAAW,IAAA,yHAAE,EACX,oDACA;QAED,GAAG,KAAK;;;;;;AAGb,kBAAkB,WAAW,GAAG;AAEhC,MAAM,oBAAoB,CAAC,EACzB,SAAS,EACT,GAAG,OACkC,iBACrC,8OAAC;QACC,WAAW,IAAA,yHAAE,EACX,iEACA;QAED,GAAG,KAAK;;;;;;AAGb,kBAAkB,WAAW,GAAG;AAEhC,MAAM,iCAAmB,mNAAgB,CAGvC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,oLAA0B;QACzB,KAAK;QACL,WAAW,IAAA,yHAAE,EAAC,yBAAyB;QACtC,GAAG,KAAK;;;;;;AAGb,iBAAiB,WAAW,GAAG,oLAA0B,CAAC,WAAW;AAErE,MAAM,uCAAyB,mNAAgB,CAG7C,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,0LAAgC;QAC/B,KAAK;QACL,WAAW,IAAA,yHAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,uBAAuB,WAAW,GAChC,0LAAgC,CAAC,WAAW;AAE9C,MAAM,kCAAoB,mNAAgB,CAGxC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,qLAA2B;QAC1B,KAAK;QACL,WAAW,IAAA,yHAAE,EAAC,IAAA,oJAAc,KAAI;QAC/B,GAAG,KAAK;;;;;;AAGb,kBAAkB,WAAW,GAAG,qLAA2B,CAAC,WAAW;AAEvE,MAAM,kCAAoB,mNAAgB,CAGxC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,qLAA2B;QAC1B,KAAK;QACL,WAAW,IAAA,yHAAE,EACX,IAAA,oJAAc,EAAC;YAAE,SAAS;QAAU,IACpC,gBACA;QAED,GAAG,KAAK;;;;;;AAGb,kBAAkB,WAAW,GAAG,qLAA2B,CAAC,WAAW"}},
    {"offset": {"line": 362, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/pages/Categories.tsx"],"sourcesContent":["import React, { useState } from 'react';\r\nimport { useNavigate, useSearchParams } from 'react-router-dom';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { ArrowLeft, Plus, Pencil, Trash2 } from 'lucide-react';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useCategories } from '@/hooks/useCategories';\r\nimport CategoryManager from '@/components/inventory/CategoryManager';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogHeader,\r\n  DialogTitle,\r\n  DialogTrigger,\r\n  DialogFooter,\r\n  DialogClose,\r\n} from '@/components/ui/dialog';\r\nimport {\r\n  AlertDialog,\r\n  AlertDialogAction,\r\n  AlertDialogCancel,\r\n  AlertDialogContent,\r\n  AlertDialogDescription,\r\n  AlertDialogFooter,\r\n  AlertDialogHeader,\r\n  AlertDialogTitle,\r\n  AlertDialogTrigger,\r\n} from '@/components/ui/alert-dialog';\r\nimport { toast } from 'sonner';\r\n\r\nconst Categories = () => {\r\n  const navigate = useNavigate();\r\n  const { user } = useAuth();\r\n  const { categories, isLoading, createCategory, updateCategory, deleteCategory } = useCategories(user?.id);\r\n  const [searchParams] = useSearchParams();\r\n  const returnTo = searchParams.get('returnTo');\r\n\r\n  // Form states\r\n  const [newCategoryName, setNewCategoryName] = useState('');\r\n  const [editCategoryId, setEditCategoryId] = useState<string | null>(null);\r\n  const [editCategoryName, setEditCategoryName] = useState('');\r\n  const [isSubmitting, setIsSubmitting] = useState(false);\r\n\r\n  const handleGoBack = () => {\r\n    if (returnTo) {\r\n      navigate(returnTo);\r\n    } else {\r\n      navigate('/products');\r\n    }\r\n  };\r\n\r\n  const handleCreateCategory = async () => {\r\n    if (!newCategoryName.trim()) {\r\n      toast.error('Category name cannot be empty');\r\n      return;\r\n    }\r\n    \r\n    setIsSubmitting(true);\r\n    try {\r\n      const result = await createCategory(newCategoryName.trim());\r\n      if (result) {\r\n        toast.success('Category created successfully');\r\n        setNewCategoryName('');\r\n      }\r\n    } finally {\r\n      setIsSubmitting(false);\r\n    }\r\n  };\r\n\r\n  const handleUpdateCategory = async () => {\r\n    if (!editCategoryId || !editCategoryName.trim()) {\r\n      toast.error('Category name cannot be empty');\r\n      return;\r\n    }\r\n    \r\n    setIsSubmitting(true);\r\n    try {\r\n      const result = await updateCategory(editCategoryId, editCategoryName.trim());\r\n      if (result) {\r\n        toast.success('Category updated successfully');\r\n        setEditCategoryId(null);\r\n        setEditCategoryName('');\r\n      }\r\n    } finally {\r\n      setIsSubmitting(false);\r\n    }\r\n  };\r\n\r\n  const handleDeleteCategory = async (id: string) => {\r\n    setIsSubmitting(true);\r\n    try {\r\n      const result = await deleteCategory(id);\r\n      if (result) {\r\n        toast.success('Category deleted successfully');\r\n      }\r\n    } finally {\r\n      setIsSubmitting(false);\r\n    }\r\n  };\r\n\r\n  const startEdit = (id: string, name: string) => {\r\n    setEditCategoryId(id);\r\n    setEditCategoryName(name);\r\n  };\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      <div className=\"flex items-center justify-between\">\r\n        <div>\r\n          <div className=\"flex items-center gap-3 mb-2\">\r\n            <Button \r\n              variant=\"outline\"\r\n              size=\"sm\"\r\n              onClick={handleGoBack}\r\n              className=\"flex items-center gap-1\"\r\n            >\r\n              <ArrowLeft className=\"h-4 w-4\" /> \r\n              {returnTo ? 'Back to Product Form' : 'Back to Products'}\r\n            </Button>\r\n          </div>\r\n          <h1 className=\"text-2xl font-bold md:text-3xl text-sales-dark\">Categories</h1>\r\n          <p className=\"text-muted-foreground mt-1\">\r\n            Manage your product categories\r\n          </p>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Add New Category Section */}\r\n      <Card>\r\n        <CardHeader>\r\n          <CardTitle className=\"flex items-center justify-between\">\r\n            Add New Category\r\n            <Dialog>\r\n              <DialogTrigger asChild>\r\n                <Button className=\"flex items-center gap-2\">\r\n                  <Plus className=\"h-4 w-4\" />\r\n                  Add Category\r\n                </Button>\r\n              </DialogTrigger>\r\n              <DialogContent className=\"sm:max-w-md\">\r\n                <DialogHeader>\r\n                  <DialogTitle>Create New Category</DialogTitle>\r\n                  <DialogDescription>\r\n                    Enter a name for your new product category.\r\n                  </DialogDescription>\r\n                </DialogHeader>\r\n                \r\n                <div className=\"py-4\">\r\n                  <Input\r\n                    placeholder=\"Enter category name\"\r\n                    value={newCategoryName}\r\n                    onChange={(e) => setNewCategoryName(e.target.value)}\r\n                  />\r\n                </div>\r\n                \r\n                <DialogFooter>\r\n                  <DialogClose asChild>\r\n                    <Button variant=\"outline\">Cancel</Button>\r\n                  </DialogClose>\r\n                  <Button \r\n                    onClick={handleCreateCategory} \r\n                    disabled={!newCategoryName.trim() || isSubmitting}\r\n                  >\r\n                    {isSubmitting ? 'Creating...' : 'Create Category'}\r\n                  </Button>\r\n                </DialogFooter>\r\n              </DialogContent>\r\n            </Dialog>\r\n          </CardTitle>\r\n        </CardHeader>\r\n        <CardContent>\r\n          <p className=\"text-sm text-muted-foreground\">\r\n            Create categories to organize your products better. Click \"Add Category\" to get started.\r\n          </p>\r\n        </CardContent>\r\n      </Card>\r\n\r\n      {/* Existing Categories with Actions */}\r\n      {categories.length > 0 && (\r\n        <Card>\r\n          <CardHeader>\r\n            <CardTitle>Existing Categories ({categories.length})</CardTitle>\r\n          </CardHeader>\r\n          <CardContent>\r\n            <div className=\"space-y-3\">\r\n              {categories.map((category) => (\r\n                <div key={category.id} className=\"flex items-center justify-between p-3 border rounded-md bg-gray-50\">\r\n                  <h3 className=\"font-medium\">{category.name}</h3>\r\n                  <div className=\"flex items-center gap-2\">\r\n                    <Button \r\n                      variant=\"ghost\" \r\n                      size=\"sm\" \r\n                      onClick={() => startEdit(category.id, category.name)}\r\n                      className=\"flex items-center gap-1\"\r\n                    >\r\n                      <Pencil className=\"h-4 w-4\" />\r\n                      Edit\r\n                    </Button>\r\n                    \r\n                    <AlertDialog>\r\n                      <AlertDialogTrigger asChild>\r\n                        <Button \r\n                          variant=\"ghost\" \r\n                          size=\"sm\" \r\n                          className=\"flex items-center gap-1 text-destructive hover:text-destructive\"\r\n                        >\r\n                          <Trash2 className=\"h-4 w-4\" />\r\n                          Delete\r\n                        </Button>\r\n                      </AlertDialogTrigger>\r\n                      <AlertDialogContent>\r\n                        <AlertDialogHeader>\r\n                          <AlertDialogTitle>Delete Category</AlertDialogTitle>\r\n                          <AlertDialogDescription>\r\n                            Are you sure you want to delete \"{category.name}\"? This action cannot be undone. Products using this category will need to be reassigned.\r\n                          </AlertDialogDescription>\r\n                        </AlertDialogHeader>\r\n                        <AlertDialogFooter>\r\n                          <AlertDialogCancel>Cancel</AlertDialogCancel>\r\n                          <AlertDialogAction \r\n                            onClick={() => handleDeleteCategory(category.id)}\r\n                            className=\"bg-destructive text-destructive-foreground hover:bg-destructive/90\"\r\n                          >\r\n                            Delete Category\r\n                          </AlertDialogAction>\r\n                        </AlertDialogFooter>\r\n                      </AlertDialogContent>\r\n                    </AlertDialog>\r\n                  </div>\r\n                </div>\r\n              ))}\r\n            </div>\r\n          </CardContent>\r\n        </Card>\r\n      )}\r\n\r\n      {/* Edit Category Dialog */}\r\n      {editCategoryId !== null && (\r\n        <Dialog \r\n          open={editCategoryId !== null} \r\n          onOpenChange={(open) => !open && setEditCategoryId(null)}\r\n        >\r\n          <DialogContent className=\"sm:max-w-md\">\r\n            <DialogHeader>\r\n              <DialogTitle>Edit Category</DialogTitle>\r\n              <DialogDescription>\r\n                Update the name of this category.\r\n              </DialogDescription>\r\n            </DialogHeader>\r\n            \r\n            <div className=\"py-4\">\r\n              <Input\r\n                placeholder=\"Enter category name\"\r\n                value={editCategoryName}\r\n                onChange={(e) => setEditCategoryName(e.target.value)}\r\n              />\r\n            </div>\r\n            \r\n            <DialogFooter>\r\n              <Button \r\n                variant=\"outline\" \r\n                onClick={() => setEditCategoryId(null)}\r\n              >\r\n                Cancel\r\n              </Button>\r\n              <Button \r\n                onClick={handleUpdateCategory} \r\n                disabled={!editCategoryName.trim() || isSubmitting}\r\n              >\r\n                {isSubmitting ? 'Saving...' : 'Save Changes'}\r\n              </Button>\r\n            </DialogFooter>\r\n          </DialogContent>\r\n        </Dialog>\r\n      )}\r\n\r\n      {/* Empty State */}\r\n      {categories.length === 0 && !isLoading && (\r\n        <Card>\r\n          <CardContent className=\"py-8 text-center\">\r\n            <p className=\"text-muted-foreground mb-4\">\r\n              No categories created yet. Create your first category to get started.\r\n            </p>\r\n          </CardContent>\r\n        </Card>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Categories;\r\n"],"names":[],"mappings":"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"}}]
}