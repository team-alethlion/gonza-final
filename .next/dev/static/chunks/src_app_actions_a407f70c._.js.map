{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgCsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qDAAA"}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqLsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqUsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAkVsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 123, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/activity.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport interface ActivityLogInput {\r\n    userId: string;\r\n    locationId: string;\r\n    activityType: ActivityType;\r\n    module: ActivityModule;\r\n    entityType: string;\r\n    entityId?: string;\r\n    entityName: string;\r\n    description: string;\r\n    metadata?: any;\r\n    profileId?: string;\r\n    profileName?: string;\r\n}\r\n\r\nexport async function logActivityAction(data: ActivityLogInput) {\r\n    try {\r\n        await db.activityHistory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                activityType: data.activityType,\r\n                module: data.module,\r\n                entityType: data.entityType,\r\n                entityId: data.entityId || null,\r\n                entityName: data.entityName,\r\n                description: data.description,\r\n                metadata: data.metadata || null,\r\n                profileId: data.profileId || null,\r\n                profileName: data.profileName || null\r\n            }\r\n        });\r\n\r\n        // revalidatePath('/history'); // Typically history page might need refresh\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error logging activity:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport interface ActivityFilters {\r\n    activityType?: string;\r\n    module?: string;\r\n    search?: string;\r\n    dateFrom?: string;\r\n    dateTo?: string;\r\n}\r\n\r\nexport async function getActivityHistoryAction(\r\n    locationId: string,\r\n    userId: string,\r\n    page: number = 1,\r\n    pageSize: number = 20,\r\n    filters?: ActivityFilters\r\n) {\r\n    try {\r\n        const skip = (page - 1) * pageSize;\r\n\r\n        const where: any = {\r\n            locationId,\r\n            userId\r\n        };\r\n\r\n        if (filters) {\r\n            if (filters.activityType && filters.activityType !== 'ALL') {\r\n                where.activityType = filters.activityType;\r\n            }\r\n            if (filters.module && filters.module !== 'ALL') {\r\n                where.module = filters.module;\r\n            }\r\n            if (filters.search) {\r\n                where.OR = [\r\n                    { entityName: { contains: filters.search, mode: 'insensitive' } },\r\n                    { description: { contains: filters.search, mode: 'insensitive' } }\r\n                ];\r\n            }\r\n            if (filters.dateFrom || filters.dateTo) {\r\n                where.createdAt = {};\r\n                if (filters.dateFrom) {\r\n                    where.createdAt.gte = new Date(filters.dateFrom);\r\n                }\r\n                if (filters.dateTo) {\r\n                    const toDate = new Date(filters.dateTo);\r\n                    toDate.setHours(23, 59, 59, 999);\r\n                    where.createdAt.lte = toDate;\r\n                }\r\n            }\r\n        }\r\n\r\n        const [activities, count] = await Promise.all([\r\n            db.activityHistory.findMany({\r\n                where,\r\n                skip,\r\n                take: pageSize,\r\n                orderBy: {\r\n                    createdAt: 'desc'\r\n                }\r\n            }),\r\n            db.activityHistory.count({ where })\r\n        ]);\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                activities: activities.map((a: any) => ({\r\n                    ...a,\r\n                    created_at: a.createdAt.toISOString(), // Map back to shape expected by hook\r\n                    activity_type: a.activityType,\r\n                    location_id: a.locationId,\r\n                    user_id: a.userId,\r\n                    entity_type: a.entityType,\r\n                    entity_id: a.entityId,\r\n                    entity_name: a.entityName,\r\n                    profile_id: a.profileId,\r\n                    profile_name: a.profileName\r\n                })),\r\n                count\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching activity history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAmBsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qDAAA"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA+IsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,0DAAA"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/sales.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getSalesAction(businessId: string, sortOrder: 'asc' | 'desc' = 'desc', pageSize?: number) {\r\n    try {\r\n        const queryOptions: any = {\r\n            where: {\r\n                branchId: businessId,\r\n            },\r\n            orderBy: {\r\n                createdAt: sortOrder,\r\n            },\r\n            include: {\r\n                cashTransaction: true,\r\n            }\r\n        };\r\n\r\n        if (pageSize && pageSize > 0) {\r\n            queryOptions.take = pageSize;\r\n        }\r\n\r\n        const sales = await db.sale.findMany(queryOptions);\r\n\r\n        // Provide default mappings to existing React components\r\n        return sales.map((item: any) => ({\r\n            id: item.id,\r\n            user_id: item.userId,\r\n            location_id: item.branchId,\r\n            receipt_number: item.saleNumber,\r\n            customer_name: item.customerName,\r\n            customer_address: item.customerAddress,\r\n            customer_contact: item.customerPhone,\r\n            customer_id: item.customerId,\r\n            items: item.items as any, // jsonb type\r\n            payment_status: item.paymentStatus,\r\n            profit: 0, // Profit not stored directly\r\n            date: item.date.toISOString(),\r\n            tax_rate: item.taxRate ? Number(item.taxRate) : 0,\r\n            created_at: item.createdAt.toISOString(),\r\n            updated_at: item.updatedAt.toISOString(),\r\n            cash_transaction_id: item.cashTransactionId,\r\n            amount_paid: Number(item.amountPaid),\r\n            amount_due: Number(item.balance),\r\n            category_id: item.categoryId,\r\n            notes: item.notes\r\n        }));\r\n    } catch (error) {\r\n        console.error('Error fetching sales:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function deleteSaleAction(id: string, businessId: string) {\r\n    try {\r\n        const sale = await db.sale.findUnique({\r\n            where: { id },\r\n            include: { cashTransaction: true, installmentPayments: true }\r\n        });\r\n\r\n        if (!sale || sale.branchId !== businessId) {\r\n            return { success: false, error: 'Sale not found or unauthorized' };\r\n        }\r\n\r\n        await db.$transaction(async (tx) => {\r\n            // Delete installments\r\n            await tx.installmentPayment.deleteMany({\r\n                where: { saleId: id }\r\n            });\r\n\r\n            // Delete associated cash transaction\r\n            if (sale.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: sale.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            // Delete the sale itself\r\n            await tx.sale.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            sale: {\r\n                receiptNumber: sale.saleNumber,\r\n                customerName: sale.customerName,\r\n                customerAddress: sale.customerAddress,\r\n                customerContact: sale.customerPhone,\r\n                paymentStatus: sale.paymentStatus,\r\n                cashTransactionId: sale.cashTransactionId,\r\n                items: sale.items as any,\r\n                amountPaid: Number(sale.amountPaid),\r\n                amountDue: Number(sale.balance),\r\n                profit: 0,\r\n                taxRate: Number(sale.taxRate),\r\n                notes: sale.notes\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error deleting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to delete sale' };\r\n    }\r\n}\r\n\r\nexport async function upsertSaleAction(saleDbData: any, isUpdate: boolean, updateId?: string) {\r\n    try {\r\n        // Map PaymentStatus if needed\r\n        let status = saleDbData.payment_status;\r\n        if (status === 'NOT PAID') status = 'UNPAID';\r\n        else if (status === 'Installment Sale') status = 'INSTALLMENT';\r\n        else if (status === 'Paid') status = 'PAID';\r\n        else if (status === 'Quote') status = 'QUOTE';\r\n\r\n        const prismaData: any = {\r\n            userId: saleDbData.user_id,\r\n            branchId: saleDbData.location_id,\r\n            saleNumber: saleDbData.receipt_number,\r\n            customerName: saleDbData.customer_name,\r\n            customerAddress: saleDbData.customer_address,\r\n            customerPhone: saleDbData.customer_contact,\r\n            customerId: saleDbData.customer_id,\r\n            items: saleDbData.items,\r\n            paymentStatus: status,\r\n            date: new Date(saleDbData.date),\r\n            taxRate: saleDbData.tax_rate,\r\n            cashTransactionId: saleDbData.cash_transaction_id,\r\n            amountPaid: saleDbData.amount_paid,\r\n            balance: saleDbData.amount_due,\r\n            categoryId: saleDbData.category_id,\r\n            notes: saleDbData.notes,\r\n            subtotal: 0, // Placeholder\r\n            total: 0,     // Placeholder\r\n        };\r\n\r\n        if (isUpdate && updateId) {\r\n            const updated = await db.sale.update({\r\n                where: { id: updateId },\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: updated };\r\n        } else {\r\n            const created = await db.sale.create({\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: created };\r\n        }\r\n    } catch (error: any) {\r\n        console.error('Error upserting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to preserve sale' };\r\n    }\r\n}\r\n\r\nexport async function createReceiptAction(saleData: any, businessId: string, userId: string) {\r\n    try {\r\n        let status = saleData.paymentStatus;\r\n        if (status === 'NOT PAID') status = 'UNPAID';\r\n        else if (status === 'Installment Sale') status = 'INSTALLMENT';\r\n        else if (status === 'Paid') status = 'PAID';\r\n        else if (status === 'Quote') status = 'QUOTE';\r\n\r\n        const created = await db.sale.create({\r\n            data: {\r\n                userId: userId,\r\n                branchId: businessId,\r\n                saleNumber: saleData.receiptNumber,\r\n                customerName: saleData.customerName,\r\n                customerId: saleData.customerId,\r\n                date: new Date(saleData.date),\r\n                items: saleData.items,\r\n                paymentStatus: status,\r\n                amountPaid: saleData.amountPaid || 0,\r\n                balance: saleData.amountDue || 0,\r\n                cashAccountId: saleData.cashAccountId,\r\n                notes: saleData.notes,\r\n                subtotal: 0,\r\n                total: 0,\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        revalidatePath('/customers');\r\n\r\n        return { success: true, data: created };\r\n    } catch (error: any) {\r\n        console.error('Error creating receipt:', error);\r\n        return { success: false, error: error.message || 'Failed to create receipt' };\r\n    }\r\n}\r\n\r\n// --- SALES CATEGORIES ---\r\n\r\nexport async function getSalesCategoriesAction(businessId: string) {\r\n    try {\r\n        const categories = await db.saleCategory.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return { success: true, data: categories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching sales categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createSalesCategoryAction(businessId: string, userId: string, name: string, isDefault: boolean = false) {\r\n    try {\r\n        const category = await db.saleCategory.create({\r\n            data: {\r\n                branchId: businessId,\r\n                userId,\r\n                name,\r\n                is_default: isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating sales category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateSalesCategoryAction(id: string, name: string) {\r\n    try {\r\n        const category = await db.saleCategory.update({\r\n            where: { id },\r\n            data: { name }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating sales category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteSalesCategoryAction(id: string) {\r\n    try {\r\n        await db.saleCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting sales category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,kDAAA"}},
    {"offset": {"line": 174, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/sales.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getSalesAction(businessId: string, sortOrder: 'asc' | 'desc' = 'desc', pageSize?: number) {\r\n    try {\r\n        const queryOptions: any = {\r\n            where: {\r\n                branchId: businessId,\r\n            },\r\n            orderBy: {\r\n                createdAt: sortOrder,\r\n            },\r\n            include: {\r\n                cashTransaction: true,\r\n            }\r\n        };\r\n\r\n        if (pageSize && pageSize > 0) {\r\n            queryOptions.take = pageSize;\r\n        }\r\n\r\n        const sales = await db.sale.findMany(queryOptions);\r\n\r\n        // Provide default mappings to existing React components\r\n        return sales.map((item: any) => ({\r\n            id: item.id,\r\n            user_id: item.userId,\r\n            location_id: item.branchId,\r\n            receipt_number: item.saleNumber,\r\n            customer_name: item.customerName,\r\n            customer_address: item.customerAddress,\r\n            customer_contact: item.customerPhone,\r\n            customer_id: item.customerId,\r\n            items: item.items as any, // jsonb type\r\n            payment_status: item.paymentStatus,\r\n            profit: 0, // Profit not stored directly\r\n            date: item.date.toISOString(),\r\n            tax_rate: item.taxRate ? Number(item.taxRate) : 0,\r\n            created_at: item.createdAt.toISOString(),\r\n            updated_at: item.updatedAt.toISOString(),\r\n            cash_transaction_id: item.cashTransactionId,\r\n            amount_paid: Number(item.amountPaid),\r\n            amount_due: Number(item.balance),\r\n            category_id: item.categoryId,\r\n            notes: item.notes\r\n        }));\r\n    } catch (error) {\r\n        console.error('Error fetching sales:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function deleteSaleAction(id: string, businessId: string) {\r\n    try {\r\n        const sale = await db.sale.findUnique({\r\n            where: { id },\r\n            include: { cashTransaction: true, installmentPayments: true }\r\n        });\r\n\r\n        if (!sale || sale.branchId !== businessId) {\r\n            return { success: false, error: 'Sale not found or unauthorized' };\r\n        }\r\n\r\n        await db.$transaction(async (tx) => {\r\n            // Delete installments\r\n            await tx.installmentPayment.deleteMany({\r\n                where: { saleId: id }\r\n            });\r\n\r\n            // Delete associated cash transaction\r\n            if (sale.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: sale.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            // Delete the sale itself\r\n            await tx.sale.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            sale: {\r\n                receiptNumber: sale.saleNumber,\r\n                customerName: sale.customerName,\r\n                customerAddress: sale.customerAddress,\r\n                customerContact: sale.customerPhone,\r\n                paymentStatus: sale.paymentStatus,\r\n                cashTransactionId: sale.cashTransactionId,\r\n                items: sale.items as any,\r\n                amountPaid: Number(sale.amountPaid),\r\n                amountDue: Number(sale.balance),\r\n                profit: 0,\r\n                taxRate: Number(sale.taxRate),\r\n                notes: sale.notes\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error deleting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to delete sale' };\r\n    }\r\n}\r\n\r\nexport async function upsertSaleAction(saleDbData: any, isUpdate: boolean, updateId?: string) {\r\n    try {\r\n        // Map PaymentStatus if needed\r\n        let status = saleDbData.payment_status;\r\n        if (status === 'NOT PAID') status = 'UNPAID';\r\n        else if (status === 'Installment Sale') status = 'INSTALLMENT';\r\n        else if (status === 'Paid') status = 'PAID';\r\n        else if (status === 'Quote') status = 'QUOTE';\r\n\r\n        const prismaData: any = {\r\n            userId: saleDbData.user_id,\r\n            branchId: saleDbData.location_id,\r\n            saleNumber: saleDbData.receipt_number,\r\n            customerName: saleDbData.customer_name,\r\n            customerAddress: saleDbData.customer_address,\r\n            customerPhone: saleDbData.customer_contact,\r\n            customerId: saleDbData.customer_id,\r\n            items: saleDbData.items,\r\n            paymentStatus: status,\r\n            date: new Date(saleDbData.date),\r\n            taxRate: saleDbData.tax_rate,\r\n            cashTransactionId: saleDbData.cash_transaction_id,\r\n            amountPaid: saleDbData.amount_paid,\r\n            balance: saleDbData.amount_due,\r\n            categoryId: saleDbData.category_id,\r\n            notes: saleDbData.notes,\r\n            subtotal: 0, // Placeholder\r\n            total: 0,     // Placeholder\r\n        };\r\n\r\n        if (isUpdate && updateId) {\r\n            const updated = await db.sale.update({\r\n                where: { id: updateId },\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: updated };\r\n        } else {\r\n            const created = await db.sale.create({\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: created };\r\n        }\r\n    } catch (error: any) {\r\n        console.error('Error upserting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to preserve sale' };\r\n    }\r\n}\r\n\r\nexport async function createReceiptAction(saleData: any, businessId: string, userId: string) {\r\n    try {\r\n        let status = saleData.paymentStatus;\r\n        if (status === 'NOT PAID') status = 'UNPAID';\r\n        else if (status === 'Installment Sale') status = 'INSTALLMENT';\r\n        else if (status === 'Paid') status = 'PAID';\r\n        else if (status === 'Quote') status = 'QUOTE';\r\n\r\n        const created = await db.sale.create({\r\n            data: {\r\n                userId: userId,\r\n                branchId: businessId,\r\n                saleNumber: saleData.receiptNumber,\r\n                customerName: saleData.customerName,\r\n                customerId: saleData.customerId,\r\n                date: new Date(saleData.date),\r\n                items: saleData.items,\r\n                paymentStatus: status,\r\n                amountPaid: saleData.amountPaid || 0,\r\n                balance: saleData.amountDue || 0,\r\n                cashAccountId: saleData.cashAccountId,\r\n                notes: saleData.notes,\r\n                subtotal: 0,\r\n                total: 0,\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        revalidatePath('/customers');\r\n\r\n        return { success: true, data: created };\r\n    } catch (error: any) {\r\n        console.error('Error creating receipt:', error);\r\n        return { success: false, error: error.message || 'Failed to create receipt' };\r\n    }\r\n}\r\n\r\n// --- SALES CATEGORIES ---\r\n\r\nexport async function getSalesCategoriesAction(businessId: string) {\r\n    try {\r\n        const categories = await db.saleCategory.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return { success: true, data: categories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching sales categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createSalesCategoryAction(businessId: string, userId: string, name: string, isDefault: boolean = false) {\r\n    try {\r\n        const category = await db.saleCategory.create({\r\n            data: {\r\n                branchId: businessId,\r\n                userId,\r\n                name,\r\n                is_default: isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating sales category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateSalesCategoryAction(id: string, name: string) {\r\n    try {\r\n        const category = await db.saleCategory.update({\r\n            where: { id },\r\n            data: { name }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating sales category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteSalesCategoryAction(id: string) {\r\n    try {\r\n        await db.saleCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting sales category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsDsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,oDAAA"}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAiNsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 208, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA4OsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,kEAAA"}},
    {"offset": {"line": 225, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgSsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,kEAAA"}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAwUsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,kEAAA"}},
    {"offset": {"line": 259, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAmWsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 276, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA+YsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,mEAAA"}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoXsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,8DAAA"}},
    {"offset": {"line": 310, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAyYsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 327, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA2ZsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 344, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0asB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 361, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.locationId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title,\r\n                items: req.items,\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAOsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,yDAAA"}},
    {"offset": {"line": 378, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.locationId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title,\r\n                items: req.items,\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoDsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 395, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.locationId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title,\r\n                items: req.items,\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsFsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 412, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.locationId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title,\r\n                items: req.items,\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsIsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,8EAAA"}},
    {"offset": {"line": 429, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.locationId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title,\r\n                items: req.items,\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4EAAA"}},
    {"offset": {"line": 446, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.locationId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title,\r\n                items: req.items,\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAiNsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,yDAAA"}},
    {"offset": {"line": 463, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.locationId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title,\r\n                items: req.items,\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAkPsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,2DAAA"}},
    {"offset": {"line": 480, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.locationId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title,\r\n                items: req.items,\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAwQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,2DAAA"}},
    {"offset": {"line": 497, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.locationId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title,\r\n                items: req.items,\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true, data: requisition };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA6RsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,2DAAA"}},
    {"offset": {"line": 514, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/analytics.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\n\r\nexport interface InventoryStats {\r\n    totalCostValue: number;\r\n    totalStockValue: number;\r\n    lowStockCount: number;\r\n    outOfStockCount: number;\r\n}\r\n\r\nexport async function getGlobalInventoryStatsAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: {\r\n                branchId: businessId,\r\n            },\r\n            select: {\r\n                stock: true,\r\n                minStock: true,\r\n                costPrice: true,\r\n                sellingPrice: true\r\n            }\r\n        });\r\n\r\n        const stats: InventoryStats = products.reduce((acc: InventoryStats, p: any) => {\r\n            const stock = p.stock || 0;\r\n            const cost = p.costPrice || 0;\r\n            const price = p.sellingPrice || 0;\r\n            const minStock = p.minStock || 0;\r\n\r\n            acc.totalCostValue += stock * cost;\r\n            acc.totalStockValue += stock * price;\r\n\r\n            if (stock <= 0) {\r\n                acc.outOfStockCount += 1;\r\n            } else if (stock <= minStock) {\r\n                acc.lowStockCount += 1;\r\n            }\r\n\r\n            return acc;\r\n        }, {\r\n            totalCostValue: 0,\r\n            totalStockValue: 0,\r\n            lowStockCount: 0,\r\n            outOfStockCount: 0\r\n        });\r\n\r\n        return { success: true, data: stats };\r\n    } catch (error: any) {\r\n        console.error('Error fetching global inventory stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getTotalExpensesAction(businessId: string, startDate?: string, endDate?: string) {\r\n    try {\r\n        const where: any = {\r\n            branchId: businessId\r\n        };\r\n\r\n        if (startDate || endDate) {\r\n            where.date = {};\r\n            if (startDate) {\r\n                where.date.gte = new Date(startDate);\r\n            }\r\n            if (endDate) {\r\n                where.date.lte = new Date(endDate);\r\n            }\r\n        }\r\n\r\n        const expenses = await db.expense.findMany({\r\n            where,\r\n            select: {\r\n                amount: true\r\n            }\r\n        });\r\n\r\n        const total = expenses.reduce((sum: number, e: any) => sum + Number(e.amount), 0);\r\n\r\n        return { success: true, data: total };\r\n    } catch (error: any) {\r\n        console.error('Error fetching total expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAWsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,iEAAA"}}]
}