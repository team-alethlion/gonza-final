{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/textarea.tsx"],"sourcesContent":["import * as React from \"react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nexport interface TextareaProps\r\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\r\n\r\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\r\n  ({ className, ...props }, ref) => {\r\n    return (\r\n      <textarea\r\n        className={cn(\r\n          \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\r\n          className\r\n        )}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    )\r\n  }\r\n)\r\nTextarea.displayName = \"Textarea\"\r\n\r\nexport { Textarea }\r\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAKA,MAAM,yBAAW,2KAAgB,MAC/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE;IACxB,qBACE,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,wSACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;;AAEF,SAAS,WAAW,GAAG"}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n\r\nexport async function getAccountStatusAction(userId: string) {\r\n    try {\r\n        const user = await db.user.findUnique({\r\n            where: { id: userId },\r\n            select: {\r\n                isFrozen: true,\r\n                createdAt: true,\r\n                subscriptions: {\r\n                    where: { status: 'active' },\r\n                    orderBy: { endDate: 'desc' },\r\n                    take: 1\r\n                },\r\n                branches: {\r\n                    select: { id: true }\r\n                }\r\n            }\r\n        });\r\n\r\n        if (!user) return null;\r\n\r\n        const activeSub = user.subscriptions[0];\r\n        const now = new Date();\r\n        const daysRemaining = activeSub ? Math.ceil((activeSub.endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)) : 0;\r\n\r\n        return {\r\n            is_frozen: user.isFrozen,\r\n            location_limit: 1, // Traditional limit or from subscription\r\n            billing_amount: activeSub ? Number(activeSub.amount) : 50000,\r\n            billing_duration: 'Monthly',\r\n            days_remaining: Math.max(0, daysRemaining),\r\n            next_billing_date: activeSub?.endDate.toISOString() || ''\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching account status:', error);\r\n        return { is_frozen: false, location_limit: 1, billing_amount: 50000, billing_duration: 'Monthly', days_remaining: 30, next_billing_date: '' };\r\n    }\r\n}\r\n\r\nexport async function getOnboardingStatusAction(locationId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId: locationId }\r\n        });\r\n\r\n        if (!settings) return null;\r\n\r\n        return {\r\n            id: settings.id,\r\n            location_id: settings.branchId,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            completed: !!settings.businessName && !!settings.phone, // Simplified completion check\r\n            is_frozen: false // Should come from branch or user status\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching onboarding status:', error);\r\n        return null;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useBusinessSettings.ts"],"sourcesContent":["\r\nimport { useState, useEffect } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { getBusinessSettingsAction, upsertBusinessSettingsAction } from '@/app/actions/business-settings';\r\n\r\nexport interface BusinessSettings {\r\n  id?: string;\r\n  businessName: string;\r\n  businessAddress: string;\r\n  businessPhone: string;\r\n  businessEmail: string;\r\n  businessLogo?: string;\r\n  currency: string;\r\n  signature?: string;\r\n  paymentInfo?: string;\r\n  defaultPrintFormat?: 'standard' | 'thermal';\r\n  defaultPrinterName?: string;\r\n  defaultPrinterType?: 'USB' | 'Bluetooth';\r\n  printerPaperSize?: '58mm' | '80mm';\r\n}\r\n\r\n// Utility function to parse payment info text into structured format\r\nexport const parsePaymentInfo = (paymentInfo: string): { method: string, accountNumber: string, accountName: string }[] => {\r\n  if (!paymentInfo || paymentInfo.trim() === '') {\r\n    return [];\r\n  }\r\n\r\n  const lines = paymentInfo.split('\\n').filter(line => line.trim() !== '');\r\n  const methods: { method: string, accountNumber: string, accountName: string }[] = [];\r\n\r\n  for (let i = 0; i < lines.length; i += 3) {\r\n    if (i + 2 < lines.length) {\r\n      methods.push({\r\n        method: lines[i].trim(),\r\n        accountNumber: lines[i + 1].trim(),\r\n        accountName: lines[i + 2].trim()\r\n      });\r\n    }\r\n  }\r\n\r\n  return methods;\r\n};\r\n\r\n// Utility function to convert payment methods array back to string format\r\nexport const convertPaymentMethodsToString = (paymentMethods: { method: string, accountNumber: string, accountName: string }[]): string => {\r\n  return paymentMethods\r\n    .filter(pm => pm.method.trim() !== '' || pm.accountNumber.trim() !== '' || pm.accountName.trim() !== '')\r\n    .map(pm => `${pm.method}\\n${pm.accountNumber}\\n${pm.accountName}`)\r\n    .join('\\n');\r\n};\r\n\r\n// Default settings for new businesses\r\nconst getDefaultSettings = (): BusinessSettings => ({\r\n  businessName: '',\r\n  businessAddress: '',\r\n  businessPhone: '',\r\n  businessEmail: '',\r\n  currency: 'UGX',\r\n  paymentInfo: '',\r\n  defaultPrintFormat: 'standard'\r\n});\r\n\r\nexport const useBusinessSettings = () => {\r\n  const [settings, setSettings] = useState<BusinessSettings>(getDefaultSettings());\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const loadSettings = async (): Promise<BusinessSettings> => {\r\n    if (!currentBusiness) {\r\n      return getDefaultSettings();\r\n    }\r\n\r\n    try {\r\n      const data = await getBusinessSettingsAction(currentBusiness.id);\r\n\r\n      if (data) {\r\n        // Extract payment info from metadata\r\n        const paymentInfo = data.metadata && typeof data.metadata === 'object' ?\r\n          (data.metadata as Record<string, unknown>).payment_info as string || '' : '';\r\n\r\n        return {\r\n          id: data.id,\r\n          businessName: data.business_name || '',\r\n          businessAddress: data.business_address || '',\r\n          businessPhone: data.business_phone || '',\r\n          businessEmail: data.business_email || '',\r\n          businessLogo: data.business_logo || undefined,\r\n          currency: data.currency || 'UGX',\r\n          signature: data.signature || undefined,\r\n          paymentInfo: paymentInfo,\r\n          defaultPrintFormat: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_print_format as 'standard' | 'thermal' || 'standard' : 'standard',\r\n          defaultPrinterName: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_name as string || '' : '',\r\n          defaultPrinterType: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_type as 'USB' | 'Bluetooth' || 'USB' : 'USB',\r\n          printerPaperSize: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).printer_paper_size as '58mm' | '80mm' || '58mm' : '58mm'\r\n        };\r\n      } else {\r\n        return getDefaultSettings();\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return getDefaultSettings();\r\n    }\r\n  };\r\n\r\n  const updateSettings = async (newSettings: Partial<BusinessSettings>) => {\r\n    if (!currentBusiness) {\r\n      console.error('No business selected for updating settings');\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"No business selected\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const userData = { user: { id: '00000000-0000-0000-0000-000000000000' } }; // Mocked user id for now\r\n\r\n      // Prepare the metadata object with payment info\r\n      const metadata = {\r\n        payment_info: newSettings.hasOwnProperty('paymentInfo') ? newSettings.paymentInfo : settings.paymentInfo || '',\r\n        default_print_format: newSettings.hasOwnProperty('defaultPrintFormat') ? newSettings.defaultPrintFormat : settings.defaultPrintFormat || 'standard',\r\n        default_printer_name: newSettings.hasOwnProperty('defaultPrinterName') ? newSettings.defaultPrinterName : settings.defaultPrinterName || '',\r\n        default_printer_type: newSettings.hasOwnProperty('defaultPrinterType') ? newSettings.defaultPrinterType : settings.defaultPrinterType || 'USB',\r\n        printer_paper_size: newSettings.hasOwnProperty('printerPaperSize') ? newSettings.printerPaperSize : settings.printerPaperSize || '58mm'\r\n      };\r\n\r\n      const updateData = {\r\n        business_name: newSettings.hasOwnProperty('businessName') ? newSettings.businessName : settings.businessName,\r\n        business_address: newSettings.hasOwnProperty('businessAddress') ? newSettings.businessAddress : settings.businessAddress,\r\n        business_phone: newSettings.hasOwnProperty('businessPhone') ? newSettings.businessPhone : settings.businessPhone,\r\n        business_email: newSettings.hasOwnProperty('businessEmail') ? newSettings.businessEmail : settings.businessEmail,\r\n        business_logo: newSettings.hasOwnProperty('businessLogo') ? newSettings.businessLogo : settings.businessLogo,\r\n        currency: newSettings.hasOwnProperty('currency') ? newSettings.currency : settings.currency,\r\n        signature: newSettings.hasOwnProperty('signature') ? newSettings.signature : settings.signature,\r\n        metadata: metadata\r\n      };\r\n\r\n      const response = await upsertBusinessSettingsAction(currentBusiness.id, userData.user.id, updateData);\r\n\r\n      if (!response.success) {\r\n        console.error('Supabase error updating business settings:', response.error);\r\n        throw new Error(response.error);\r\n      }\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Business settings updated successfully\"\r\n      });\r\n\r\n      // Refetch settings after update\r\n      refetch();\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // React Query for settings loading with proper caching\r\n  const { data: queriedData, isLoading: isQueryLoading, isFetching, refetch } = useQuery({\r\n    queryKey: ['businessSettings', currentBusiness?.id],\r\n    queryFn: loadSettings,\r\n    enabled: !!currentBusiness?.id,\r\n    staleTime: 5 * 60_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: false,\r\n    refetchOnReconnect: false,\r\n  });\r\n\r\n  // Sync React Query data with local state\r\n  useEffect(() => {\r\n    if (queriedData) {\r\n      setSettings(queriedData);\r\n    } else if (!currentBusiness) {\r\n      setSettings(getDefaultSettings());\r\n    }\r\n  }, [queriedData, currentBusiness]);\r\n\r\n  // Sync loading state from React Query\r\n  useEffect(() => {\r\n    setIsLoading(isQueryLoading || isFetching);\r\n  }, [isQueryLoading, isFetching]);\r\n\r\n  return {\r\n    settings,\r\n    isLoading,\r\n    updateSettings,\r\n    loadSettings\r\n  };\r\n};\r\n"],"names":[],"mappings":";;;;;;;;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;;;AAmBO,MAAM,mBAAmB,CAAC;IAC/B,IAAI,CAAC,eAAe,YAAY,IAAI,OAAO,IAAI;QAC7C,OAAO,EAAE;IACX;IAEA,MAAM,QAAQ,YAAY,KAAK,CAAC,MAAM,MAAM,CAAC,CAAA,OAAQ,KAAK,IAAI,OAAO;IACrE,MAAM,UAA4E,EAAE;IAEpF,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,EAAG;QACxC,IAAI,IAAI,IAAI,MAAM,MAAM,EAAE;YACxB,QAAQ,IAAI,CAAC;gBACX,QAAQ,KAAK,CAAC,EAAE,CAAC,IAAI;gBACrB,eAAe,KAAK,CAAC,IAAI,EAAE,CAAC,IAAI;gBAChC,aAAa,KAAK,CAAC,IAAI,EAAE,CAAC,IAAI;YAChC;QACF;IACF;IAEA,OAAO;AACT;AAGO,MAAM,gCAAgC,CAAC;IAC5C,OAAO,eACJ,MAAM,CAAC,CAAA,KAAM,GAAG,MAAM,CAAC,IAAI,OAAO,MAAM,GAAG,aAAa,CAAC,IAAI,OAAO,MAAM,GAAG,WAAW,CAAC,IAAI,OAAO,IACpG,GAAG,CAAC,CAAA,KAAM,GAAG,GAAG,MAAM,CAAC,EAAE,EAAE,GAAG,aAAa,CAAC,EAAE,EAAE,GAAG,WAAW,EAAE,EAChE,IAAI,CAAC;AACV;AAEA,sCAAsC;AACtC,MAAM,qBAAqB,IAAwB,CAAC;QAClD,cAAc;QACd,iBAAiB;QACjB,eAAe;QACf,eAAe;QACf,UAAU;QACV,aAAa;QACb,oBAAoB;IACtB,CAAC;AAEM,MAAM,sBAAsB;;IACjC,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,yKAAQ,EAAmB;IAC3D,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAC;IAC3C,MAAM,EAAE,KAAK,EAAE,GAAG,IAAA,2IAAQ;IAC1B,MAAM,EAAE,eAAe,EAAE,GAAG,IAAA,qJAAW;IAEvC,MAAM,eAAe;QACnB,IAAI,CAAC,iBAAiB;YACpB,OAAO;QACT;QAEA,IAAI;YACF,MAAM,OAAO,MAAM,IAAA,6LAAyB,EAAC,gBAAgB,EAAE;YAE/D,IAAI,MAAM;gBACR,qCAAqC;gBACrC,MAAM,cAAc,KAAK,QAAQ,IAAI,OAAO,KAAK,QAAQ,KAAK,WAC5D,AAAC,KAAK,QAAQ,CAA6B,YAAY,IAAc,KAAK;gBAE5E,OAAO;oBACL,IAAI,KAAK,EAAE;oBACX,cAAc,KAAK,aAAa,IAAI;oBACpC,iBAAiB,KAAK,gBAAgB,IAAI;oBAC1C,eAAe,KAAK,cAAc,IAAI;oBACtC,eAAe,KAAK,cAAc,IAAI;oBACtC,cAAc,KAAK,aAAa,IAAI;oBACpC,UAAU,KAAK,QAAQ,IAAI;oBAC3B,WAAW,KAAK,SAAS,IAAI;oBAC7B,aAAa;oBACb,oBAAoB,KAAK,QAAQ,IAAI,OAAO,KAAK,QAAQ,KAAK,WAC5D,AAAC,KAAK,QAAQ,CAA6B,oBAAoB,IAA8B,aAAa;oBAC5G,oBAAoB,KAAK,QAAQ,IAAI,OAAO,KAAK,QAAQ,KAAK,WAC5D,AAAC,KAAK,QAAQ,CAA6B,oBAAoB,IAAc,KAAK;oBACpF,oBAAoB,KAAK,QAAQ,IAAI,OAAO,KAAK,QAAQ,KAAK,WAC5D,AAAC,KAAK,QAAQ,CAA6B,oBAAoB,IAA2B,QAAQ;oBACpG,kBAAkB,KAAK,QAAQ,IAAI,OAAO,KAAK,QAAQ,KAAK,WAC1D,AAAC,KAAK,QAAQ,CAA6B,kBAAkB,IAAuB,SAAS;gBACjG;YACF,OAAO;gBACL,OAAO;YACT;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,oCAAoC;YAClD,MAAM;gBACJ,OAAO;gBACP,aAAa;gBACb,SAAS;YACX;YACA,OAAO;QACT;IACF;IAEA,MAAM,iBAAiB,OAAO;QAC5B,IAAI,CAAC,iBAAiB;YACpB,QAAQ,KAAK,CAAC;YACd,MAAM;gBACJ,OAAO;gBACP,aAAa;gBACb,SAAS;YACX;YACA,OAAO;QACT;QAEA,IAAI;YACF,MAAM,WAAW;gBAAE,MAAM;oBAAE,IAAI;gBAAuC;YAAE,GAAG,yBAAyB;YAEpG,gDAAgD;YAChD,MAAM,WAAW;gBACf,cAAc,YAAY,cAAc,CAAC,iBAAiB,YAAY,WAAW,GAAG,SAAS,WAAW,IAAI;gBAC5G,sBAAsB,YAAY,cAAc,CAAC,wBAAwB,YAAY,kBAAkB,GAAG,SAAS,kBAAkB,IAAI;gBACzI,sBAAsB,YAAY,cAAc,CAAC,wBAAwB,YAAY,kBAAkB,GAAG,SAAS,kBAAkB,IAAI;gBACzI,sBAAsB,YAAY,cAAc,CAAC,wBAAwB,YAAY,kBAAkB,GAAG,SAAS,kBAAkB,IAAI;gBACzI,oBAAoB,YAAY,cAAc,CAAC,sBAAsB,YAAY,gBAAgB,GAAG,SAAS,gBAAgB,IAAI;YACnI;YAEA,MAAM,aAAa;gBACjB,eAAe,YAAY,cAAc,CAAC,kBAAkB,YAAY,YAAY,GAAG,SAAS,YAAY;gBAC5G,kBAAkB,YAAY,cAAc,CAAC,qBAAqB,YAAY,eAAe,GAAG,SAAS,eAAe;gBACxH,gBAAgB,YAAY,cAAc,CAAC,mBAAmB,YAAY,aAAa,GAAG,SAAS,aAAa;gBAChH,gBAAgB,YAAY,cAAc,CAAC,mBAAmB,YAAY,aAAa,GAAG,SAAS,aAAa;gBAChH,eAAe,YAAY,cAAc,CAAC,kBAAkB,YAAY,YAAY,GAAG,SAAS,YAAY;gBAC5G,UAAU,YAAY,cAAc,CAAC,cAAc,YAAY,QAAQ,GAAG,SAAS,QAAQ;gBAC3F,WAAW,YAAY,cAAc,CAAC,eAAe,YAAY,SAAS,GAAG,SAAS,SAAS;gBAC/F,UAAU;YACZ;YAEA,MAAM,WAAW,MAAM,IAAA,gMAA4B,EAAC,gBAAgB,EAAE,EAAE,SAAS,IAAI,CAAC,EAAE,EAAE;YAE1F,IAAI,CAAC,SAAS,OAAO,EAAE;gBACrB,QAAQ,KAAK,CAAC,8CAA8C,SAAS,KAAK;gBAC1E,MAAM,IAAI,MAAM,SAAS,KAAK;YAChC;YAEA,MAAM;gBACJ,OAAO;gBACP,aAAa;YACf;YAEA,gCAAgC;YAChC;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,qCAAqC;YACnD,MAAM;gBACJ,OAAO;gBACP,aAAa;gBACb,SAAS;YACX;YACA,OAAO;QACT;IACF;IAEA,uDAAuD;IACvD,MAAM,EAAE,MAAM,WAAW,EAAE,WAAW,cAAc,EAAE,UAAU,EAAE,OAAO,EAAE,GAAG,IAAA,0LAAQ,EAAC;QACrF,UAAU;YAAC;YAAoB,iBAAiB;SAAG;QACnD,SAAS;QACT,SAAS,CAAC,CAAC,iBAAiB;QAC5B,WAAW,IAAI;QACf,QAAQ,KAAK;QACb,sBAAsB;QACtB,oBAAoB;IACtB;IAEA,yCAAyC;IACzC,IAAA,0KAAS;yCAAC;YACR,IAAI,aAAa;gBACf,YAAY;YACd,OAAO,IAAI,CAAC,iBAAiB;gBAC3B,YAAY;YACd;QACF;wCAAG;QAAC;QAAa;KAAgB;IAEjC,sCAAsC;IACtC,IAAA,0KAAS;yCAAC;YACR,aAAa,kBAAkB;QACjC;wCAAG;QAAC;QAAgB;KAAW;IAE/B,OAAO;QACL;QACA;QACA;QACA;IACF;AACF;GAhJa;;QAGO,2IAAQ;QACE,qJAAW;QA8GuC,0LAAQ"}},
    {"offset": {"line": 260, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useProductImage.ts"],"sourcesContent":["import { useToast } from '@/hooks/use-toast';\r\n\r\n/**\r\n * Hook for handling product image uploads with enhanced compression\r\n */\r\nexport const useProductImage = (userId: string | undefined) => {\r\n  const { toast } = useToast();\r\n\r\n  /**\r\n   * Progressive compression that guarantees file size under 10KB\r\n   * @param file The original image file\r\n   * @returns A promise that resolves to the compressed file\r\n   */\r\n  const compressImage = async (file: File): Promise<File> => {\r\n    const MAX_SIZE_KB = 10;\r\n    const MAX_SIZE_BYTES = MAX_SIZE_KB * 1024;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const reader = new FileReader();\r\n        reader.onerror = () => {\r\n          console.error('FileReader error');\r\n          reject(new Error('Failed to read file'));\r\n        };\r\n\r\n        reader.onload = (event) => {\r\n          try {\r\n            const img = new Image();\r\n            img.onerror = () => {\r\n              console.error('Image load error');\r\n              reject(new Error('Failed to load image'));\r\n            };\r\n\r\n            img.onload = () => {\r\n              try {\r\n                // Progressive compression function\r\n                const compressWithQuality = (width: number, height: number, quality: number): Promise<File> => {\r\n                  return new Promise((resolveCompress) => {\r\n                    const canvas = document.createElement('canvas');\r\n                    canvas.width = width;\r\n                    canvas.height = height;\r\n\r\n                    const ctx = canvas.getContext('2d');\r\n                    if (!ctx) {\r\n                      reject(new Error('Could not get canvas context'));\r\n                      return;\r\n                    }\r\n\r\n                    // Clear canvas and draw image\r\n                    ctx.clearRect(0, 0, width, height);\r\n                    ctx.drawImage(img, 0, 0, width, height);\r\n\r\n                    // Convert to JPEG with specified quality\r\n                    canvas.toBlob(\r\n                      (blob) => {\r\n                        if (!blob) {\r\n                          reject(new Error('Could not compress image'));\r\n                          return;\r\n                        }\r\n\r\n                        const compressedFile = new File([blob], `${file.name.replace(/\\.[^/.]+$/, '')}-optimized.jpg`, {\r\n                          type: 'image/jpeg',\r\n                          lastModified: Date.now(),\r\n                        });\r\n\r\n                        resolveCompress(compressedFile);\r\n                      },\r\n                      'image/jpeg',\r\n                      quality\r\n                    );\r\n                  });\r\n                };\r\n\r\n                // Progressive compression algorithm\r\n                const progressiveCompress = async () => {\r\n                  let { width, height } = img;\r\n\r\n                  // Start with reasonable dimensions and quality\r\n                  const maxDimension = 400;\r\n                  if (width > maxDimension || height > maxDimension) {\r\n                    const aspectRatio = width / height;\r\n                    if (width > height) {\r\n                      width = maxDimension;\r\n                      height = width / aspectRatio;\r\n                    } else {\r\n                      height = maxDimension;\r\n                      width = height * aspectRatio;\r\n                    }\r\n                  }\r\n\r\n                  // Ensure dimensions are valid\r\n                  width = Math.max(50, Math.floor(width));\r\n                  height = Math.max(50, Math.floor(height));\r\n\r\n                  // Try different quality levels\r\n                  const qualityLevels = [0.8, 0.6, 0.4, 0.3, 0.2, 0.1, 0.05, 0.02, 0.01];\r\n\r\n                  for (const quality of qualityLevels) {\r\n                    const compressedFile = await compressWithQuality(width, height, quality);\r\n\r\n                    if (compressedFile.size <= MAX_SIZE_BYTES) {\r\n                      console.log(`Image compression successful:`);\r\n                      console.log(`  Original: ${(file.size / 1024).toFixed(1)}KB`);\r\n                      console.log(`  Compressed: ${(compressedFile.size / 1024).toFixed(1)}KB`);\r\n                      console.log(`  Reduction: ${((file.size - compressedFile.size) / file.size * 100).toFixed(1)}%`);\r\n                      console.log(`  Dimensions: ${width}x${height}px`);\r\n                      console.log(`  Quality: ${(quality * 100).toFixed(0)}%`);\r\n\r\n                      return compressedFile;\r\n                    }\r\n                  }\r\n\r\n                  // If still too large, reduce dimensions further\r\n                  const dimensionReductions = [0.8, 0.6, 0.5, 0.4, 0.3, 0.25, 0.2];\r\n\r\n                  for (const reduction of dimensionReductions) {\r\n                    const newWidth = Math.max(50, Math.floor(width * reduction));\r\n                    const newHeight = Math.max(50, Math.floor(height * reduction));\r\n\r\n                    for (const quality of [0.1, 0.05, 0.02, 0.01]) {\r\n                      const compressedFile = await compressWithQuality(newWidth, newHeight, quality);\r\n\r\n                      if (compressedFile.size <= MAX_SIZE_BYTES) {\r\n                        console.log(`Image compression successful with dimension reduction:`);\r\n                        console.log(`  Original: ${(file.size / 1024).toFixed(1)}KB`);\r\n                        console.log(`  Compressed: ${(compressedFile.size / 1024).toFixed(1)}KB`);\r\n                        console.log(`  Reduction: ${((file.size - compressedFile.size) / file.size * 100).toFixed(1)}%`);\r\n                        console.log(`  Dimensions: ${newWidth}x${newHeight}px`);\r\n                        console.log(`  Quality: ${(quality * 100).toFixed(0)}%`);\r\n\r\n                        return compressedFile;\r\n                      }\r\n                    }\r\n                  }\r\n\r\n                  // Final fallback - create a very small image\r\n                  const finalFile = await compressWithQuality(50, 50, 0.01);\r\n                  console.log(`Image compression fallback:`);\r\n                  console.log(`  Original: ${(file.size / 1024).toFixed(1)}KB`);\r\n                  console.log(`  Compressed: ${(finalFile.size / 1024).toFixed(1)}KB`);\r\n                  console.log(`  Dimensions: 50x50px`);\r\n\r\n                  return finalFile;\r\n                };\r\n\r\n                progressiveCompress().then(resolve).catch(reject);\r\n\r\n              } catch (error) {\r\n                console.error('Canvas processing error:', error);\r\n                reject(new Error('Failed to process image on canvas'));\r\n              }\r\n            };\r\n\r\n            img.src = event.target?.result as string;\r\n          } catch (error) {\r\n            console.error('Image creation error:', error);\r\n            reject(new Error('Failed to create image'));\r\n          }\r\n        };\r\n\r\n        reader.readAsDataURL(file);\r\n      } catch (error) {\r\n        console.error('File reading setup error:', error);\r\n        reject(new Error('Failed to setup file reader'));\r\n      }\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Additional optimization to remove EXIF data and metadata\r\n   * @param file The image file to optimize\r\n   * @returns Promise resolving to optimized file\r\n   */\r\n  const removeMetadata = async (file: File): Promise<File> => {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const reader = new FileReader();\r\n        reader.onerror = () => reject(new Error('Failed to read file'));\r\n\r\n        reader.onload = (event) => {\r\n          try {\r\n            const img = new Image();\r\n            img.onerror = () => reject(new Error('Failed to load image'));\r\n\r\n            img.onload = () => {\r\n              try {\r\n                const canvas = document.createElement('canvas');\r\n                canvas.width = img.width;\r\n                canvas.height = img.height;\r\n\r\n                const ctx = canvas.getContext('2d');\r\n                if (!ctx) {\r\n                  reject(new Error('Could not get canvas context'));\r\n                  return;\r\n                }\r\n\r\n                ctx.drawImage(img, 0, 0);\r\n\r\n                canvas.toBlob(\r\n                  (blob) => {\r\n                    if (!blob) {\r\n                      reject(new Error('Could not process image'));\r\n                      return;\r\n                    }\r\n\r\n                    const cleanFile = new File([blob], file.name, {\r\n                      type: file.type,\r\n                      lastModified: Date.now(),\r\n                    });\r\n\r\n                    resolve(cleanFile);\r\n                  },\r\n                  file.type,\r\n                  0.95\r\n                );\r\n              } catch (error) {\r\n                console.error('Metadata removal canvas error:', error);\r\n                reject(new Error('Failed to process image'));\r\n              }\r\n            };\r\n\r\n            img.src = event.target?.result as string;\r\n          } catch (error) {\r\n            console.error('Metadata removal image error:', error);\r\n            reject(new Error('Failed to load image'));\r\n          }\r\n        };\r\n\r\n        reader.readAsDataURL(file);\r\n      } catch (error) {\r\n        console.error('Metadata removal setup error:', error);\r\n        reject(new Error('Failed to setup file reader'));\r\n      }\r\n    });\r\n  };\r\n\r\n  const uploadProductImage = async (file: File): Promise<string | null> => {\r\n    try {\r\n      if (!userId || !file) {\r\n        console.error('Missing userId or file for image upload');\r\n        return null;\r\n      }\r\n\r\n      // Check if the file is an image\r\n      if (!file.type.startsWith('image/')) {\r\n        toast({\r\n          title: \"Error\",\r\n          description: \"Only image files are allowed.\",\r\n          variant: \"destructive\"\r\n        });\r\n        return null;\r\n      }\r\n\r\n      // Check file size (max 20MB before compression)\r\n      if (file.size > 20 * 1024 * 1024) {\r\n        toast({\r\n          title: \"Error\",\r\n          description: \"Image file is too large. Maximum size is 20MB.\",\r\n          variant: \"destructive\"\r\n        });\r\n        return null;\r\n      }\r\n\r\n      console.log('Starting image processing...');\r\n\r\n      // Show compression progress\r\n      toast({\r\n        title: \"Processing Image\",\r\n        description: \"Optimizing image to under 10KB...\",\r\n      });\r\n\r\n      // Remove metadata first, then compress\r\n      const cleanFile = await removeMetadata(file);\r\n      const compressedFile = await compressImage(cleanFile);\r\n\r\n      // Verify final size\r\n      const finalSizeKB = compressedFile.size / 1024;\r\n      console.log(`Final compressed size: ${finalSizeKB.toFixed(1)}KB`);\r\n\r\n      // Mock upload for now - in a real app this would call a server action\r\n      console.warn('Image upload placeholder â€“ integration with Prisma server action/storage required');\r\n\r\n      toast({\r\n        title: \"Image Processed\",\r\n        description: `Image optimized to ${finalSizeKB.toFixed(1)}KB. Backend upload is pending migration.`,\r\n      });\r\n\r\n      // Returning a data URL as a temporary \"upload result\" so it can be previewed\r\n      return new Promise((resolve) => {\r\n        const reader = new FileReader();\r\n        reader.onloadend = () => resolve(reader.result as string);\r\n        reader.readAsDataURL(compressedFile);\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Error uploading product image:', error);\r\n      toast({\r\n        title: \"Upload Error\",\r\n        description: \"Failed to process image.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return null;\r\n    }\r\n  };\r\n\r\n  return {\r\n    uploadProductImage,\r\n    compressImage,\r\n    removeMetadata\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 554, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/popover.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Popover = PopoverPrimitive.Root\r\n\r\nconst PopoverTrigger = PopoverPrimitive.Trigger\r\n\r\nconst PopoverContent = React.forwardRef<\r\n  React.ElementRef<typeof PopoverPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\r\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\r\n  <PopoverPrimitive.Portal>\r\n    <PopoverPrimitive.Content\r\n      ref={ref}\r\n      align={align}\r\n      sideOffset={sideOffset}\r\n      className={cn(\r\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\r\n        className\r\n      )}\r\n      {...props}\r\n    />\r\n  </PopoverPrimitive.Portal>\r\n))\r\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\r\n\r\nexport { Popover, PopoverTrigger, PopoverContent }\r\n"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,UAAU,8KAAqB;AAErC,MAAM,iBAAiB,iLAAwB;AAE/C,MAAM,+BAAiB,2KAAgB,MAGrC,CAAC,EAAE,SAAS,EAAE,QAAQ,QAAQ,EAAE,aAAa,CAAC,EAAE,GAAG,OAAO,EAAE,oBAC5D,6LAAC,gLAAuB;kBACtB,cAAA,6LAAC,iLAAwB;YACvB,KAAK;YACL,OAAO;YACP,YAAY;YACZ,WAAW,IAAA,4HAAE,EACX,8aACA;YAED,GAAG,KAAK;;;;;;;;;;;;AAIf,eAAe,WAAW,GAAG,iLAAwB,CAAC,WAAW"}},
    {"offset": {"line": 602, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/calendar.tsx"],"sourcesContent":["\r\nimport * as React from \"react\";\r\nimport { ChevronLeft, ChevronRight } from \"lucide-react\";\r\nimport { DayPicker } from \"react-day-picker\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\nimport { buttonVariants } from \"@/components/ui/button\";\r\n\r\nexport type CalendarProps = React.ComponentProps<typeof DayPicker>;\r\n\r\nfunction Calendar({\r\n  className,\r\n  classNames,\r\n  showOutsideDays = true,\r\n  ...props\r\n}: CalendarProps) {\r\n  return (\r\n    <DayPicker\r\n      showOutsideDays={showOutsideDays}\r\n      className={cn(\"p-3 pointer-events-auto\", className)}\r\n      classNames={{\r\n        months: \"flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0\",\r\n        month: \"space-y-4\",\r\n        caption: \"flex justify-center pt-1 relative items-center\",\r\n        caption_label: \"text-sm font-medium\",\r\n        caption_dropdowns: \"flex justify-center gap-1\",\r\n        nav: \"space-x-1 flex items-center\",\r\n        nav_button: cn(\r\n          buttonVariants({ variant: \"outline\" }),\r\n          \"h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100\"\r\n        ),\r\n        nav_button_previous: \"absolute left-1\",\r\n        nav_button_next: \"absolute right-1\",\r\n        table: \"w-full border-collapse space-y-1\",\r\n        head_row: \"flex\",\r\n        head_cell:\r\n          \"text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]\",\r\n        row: \"flex w-full mt-2\",\r\n        cell: \"h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20\",\r\n        day: cn(\r\n          buttonVariants({ variant: \"ghost\" }),\r\n          \"h-9 w-9 p-0 font-normal aria-selected:opacity-100\"\r\n        ),\r\n        day_range_end: \"day-range-end\",\r\n        day_selected:\r\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground\",\r\n        day_today: \"bg-accent text-accent-foreground\",\r\n        day_outside:\r\n          \"day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30\",\r\n        day_disabled: \"text-muted-foreground opacity-50\",\r\n        day_range_middle:\r\n          \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\r\n        day_hidden: \"invisible\",\r\n        dropdown: \"bg-background rounded-md border p-1 shadow-md\",\r\n        dropdown_month: \"w-[var(--rdp-caption-dropdown-month-width)]\",\r\n        dropdown_year: \"w-[var(--rdp-caption-dropdown-year-width)]\",\r\n        dropdown_icon: \"w-4 h-4\",\r\n        button_reset: \"appearance-none bg-transparent border-none p-0 m-0\",\r\n        vhidden: \"sr-only\",\r\n        ...classNames,\r\n      }}\r\n      components={{\r\n        IconLeft: ({ ..._props }) => <ChevronLeft className=\"h-4 w-4\" />,\r\n        IconRight: ({ ..._props }) => <ChevronRight className=\"h-4 w-4\" />,\r\n      }}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\nCalendar.displayName = \"Calendar\";\r\n\r\nexport { Calendar };\r\n"],"names":[],"mappings":";;;;;AAEA;AAAA;AACA;AAEA;AACA;;;;;;AAIA,SAAS,SAAS,EAChB,SAAS,EACT,UAAU,EACV,kBAAkB,IAAI,EACtB,GAAG,OACW;IACd,qBACE,6LAAC,8KAAS;QACR,iBAAiB;QACjB,WAAW,IAAA,4HAAE,EAAC,2BAA2B;QACzC,YAAY;YACV,QAAQ;YACR,OAAO;YACP,SAAS;YACT,eAAe;YACf,mBAAmB;YACnB,KAAK;YACL,YAAY,IAAA,4HAAE,EACZ,IAAA,uJAAc,EAAC;gBAAE,SAAS;YAAU,IACpC;YAEF,qBAAqB;YACrB,iBAAiB;YACjB,OAAO;YACP,UAAU;YACV,WACE;YACF,KAAK;YACL,MAAM;YACN,KAAK,IAAA,4HAAE,EACL,IAAA,uJAAc,EAAC;gBAAE,SAAS;YAAQ,IAClC;YAEF,eAAe;YACf,cACE;YACF,WAAW;YACX,aACE;YACF,cAAc;YACd,kBACE;YACF,YAAY;YACZ,UAAU;YACV,gBAAgB;YAChB,eAAe;YACf,eAAe;YACf,cAAc;YACd,SAAS;YACT,GAAG,UAAU;QACf;QACA,YAAY;YACV,UAAU,CAAC,EAAE,GAAG,QAAQ,iBAAK,6LAAC,sOAAW;oBAAC,WAAU;;;;;;YACpD,WAAW,CAAC,EAAE,GAAG,QAAQ,iBAAK,6LAAC,yOAAY;oBAAC,WAAU;;;;;;QACxD;QACC,GAAG,KAAK;;;;;;AAGf;KA1DS;AA2DT,SAAS,WAAW,GAAG"}},
    {"offset": {"line": 691, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/switch.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Switch = React.forwardRef<\r\n  React.ElementRef<typeof SwitchPrimitives.Root>,\r\n  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>\r\n>(({ className, ...props }, ref) => (\r\n  <SwitchPrimitives.Root\r\n    className={cn(\r\n      \"peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\r\n      className\r\n    )}\r\n    {...props}\r\n    ref={ref}\r\n  >\r\n    <SwitchPrimitives.Thumb\r\n      className={cn(\r\n        \"pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0\"\r\n      )}\r\n    />\r\n  </SwitchPrimitives.Root>\r\n))\r\nSwitch.displayName = SwitchPrimitives.Root.displayName\r\n\r\nexport { Switch }\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,uBAAS,2KAAgB,MAG7B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,6KAAqB;QACpB,WAAW,IAAA,4HAAE,EACX,sXACA;QAED,GAAG,KAAK;QACT,KAAK;kBAEL,cAAA,6LAAC,8KAAsB;YACrB,WAAW,IAAA,4HAAE,EACX;;;;;;;;;;;;AAKR,OAAO,WAAW,GAAG,6KAAqB,CAAC,WAAW"}},
    {"offset": {"line": 732, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/inventory/ProductForm.tsx"],"sourcesContent":["import React, { useState, useEffect, useRef, DragEvent } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Label } from '@/components/ui/label';\r\nimport { Textarea } from '@/components/ui/textarea';\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue,\r\n} from '@/components/ui/select';\r\nimport { Product, ProductCategory, ProductFormData } from '@/types';\r\nimport { useBusinessSettings } from '@/hooks/useBusinessSettings';\r\nimport { toast } from 'sonner';\r\nimport { Trash2, Upload, ExternalLink, Loader2, Zap, Calendar, Printer } from 'lucide-react';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useProductImage } from '@/hooks/useProductImage';\r\nimport { cn } from '@/lib/utils';\r\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';\r\nimport { Calendar as CalendarComponent } from '@/components/ui/calendar';\r\nimport { format } from 'date-fns';\r\nimport { Switch } from '@/components/ui/switch';\r\n\r\ninterface ProductFormProps {\r\n  initialData?: Product;\r\n  categories: ProductCategory[];\r\n  onProductSubmit: (data: ProductFormData & { autoPrintLabel?: boolean, printQuantity?: number }) => void;\r\n  isLoading: boolean;\r\n}\r\n\r\n// Extended form data type to handle quantity as string or number\r\ninterface ExtendedProductFormData extends Omit<ProductFormData, 'quantity'> {\r\n  quantity: number | string;\r\n  createdAt?: Date;\r\n  autoPrintLabel?: boolean;\r\n  printQuantity: number;\r\n}\r\n\r\nconst ProductForm: React.FC<ProductFormProps> = ({\r\n  initialData,\r\n  categories,\r\n  onProductSubmit,\r\n  isLoading,\r\n}) => {\r\n  const navigate = useNavigate();\r\n  const { settings } = useBusinessSettings();\r\n  const { user } = useAuth();\r\n  const { uploadProductImage, compressImage } = useProductImage(user?.id);\r\n\r\n  // Function to get initial form data\r\n  const getInitialFormData = (productData?: Product): ExtendedProductFormData => {\r\n    if (productData) {\r\n      // When editing/duplicating, use the product's data\r\n      return {\r\n        name: productData.name,\r\n        barcode: productData.barcode || '',\r\n        manufacturerBarcode: productData.manufacturerBarcode || '',\r\n        description: productData.description || '',\r\n        category: productData.category,\r\n        quantity: productData.quantity ?? 0,\r\n        costPrice: productData.costPrice,\r\n        sellingPrice: productData.sellingPrice,\r\n        supplier: productData.supplier || '',\r\n        minimumStock: productData.minimumStock,\r\n        imageFile: null,\r\n        imageUrl: productData.imageUrl,\r\n        createdAt: productData.createdAt || new Date(), // Use product's creation date\r\n        printQuantity: 1,\r\n        autoPrintLabel: false\r\n      };\r\n    } else {\r\n      // When creating new product, use defaults\r\n      return {\r\n        name: '',\r\n        barcode: '',\r\n        manufacturerBarcode: '',\r\n        description: '',\r\n        category: '',\r\n        quantity: 0,\r\n        costPrice: undefined,\r\n        sellingPrice: undefined,\r\n        supplier: '',\r\n        minimumStock: undefined,\r\n        imageFile: null,\r\n        imageUrl: null,\r\n        createdAt: new Date(), // Default to current date for new products\r\n        autoPrintLabel: true, // Default to true for new products as requested\r\n        printQuantity: 1\r\n      };\r\n    }\r\n  };\r\n\r\n  // Form state - initialize with proper data immediately\r\n  const [formData, setFormData] = useState<ExtendedProductFormData>(() =>\r\n    getInitialFormData(initialData)\r\n  );\r\n\r\n  const [errors, setErrors] = useState<Record<string, string>>({});\r\n  const [imagePreview, setImagePreview] = useState<string | null>(null);\r\n  const [imageChanged, setImageChanged] = useState(false);\r\n  const [uploading, setUploading] = useState(false);\r\n  const [compressing, setCompressing] = useState(false);\r\n  const [isDragging, setIsDragging] = useState(false);\r\n  const [compressionStats, setCompressionStats] = useState<{\r\n    originalSize: number;\r\n    compressedSize: number;\r\n    reduction: number;\r\n  } | null>(null);\r\n  const [isCalendarOpen, setIsCalendarOpen] = useState(false);\r\n  const fileInputRef = useRef<HTMLInputElement>(null);\r\n\r\n  // Update form data when initialData changes\r\n  useEffect(() => {\r\n    if (initialData) {\r\n      console.log('ProductForm - Setting form data from initialData:', initialData);\r\n      console.log('ProductForm - InitialData createdAt:', initialData.createdAt);\r\n\r\n      const newFormData = getInitialFormData(initialData);\r\n      setFormData(newFormData);\r\n\r\n      console.log('ProductForm - Form data set to:', newFormData);\r\n      console.log('ProductForm - Form createdAt set to:', newFormData.createdAt);\r\n\r\n      if (initialData.imageUrl) {\r\n        setImagePreview(initialData.imageUrl);\r\n      }\r\n    }\r\n  }, [initialData]);\r\n\r\n  const handleChange = (\r\n    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>\r\n  ) => {\r\n    const { name, value } = e.target;\r\n    let processedValue: any = value;\r\n\r\n    // Convert numeric fields to numbers or undefined if empty\r\n    if (\r\n      name === 'quantity' ||\r\n      name === 'minimumStock' ||\r\n      name === 'costPrice' ||\r\n      name === 'sellingPrice'\r\n    ) {\r\n      // For quantity, allow empty string and convert to number when not empty\r\n      if (name === 'quantity') {\r\n        if (value === '') {\r\n          processedValue = ''; // Keep as empty string to allow deletion\r\n        } else {\r\n          processedValue = parseFloat(value) || 0; // Allow decimal values\r\n        }\r\n        console.log('Quantity changed to:', processedValue);\r\n      } else {\r\n        processedValue = value === '' ? undefined : parseFloat(value);\r\n      }\r\n    }\r\n\r\n    setFormData({\r\n      ...formData,\r\n      [name]: processedValue\r\n    });\r\n\r\n    // Clear error when field is edited\r\n    if (errors[name]) {\r\n      setErrors({\r\n        ...errors,\r\n        [name]: ''\r\n      });\r\n    }\r\n  };\r\n\r\n  const handleCategoryChange = (value: string) => {\r\n    setFormData({\r\n      ...formData,\r\n      category: value\r\n    });\r\n\r\n    if (errors.category) {\r\n      setErrors({\r\n        ...errors,\r\n        category: ''\r\n      });\r\n    }\r\n\r\n    // Focus description field after category selection\r\n    setTimeout(() => {\r\n      document.getElementById('description')?.focus();\r\n    }, 100);\r\n  };\r\n\r\n  const handleDateChange = (date: Date | undefined) => {\r\n    if (date) {\r\n      // Set time to Noon (12:00:00) to avoid timezone issues where midnight UTC becomes 3 AM EAT\r\n      const adjustedDate = new Date(date);\r\n      adjustedDate.setHours(12, 0, 0, 0);\r\n\r\n      console.log('ProductForm - Date changed to:', adjustedDate);\r\n      setFormData({\r\n        ...formData,\r\n        createdAt: adjustedDate\r\n      });\r\n      setIsCalendarOpen(false);\r\n    }\r\n  };\r\n\r\n  const processImageFile = async (file: File) => {\r\n    if (file.size > 20 * 1024 * 1024) { // 20MB\r\n      toast.error('Image file is too large. Maximum size is 20MB.');\r\n      return;\r\n    }\r\n\r\n    if (!file.type.startsWith('image/')) {\r\n      toast.error('Only image files are allowed.');\r\n      return;\r\n    }\r\n\r\n    setCompressing(true);\r\n    setCompressionStats(null);\r\n\r\n    try {\r\n      // Use the compressImage function from the properly called hook\r\n      const compressedFile = await compressImage(file);\r\n\r\n      // Calculate compression stats\r\n      const reduction = ((file.size - compressedFile.size) / file.size * 100);\r\n      setCompressionStats({\r\n        originalSize: file.size,\r\n        compressedSize: compressedFile.size,\r\n        reduction: reduction\r\n      });\r\n\r\n      setFormData({\r\n        ...formData,\r\n        imageFile: compressedFile\r\n      });\r\n\r\n      setImageChanged(true);\r\n\r\n      // Create preview\r\n      const reader = new FileReader();\r\n      reader.onload = () => {\r\n        setImagePreview(reader.result as string);\r\n      };\r\n      reader.readAsDataURL(compressedFile);\r\n\r\n      toast.success(`Image optimized to ${(compressedFile.size / 1024).toFixed(1)}KB!`);\r\n    } catch (error) {\r\n      console.error('Error compressing image:', error);\r\n      toast.error('Failed to process image. Please try again.');\r\n    } finally {\r\n      setCompressing(false);\r\n    }\r\n  };\r\n\r\n  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const file = e.target.files?.[0];\r\n\r\n    if (file) {\r\n      processImageFile(file);\r\n    }\r\n  };\r\n\r\n  const handleDragOver = (e: DragEvent<HTMLDivElement>) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n    setIsDragging(true);\r\n  };\r\n\r\n  const handleDragLeave = (e: DragEvent<HTMLDivElement>) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n    setIsDragging(false);\r\n  };\r\n\r\n  const handleDrop = (e: DragEvent<HTMLDivElement>) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n    setIsDragging(false);\r\n\r\n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\r\n      const file = e.dataTransfer.files[0];\r\n      processImageFile(file);\r\n    }\r\n  };\r\n\r\n  const handleImageUploadClick = () => {\r\n    fileInputRef.current?.click();\r\n  };\r\n\r\n  const removeImage = () => {\r\n    setFormData({\r\n      ...formData,\r\n      imageFile: null,\r\n      imageUrl: null  // Clear the image URL when removing image\r\n    });\r\n    setImagePreview(null);\r\n    setImageChanged(true);\r\n    setCompressionStats(null);\r\n\r\n    // Reset the file input\r\n    if (fileInputRef.current) {\r\n      fileInputRef.current.value = '';\r\n    }\r\n  };\r\n\r\n  const validateForm = (): boolean => {\r\n    const newErrors: Record<string, string> = {};\r\n\r\n    if (!formData.name.trim()) {\r\n      newErrors.name = 'Product name is required';\r\n    }\r\n\r\n    // Category is optional, so no validation needed\r\n\r\n    // Note: Initial stock can now be negative to handle cases like backorders or inventory deficits\r\n    // Removed validation that prevented negative initial stock values\r\n\r\n    if (formData.costPrice !== undefined && formData.costPrice < 0) {\r\n      newErrors.costPrice = 'Cost price cannot be negative';\r\n    }\r\n\r\n    if (formData.sellingPrice !== undefined && formData.sellingPrice < 0) {\r\n      newErrors.sellingPrice = 'Selling price cannot be negative';\r\n    }\r\n\r\n    if (formData.minimumStock !== undefined && formData.minimumStock < 0) {\r\n      newErrors.minimumStock = 'Minimum stock cannot be negative';\r\n    }\r\n\r\n    setErrors(newErrors);\r\n    return Object.keys(newErrors).length === 0;\r\n  };\r\n\r\n  const handleSubmit = async (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n\r\n    console.log('ProductForm - Form data before validation:', formData);\r\n    console.log('ProductForm - Quantity value:', formData.quantity, 'Type:', typeof formData.quantity);\r\n    console.log('ProductForm - CreatedAt value:', formData.createdAt);\r\n\r\n    if (!validateForm()) {\r\n      toast.error('Please correct the errors in the form');\r\n      return;\r\n    }\r\n\r\n    let finalImageUrl = formData.imageUrl;\r\n\r\n    try {\r\n      // Handle image upload separately if needed\r\n      if (imageChanged && formData.imageFile) {\r\n        setUploading(true);\r\n        toast.info('Uploading optimized image...');\r\n        finalImageUrl = await uploadProductImage(formData.imageFile);\r\n\r\n        if (!finalImageUrl) {\r\n          setUploading(false);\r\n          return; // Stop if image upload failed - error is already shown by the hook\r\n        }\r\n        toast.success('Image uploaded successfully!');\r\n      } else if (imageChanged && !formData.imageFile) {\r\n        // Image was removed\r\n        finalImageUrl = null;\r\n      }\r\n\r\n      // Prepare final submission data - convert empty string quantity to 0\r\n      const finalQuantity = typeof formData.quantity === 'string' ? (formData.quantity === '' ? 0 : Number(formData.quantity)) : formData.quantity;\r\n      const submissionData = {\r\n        ...formData,\r\n        imageUrl: finalImageUrl,\r\n        quantity: finalQuantity // Convert to number for submission\r\n      };\r\n\r\n      console.log('ProductForm - Final submission data:', submissionData);\r\n      console.log('ProductForm - Final quantity being submitted:', submissionData.quantity);\r\n      console.log('ProductForm - Final createdAt being submitted:', submissionData.createdAt);\r\n\r\n      // Submit form with final image URL\r\n      await onProductSubmit(submissionData);\r\n    } catch (error) {\r\n      console.error('Error handling form submission:', error);\r\n      toast.error('Something went wrong. Please try again.');\r\n    } finally {\r\n      setUploading(false);\r\n    }\r\n  };\r\n\r\n  const isSubmitting = isLoading || uploading;\r\n\r\n  return (\r\n    <Card className=\"w-full\">\r\n      <CardHeader>\r\n        <CardTitle>{initialData ? 'Edit Product' : 'New Product'}</CardTitle>\r\n        <CardDescription>Enter the product details below. Only name is required.</CardDescription>\r\n      </CardHeader>\r\n      <CardContent>\r\n        <form onSubmit={handleSubmit} className=\"space-y-6\">\r\n          <div className=\"grid md:grid-cols-2 gap-6\">\r\n            <div className=\"space-y-6\">\r\n              <div className=\"grid gap-3\">\r\n                <Label htmlFor=\"name\">Product Name*</Label>\r\n                <Input\r\n                  id=\"name\"\r\n                  name=\"name\"\r\n                  value={formData.name}\r\n                  onChange={handleChange}\r\n                  onKeyDown={(e) => {\r\n                    if (e.key === 'Enter') {\r\n                      e.preventDefault();\r\n                      const categorySelect = document.querySelector('[role=\"combobox\"]') as HTMLElement;\r\n                      categorySelect?.focus();\r\n                    }\r\n                  }}\r\n                  placeholder=\"Enter product name\"\r\n                  className={errors.name ? 'border-red-500' : ''}\r\n                  disabled={isSubmitting}\r\n                />\r\n                {errors.name && (\r\n                  <p className=\"text-red-500 text-xs\">{errors.name}</p>\r\n                )}\r\n              </div>\r\n\r\n              <div className=\"grid gap-3\">\r\n                <Label htmlFor=\"manufacturerBarcode\">Manufacturer Barcode (Optional)</Label>\r\n                <Input\r\n                  id=\"manufacturerBarcode\"\r\n                  name=\"manufacturerBarcode\"\r\n                  value={formData.manufacturerBarcode}\r\n                  onChange={handleChange}\r\n                  onKeyDown={(e) => {\r\n                    if (e.key === 'Enter') {\r\n                      e.preventDefault();\r\n                      const categorySelect = document.querySelector('[role=\"combobox\"]') as HTMLElement;\r\n                      categorySelect?.focus();\r\n                    }\r\n                  }}\r\n                  placeholder=\"Enter manufacturer barcode (if any)\"\r\n                  disabled={isSubmitting}\r\n                />\r\n              </div>\r\n\r\n\r\n              <div className=\"grid gap-3\">\r\n                <Label htmlFor=\"category\">Category (Optional)</Label>\r\n                <p className=\"text-sm text-muted-foreground\">\r\n                  Need to create a new category? Go to the{' '}\r\n                  <Button\r\n                    type=\"button\"\r\n                    variant=\"link\"\r\n                    className=\"p-0 h-auto text-blue-600 underline\"\r\n                    onClick={() => navigate(`/categories?returnTo=${encodeURIComponent(window.location.pathname)}`)}\r\n                    disabled={isSubmitting}\r\n                  >\r\n                    Categories page <ExternalLink className=\"h-3 w-3 ml-1 inline\" />\r\n                  </Button>\r\n                  {' '}first, then return here to select it.\r\n                </p>\r\n                <Select\r\n                  value={formData.category}\r\n                  onValueChange={handleCategoryChange}\r\n                  disabled={isSubmitting}\r\n                >\r\n                  <SelectTrigger\r\n                    className={cn(errors.category ? 'border-red-500' : '')}\r\n                    onKeyDown={(e) => {\r\n                      console.log('SelectTrigger keydown:', e.key, 'Category:', formData.category);\r\n                      if (e.key === 'Enter') {\r\n                        e.preventDefault();\r\n                        e.stopPropagation();\r\n                        console.log('Enter pressed on SelectTrigger, focusing description');\r\n                        // Always move to description when Enter is pressed\r\n                        setTimeout(() => {\r\n                          const descriptionField = document.getElementById('description');\r\n                          console.log('Description field found:', !!descriptionField);\r\n                          descriptionField?.focus();\r\n                        }, 50);\r\n                        return false;\r\n                      } else if (e.key === 'Escape') {\r\n                        // On Escape, also move to description\r\n                        setTimeout(() => {\r\n                          document.getElementById('description')?.focus();\r\n                        }, 50);\r\n                      }\r\n                    }}\r\n                  >\r\n                    <SelectValue placeholder=\"Select category (optional)\" />\r\n                  </SelectTrigger>\r\n                  <SelectContent>\r\n                    {categories.length > 0 ? (\r\n                      categories.map((category) => (\r\n                        <SelectItem key={category.id} value={category.name}>\r\n                          {category.name}\r\n                        </SelectItem>\r\n                      ))\r\n                    ) : (\r\n                      <div className=\"p-2 text-sm text-muted-foreground\">\r\n                        No categories available\r\n                      </div>\r\n                    )}\r\n                  </SelectContent>\r\n                </Select>\r\n                {errors.category && (\r\n                  <p className=\"text-red-500 text-xs\">{errors.category}</p>\r\n                )}\r\n              </div>\r\n\r\n              <div className=\"grid gap-3\">\r\n                <Label htmlFor=\"description\">Description</Label>\r\n                <Textarea\r\n                  id=\"description\"\r\n                  name=\"description\"\r\n                  value={formData.description}\r\n                  onChange={handleChange}\r\n                  onKeyDown={(e) => {\r\n                    if (e.key === 'Enter' && !e.shiftKey) {\r\n                      e.preventDefault();\r\n                      document.getElementById('supplier')?.focus();\r\n                    }\r\n                  }}\r\n                  placeholder=\"Enter product description\"\r\n                  className=\"resize-none h-32\"\r\n                  disabled={isSubmitting}\r\n                />\r\n              </div>\r\n\r\n              <div className=\"grid gap-3\">\r\n                <Label htmlFor=\"supplier\">Supplier</Label>\r\n                <Input\r\n                  id=\"supplier\"\r\n                  name=\"supplier\"\r\n                  value={formData.supplier}\r\n                  onChange={handleChange}\r\n                  onKeyDown={(e) => {\r\n                    if (e.key === 'Enter') {\r\n                      e.preventDefault();\r\n                      document.getElementById('quantity')?.focus();\r\n                    }\r\n                  }}\r\n                  placeholder=\"Enter supplier name\"\r\n                  disabled={isSubmitting}\r\n                />\r\n              </div>\r\n\r\n              <div className=\"grid gap-3\">\r\n                <Label>Created Date</Label>\r\n                <Popover open={isCalendarOpen} onOpenChange={setIsCalendarOpen}>\r\n                  <PopoverTrigger asChild>\r\n                    <Button\r\n                      variant=\"outline\"\r\n                      className={cn(\r\n                        \"w-full justify-start text-left font-normal\",\r\n                        !formData.createdAt && \"text-muted-foreground\",\r\n                        initialData && \"cursor-not-allowed opacity-60\"\r\n                      )}\r\n                      disabled={isSubmitting || !!initialData}\r\n                    >\r\n                      <Calendar className=\"mr-2 h-4 w-4\" />\r\n                      {formData.createdAt ? format(formData.createdAt, \"PPP\") : \"Pick a date\"}\r\n                    </Button>\r\n                  </PopoverTrigger>\r\n                  <PopoverContent className=\"w-auto p-0\" align=\"start\">\r\n                    <CalendarComponent\r\n                      mode=\"single\"\r\n                      selected={formData.createdAt}\r\n                      onSelect={handleDateChange}\r\n                      disabled={(date) => date > new Date()}\r\n                      initialFocus\r\n                    />\r\n                  </PopoverContent>\r\n                </Popover>\r\n                {initialData && (\r\n                  <div className=\"bg-amber-50 border border-amber-200 p-3 rounded-lg\">\r\n                    <div className=\"text-amber-800 text-sm\">\r\n                      <strong>Note:</strong> To edit the creation date, please edit the initial stock history entry for this product through the inventory stock history.\r\n                    </div>\r\n                  </div>\r\n                )}\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"space-y-6\">\r\n              <div className=\"grid gap-3\">\r\n                <Label htmlFor=\"imageFile\">Product Image</Label>\r\n                <div className=\"flex flex-col items-center space-y-4\">\r\n                  {imagePreview ? (\r\n                    <div className=\"relative w-full\">\r\n                      <img\r\n                        src={imagePreview}\r\n                        alt=\"Product preview\"\r\n                        className=\"w-full h-40 object-contain border rounded-md\"\r\n                      />\r\n                      <Button\r\n                        type=\"button\"\r\n                        variant=\"destructive\"\r\n                        size=\"icon\"\r\n                        className=\"absolute top-2 right-2 rounded-full h-8 w-8\"\r\n                        onClick={removeImage}\r\n                        disabled={isSubmitting || compressing}\r\n                      >\r\n                        <Trash2 className=\"h-4 w-4\" />\r\n                      </Button>\r\n\r\n                      {/* Compression stats display */}\r\n                      {compressionStats && (\r\n                        <div className=\"mt-2 p-2 bg-green-50 border border-green-200 rounded-md\">\r\n                          <div className=\"flex items-center gap-2 text-green-700\">\r\n                            <Zap className=\"h-4 w-4\" />\r\n                            <span className=\"text-xs font-medium\">\r\n                              Optimized to {(compressionStats.compressedSize / 1024).toFixed(1)}KB\r\n                            </span>\r\n                          </div>\r\n                          <div className=\"text-xs text-green-600 mt-1\">\r\n                            {(compressionStats.originalSize / 1024).toFixed(1)}KB â†’ {(compressionStats.compressedSize / 1024).toFixed(1)}KB ({compressionStats.reduction.toFixed(1)}% reduction)\r\n                          </div>\r\n                        </div>\r\n                      )}\r\n                    </div>\r\n                  ) : (\r\n                    <div\r\n                      className={cn(\r\n                        \"border-2 border-dashed rounded-md p-8 w-full flex flex-col items-center justify-center cursor-pointer transition-colors\",\r\n                        isDragging ? \"border-blue-500 bg-blue-50\" : \"border-gray-300 hover:border-gray-400\",\r\n                        (isSubmitting || compressing) && \"opacity-50 cursor-not-allowed\"\r\n                      )}\r\n                      onDragOver={handleDragOver}\r\n                      onDragLeave={handleDragLeave}\r\n                      onDrop={handleDrop}\r\n                      onClick={!(isSubmitting || compressing) ? handleImageUploadClick : undefined}\r\n                    >\r\n                      {compressing ? (\r\n                        <>\r\n                          <Loader2 className=\"h-10 w-10 text-blue-500 mb-2 animate-spin\" />\r\n                          <p className=\"text-sm text-gray-500\">Optimizing image...</p>\r\n                          <p className=\"text-xs text-gray-400\">Compressing to under 15KB</p>\r\n                        </>\r\n                      ) : uploading ? (\r\n                        <>\r\n                          <Loader2 className=\"h-10 w-10 text-blue-500 mb-2 animate-spin\" />\r\n                          <p className=\"text-sm text-gray-500\">Uploading image...</p>\r\n                        </>\r\n                      ) : (\r\n                        <>\r\n                          <Upload className=\"h-10 w-10 text-gray-400 mb-2\" />\r\n                          <p className=\"text-sm text-gray-500\">\r\n                            Click to upload or drag and drop\r\n                          </p>\r\n                          <p className=\"text-xs text-gray-400\">PNG, JPG, GIF up to 20MB</p>\r\n                          <p className=\"text-xs text-blue-500 mt-1\">\r\n                            âš¡ Auto Image compression for instant loading\r\n                          </p>\r\n                        </>\r\n                      )}\r\n                    </div>\r\n                  )}\r\n                  <input\r\n                    type=\"file\"\r\n                    id=\"imageFile\"\r\n                    ref={fileInputRef}\r\n                    accept=\"image/*\"\r\n                    onChange={handleImageChange}\r\n                    className=\"hidden\"\r\n                    disabled={isSubmitting || compressing}\r\n                  />\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"grid md:grid-cols-2 gap-4\">\r\n                <div className=\"grid gap-3\">\r\n                  <Label htmlFor=\"quantity\">Initial Stock</Label>\r\n                  <Input\r\n                    id=\"quantity\"\r\n                    name=\"quantity\"\r\n                    type=\"number\"\r\n                    step=\"0.01\"\r\n                    value={formData.quantity}\r\n                    onChange={handleChange}\r\n                    onKeyDown={(e) => {\r\n                      if (e.key === 'Enter') {\r\n                        e.preventDefault();\r\n                        document.getElementById('minimumStock')?.focus();\r\n                      }\r\n                    }}\r\n                    className={errors.quantity ? 'border-red-500' : ''}\r\n                    disabled={isSubmitting}\r\n                    placeholder=\"Enter initial stock quantity (can be negative)\"\r\n                  />\r\n                  {errors.quantity && (\r\n                    <p className=\"text-red-500 text-xs\">{errors.quantity}</p>\r\n                  )}\r\n                  {initialData && (\r\n                    <p className=\"text-xs text-muted-foreground\">\r\n                      Current stock: {initialData.quantity} units\r\n                    </p>\r\n                  )}\r\n                </div>\r\n\r\n                <div className=\"grid gap-3\">\r\n                  <Label htmlFor=\"minimumStock\">Minimum Stock Level</Label>\r\n                  <Input\r\n                    id=\"minimumStock\"\r\n                    name=\"minimumStock\"\r\n                    type=\"number\"\r\n                    min=\"0\"\r\n                    step=\"0.01\"\r\n                    value={formData.minimumStock === undefined ? '' : formData.minimumStock}\r\n                    onChange={handleChange}\r\n                    onKeyDown={(e) => {\r\n                      if (e.key === 'Enter') {\r\n                        e.preventDefault();\r\n                        document.getElementById('costPrice')?.focus();\r\n                      }\r\n                    }}\r\n                    className={errors.minimumStock ? 'border-red-500' : ''}\r\n                    disabled={isSubmitting}\r\n                  />\r\n                  {errors.minimumStock && (\r\n                    <p className=\"text-red-500 text-xs\">{errors.minimumStock}</p>\r\n                  )}\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"grid md:grid-cols-2 gap-4\">\r\n                <div className=\"grid gap-3\">\r\n                  <Label htmlFor=\"costPrice\">Cost Price</Label>\r\n                  <div className=\"flex\">\r\n                    <span className=\"inline-flex items-center px-3 rounded-l-md border border-r-0 border-gray-300 bg-gray-50 text-gray-500\">\r\n                      {settings.currency}\r\n                    </span>\r\n                    <Input\r\n                      id=\"costPrice\"\r\n                      name=\"costPrice\"\r\n                      type=\"number\"\r\n                      min=\"0\"\r\n                      step=\"0.01\"\r\n                      value={formData.costPrice === undefined ? '' : formData.costPrice}\r\n                      onChange={handleChange}\r\n                      onKeyDown={(e) => {\r\n                        if (e.key === 'Enter') {\r\n                          e.preventDefault();\r\n                          document.getElementById('sellingPrice')?.focus();\r\n                        }\r\n                      }}\r\n                      className={`rounded-l-none ${errors.costPrice ? 'border-red-500' : ''}`}\r\n                      disabled={isSubmitting}\r\n                    />\r\n                  </div>\r\n                  {errors.costPrice && (\r\n                    <p className=\"text-red-500 text-xs\">{errors.costPrice}</p>\r\n                  )}\r\n                </div>\r\n\r\n                <div className=\"grid gap-3\">\r\n                  <Label htmlFor=\"sellingPrice\">Selling Price</Label>\r\n                  <div className=\"flex\">\r\n                    <span className=\"inline-flex items-center px-3 rounded-l-md border border-r-0 border-gray-300 bg-gray-50 text-gray-500\">\r\n                      {settings.currency}\r\n                    </span>\r\n                    <Input\r\n                      id=\"sellingPrice\"\r\n                      name=\"sellingPrice\"\r\n                      type=\"number\"\r\n                      min=\"0\"\r\n                      step=\"0.01\"\r\n                      value={formData.sellingPrice === undefined ? '' : formData.sellingPrice}\r\n                      onChange={handleChange}\r\n                      onKeyDown={(e) => {\r\n                        if (e.key === 'Enter') {\r\n                          e.preventDefault();\r\n                          const submitButton = document.querySelector('button[type=\"submit\"]') as HTMLElement;\r\n                          submitButton?.focus();\r\n                        }\r\n                      }}\r\n                      className={`rounded-l-none ${errors.sellingPrice ? 'border-red-500' : ''}`}\r\n                      disabled={isSubmitting}\r\n                    />\r\n                  </div>\r\n                  {errors.sellingPrice && (\r\n                    <p className=\"text-red-500 text-xs\">{errors.sellingPrice}</p>\r\n                  )}\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"grid gap-3\">\r\n                <p className=\"text-sm text-gray-500\">\r\n                  * Required fields | Initial Stock: The starting quantity for this product\r\n                </p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          <div className=\"flex items-center justify-end space-x-4\">\r\n            <Button\r\n              variant=\"outline\"\r\n              type=\"button\"\r\n              onClick={() => navigate('/inventory')}\r\n              disabled={isSubmitting || compressing}\r\n            >\r\n              Cancel\r\n            </Button>\r\n            <Button\r\n              type=\"submit\"\r\n              disabled={isSubmitting || compressing}\r\n              className=\"min-w-[100px]\"\r\n            >\r\n              {compressing ? (\r\n                <>\r\n                  <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\r\n                  Optimizing...\r\n                </>\r\n              ) : isSubmitting ? (\r\n                <>\r\n                  <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\r\n                  {uploading ? 'Uploading...' : 'Saving...'}\r\n                </>\r\n              ) : (\r\n                initialData ? 'Update Product' : 'Create Product'\r\n              )}\r\n            </Button>\r\n          </div>\r\n\r\n          {!initialData && (\r\n            <div className=\"flex flex-col md:flex-row items-center justify-end gap-4 pt-3 border-t\">\r\n              {formData.autoPrintLabel && (\r\n                <div className=\"flex items-center gap-2\">\r\n                  <Label htmlFor=\"printQuantity\" className=\"text-sm text-muted-foreground whitespace-nowrap\">\r\n                    Quantity to print:\r\n                  </Label>\r\n                  <Input\r\n                    id=\"printQuantity\"\r\n                    type=\"number\"\r\n                    min=\"1\"\r\n                    className=\"w-20 h-8\"\r\n                    value={formData.printQuantity}\r\n                    onChange={(e) => setFormData(prev => ({ ...prev, printQuantity: parseInt(e.target.value) || 1 }))}\r\n                    disabled={isSubmitting}\r\n                  />\r\n                </div>\r\n              )}\r\n              <div className=\"flex items-center space-x-2\">\r\n                <Printer className=\"h-4 w-4 text-muted-foreground\" />\r\n                <Label htmlFor=\"autoPrint\" className=\"text-sm font-medium cursor-pointer\">\r\n                  Auto-print barcode label\r\n                </Label>\r\n                <Switch\r\n                  id=\"autoPrint\"\r\n                  checked={formData.autoPrintLabel}\r\n                  onCheckedChange={(checked) => setFormData(prev => ({ ...prev, autoPrintLabel: checked }))}\r\n                  disabled={isSubmitting}\r\n                />\r\n              </div>\r\n            </div>\r\n          )}\r\n        </form>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n};\r\n\r\nexport default ProductForm;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2145, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/utils/inventoryCacheUtils.ts"],"sourcesContent":["import { QueryClient } from \"@tanstack/react-query\";\r\n\r\n/**\r\n * Utility to clear inventory-related caches (both localStorage and React Query)\r\n * to ensure real-time data accuracy.\r\n */\r\nexport const clearInventoryCaches = (queryClient?: QueryClient) => {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    // 1. Clear LocalStorage (Legacy / Manual caches)\r\n    const keys = Object.keys(localStorage);\r\n    const patterns = [\r\n        'allProductsStats_',\r\n        'stockSummary_',\r\n        'soldItems_',\r\n        'dashboardData_',\r\n        'analyticsData_'\r\n    ];\r\n\r\n    let clearedCount = 0;\r\n    keys.forEach(key => {\r\n        if (patterns.some(pattern => key.startsWith(pattern))) {\r\n            localStorage.removeItem(key);\r\n            clearedCount++;\r\n        }\r\n    });\r\n\r\n    if (clearedCount > 0) {\r\n        console.log(`[Cache] Cleared ${clearedCount} inventory-related localStorage entries.`);\r\n    }\r\n\r\n    // 2. Invalidate React Query Keys (Modern State)\r\n    if (queryClient) {\r\n        console.log('[Cache] Invalidating React Query inventory keys...');\r\n        // Invalidate specific keys used in the inventory module\r\n        queryClient.invalidateQueries({ queryKey: ['inventory_global_stats'] });\r\n        queryClient.invalidateQueries({ queryKey: ['stockSummary'] });\r\n        queryClient.invalidateQueries({ queryKey: ['products'] });\r\n        queryClient.invalidateQueries({ queryKey: ['sales'] });\r\n        queryClient.invalidateQueries({ queryKey: ['all-products-for-scanner'] });\r\n        queryClient.invalidateQueries({ queryKey: ['all-products'] });\r\n    }\r\n};\r\n"],"names":[],"mappings":";;;;AAMO,MAAM,uBAAuB,CAAC;IACjC;;IAEA,iDAAiD;IACjD,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,MAAM,WAAW;QACb;QACA;QACA;QACA;QACA;KACH;IAED,IAAI,eAAe;IACnB,KAAK,OAAO,CAAC,CAAA;QACT,IAAI,SAAS,IAAI,CAAC,CAAA,UAAW,IAAI,UAAU,CAAC,WAAW;YACnD,aAAa,UAAU,CAAC;YACxB;QACJ;IACJ;IAEA,IAAI,eAAe,GAAG;QAClB,QAAQ,GAAG,CAAC,CAAC,gBAAgB,EAAE,aAAa,wCAAwC,CAAC;IACzF;IAEA,gDAAgD;IAChD,IAAI,aAAa;QACb,QAAQ,GAAG,CAAC;QACZ,wDAAwD;QACxD,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAyB;QAAC;QACrE,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAe;QAAC;QAC3D,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAW;QAAC;QACvD,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAQ;QAAC;QACpD,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAA2B;QAAC;QACvE,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAe;QAAC;IAC/D;AACJ"}},
    {"offset": {"line": 2214, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qDAAA"}},
    {"offset": {"line": 2231, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqLsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 2248, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 2265, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqUsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 2282, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAkVsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 2299, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useProducts.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useMemo } from 'react';\r\nimport { Product, ProductFormData, ProductFilters } from '@/types';\r\nimport { useBusinessSettings } from './useBusinessSettings';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { clearInventoryCaches } from '@/utils/inventoryCacheUtils';\r\n\r\n// Import our new Server Actions\r\nimport {\r\n  getProductsAction,\r\n  createProductAction,\r\n  updateProductAction,\r\n  deleteProductAction,\r\n  updateProductsBulkAction\r\n} from '@/app/actions/products';\r\n\r\nexport const useProducts = (userId: string | undefined, initialPageSize: number = 50) => {\r\n  const [products, setProducts] = useState<Product[]>([]);\r\n  const [page, setPage] = useState(1);\r\n  const [pageSize, setPageSize] = useState(initialPageSize);\r\n  const [totalCount, setTotalCount] = useState(0);\r\n  const [isTyping, setIsTyping] = useState(false);\r\n  const { settings } = useBusinessSettings();\r\n  const { currentBusiness } = useBusiness();\r\n  const queryClient = useQueryClient();\r\n\r\n  const [filters, setFilters] = useState<ProductFilters>({\r\n    search: '',\r\n    category: 'all',\r\n    stockStatus: 'all'\r\n  });\r\n\r\n  const [typingTimer, setTypingTimer] = useState<NodeJS.Timeout | null>(null);\r\n\r\n  const setFiltersWithTypingState = useCallback((newFilters: ProductFilters) => {\r\n    if (newFilters.search !== filters.search) {\r\n      setIsTyping(true);\r\n      if (typingTimer) clearTimeout(typingTimer);\r\n      const timer = setTimeout(() => {\r\n        setIsTyping(false);\r\n      }, 600);\r\n      setTypingTimer(timer);\r\n    }\r\n    setFilters(newFilters);\r\n  }, [filters.search, typingTimer]);\r\n\r\n  // Use Server Action instead of Supabase\r\n  const loadProducts = useCallback(async (): Promise<{ products: Product[], count: number }> => {\r\n    if (!userId || !currentBusiness) {\r\n      return { products: [], count: 0 };\r\n    }\r\n\r\n    try {\r\n      // Server Action call\r\n      const result = await getProductsAction({\r\n        userId,\r\n        businessId: currentBusiness.id,\r\n        page,\r\n        pageSize,\r\n        search: filters.search,\r\n        category: filters.category === 'all' ? undefined : filters.category,\r\n        stockStatus: filters.stockStatus,\r\n      });\r\n      return result as { products: Product[], count: number };\r\n    } catch (error) {\r\n      console.error('Error loading products from server action:', error);\r\n      return { products: [], count: 0 };\r\n    }\r\n  }, [userId, currentBusiness?.id, page, pageSize, filters.search, filters.category, filters.stockStatus]);\r\n\r\n  const baseQueryKey = useMemo(() => ['products', userId, currentBusiness?.id], [userId, currentBusiness?.id]);\r\n  const queryKey = useMemo(() => [...baseQueryKey, page, pageSize, filters.search, filters.category, filters.stockStatus], [baseQueryKey, page, pageSize, filters.search, filters.category, filters.stockStatus]);\r\n\r\n  const { data: queriedData, isLoading: isQueryLoading, isFetching, refetch } = useQuery({\r\n    queryKey,\r\n    queryFn: loadProducts,\r\n    enabled: !!userId && !!currentBusiness?.id,\r\n    staleTime: 30_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: true,\r\n    refetchOnReconnect: true,\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (queriedData) {\r\n      setProducts(queriedData.products);\r\n      setTotalCount(queriedData.count);\r\n    }\r\n  }, [queriedData]);\r\n\r\n  const isLoading = (isQueryLoading && !queriedData) && !isTyping;\r\n\r\n  // Supabase Storage remains untouched since Prisma doesn't do file storage\r\n  // but we isolate it here.\r\n  const uploadProductImage = async (imageFile: File): Promise<string | null> => {\r\n    try {\r\n      if (!userId) return null;\r\n\r\n      // We will implement a server action for this. \r\n      // For now, let's assume we have an uploadImageAction.\r\n      // const formData = new FormData();\r\n      // formData.append('file', imageFile);\r\n      // formData.append('userId', userId);\r\n      // const result = await uploadImageAction(formData);\r\n      // return result.url;\r\n\r\n      console.warn('Image upload redirecting to server action (TODO)');\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error in uploadProductImage:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const createProduct = async (productData: ProductFormData): Promise<Product | null> => {\r\n    try {\r\n      if (!userId || !currentBusiness) return null;\r\n\r\n      const result = await createProductAction({\r\n        ...productData,\r\n        userId,\r\n        businessId: currentBusiness.id\r\n      });\r\n\r\n      if (!result) return null;\r\n\r\n      const newProduct = result as Product;\r\n\r\n      setProducts(prev => [newProduct, ...prev]);\r\n      setTotalCount(c => c + 1);\r\n\r\n      queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n      clearInventoryCaches(queryClient);\r\n\r\n      return newProduct;\r\n    } catch (error) {\r\n      console.error('Error creating product:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updateProduct = async (\r\n    id: string,\r\n    updates: Partial<Product>,\r\n    imageFile?: File | null,\r\n    isFromSale = false,\r\n    customChangeReason?: string,\r\n    adjustmentDate?: Date,\r\n    referenceId?: string,\r\n    receiptNumber?: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      let imageUrl = updates.imageUrl;\r\n      if (imageFile) {\r\n        imageUrl = await uploadProductImage(imageFile);\r\n      }\r\n\r\n      const result = await updateProductAction(id, {\r\n        ...updates,\r\n        imageUrl,\r\n        userId,\r\n        businessId: currentBusiness.id,\r\n        isFromSale,\r\n        customChangeReason,\r\n        referenceId\r\n      });\r\n\r\n      if (!result) return false;\r\n\r\n      queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n      clearInventoryCaches(queryClient);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating product:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteProduct = async (id: string): Promise<boolean> => {\r\n    try {\r\n      if (!userId) return false;\r\n\r\n      const success = await deleteProductAction(id);\r\n\r\n      if (success) {\r\n        queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n        clearInventoryCaches(queryClient);\r\n        return true;\r\n      }\r\n      return false;\r\n    } catch (error) {\r\n      console.error('Error deleting product:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const updateProductsBulk = async (\r\n    updates: Array<{ id: string; updated: Partial<Product>; imageFile?: File | null }>,\r\n    userIdForHistory?: string,\r\n    changeReason?: string,\r\n    referenceId?: string,\r\n    adjustmentDate?: Date,\r\n    receiptNumber?: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      const success = await updateProductsBulkAction(\r\n        updates.map(u => ({ id: u.id, updated: u.updated })),\r\n        currentBusiness.id\r\n      );\r\n\r\n      if (success) {\r\n        queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n        clearInventoryCaches(queryClient);\r\n      }\r\n\r\n      return success;\r\n    } catch (error) {\r\n      console.error('Error in bulk update:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  return {\r\n    products,\r\n    isLoading,\r\n    loadProducts,\r\n    page,\r\n    setPage,\r\n    pageSize,\r\n    setPageSize,\r\n    totalCount,\r\n    createProduct,\r\n    updateProduct,\r\n    updateProductsBulk,\r\n    deleteProduct,\r\n    uploadProductImage,\r\n    refetch,\r\n    isFetching,\r\n    filters,\r\n    setFilters: setFiltersWithTypingState,\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2583, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoXsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,8DAAA"}},
    {"offset": {"line": 2600, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAyYsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 2617, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA2ZsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 2634, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0asB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 2651, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useCategories.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\nimport { ProductCategory } from '@/types';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport {\r\n  getProductCategoriesAction,\r\n  createProductCategoryAction,\r\n  updateProductCategoryAction,\r\n  deleteProductCategoryAction\r\n} from '@/app/actions/products';\r\n\r\nexport const useCategories = (userId: string | undefined) => {\r\n  const [categories, setCategories] = useState<ProductCategory[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const loadCategories = useCallback(async () => {\r\n    try {\r\n      if (!currentBusiness?.id) {\r\n        setCategories([]);\r\n        setIsLoading(false);\r\n        return;\r\n      }\r\n\r\n      setIsLoading(true);\r\n      const result = await getProductCategoriesAction(currentBusiness.id);\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error || 'Failed to fetch categories');\r\n      }\r\n\r\n      const formattedCategories: ProductCategory[] = result.data.map((item: any) => ({\r\n        id: item.id,\r\n        name: item.name,\r\n        createdAt: item.createdAt ? new Date(item.createdAt) : (item.created_at ? new Date(item.created_at) : undefined)\r\n      }));\r\n\r\n      setCategories(formattedCategories);\r\n    } catch (error) {\r\n      console.error('Error loading categories:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load product categories.\",\r\n        variant: \"destructive\"\r\n      });\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [currentBusiness?.id, toast]);\r\n\r\n  useEffect(() => {\r\n    loadCategories();\r\n  }, [loadCategories]);\r\n\r\n  const createCategory = async (name: string) => {\r\n    try {\r\n      if (!userId || !currentBusiness?.id) return null;\r\n\r\n      // Check if category already exists\r\n      const existingCategory = categories.find(\r\n        cat => cat.name.toLowerCase() === name.toLowerCase()\r\n      );\r\n\r\n      if (existingCategory) {\r\n        toast({\r\n          title: \"Category exists\",\r\n          description: \"This category already exists.\",\r\n        });\r\n        return existingCategory;\r\n      }\r\n\r\n      const result = await createProductCategoryAction(currentBusiness.id, userId, name);\r\n\r\n      if (!result.success || !result.data) throw new Error(result.error);\r\n\r\n      const newCategory: ProductCategory = {\r\n        id: result.data.id,\r\n        name: result.data.name,\r\n        createdAt: new Date(result.data.createdAt)\r\n      };\r\n\r\n      setCategories(prev => [...prev, newCategory]);\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Category created successfully\"\r\n      });\r\n      return newCategory;\r\n    } catch (error) {\r\n      console.error('Error creating category:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to create category.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updateCategory = async (id: string, name: string) => {\r\n    try {\r\n      // Check if another category with this name exists\r\n      const existingCategory = categories.find(\r\n        cat => cat.name.toLowerCase() === name.toLowerCase() && cat.id !== id\r\n      );\r\n\r\n      if (existingCategory) {\r\n        toast({\r\n          title: \"Category exists\",\r\n          description: \"Another category with this name already exists.\",\r\n        });\r\n        return false;\r\n      }\r\n\r\n      const result = await updateProductCategoryAction(id, name);\r\n\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      setCategories(prev => prev.map(c => c.id === id ? { ...c, name } : c));\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Category updated successfully\"\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating category:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update category.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteCategory = async (id: string) => {\r\n    try {\r\n      const result = await deleteProductCategoryAction(id);\r\n\r\n      if (!result.success) {\r\n        toast({\r\n          title: \"Cannot delete category\",\r\n          description: result.error || \"Failed to delete category.\",\r\n          variant: \"destructive\"\r\n        });\r\n        return false;\r\n      }\r\n\r\n      setCategories(prev => prev.filter(c => c.id !== id));\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Category deleted successfully\"\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting category:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete category.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  return {\r\n    categories,\r\n    isLoading,\r\n    loadCategories,\r\n    createCategory,\r\n    updateCategory,\r\n    deleteCategory\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2835, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/pages/NewProduct.tsx"],"sourcesContent":["\r\nimport React, { useEffect, useState } from 'react';\r\nimport { useNavigate, useParams, useLocation } from 'react-router-dom';\r\nimport ProductForm from '@/components/inventory/ProductForm';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useProducts } from '@/hooks/useProducts';\r\nimport { useCategories } from '@/hooks/useCategories';\r\nimport { Product, ProductFormData } from '@/types';\r\nimport { toast } from 'sonner';\r\nimport { Button } from '@/components/ui/button';\r\nimport { ArrowLeft, RefreshCw } from 'lucide-react';\r\nimport { useBusinessSettings } from '@/hooks/useBusinessSettings';\r\nimport { formatNumber } from '@/lib/utils';\r\nimport { useProfiles } from '@/contexts/ProfileContext';\r\nimport { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';\r\nimport { AlertCircle } from 'lucide-react';\r\n\r\nconst NewProduct = () => {\r\n  const { id } = useParams<{ id: string }>();\r\n  const location = useLocation();\r\n  const navigate = useNavigate();\r\n  const { user } = useAuth();\r\n  const { products, isLoading: productsLoading, createProduct, updateProduct, loadProducts, refetch } = useProducts(user?.id, 10000); // Load all products\r\n  const { categories, isLoading: categoriesLoading } = useCategories(user?.id);\r\n  const [product, setProduct] = useState<Product | undefined>(undefined);\r\n  const [isSubmitting, setIsSubmitting] = useState(false);\r\n  const [loadError, setLoadError] = useState<string | null>(null);\r\n  const [isRefreshing, setIsRefreshing] = useState(false);\r\n  const [dataLoaded, setDataLoaded] = useState(false);\r\n  const { settings } = useBusinessSettings();\r\n  const { hasPermission, isLoading: profilesLoading } = useProfiles();\r\n\r\n  // Check for duplicate data from navigation state\r\n  const duplicateData = location.state?.duplicateData;\r\n\r\n  const loadProductData = async () => {\r\n    if (id) {\r\n      // If refreshing, set state \r\n      setIsRefreshing(true);\r\n\r\n      // Clear any previous error\r\n      setLoadError(null);\r\n\r\n      // Load fresh product data\r\n      const { data: refetchedData } = await refetch();\r\n      const fetchedProducts = refetchedData?.products || [];\r\n\r\n      const foundProduct = fetchedProducts.find(p => p.id === id);\r\n\r\n      if (foundProduct) {\r\n        setProduct(foundProduct);\r\n        setDataLoaded(true);\r\n      } else {\r\n        setLoadError('Product not found. It may have been deleted or you may not have permission to view it.');\r\n        toast.error('Product not found');\r\n      }\r\n\r\n      setIsRefreshing(false);\r\n    } else if (duplicateData) {\r\n      // For duplicate mode, set the data as loaded\r\n      setDataLoaded(true);\r\n    } else {\r\n      // For new product mode\r\n      setDataLoaded(true);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    // Only load if we have an ID, haven't loaded yet, and products are available\r\n    if (id && products.length > 0 && !dataLoaded) {\r\n      const foundProduct = products.find(p => p.id === id);\r\n\r\n      if (foundProduct) {\r\n        setProduct(foundProduct);\r\n        setDataLoaded(true);\r\n        // Clear any previous error\r\n        setLoadError(null);\r\n      } else if (products.length > 0) {\r\n        // Only set error if we have products loaded but didn't find the one we're looking for\r\n        setLoadError('Product not found. It may have been deleted or you may not have permission to view it.');\r\n        toast.error('Product not found');\r\n      }\r\n    } else if (!id) {\r\n      // New product or duplicate mode\r\n      setDataLoaded(true);\r\n    }\r\n  }, [id, products.length, dataLoaded]); // Use products.length instead of products array\r\n\r\n  const handleRefresh = async () => {\r\n    toast.info('Refreshing product data...');\r\n    setDataLoaded(false);\r\n    await loadProductData();\r\n  };\r\n\r\n  const handleProductSubmit = async (formData: ProductFormData & { createdAt?: Date, autoPrintLabel?: boolean, printQuantity?: number }) => {\r\n    setIsSubmitting(true);\r\n\r\n    try {\r\n      if (id && product) {\r\n        // ... (update existing product logic - unchanged)\r\n        const updateData = {\r\n          name: formData.name,\r\n          description: formData.description || '',\r\n          category: formData.category || '',\r\n          quantity: formData.quantity,\r\n          costPrice: formData.costPrice ?? 0,\r\n          sellingPrice: formData.sellingPrice ?? 0,\r\n          supplier: formData.supplier || '',\r\n          minimumStock: formData.minimumStock ?? 0,\r\n          imageUrl: formData.imageUrl || null,\r\n          createdAt: formData.createdAt,\r\n          barcode: formData.barcode,\r\n          manufacturerBarcode: formData.manufacturerBarcode\r\n        };\r\n\r\n        const result = await updateProduct(id, updateData);\r\n\r\n        if (result) {\r\n          toast.success('Product updated successfully');\r\n          navigate(`/inventory/${id}`);\r\n        } else {\r\n          toast.error('Failed to update product');\r\n        }\r\n      } else {\r\n        // Create new product\r\n        if (!user?.id) {\r\n          toast.error('You must be logged in to create products');\r\n          return;\r\n        }\r\n\r\n        const createData = {\r\n          id: '',\r\n          name: formData.name,\r\n          description: formData.description || '',\r\n          category: formData.category || '',\r\n          quantity: formData.quantity,\r\n          costPrice: formData.costPrice ?? 0,\r\n          sellingPrice: formData.sellingPrice ?? 0,\r\n          supplier: formData.supplier || '',\r\n          minimumStock: formData.minimumStock ?? 0,\r\n          imageUrl: formData.imageUrl || null,\r\n          createdAt: formData.createdAt || new Date(),\r\n          updatedAt: new Date(),\r\n          barcode: formData.barcode || '',\r\n          manufacturerBarcode: formData.manufacturerBarcode || ''\r\n        };\r\n\r\n        const newProduct = await createProduct(createData);\r\n\r\n        if (newProduct) {\r\n          toast.success('Product created successfully');\r\n\r\n          // Auto-print label if requested\r\n          if (formData.autoPrintLabel && newProduct.barcode) {\r\n            try {\r\n              const printQty = formData.printQuantity || 1;\r\n              toast.info(`Sending ${printQty} barcode label${printQty > 1 ? 's' : ''} to printer...`);\r\n              await fetch('http://localhost:5000/print/label', {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                mode: 'cors',\r\n                body: JSON.stringify({\r\n                  PrinterName: settings.defaultPrinterName || 'Label Printer',\r\n                  Content: `SIZE 50 mm, 30 mm\\nGAP 3 mm, 0 mm\\nCLS\\nTEXT 15,20,\"3\",0,1,1,\"${newProduct.name}\"\\nBARCODE 15,70,\"128\",60,1,0,2,2,\"${newProduct.barcode}\"\\nTEXT 15,180,\"3\",0,1,1,\"${settings.currency} ${formatNumber(newProduct.sellingPrice)}\"\\nPRINT ${printQty}\\n`\r\n                })\r\n              });\r\n              toast.success('Barcode label printed');\r\n            } catch (err) {\r\n              console.error('Failed to auto-print label:', err);\r\n              toast.error('Failed to print label. Is the Printer Bridge running?');\r\n            }\r\n          }\r\n\r\n          navigate(`/inventory/${newProduct.id}`);\r\n        } else {\r\n          toast.error('Failed to create product');\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error submitting product:', error);\r\n      toast.error('An error occurred while saving the product');\r\n    } finally {\r\n      setIsSubmitting(false);\r\n    }\r\n  };\r\n\r\n  const isLoading = productsLoading || categoriesLoading || isSubmitting || isRefreshing;\r\n\r\n  // Determine initial data - use duplicateData if available, otherwise use product for edit mode\r\n  const initialData = duplicateData ? {\r\n    ...duplicateData,\r\n    quantity: 0, // Always start with 0 quantity for duplicates\r\n    id: '', // No ID for new product\r\n    itemNumber: '', // Will be auto-generated\r\n    createdAt: new Date(), // Use current time for duplicate, not original product time\r\n    updatedAt: new Date(),\r\n    barcode: '', // Clear barcode to avoid unique constraint conflict\r\n    manufacturerBarcode: '' // Clear manufacturer barcode as well\r\n  } as Product : product;\r\n\r\n  // Permission Check\r\n  const canEdit = id ? hasPermission('inventory', 'edit') : true;\r\n  const canCreate = !id ? hasPermission('inventory', 'create') : true;\r\n\r\n  if (profilesLoading || productsLoading || categoriesLoading) {\r\n    return (\r\n      <div className=\"flex items-center justify-center min-h-[400px]\">\r\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary\"></div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!canEdit || !canCreate) {\r\n    return (\r\n      <div className=\"max-w-4xl mx-auto p-6\">\r\n        <Alert variant=\"destructive\">\r\n          <AlertCircle className=\"h-4 w-4\" />\r\n          <AlertTitle>Access Denied</AlertTitle>\r\n          <AlertDescription>\r\n            You do not have permission to {id ? 'edit this product' : 'create a new product'}.\r\n            Please contact your administrator if you believe this is an error.\r\n          </AlertDescription>\r\n        </Alert>\r\n        <div className=\"mt-4\">\r\n          <Button onClick={() => navigate('/inventory')} variant=\"outline\">\r\n            Back to Inventory\r\n          </Button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Don't render the form until we have loaded the data or determined we don't need to load it\r\n  if (id && !dataLoaded && !loadError) {\r\n    return (\r\n      <div className=\"space-y-6\">\r\n        <div className=\"flex items-center justify-between\">\r\n          <Button\r\n            variant=\"outline\"\r\n            size=\"sm\"\r\n            onClick={() => navigate('/inventory')}\r\n            className=\"flex items-center gap-1\"\r\n          >\r\n            <ArrowLeft className=\"h-4 w-4\" /> Back to Inventory\r\n          </Button>\r\n        </div>\r\n        <div className=\"flex items-center justify-center h-64\">\r\n          <div className=\"text-center\">\r\n            <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900 mx-auto mb-4\"></div>\r\n            <p className=\"text-gray-600\">Loading product data...</p>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      <div className=\"flex items-center justify-between\">\r\n        <Button\r\n          variant=\"outline\"\r\n          size=\"sm\"\r\n          onClick={() => navigate('/inventory')}\r\n          className=\"flex items-center gap-1\"\r\n        >\r\n          <ArrowLeft className=\"h-4 w-4\" /> Back to Inventory\r\n        </Button>\r\n\r\n        {/* Add refresh button when in edit mode */}\r\n        {id && (\r\n          <Button\r\n            variant=\"outline\"\r\n            size=\"sm\"\r\n            onClick={handleRefresh}\r\n            disabled={isLoading}\r\n            className=\"flex items-center gap-1\"\r\n          >\r\n            <RefreshCw className={`h-4 w-4 ${isRefreshing ? 'animate-spin' : ''}`} />\r\n            {isRefreshing ? 'Refreshing...' : 'Refresh Data'}\r\n          </Button>\r\n        )}\r\n      </div>\r\n\r\n      {loadError ? (\r\n        <div className=\"p-6 bg-red-50 border border-red-200 rounded-md\">\r\n          <h3 className=\"text-lg font-medium text-red-800 mb-2\">Error Loading Product</h3>\r\n          <p className=\"text-red-600\">{loadError}</p>\r\n          <Button\r\n            className=\"mt-4\"\r\n            onClick={() => navigate('/inventory')}\r\n          >\r\n            Return to Inventory\r\n          </Button>\r\n        </div>\r\n      ) : (\r\n        <ProductForm\r\n          initialData={initialData}\r\n          categories={categories}\r\n          onProductSubmit={handleProductSubmit}\r\n          isLoading={isLoading}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default NewProduct;\r\n"],"names":[],"mappings":"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"}}]
}