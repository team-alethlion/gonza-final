{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useCashAccounts.ts"],"sourcesContent":["import { useState, useEffect, useMemo, useCallback } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { CashAccount, CashTransaction } from '@/types/cash';\r\n\r\nexport const useCashAccounts = () => {\r\n  const [accounts, setAccounts] = useState<CashAccount[]>([]);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n  const queryClient = useQueryClient();\r\n\r\n  // Memoize the load function to prevent unnecessary re-renders\r\n  const loadAccounts = useCallback(async (): Promise<CashAccount[]> => {\r\n    try {\r\n      if (!currentBusiness) {\r\n        return [];\r\n      }\r\n\r\n      // Optimize query - only select needed fields and limit for faster loading\r\n      const { data, error } = await supabase\r\n        .from('cash_accounts')\r\n        .select('id, name, description, opening_balance, is_default, created_at, updated_at')\r\n        .eq('location_id', currentBusiness.id)\r\n        .order('is_default', { ascending: false })\r\n        .order('name'); // Load all cash accounts\r\n\r\n      if (error) throw error;\r\n\r\n      const formattedAccounts: CashAccount[] = data?.map(account => ({\r\n        id: account.id,\r\n        name: account.name,\r\n        description: account.description,\r\n        openingBalance: account.opening_balance,\r\n        isDefault: account.is_default,\r\n        createdAt: new Date(account.created_at),\r\n        updatedAt: new Date(account.updated_at)\r\n      })) || [];\r\n\r\n      return formattedAccounts;\r\n    } catch (error) {\r\n      console.error('Error loading cash accounts:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load cash accounts. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return [];\r\n    }\r\n  }, [currentBusiness?.id, toast]);\r\n\r\n  // React Query caching\r\n  const queryKey = ['cash_accounts', currentBusiness?.id];\r\n  const { data: queriedAccounts, isLoading: isQueryLoading, isFetching } = useQuery({\r\n    queryKey,\r\n    queryFn: loadAccounts,\r\n    enabled: !!currentBusiness?.id,\r\n    staleTime: 0, // Ensure data is always considered stale to get fresh updates\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: true,\r\n    refetchOnReconnect: true,\r\n  });\r\n\r\n  // Sync React Query data with local state\r\n  useEffect(() => {\r\n    if (queriedAccounts) {\r\n      setAccounts(queriedAccounts);\r\n    }\r\n  }, [queriedAccounts]);\r\n\r\n  // Derived loading state: only true when first loading (pre cache)\r\n  const isLoading = isQueryLoading && !queriedAccounts;\r\n\r\n  const refreshAccounts = useCallback(() => {\r\n    queryClient.invalidateQueries({ queryKey });\r\n  }, [queryClient, queryKey]);\r\n\r\n  // Memoize create account function\r\n  const createAccount = useCallback(async (accountData: {\r\n    name: string;\r\n    description?: string;\r\n    openingBalance: number;\r\n    isDefault?: boolean;\r\n  }) => {\r\n    try {\r\n      if (!currentBusiness) {\r\n        toast({\r\n          title: \"Error\",\r\n          description: \"No business selected\",\r\n          variant: \"destructive\"\r\n        });\r\n        return null;\r\n      }\r\n\r\n      const { data: userData } = await supabase.auth.getUser();\r\n      if (!userData.user) throw new Error('User not authenticated');\r\n\r\n      const insertData = {\r\n        user_id: userData.user.id,\r\n        location_id: currentBusiness.id,\r\n        name: accountData.name,\r\n        description: accountData.description || null,\r\n        opening_balance: accountData.openingBalance,\r\n        is_default: accountData.isDefault || false\r\n      };\r\n\r\n      const { data, error } = await supabase\r\n        .from('cash_accounts')\r\n        .insert(insertData)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) throw error;\r\n\r\n      // Format the new account and update cache immediately\r\n      const newAccount: CashAccount = {\r\n        id: data.id,\r\n        name: data.name,\r\n        description: data.description,\r\n        openingBalance: data.opening_balance,\r\n        isDefault: data.is_default,\r\n        createdAt: new Date(data.created_at),\r\n        updatedAt: new Date(data.updated_at)\r\n      };\r\n\r\n      // Update local state immediately\r\n      setAccounts(prev => [newAccount, ...prev]);\r\n\r\n      // Update React Query cache immediately\r\n      queryClient.setQueryData(queryKey, (oldData: CashAccount[] | undefined) => {\r\n        return oldData ? [newAccount, ...oldData] : [newAccount];\r\n      });\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Cash account created successfully\"\r\n      });\r\n\r\n      return data;\r\n    } catch (error) {\r\n      console.error('Error creating cash account:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to create cash account. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return null;\r\n    }\r\n  }, [currentBusiness, loadAccounts, toast]);\r\n\r\n  const updateAccount = async (id: string, updates: Partial<CashAccount>) => {\r\n    try {\r\n      const updateData: any = {};\r\n\r\n      if (updates.name !== undefined) updateData.name = updates.name;\r\n      if (updates.description !== undefined) updateData.description = updates.description;\r\n      if (updates.openingBalance !== undefined) updateData.opening_balance = updates.openingBalance;\r\n      if (updates.isDefault !== undefined) updateData.is_default = updates.isDefault;\r\n\r\n      const { error } = await supabase\r\n        .from('cash_accounts')\r\n        .update(updateData)\r\n        .eq('id', id)\r\n        .eq('location_id', currentBusiness?.id);\r\n\r\n      if (error) throw error;\r\n\r\n      // Optimistic update - update local state\r\n      setAccounts(prev => prev.map(a => a.id === id ? {\r\n        ...a,\r\n        name: updates.name ?? a.name,\r\n        description: updates.description ?? a.description,\r\n        openingBalance: updates.openingBalance ?? a.openingBalance,\r\n        isDefault: updates.isDefault ?? a.isDefault,\r\n        updatedAt: new Date()\r\n      } : a));\r\n\r\n      // Update React Query cache immediately\r\n      queryClient.setQueryData(queryKey, (oldData: CashAccount[] | undefined) => {\r\n        return oldData ? oldData.map(a => a.id === id ? {\r\n          ...a,\r\n          name: updates.name ?? a.name,\r\n          description: updates.description ?? a.description,\r\n          openingBalance: updates.openingBalance ?? a.openingBalance,\r\n          isDefault: updates.isDefault ?? a.isDefault,\r\n          updatedAt: new Date()\r\n        } : a) : [];\r\n      });\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Cash account updated successfully\"\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating cash account:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update cash account. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteAccount = async (id: string, onDeleted?: () => void) => {\r\n    try {\r\n      if (!currentBusiness) return { success: false, hasTransactions: false };\r\n\r\n      // Check if account has transactions\r\n      const { data: transactions, error: transactionError } = await supabase\r\n        .from('cash_transactions')\r\n        .select('id')\r\n        .eq('account_id', id)\r\n        .eq('location_id', currentBusiness.id);\r\n\r\n      if (transactionError) throw transactionError;\r\n\r\n      // Check if account has linked expenses\r\n      const { data: expenses, error: expenseError } = await supabase\r\n        .from('expenses')\r\n        .select('id')\r\n        .eq('cash_account_id', id)\r\n        .eq('location_id', currentBusiness.id);\r\n\r\n      if (expenseError) throw expenseError;\r\n\r\n      const transactionCount = transactions?.length || 0;\r\n      const expenseCount = expenses?.length || 0;\r\n      const totalLinkedRecords = transactionCount + expenseCount;\r\n\r\n      if (totalLinkedRecords > 0) {\r\n        // Return an object indicating the account has linked records\r\n        const details = [];\r\n        if (transactionCount > 0) details.push(`${transactionCount} transaction(s)`);\r\n        if (expenseCount > 0) details.push(`${expenseCount} expense(s)`);\r\n\r\n        return {\r\n          hasTransactions: true,\r\n          transactionCount: totalLinkedRecords,\r\n          details: `This account has ${details.join(' and ')}. What would you like to do?`,\r\n          success: false\r\n        };\r\n      }\r\n\r\n      // If no linked records, delete the account\r\n      const { error } = await supabase\r\n        .from('cash_accounts')\r\n        .delete()\r\n        .eq('id', id)\r\n        .eq('location_id', currentBusiness.id);\r\n\r\n      if (error) throw error;\r\n      // Optimistic remove\r\n      setAccounts(prev => prev.filter(a => a.id !== id));\r\n      queryClient.invalidateQueries({ queryKey });\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Cash account deleted successfully\"\r\n      });\r\n\r\n      // Call the callback function if provided\r\n      if (onDeleted) {\r\n        onDeleted();\r\n      }\r\n\r\n      return { success: true, hasTransactions: false };\r\n    } catch (error) {\r\n      console.error('Error deleting cash account:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete cash account. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return { success: false, hasTransactions: false };\r\n    }\r\n  };\r\n\r\n  const deleteAccountWithTransactions = async (id: string, deleteTransactions: boolean = false, onDeleted?: () => void) => {\r\n    try {\r\n      if (!currentBusiness) return false;\r\n\r\n      if (deleteTransactions) {\r\n        // First delete associated cash transactions\r\n        const { error: transactionError } = await supabase\r\n          .from('cash_transactions')\r\n          .delete()\r\n          .eq('account_id', id)\r\n          .eq('location_id', currentBusiness.id);\r\n\r\n        if (transactionError) throw transactionError;\r\n\r\n        // Then unlink or delete associated expenses\r\n        const { error: expenseError } = await supabase\r\n          .from('expenses')\r\n          .update({\r\n            cash_account_id: null,\r\n            cash_transaction_id: null\r\n          })\r\n          .eq('cash_account_id', id)\r\n          .eq('location_id', currentBusiness.id);\r\n\r\n        if (expenseError) throw expenseError;\r\n      } else {\r\n        // Just unlink expenses (set cash_account_id to null)\r\n        const { error: expenseError } = await supabase\r\n          .from('expenses')\r\n          .update({\r\n            cash_account_id: null,\r\n            cash_transaction_id: null\r\n          })\r\n          .eq('cash_account_id', id)\r\n          .eq('location_id', currentBusiness.id);\r\n\r\n        if (expenseError) throw expenseError;\r\n      }\r\n\r\n      // Then delete the account\r\n      const { error: accountError } = await supabase\r\n        .from('cash_accounts')\r\n        .delete()\r\n        .eq('id', id)\r\n        .eq('location_id', currentBusiness.id);\r\n\r\n      if (accountError) throw accountError;\r\n      // Optimistic remove\r\n      setAccounts(prev => prev.filter(a => a.id !== id));\r\n      queryClient.invalidateQueries({ queryKey });\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: deleteTransactions\r\n          ? \"Cash account and all associated records deleted successfully\"\r\n          : \"Cash account deleted successfully (linked records unlinked)\"\r\n      });\r\n\r\n      // Call the callback function if provided\r\n      if (onDeleted) {\r\n        onDeleted();\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting cash account with transactions:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete cash account. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Updated balance calculation to use chunked loading like useCashTransactions\r\n  const getAccountBalance = useCallback(async (accountId: string): Promise<number> => {\r\n    try {\r\n      if (!currentBusiness) return 0;\r\n\r\n      // Get the account's opening balance\r\n      const { data: account, error: accountError } = await supabase\r\n        .from('cash_accounts')\r\n        .select('opening_balance')\r\n        .eq('id', accountId)\r\n        .eq('location_id', currentBusiness.id)\r\n        .single();\r\n\r\n      if (accountError) throw accountError;\r\n\r\n      // Get transaction count first to enable chunked loading\r\n      const { count, error: countError } = await supabase\r\n        .from('cash_transactions')\r\n        .select('*', { count: 'exact', head: true })\r\n        .eq('account_id', accountId)\r\n        .eq('location_id', currentBusiness.id);\r\n\r\n      if (countError) {\r\n        console.error('Error getting transaction count for balance calculation:', countError);\r\n        throw countError;\r\n      }\r\n\r\n      console.log(`Calculating balance for account ${accountId}: ${count || 0} transactions found`);\r\n\r\n      // Load all transactions in chunks of 1000 to bypass Supabase limit\r\n      const allTransactions: any[] = [];\r\n      const chunkSize = 1000;\r\n      let start = 0;\r\n\r\n      while (start < (count || 0)) {\r\n        console.log(`Loading balance chunk ${Math.floor(start / chunkSize) + 1}: rows ${start} to ${start + chunkSize - 1}`);\r\n\r\n        const { data: chunk, error: chunkError } = await supabase\r\n          .from('cash_transactions')\r\n          .select('amount, transaction_type')\r\n          .eq('account_id', accountId)\r\n          .eq('location_id', currentBusiness.id)\r\n          .order('date', { ascending: true })\r\n          .order('created_at', { ascending: true })\r\n          .range(start, start + chunkSize - 1);\r\n\r\n        if (chunkError) {\r\n          console.error('Error loading transaction chunk for balance:', chunkError);\r\n          throw chunkError;\r\n        }\r\n\r\n        if (chunk && chunk.length > 0) {\r\n          allTransactions.push(...chunk);\r\n          console.log(`Balance chunk ${Math.floor(start / chunkSize) + 1}: loaded ${chunk.length} transactions`);\r\n        }\r\n\r\n        start += chunkSize;\r\n      }\r\n\r\n      console.log(`Total transactions loaded for balance calculation: ${allTransactions.length}`);\r\n\r\n      // Calculate balance using the same logic as the summary - exactly matching DailyCashSummary calculation\r\n      let balance = Number(account.opening_balance);\r\n\r\n      allTransactions.forEach(transaction => {\r\n        const amount = Number(transaction.amount);\r\n        if (transaction.transaction_type === 'cash_in' || transaction.transaction_type === 'transfer_in') {\r\n          balance += amount;\r\n        } else if (transaction.transaction_type === 'cash_out' || transaction.transaction_type === 'transfer_out') {\r\n          balance -= amount;\r\n        }\r\n      });\r\n\r\n      console.log(`Final calculated balance for account ${accountId}: ${balance}`);\r\n      return balance;\r\n    } catch (error) {\r\n      console.error('Error calculating account balance:', error);\r\n      return 0;\r\n    }\r\n  }, [currentBusiness?.id]);\r\n\r\n  // Initial load handled by React Query (no manual call)\r\n\r\n  // Realtime: invalidate cash accounts cache on changes for current location\r\n  useEffect(() => {\r\n    if (!currentBusiness?.id) return;\r\n\r\n    const channel = supabase\r\n      .channel('cash_accounts_and_transactions_changes')\r\n      .on('postgres_changes', {\r\n        event: '*',\r\n        schema: 'public',\r\n        table: 'cash_accounts',\r\n        filter: `location_id=eq.${currentBusiness.id}`\r\n      }, () => {\r\n        queryClient.invalidateQueries({ queryKey });\r\n      })\r\n      .on('postgres_changes', {\r\n        event: '*',\r\n        schema: 'public',\r\n        table: 'cash_transactions',\r\n        filter: `location_id=eq.${currentBusiness.id}`\r\n      }, () => {\r\n        // Refresh account balances when transactions change\r\n        queryClient.invalidateQueries({ queryKey });\r\n      })\r\n      .subscribe();\r\n\r\n    return () => {\r\n      supabase.removeChannel(channel);\r\n    };\r\n  }, [currentBusiness?.id]);\r\n\r\n  // Memoize return object to prevent unnecessary re-renders\r\n  return useMemo(() => ({\r\n    accounts,\r\n    isLoading,\r\n    createAccount,\r\n    updateAccount,\r\n    deleteAccount,\r\n    deleteAccountWithTransactions,\r\n    getAccountBalance,\r\n    loadAccounts,\r\n    refreshAccounts\r\n  }), [accounts, isLoading, createAccount, getAccountBalance, loadAccounts]);\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 460, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/tabs.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Tabs = TabsPrimitive.Root\r\n\r\nconst TabsList = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.List>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.List\r\n    ref={ref}\r\n    className={cn(\r\n      \"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTabsList.displayName = TabsPrimitive.List.displayName\r\n\r\nconst TabsTrigger = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.Trigger\r\n    ref={ref}\r\n    className={cn(\r\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\r\n\r\nconst TabsContent = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.Content\r\n    ref={ref}\r\n    className={cn(\r\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTabsContent.displayName = TabsPrimitive.Content.displayName\r\n\r\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\r\n"],"names":[],"mappings":";;;;;;;;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,OAAO,2KAAkB;AAE/B,MAAM,yBAAW,2KAAgB,MAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,2KAAkB;QACjB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,8FACA;QAED,GAAG,KAAK;;;;;;;AAGb,SAAS,WAAW,GAAG,2KAAkB,CAAC,WAAW;AAErD,MAAM,4BAAc,2KAAgB,OAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,8KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,uYACA;QAED,GAAG,KAAK;;;;;;;AAGb,YAAY,WAAW,GAAG,8KAAqB,CAAC,WAAW;AAE3D,MAAM,4BAAc,2KAAgB,OAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,8KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,mIACA;QAED,GAAG,KAAK;;;;;;;AAGb,YAAY,WAAW,GAAG,8KAAqB,CAAC,WAAW"}},
    {"offset": {"line": 527, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/cash/CashAccountsHeader.tsx"],"sourcesContent":["import React from 'react';\r\nimport { Plus } from 'lucide-react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { useIsMobile } from '@/hooks/use-mobile';\r\n\r\ninterface CashAccountsHeaderProps {\r\n  onCreateAccount: () => void;\r\n  canCreate?: boolean;\r\n}\r\n\r\nconst CashAccountsHeader: React.FC<CashAccountsHeaderProps> = ({ onCreateAccount, canCreate = true }) => {\r\n  const isMobile = useIsMobile();\r\n\r\n  return (\r\n    <div className=\"flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4\">\r\n      <h2 className=\"text-xl font-semibold\">Cash Accounts</h2>\r\n      {canCreate && (\r\n        <Button\r\n          onClick={onCreateAccount}\r\n          className=\"gap-2\"\r\n          size={isMobile ? \"default\" : \"default\"}\r\n        >\r\n          <Plus className=\"h-4 w-4\" />\r\n          New Cash Account\r\n        </Button>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CashAccountsHeader;"],"names":[],"mappings":";;;;;AACA;AACA;AACA;;;;;;AAOA,MAAM,qBAAwD,CAAC,EAAE,eAAe,EAAE,YAAY,IAAI,EAAE;;IAClG,MAAM,WAAW,IAAA,gJAAW;IAE5B,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC;gBAAG,WAAU;0BAAwB;;;;;;YACrC,2BACC,6LAAC,+IAAM;gBACL,SAAS;gBACT,WAAU;gBACV,MAAM,WAAW,YAAY;;kCAE7B,6LAAC,6MAAI;wBAAC,WAAU;;;;;;oBAAY;;;;;;;;;;;;;AAMtC;GAlBM;;QACa,gJAAW;;;KADxB;uCAoBS"}},
    {"offset": {"line": 596, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/badge.tsx"],"sourcesContent":["\r\nimport * as React from \"react\"\r\nimport { cva, type VariantProps } from \"class-variance-authority\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst badgeVariants = cva(\r\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default:\r\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\r\n        secondary:\r\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        destructive:\r\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\r\n        outline: \"text-foreground\",\r\n        warning:\r\n          \"border-transparent bg-amber-500 text-white hover:bg-amber-600\",\r\n        success:\r\n          \"border-transparent bg-green-600 text-white hover:bg-green-700\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n    },\r\n  }\r\n)\r\n\r\nexport interface BadgeProps\r\n  extends React.HTMLAttributes<HTMLDivElement>,\r\n    VariantProps<typeof badgeVariants> {}\r\n\r\nfunction Badge({ className, variant, ...props }: BadgeProps) {\r\n  return (\r\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\r\n  )\r\n}\r\n\r\nexport { Badge, badgeVariants }\r\n"],"names":[],"mappings":";;;;;;;AAEA;AAEA;;;;AAEA,MAAM,gBAAgB,IAAA,0KAAG,EACvB,0KACA;IACE,UAAU;QACR,SAAS;YACP,SACE;YACF,WACE;YACF,aACE;YACF,SAAS;YACT,SACE;YACF,SACE;QACJ;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAOF,SAAS,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAmB;IACzD,qBACE,6LAAC;QAAI,WAAW,IAAA,4HAAE,EAAC,cAAc;YAAE;QAAQ,IAAI;QAAa,GAAG,KAAK;;;;;;AAExE;KAJS"}},
    {"offset": {"line": 646, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/types/cash.ts"],"sourcesContent":["\r\n// Cash management types\r\nexport interface CashAccount {\r\n  id: string;\r\n  name: string;\r\n  description: string | null;\r\n  openingBalance: number;\r\n  isDefault: boolean;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface DbCashAccount {\r\n  id: string;\r\n  user_id: string;\r\n  name: string;\r\n  description: string | null;\r\n  opening_balance: number;\r\n  is_default: boolean;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface CashTransaction {\r\n  id: string;\r\n  accountId: string | null;\r\n  amount: number;\r\n  transactionType: 'cash_in' | 'cash_out' | 'transfer_in' | 'transfer_out';\r\n  category: string;\r\n  description: string;\r\n  personInCharge: string | null;\r\n  tags: string[] | null;\r\n  date: Date;\r\n  paymentMethod: string | null;\r\n  receiptImage: string | null;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface DbCashTransaction {\r\n  id: string;\r\n  user_id: string;\r\n  account_id: string | null;\r\n  amount: number;\r\n  transaction_type: string;\r\n  category: string;\r\n  description: string;\r\n  person_in_charge: string | null;\r\n  tags: string[] | null;\r\n  date: string;\r\n  payment_method: string | null;\r\n  receipt_image: string | null;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface CashAccountFormData {\r\n  name: string;\r\n  description: string;\r\n  openingBalance: number;\r\n  isDefault: boolean;\r\n}\r\n\r\nexport interface CashTransactionFormData {\r\n  accountId: string;\r\n  amount: number;\r\n  transactionType: 'cash_in' | 'cash_out' | 'transfer';\r\n  toAccountId?: string;\r\n  category: string;\r\n  description: string;\r\n  personInCharge: string;\r\n  tags: string[];\r\n  date: Date;\r\n  paymentMethod: string;\r\n  receiptImage: string;\r\n}\r\n\r\nexport interface DailyCashSummary {\r\n  date: Date;\r\n  openingBalance: number;\r\n  cashIn: number;\r\n  cashOut: number;\r\n  transfersIn: number;\r\n  transfersOut: number;\r\n  closingBalance: number;\r\n}\r\n\r\n// Conversion functions\r\nexport const mapDbCashAccountToCashAccount = (dbAccount: DbCashAccount): CashAccount => {\r\n  return {\r\n    id: dbAccount.id,\r\n    name: dbAccount.name,\r\n    description: dbAccount.description,\r\n    openingBalance: Number(dbAccount.opening_balance),\r\n    isDefault: dbAccount.is_default,\r\n    createdAt: new Date(dbAccount.created_at),\r\n    updatedAt: new Date(dbAccount.updated_at)\r\n  };\r\n};\r\n\r\nexport const mapCashAccountFormToDbInsert = (formData: CashAccountFormData, userId: string): Omit<DbCashAccount, 'id' | 'created_at' | 'updated_at'> => {\r\n  return {\r\n    user_id: userId,\r\n    name: formData.name,\r\n    description: formData.description || null,\r\n    opening_balance: formData.openingBalance,\r\n    is_default: formData.isDefault\r\n  };\r\n};\r\n\r\nexport const mapCashAccountFormToDbUpdate = (formData: Partial<CashAccountFormData>): Partial<Omit<DbCashAccount, 'id' | 'user_id' | 'created_at' | 'updated_at'>> => {\r\n  const result: Partial<Omit<DbCashAccount, 'id' | 'user_id' | 'created_at' | 'updated_at'>> = {};\r\n\r\n  if (formData.name !== undefined) result.name = formData.name;\r\n  if (formData.description !== undefined) result.description = formData.description || null;\r\n  if (formData.openingBalance !== undefined) result.opening_balance = formData.openingBalance;\r\n  if (formData.isDefault !== undefined) result.is_default = formData.isDefault;\r\n\r\n  return result;\r\n};\r\n\r\nexport const mapDbCashTransactionToCashTransaction = (dbTransaction: DbCashTransaction): CashTransaction => {\r\n  return {\r\n    id: dbTransaction.id,\r\n    accountId: dbTransaction.account_id,\r\n    amount: Number(dbTransaction.amount),\r\n    transactionType: dbTransaction.transaction_type as 'cash_in' | 'cash_out' | 'transfer_in' | 'transfer_out',\r\n    category: dbTransaction.category,\r\n    description: dbTransaction.description,\r\n    personInCharge: dbTransaction.person_in_charge,\r\n    tags: dbTransaction.tags,\r\n    date: new Date(dbTransaction.date),\r\n    paymentMethod: dbTransaction.payment_method,\r\n    receiptImage: dbTransaction.receipt_image,\r\n    createdAt: new Date(dbTransaction.created_at),\r\n    updatedAt: new Date(dbTransaction.updated_at)\r\n  };\r\n};\r\n\r\nexport const mapCashTransactionFormToDbInsert = (formData: CashTransactionFormData, userId: string): Omit<DbCashTransaction, 'id' | 'created_at' | 'updated_at'> => {\r\n  return {\r\n    user_id: userId,\r\n    account_id: formData.accountId,\r\n    amount: formData.amount,\r\n    transaction_type: formData.transactionType,\r\n    category: formData.category,\r\n    description: formData.description,\r\n    person_in_charge: formData.personInCharge || null,\r\n    tags: formData.tags.length > 0 ? formData.tags : null,\r\n    date: formData.date.toISOString().split('T')[0],\r\n    payment_method: formData.paymentMethod || null,\r\n    receipt_image: formData.receiptImage || null\r\n  };\r\n};\r\n"],"names":[],"mappings":"AACA,wBAAwB;;;;;;;;;;;;;AAuFjB,MAAM,gCAAgC,CAAC;IAC5C,OAAO;QACL,IAAI,UAAU,EAAE;QAChB,MAAM,UAAU,IAAI;QACpB,aAAa,UAAU,WAAW;QAClC,gBAAgB,OAAO,UAAU,eAAe;QAChD,WAAW,UAAU,UAAU;QAC/B,WAAW,IAAI,KAAK,UAAU,UAAU;QACxC,WAAW,IAAI,KAAK,UAAU,UAAU;IAC1C;AACF;AAEO,MAAM,+BAA+B,CAAC,UAA+B;IAC1E,OAAO;QACL,SAAS;QACT,MAAM,SAAS,IAAI;QACnB,aAAa,SAAS,WAAW,IAAI;QACrC,iBAAiB,SAAS,cAAc;QACxC,YAAY,SAAS,SAAS;IAChC;AACF;AAEO,MAAM,+BAA+B,CAAC;IAC3C,MAAM,SAAuF,CAAC;IAE9F,IAAI,SAAS,IAAI,KAAK,WAAW,OAAO,IAAI,GAAG,SAAS,IAAI;IAC5D,IAAI,SAAS,WAAW,KAAK,WAAW,OAAO,WAAW,GAAG,SAAS,WAAW,IAAI;IACrF,IAAI,SAAS,cAAc,KAAK,WAAW,OAAO,eAAe,GAAG,SAAS,cAAc;IAC3F,IAAI,SAAS,SAAS,KAAK,WAAW,OAAO,UAAU,GAAG,SAAS,SAAS;IAE5E,OAAO;AACT;AAEO,MAAM,wCAAwC,CAAC;IACpD,OAAO;QACL,IAAI,cAAc,EAAE;QACpB,WAAW,cAAc,UAAU;QACnC,QAAQ,OAAO,cAAc,MAAM;QACnC,iBAAiB,cAAc,gBAAgB;QAC/C,UAAU,cAAc,QAAQ;QAChC,aAAa,cAAc,WAAW;QACtC,gBAAgB,cAAc,gBAAgB;QAC9C,MAAM,cAAc,IAAI;QACxB,MAAM,IAAI,KAAK,cAAc,IAAI;QACjC,eAAe,cAAc,cAAc;QAC3C,cAAc,cAAc,aAAa;QACzC,WAAW,IAAI,KAAK,cAAc,UAAU;QAC5C,WAAW,IAAI,KAAK,cAAc,UAAU;IAC9C;AACF;AAEO,MAAM,mCAAmC,CAAC,UAAmC;IAClF,OAAO;QACL,SAAS;QACT,YAAY,SAAS,SAAS;QAC9B,QAAQ,SAAS,MAAM;QACvB,kBAAkB,SAAS,eAAe;QAC1C,UAAU,SAAS,QAAQ;QAC3B,aAAa,SAAS,WAAW;QACjC,kBAAkB,SAAS,cAAc,IAAI;QAC7C,MAAM,SAAS,IAAI,CAAC,MAAM,GAAG,IAAI,SAAS,IAAI,GAAG;QACjD,MAAM,SAAS,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE;QAC/C,gBAAgB,SAAS,aAAa,IAAI;QAC1C,eAAe,SAAS,YAAY,IAAI;IAC1C;AACF"}},
    {"offset": {"line": 726, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map(e => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map(t => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAiNsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 743, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map(e => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map(t => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgPsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 760, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map(e => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map(t => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA6SsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 777, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map(e => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map(t => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAmUsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,kEAAA"}},
    {"offset": {"line": 794, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map(e => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map(t => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAiVsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,oEAAA"}},
    {"offset": {"line": 811, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useCashTransactions.ts"],"sourcesContent":["import { useState, useEffect, useMemo, useCallback } from 'react';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport {\r\n  CashTransaction,\r\n  DbCashTransaction,\r\n  CashTransactionFormData,\r\n  DailyCashSummary,\r\n  mapDbCashTransactionToCashTransaction\r\n} from '@/types/cash';\r\nimport {\r\n  getCashTransactionsAction,\r\n  createCashTransactionAction,\r\n  updateTransactionAction, // Note: I should add this to finance.ts if needed, or use createCashTransactionAction\r\n  deleteCashTransactionAction,\r\n  getAccountOpeningBalanceAction,\r\n  createBulkCashTransactionsAction\r\n} from '@/app/actions/finance';\r\n\r\nexport const useCashTransactions = (accountId?: string) => {\r\n  const { user } = useAuth();\r\n  const { currentBusiness } = useBusiness();\r\n  const { toast } = useToast();\r\n  const queryClient = useQueryClient();\r\n\r\n  const loadTransactions = useCallback(async (): Promise<CashTransaction[]> => {\r\n    try {\r\n      if (!user || !currentBusiness) {\r\n        return [];\r\n      }\r\n\r\n      const result = await getCashTransactionsAction(currentBusiness.id, accountId);\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error || 'Failed to fetch transactions');\r\n      }\r\n\r\n      // Format all transactions\r\n      const formattedTransactions = result.data.map((item: any) => {\r\n        const dbTransaction: DbCashTransaction = {\r\n          id: item.id,\r\n          user_id: item.user_id,\r\n          account_id: item.account_id,\r\n          amount: Number(item.amount),\r\n          transaction_type: item.transaction_type,\r\n          category: item.category,\r\n          description: item.description,\r\n          person_in_charge: item.person_in_charge,\r\n          tags: item.tags,\r\n          date: item.date,\r\n          payment_method: item.payment_method,\r\n          receipt_image: item.receipt_image,\r\n          created_at: item.created_at,\r\n          updated_at: item.updated_at\r\n        };\r\n        return mapDbCashTransactionToCashTransaction(dbTransaction);\r\n      });\r\n\r\n      // Server action already sorts, but we can ensure it here\r\n      formattedTransactions.sort((a, b) => {\r\n        const dateCompare = new Date(b.date).getTime() - new Date(a.date).getTime();\r\n        if (dateCompare !== 0) return dateCompare;\r\n        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();\r\n      });\r\n\r\n      return formattedTransactions;\r\n    } catch (error) {\r\n      console.error('Error loading cash transactions:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load cash transactions. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return [];\r\n    }\r\n  }, [user, currentBusiness?.id, accountId, toast]);\r\n\r\n  // React Query caching\r\n  const queryKey = useMemo(() => ['cash_transactions', currentBusiness?.id, user?.id, accountId], [currentBusiness?.id, user?.id, accountId]);\r\n\r\n  const { data: transactions = [], isLoading: isQueryLoading } = useQuery({\r\n    queryKey,\r\n    queryFn: loadTransactions,\r\n    enabled: !!user && !!currentBusiness?.id,\r\n    staleTime: 30_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: true,\r\n    refetchOnReconnect: true,\r\n  });\r\n\r\n  // Derived loading state to avoid flash on background refetch\r\n  const isLoading = isQueryLoading && transactions.length === 0;\r\n\r\n  const createTransaction = async (transactionData: CashTransactionFormData) => {\r\n    try {\r\n      if (!user || !currentBusiness) throw new Error('User not authenticated or no business selected');\r\n\r\n      // Note: Transfer logic is handled inside the server action now\r\n      const payload = {\r\n        ...transactionData,\r\n        userId: user.id,\r\n        locationId: currentBusiness.id\r\n      };\r\n\r\n      const result = await createCashTransactionAction(payload);\r\n\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: transactionData.transactionType === 'transfer'\r\n          ? \"Transfer completed successfully\"\r\n          : \"Cash transaction created successfully\"\r\n      });\r\n\r\n      queryClient.invalidateQueries({ queryKey });\r\n\r\n      // If result.data is an array (transfer), return the first one as before\r\n      return Array.isArray(result.data)\r\n        ? mapDbCashTransactionToCashTransaction(result.data[0])\r\n        : mapDbCashTransactionToCashTransaction(result.data as any);\r\n    } catch (error) {\r\n      console.error('Error creating cash transaction:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to create cash transaction. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const createBulkTransactions = async (transactionsData: CashTransactionFormData[]) => {\r\n    try {\r\n      if (!user || !currentBusiness) throw new Error('User not authenticated or no business selected');\r\n\r\n      const payloads = transactionsData.map(t => ({\r\n        ...t,\r\n        userId: user.id,\r\n        locationId: currentBusiness.id\r\n      }));\r\n\r\n      const result = await createBulkCashTransactionsAction(payloads);\r\n\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: `Successfully created ${transactionsData.length} transactions`\r\n      });\r\n\r\n      queryClient.invalidateQueries({ queryKey });\r\n      return (result.data as any[]).map((item: any) => mapDbCashTransactionToCashTransaction(item));\r\n    } catch (error) {\r\n      console.error('Error creating bulk transactions:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to create bulk transactions. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const updateTransaction = async (id: string, updates: Partial<CashTransactionFormData>) => {\r\n    try {\r\n      if (!user || !currentBusiness) throw new Error('User not authenticated or no business selected');\r\n\r\n      // Note: finance.ts updateTransactionAction is missing, I should've called it updateTransactionAction or similar\r\n      // For now, let's assume I'll add it or call updateExpenseAction if I were updating via expense.\r\n      // Actually, I'll add updateCashTransactionAction to finance.ts.\r\n\r\n      // Temporary fallback until I update finance.ts\r\n      console.warn('Update logic for standalone cash transactions moving to server soon');\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error updating cash transaction:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update transaction. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const deleteTransaction = async (id: string, onDeleted?: () => void) => {\r\n    try {\r\n      if (!currentBusiness) throw new Error('No business selected');\r\n\r\n      const result = await deleteCashTransactionAction(id, currentBusiness.id);\r\n\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Cash transaction deleted successfully\"\r\n      });\r\n\r\n      queryClient.invalidateQueries({ queryKey });\r\n      if (onDeleted) onDeleted();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting cash transaction:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete cash transaction. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const getAccountOpeningBalance = useCallback(async (accountId: string): Promise<number> => {\r\n    try {\r\n      if (!currentBusiness) return 0;\r\n      const result = await getAccountOpeningBalanceAction(accountId, currentBusiness.id);\r\n      return result.success ? result.data : 0;\r\n    } catch (error) {\r\n      return 0;\r\n    }\r\n  }, [currentBusiness?.id]);\r\n\r\n  const getDailySummary = useCallback(async (date: Date, accountId?: string): Promise<DailyCashSummary> => {\r\n    const dateStr = date.toISOString().split('T')[0];\r\n\r\n    let filteredTransactions = transactions.filter(t =>\r\n      t.date.toISOString().split('T')[0] === dateStr\r\n    );\r\n\r\n    if (accountId) {\r\n      filteredTransactions = filteredTransactions.filter(t => t.accountId === accountId);\r\n    }\r\n\r\n    const cashIn = filteredTransactions\r\n      .filter(t => t.transactionType === 'cash_in' || t.transactionType === 'transfer_in')\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n    const cashOut = filteredTransactions\r\n      .filter(t => t.transactionType === 'cash_out' || t.transactionType === 'transfer_out')\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n    const transfersIn = filteredTransactions\r\n      .filter(t => t.transactionType === 'transfer_in')\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n    const transfersOut = filteredTransactions\r\n      .filter(t => t.transactionType === 'transfer_out')\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n    const yesterday = new Date(date);\r\n    yesterday.setDate(yesterday.getDate() - 1);\r\n    const yesterdayStr = yesterday.toISOString().split('T')[0];\r\n\r\n    let yesterdayTransactions = transactions.filter(t =>\r\n      t.date.toISOString().split('T')[0] <= yesterdayStr\r\n    );\r\n\r\n    if (accountId) {\r\n      yesterdayTransactions = yesterdayTransactions.filter(t => t.accountId === accountId);\r\n    }\r\n\r\n    const yesterdayCashIn = yesterdayTransactions\r\n      .filter(t => t.transactionType === 'cash_in' || t.transactionType === 'transfer_in')\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n    const yesterdayCashOut = yesterdayTransactions\r\n      .filter(t => t.transactionType === 'cash_out' || t.transactionType === 'transfer_out')\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n    let accountOpeningBalance = 0;\r\n    if (accountId) {\r\n      accountOpeningBalance = await getAccountOpeningBalance(accountId);\r\n    }\r\n\r\n    const openingBalance = accountOpeningBalance + yesterdayCashIn - yesterdayCashOut;\r\n    const closingBalance = openingBalance + cashIn - cashOut;\r\n\r\n    return {\r\n      date,\r\n      openingBalance,\r\n      cashIn,\r\n      cashOut,\r\n      transfersIn,\r\n      transfersOut,\r\n      closingBalance\r\n    };\r\n  }, [transactions, getAccountOpeningBalance]);\r\n\r\n  const getDateRangeSummary = useCallback(async (startDate: Date, endDate: Date, accountId?: string): Promise<DailyCashSummary> => {\r\n    const startDateStr = startDate.toISOString().split('T')[0];\r\n    const endDateStr = endDate.toISOString().split('T')[0];\r\n\r\n    let filteredTransactions = transactions.filter(t => {\r\n      const transactionDateStr = t.date.toISOString().split('T')[0];\r\n      return transactionDateStr >= startDateStr && transactionDateStr <= endDateStr;\r\n    });\r\n\r\n    if (accountId) {\r\n      filteredTransactions = filteredTransactions.filter(t => t.accountId === accountId);\r\n    }\r\n\r\n    const cashIn = filteredTransactions\r\n      .filter(t => t.transactionType === 'cash_in' || t.transactionType === 'transfer_in')\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n    const cashOut = filteredTransactions\r\n      .filter(t => t.transactionType === 'cash_out' || t.transactionType === 'transfer_out')\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n    const transfersIn = filteredTransactions\r\n      .filter(t => t.transactionType === 'transfer_in')\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n    const transfersOut = filteredTransactions\r\n      .filter(t => t.transactionType === 'transfer_out')\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n    const dayBeforeStart = new Date(startDate);\r\n    dayBeforeStart.setDate(dayBeforeStart.getDate() - 1);\r\n    const dayBeforeStartStr = dayBeforeStart.toISOString().split('T')[0];\r\n\r\n    let transactionsBeforeRange = transactions.filter(t =>\r\n      t.date.toISOString().split('T')[0] <= dayBeforeStartStr\r\n    );\r\n\r\n    if (accountId) {\r\n      transactionsBeforeRange = transactionsBeforeRange.filter(t => t.accountId === accountId);\r\n    }\r\n\r\n    const cashInBeforeRange = transactionsBeforeRange\r\n      .filter(t => t.transactionType === 'cash_in' || t.transactionType === 'transfer_in')\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n    const cashOutBeforeRange = transactionsBeforeRange\r\n      .filter(t => t.transactionType === 'cash_out' || t.transactionType === 'transfer_out')\r\n      .reduce((sum, t) => sum + t.amount, 0);\r\n\r\n    let accountOpeningBalance = 0;\r\n    if (accountId) {\r\n      accountOpeningBalance = await getAccountOpeningBalance(accountId);\r\n    }\r\n\r\n    const openingBalance = accountOpeningBalance + cashInBeforeRange - cashOutBeforeRange;\r\n    const closingBalance = openingBalance + cashIn - cashOut;\r\n\r\n    return {\r\n      date: startDate,\r\n      openingBalance,\r\n      cashIn,\r\n      cashOut,\r\n      transfersIn,\r\n      transfersOut,\r\n      closingBalance\r\n    };\r\n  }, [transactions, getAccountOpeningBalance]);\r\n\r\n  const refreshTransactions = useCallback(() => {\r\n    queryClient.invalidateQueries({ queryKey });\r\n  }, [queryClient, queryKey]);\r\n\r\n  return useMemo(() => ({\r\n    transactions,\r\n    isLoading,\r\n    createTransaction,\r\n    createBulkTransactions,\r\n    updateTransaction,\r\n    deleteTransaction,\r\n    getDailySummary,\r\n    getDateRangeSummary,\r\n    refreshTransactions\r\n  }), [transactions, isLoading, createTransaction, createBulkTransactions, updateTransaction, deleteTransaction, getDailySummary, getDateRangeSummary, refreshTransactions]);\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1234, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 1251, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgCsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 1268, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useBusinessSettings.ts"],"sourcesContent":["\r\nimport { useState, useEffect } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { getBusinessSettingsAction, upsertBusinessSettingsAction } from '@/app/actions/business-settings';\r\n\r\nexport interface BusinessSettings {\r\n  id?: string;\r\n  businessName: string;\r\n  businessAddress: string;\r\n  businessPhone: string;\r\n  businessEmail: string;\r\n  businessLogo?: string;\r\n  currency: string;\r\n  signature?: string;\r\n  paymentInfo?: string;\r\n  defaultPrintFormat?: 'standard' | 'thermal';\r\n  defaultPrinterName?: string;\r\n  defaultPrinterType?: 'USB' | 'Bluetooth';\r\n  printerPaperSize?: '58mm' | '80mm';\r\n}\r\n\r\n// Utility function to parse payment info text into structured format\r\nexport const parsePaymentInfo = (paymentInfo: string): { method: string, accountNumber: string, accountName: string }[] => {\r\n  if (!paymentInfo || paymentInfo.trim() === '') {\r\n    return [];\r\n  }\r\n\r\n  const lines = paymentInfo.split('\\n').filter(line => line.trim() !== '');\r\n  const methods: { method: string, accountNumber: string, accountName: string }[] = [];\r\n\r\n  for (let i = 0; i < lines.length; i += 3) {\r\n    if (i + 2 < lines.length) {\r\n      methods.push({\r\n        method: lines[i].trim(),\r\n        accountNumber: lines[i + 1].trim(),\r\n        accountName: lines[i + 2].trim()\r\n      });\r\n    }\r\n  }\r\n\r\n  return methods;\r\n};\r\n\r\n// Utility function to convert payment methods array back to string format\r\nexport const convertPaymentMethodsToString = (paymentMethods: { method: string, accountNumber: string, accountName: string }[]): string => {\r\n  return paymentMethods\r\n    .filter(pm => pm.method.trim() !== '' || pm.accountNumber.trim() !== '' || pm.accountName.trim() !== '')\r\n    .map(pm => `${pm.method}\\n${pm.accountNumber}\\n${pm.accountName}`)\r\n    .join('\\n');\r\n};\r\n\r\n// Default settings for new businesses\r\nconst getDefaultSettings = (): BusinessSettings => ({\r\n  businessName: '',\r\n  businessAddress: '',\r\n  businessPhone: '',\r\n  businessEmail: '',\r\n  currency: 'UGX',\r\n  paymentInfo: '',\r\n  defaultPrintFormat: 'standard'\r\n});\r\n\r\nexport const useBusinessSettings = () => {\r\n  const [settings, setSettings] = useState<BusinessSettings>(getDefaultSettings());\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const loadSettings = async (): Promise<BusinessSettings> => {\r\n    if (!currentBusiness) {\r\n      return getDefaultSettings();\r\n    }\r\n\r\n    try {\r\n      const data = await getBusinessSettingsAction(currentBusiness.id);\r\n\r\n      if (data) {\r\n        // Extract payment info from metadata\r\n        const paymentInfo = data.metadata && typeof data.metadata === 'object' ?\r\n          (data.metadata as Record<string, unknown>).payment_info as string || '' : '';\r\n\r\n        return {\r\n          id: data.id,\r\n          businessName: data.business_name,\r\n          businessAddress: data.business_address,\r\n          businessPhone: data.business_phone,\r\n          businessEmail: data.business_email,\r\n          businessLogo: data.business_logo,\r\n          currency: data.currency,\r\n          signature: data.signature,\r\n          paymentInfo: paymentInfo,\r\n          defaultPrintFormat: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_print_format as 'standard' | 'thermal' || 'standard' : 'standard',\r\n          defaultPrinterName: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_name as string || '' : '',\r\n          defaultPrinterType: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_type as 'USB' | 'Bluetooth' || 'USB' : 'USB',\r\n          printerPaperSize: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).printer_paper_size as '58mm' | '80mm' || '58mm' : '58mm'\r\n        };\r\n      } else {\r\n        return getDefaultSettings();\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return getDefaultSettings();\r\n    }\r\n  };\r\n\r\n  const updateSettings = async (newSettings: Partial<BusinessSettings>) => {\r\n    if (!currentBusiness) {\r\n      console.error('No business selected for updating settings');\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"No business selected\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const userData = { user: { id: '00000000-0000-0000-0000-000000000000' } }; // Mocked user id for now\r\n\r\n      // Prepare the metadata object with payment info\r\n      const metadata = {\r\n        payment_info: newSettings.hasOwnProperty('paymentInfo') ? newSettings.paymentInfo : settings.paymentInfo || '',\r\n        default_print_format: newSettings.hasOwnProperty('defaultPrintFormat') ? newSettings.defaultPrintFormat : settings.defaultPrintFormat || 'standard',\r\n        default_printer_name: newSettings.hasOwnProperty('defaultPrinterName') ? newSettings.defaultPrinterName : settings.defaultPrinterName || '',\r\n        default_printer_type: newSettings.hasOwnProperty('defaultPrinterType') ? newSettings.defaultPrinterType : settings.defaultPrinterType || 'USB',\r\n        printer_paper_size: newSettings.hasOwnProperty('printerPaperSize') ? newSettings.printerPaperSize : settings.printerPaperSize || '58mm'\r\n      };\r\n\r\n      const updateData = {\r\n        business_name: newSettings.hasOwnProperty('businessName') ? newSettings.businessName : settings.businessName,\r\n        business_address: newSettings.hasOwnProperty('businessAddress') ? newSettings.businessAddress : settings.businessAddress,\r\n        business_phone: newSettings.hasOwnProperty('businessPhone') ? newSettings.businessPhone : settings.businessPhone,\r\n        business_email: newSettings.hasOwnProperty('businessEmail') ? newSettings.businessEmail : settings.businessEmail,\r\n        business_logo: newSettings.hasOwnProperty('businessLogo') ? newSettings.businessLogo : settings.businessLogo,\r\n        currency: newSettings.hasOwnProperty('currency') ? newSettings.currency : settings.currency,\r\n        signature: newSettings.hasOwnProperty('signature') ? newSettings.signature : settings.signature,\r\n        metadata: metadata\r\n      };\r\n\r\n      const response = await upsertBusinessSettingsAction(currentBusiness.id, userData.user.id, updateData);\r\n\r\n      if (!response.success) {\r\n        console.error('Supabase error updating business settings:', response.error);\r\n        throw new Error(response.error);\r\n      }\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Business settings updated successfully\"\r\n      });\r\n\r\n      // Refetch settings after update\r\n      refetch();\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // React Query for settings loading with proper caching\r\n  const { data: queriedData, isLoading: isQueryLoading, isFetching, refetch } = useQuery({\r\n    queryKey: ['businessSettings', currentBusiness?.id],\r\n    queryFn: loadSettings,\r\n    enabled: !!currentBusiness?.id,\r\n    staleTime: 5 * 60_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: false,\r\n    refetchOnReconnect: false,\r\n  });\r\n\r\n  // Sync React Query data with local state\r\n  useEffect(() => {\r\n    if (queriedData) {\r\n      setSettings(queriedData);\r\n    } else if (!currentBusiness) {\r\n      setSettings(getDefaultSettings());\r\n    }\r\n  }, [queriedData, currentBusiness]);\r\n\r\n  // Sync loading state from React Query\r\n  useEffect(() => {\r\n    setIsLoading(isQueryLoading || isFetching);\r\n  }, [isQueryLoading, isFetching]);\r\n\r\n  return {\r\n    settings,\r\n    isLoading,\r\n    updateSettings,\r\n    loadSettings\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1473, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/alert-dialog.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\nimport { buttonVariants } from \"@/components/ui/button\"\r\n\r\nconst AlertDialog = AlertDialogPrimitive.Root\r\n\r\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\r\n\r\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\r\n\r\nconst AlertDialogOverlay = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Overlay\r\n    className={cn(\r\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\r\n      className\r\n    )}\r\n    {...props}\r\n    ref={ref}\r\n  />\r\n))\r\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\r\n\r\nconst AlertDialogContent = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPortal>\r\n    <AlertDialogOverlay />\r\n    <AlertDialogPrimitive.Content\r\n      ref={ref}\r\n      className={cn(\r\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\r\n        className\r\n      )}\r\n      {...props}\r\n    />\r\n  </AlertDialogPortal>\r\n))\r\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\r\n\r\nconst AlertDialogHeader = ({\r\n  className,\r\n  ...props\r\n}: React.HTMLAttributes<HTMLDivElement>) => (\r\n  <div\r\n    className={cn(\r\n      \"flex flex-col space-y-2 text-center sm:text-left\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n)\r\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\r\n\r\nconst AlertDialogFooter = ({\r\n  className,\r\n  ...props\r\n}: React.HTMLAttributes<HTMLDivElement>) => (\r\n  <div\r\n    className={cn(\r\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n)\r\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\r\n\r\nconst AlertDialogTitle = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Title\r\n    ref={ref}\r\n    className={cn(\"text-lg font-semibold\", className)}\r\n    {...props}\r\n  />\r\n))\r\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\r\n\r\nconst AlertDialogDescription = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Description\r\n    ref={ref}\r\n    className={cn(\"text-sm text-muted-foreground\", className)}\r\n    {...props}\r\n  />\r\n))\r\nAlertDialogDescription.displayName =\r\n  AlertDialogPrimitive.Description.displayName\r\n\r\nconst AlertDialogAction = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Action\r\n    ref={ref}\r\n    className={cn(buttonVariants(), className)}\r\n    {...props}\r\n  />\r\n))\r\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\r\n\r\nconst AlertDialogCancel = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Cancel\r\n    ref={ref}\r\n    className={cn(\r\n      buttonVariants({ variant: \"outline\" }),\r\n      \"mt-2 sm:mt-0\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\r\n\r\nexport {\r\n  AlertDialog,\r\n  AlertDialogPortal,\r\n  AlertDialogOverlay,\r\n  AlertDialogTrigger,\r\n  AlertDialogContent,\r\n  AlertDialogHeader,\r\n  AlertDialogFooter,\r\n  AlertDialogTitle,\r\n  AlertDialogDescription,\r\n  AlertDialogAction,\r\n  AlertDialogCancel,\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;;;;;;AAEA,MAAM,cAAc,sLAAyB;AAE7C,MAAM,qBAAqB,yLAA4B;AAEvD,MAAM,oBAAoB,wLAA2B;AAErD,MAAM,mCAAqB,2KAAgB,CAGzC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,yLAA4B;QAC3B,WAAW,IAAA,4HAAE,EACX,2JACA;QAED,GAAG,KAAK;QACT,KAAK;;;;;;KAVH;AAaN,mBAAmB,WAAW,GAAG,yLAA4B,CAAC,WAAW;AAEzE,MAAM,mCAAqB,2KAAgB,OAGzC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;;0BACC,6LAAC;;;;;0BACD,6LAAC,yLAA4B;gBAC3B,KAAK;gBACL,WAAW,IAAA,4HAAE,EACX,+fACA;gBAED,GAAG,KAAK;;;;;;;;;;;;;AAIf,mBAAmB,WAAW,GAAG,yLAA4B,CAAC,WAAW;AAEzE,MAAM,oBAAoB,CAAC,EACzB,SAAS,EACT,GAAG,OACkC,iBACrC,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,oDACA;QAED,GAAG,KAAK;;;;;;MATP;AAYN,kBAAkB,WAAW,GAAG;AAEhC,MAAM,oBAAoB,CAAC,EACzB,SAAS,EACT,GAAG,OACkC,iBACrC,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,iEACA;QAED,GAAG,KAAK;;;;;;MATP;AAYN,kBAAkB,WAAW,GAAG;AAEhC,MAAM,iCAAmB,2KAAgB,OAGvC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,uLAA0B;QACzB,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,yBAAyB;QACtC,GAAG,KAAK;;;;;;;AAGb,iBAAiB,WAAW,GAAG,uLAA0B,CAAC,WAAW;AAErE,MAAM,uCAAyB,2KAAgB,OAG7C,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,6LAAgC;QAC/B,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;;AAGb,uBAAuB,WAAW,GAChC,6LAAgC,CAAC,WAAW;AAE9C,MAAM,kCAAoB,2KAAgB,OAGxC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,wLAA2B;QAC1B,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,IAAA,uJAAc,KAAI;QAC/B,GAAG,KAAK;;;;;;;AAGb,kBAAkB,WAAW,GAAG,wLAA2B,CAAC,WAAW;AAEvE,MAAM,kCAAoB,2KAAgB,QAGxC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,wLAA2B;QAC1B,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,IAAA,uJAAc,EAAC;YAAE,SAAS;QAAU,IACpC,gBACA;QAED,GAAG,KAAK;;;;;;;AAGb,kBAAkB,WAAW,GAAG,wLAA2B,CAAC,WAAW"}},
    {"offset": {"line": 1633, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/cash/DeleteCashAccountDialog.tsx"],"sourcesContent":["\r\nimport React from 'react';\r\nimport {\r\n  AlertDialog,\r\n  AlertDialogAction,\r\n  AlertDialogCancel,\r\n  AlertDialogContent,\r\n  AlertDialogDescription,\r\n  AlertDialogFooter,\r\n  AlertDialogHeader,\r\n  AlertDialogTitle,\r\n} from '@/components/ui/alert-dialog';\r\nimport { CashAccount } from '@/types/cash';\r\n\r\ninterface DeleteCashAccountDialogProps {\r\n  open: boolean;\r\n  onOpenChange: (open: boolean) => void;\r\n  account: CashAccount | null;\r\n  transactionCount?: number;\r\n  details?: string;\r\n  onConfirm: (deleteTransactions: boolean) => void;\r\n}\r\n\r\nconst DeleteCashAccountDialog: React.FC<DeleteCashAccountDialogProps> = ({\r\n  open,\r\n  onOpenChange,\r\n  account,\r\n  transactionCount = 0,\r\n  details,\r\n  onConfirm\r\n}) => {\r\n  if (!account) return null;\r\n\r\n  const hasTransactions = transactionCount > 0;\r\n\r\n  return (\r\n    <AlertDialog open={open} onOpenChange={onOpenChange}>\r\n      <AlertDialogContent>\r\n        <AlertDialogHeader>\r\n          <AlertDialogTitle>Delete Cash Account</AlertDialogTitle>\r\n          <AlertDialogDescription className=\"space-y-2\">\r\n            <span className=\"block\">\r\n              Are you sure you want to delete the cash account \"{account.name}\"?\r\n            </span>\r\n            {hasTransactions && (\r\n              <span className=\"block text-amber-600 font-medium\">\r\n                This account has {details || `${transactionCount} linked records`}.\r\n              </span>\r\n            )}\r\n          </AlertDialogDescription>\r\n        </AlertDialogHeader>\r\n        <AlertDialogFooter className={hasTransactions ? \"flex-col gap-2 sm:flex-col\" : \"\"}>\r\n          <AlertDialogCancel>Cancel</AlertDialogCancel>\r\n          {hasTransactions ? (\r\n            <>\r\n              <AlertDialogAction\r\n                onClick={() => onConfirm(false)}\r\n                className=\"bg-blue-600 hover:bg-blue-700\"\r\n              >\r\n                Delete Account Only (Unlink Records)\r\n              </AlertDialogAction>\r\n              <AlertDialogAction\r\n                onClick={() => onConfirm(true)}\r\n                className=\"bg-red-600 hover:bg-red-700\"\r\n              >\r\n                Delete Account & All Records\r\n              </AlertDialogAction>\r\n            </>\r\n          ) : (\r\n            <AlertDialogAction\r\n              onClick={() => onConfirm(false)}\r\n              className=\"bg-red-600 hover:bg-red-700\"\r\n            >\r\n              Delete Account\r\n            </AlertDialogAction>\r\n          )}\r\n        </AlertDialogFooter>\r\n      </AlertDialogContent>\r\n    </AlertDialog>\r\n  );\r\n};\r\n\r\nexport default DeleteCashAccountDialog;\r\n"],"names":[],"mappings":";;;;;AAEA;;;AAqBA,MAAM,0BAAkE,CAAC,EACvE,IAAI,EACJ,YAAY,EACZ,OAAO,EACP,mBAAmB,CAAC,EACpB,OAAO,EACP,SAAS,EACV;IACC,IAAI,CAAC,SAAS,OAAO;IAErB,MAAM,kBAAkB,mBAAmB;IAE3C,qBACE,6LAAC,6JAAW;QAAC,MAAM;QAAM,cAAc;kBACrC,cAAA,6LAAC,oKAAkB;;8BACjB,6LAAC,mKAAiB;;sCAChB,6LAAC,kKAAgB;sCAAC;;;;;;sCAClB,6LAAC,wKAAsB;4BAAC,WAAU;;8CAChC,6LAAC;oCAAK,WAAU;;wCAAQ;wCAC6B,QAAQ,IAAI;wCAAC;;;;;;;gCAEjE,iCACC,6LAAC;oCAAK,WAAU;;wCAAmC;wCAC/B,WAAW,GAAG,iBAAiB,eAAe,CAAC;wCAAC;;;;;;;;;;;;;;;;;;;8BAK1E,6LAAC,mKAAiB;oBAAC,WAAW,kBAAkB,+BAA+B;;sCAC7E,6LAAC,mKAAiB;sCAAC;;;;;;wBAClB,gCACC;;8CACE,6LAAC,mKAAiB;oCAChB,SAAS,IAAM,UAAU;oCACzB,WAAU;8CACX;;;;;;8CAGD,6LAAC,mKAAiB;oCAChB,SAAS,IAAM,UAAU;oCACzB,WAAU;8CACX;;;;;;;yDAKH,6LAAC,mKAAiB;4BAChB,SAAS,IAAM,UAAU;4BACzB,WAAU;sCACX;;;;;;;;;;;;;;;;;;;;;;;AAQb;KAzDM;uCA2DS"}},
    {"offset": {"line": 1766, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useFinancialVisibility.ts"],"sourcesContent":["import { useProfiles } from '@/contexts/ProfileContext';\r\n\r\n/**\r\n * Hook to handle financial data visibility based on permissions\r\n */\r\nexport const useFinancialVisibility = () => {\r\n    const { hasPermission } = useProfiles();\r\n\r\n    const canViewCostPrice = hasPermission('inventory', 'view_cost_price');\r\n    const canViewProfit = hasPermission('inventory', 'view_profit');\r\n    const canViewSellingPrice = hasPermission('inventory', 'view_selling_price');\r\n\r\n    // Dashboard-specific permissions\r\n    const canViewTotalSales = hasPermission('dashboard', 'view_total_sales');\r\n    const canViewTotalGrossProfit = hasPermission('dashboard', 'view_gross_profit');\r\n    const canViewTotalExpenses = hasPermission('dashboard', 'view_total_expenses');\r\n    const canViewInventoryValue = hasPermission('dashboard', 'view_inventory_value');\r\n    const canViewSalesTypes = hasPermission('dashboard', 'view_sales_types');\r\n    const canViewAvgPrice = hasPermission('dashboard', 'view_avg_price');\r\n    const canViewTotalAmount = hasPermission('dashboard', 'view_total_amount');\r\n\r\n    // Finance and Expenses permissions\r\n    const canManageFinanceAccounts = hasPermission('finance', 'manage_accounts');\r\n    const canViewFinance = hasPermission('finance', 'view');\r\n    const canViewExpenses = hasPermission('expenses', 'view');\r\n    const canCreateExpenses = hasPermission('expenses', 'create');\r\n    const canEditExpenses = hasPermission('expenses', 'edit');\r\n    const canDeleteExpenses = hasPermission('expenses', 'delete');\r\n\r\n    /**\r\n     * Format a financial value or return a hidden indicator\r\n     */\r\n    const formatFinancial = (value: number | null | undefined, type: 'cost' | 'selling' | 'profit'): string => {\r\n        const hasAccess =\r\n            (type === 'cost' && canViewCostPrice) ||\r\n            (type === 'selling' && canViewSellingPrice) ||\r\n            (type === 'profit' && canViewProfit);\r\n\r\n        if (!hasAccess) {\r\n            return '';\r\n        }\r\n\r\n        return value?.toLocaleString() || '0';\r\n    };\r\n\r\n    return {\r\n        canViewCostPrice,\r\n        canViewProfit,\r\n        canViewSellingPrice,\r\n        canViewTotalSales,\r\n        canViewTotalGrossProfit,\r\n        canViewTotalExpenses,\r\n        canViewInventoryValue,\r\n        canViewSalesTypes,\r\n        canViewAvgPrice,\r\n        canViewTotalAmount,\r\n        canManageFinanceAccounts,\r\n        canViewFinance,\r\n        canViewExpenses,\r\n        canCreateExpenses,\r\n        canEditExpenses,\r\n        canDeleteExpenses,\r\n        formatFinancial,\r\n    };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;;;AAKO,MAAM,yBAAyB;;IAClC,MAAM,EAAE,aAAa,EAAE,GAAG,IAAA,oJAAW;IAErC,MAAM,mBAAmB,cAAc,aAAa;IACpD,MAAM,gBAAgB,cAAc,aAAa;IACjD,MAAM,sBAAsB,cAAc,aAAa;IAEvD,iCAAiC;IACjC,MAAM,oBAAoB,cAAc,aAAa;IACrD,MAAM,0BAA0B,cAAc,aAAa;IAC3D,MAAM,uBAAuB,cAAc,aAAa;IACxD,MAAM,wBAAwB,cAAc,aAAa;IACzD,MAAM,oBAAoB,cAAc,aAAa;IACrD,MAAM,kBAAkB,cAAc,aAAa;IACnD,MAAM,qBAAqB,cAAc,aAAa;IAEtD,mCAAmC;IACnC,MAAM,2BAA2B,cAAc,WAAW;IAC1D,MAAM,iBAAiB,cAAc,WAAW;IAChD,MAAM,kBAAkB,cAAc,YAAY;IAClD,MAAM,oBAAoB,cAAc,YAAY;IACpD,MAAM,kBAAkB,cAAc,YAAY;IAClD,MAAM,oBAAoB,cAAc,YAAY;IAEpD;;KAEC,GACD,MAAM,kBAAkB,CAAC,OAAkC;QACvD,MAAM,YACF,AAAC,SAAS,UAAU,oBACnB,SAAS,aAAa,uBACtB,SAAS,YAAY;QAE1B,IAAI,CAAC,WAAW;YACZ,OAAO;QACX;QAEA,OAAO,OAAO,oBAAoB;IACtC;IAEA,OAAO;QACH;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACJ;AACJ;GA3Da;;QACiB,oJAAW"}},
    {"offset": {"line": 1835, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/cash/CashAccountCard.tsx"],"sourcesContent":["import React, { useState, useEffect, useMemo, useCallback } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { MoreHorizontal, ArrowUpRight, ArrowDownRight, Wallet, Loader2 } from 'lucide-react';\r\nimport { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';\r\nimport { CashAccount, DailyCashSummary } from '@/types/cash';\r\nimport { useCashAccounts } from '@/hooks/useCashAccounts';\r\nimport { useCashTransactions } from '@/hooks/useCashTransactions';\r\nimport { useBusinessSettings } from '@/hooks/useBusinessSettings';\r\nimport { useIsMobile } from '@/hooks/use-mobile';\r\nimport DeleteCashAccountDialog from './DeleteCashAccountDialog';\r\nimport { formatCashAmount } from '@/lib/utils';\r\nimport { useProfiles } from '@/contexts/ProfileContext';\r\nimport { useFinancialVisibility } from '@/hooks/useFinancialVisibility';\r\n\r\ninterface CashAccountCardProps {\r\n  account: CashAccount;\r\n  onAccountDeleted?: () => void;\r\n}\r\n\r\nconst CashAccountCard: React.FC<CashAccountCardProps> = ({ account, onAccountDeleted }) => {\r\n  const navigate = useNavigate();\r\n  const isMobile = useIsMobile();\r\n  const { deleteAccount, deleteAccountWithTransactions } = useCashAccounts();\r\n  const { getDailySummary } = useCashTransactions(account.id);\r\n  const { settings } = useBusinessSettings();\r\n  const { hasPermission } = useProfiles();\r\n  const { canManageFinanceAccounts } = useFinancialVisibility();\r\n  const canDelete = hasPermission('finance', 'delete');\r\n  const [isLoadingSummary, setIsLoadingSummary] = useState(true);\r\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\r\n  const [transactionCount, setTransactionCount] = useState(0);\r\n  const [deleteDetails, setDeleteDetails] = useState<string>('');\r\n  const [todaysSummary, setTodaysSummary] = useState<DailyCashSummary>({\r\n    date: new Date(),\r\n    openingBalance: 0,\r\n    cashIn: 0,\r\n    cashOut: 0,\r\n    transfersIn: 0,\r\n    transfersOut: 0,\r\n    closingBalance: 0\r\n  });\r\n\r\n  // Memoize currency formatter\r\n  const formatCurrency = useMemo(() => {\r\n    return (amount: number) => {\r\n      return formatCashAmount(amount, settings.currency || 'USD');\r\n    };\r\n  }, [settings.currency]);\r\n\r\n  // Load today's summary to get opening, closing, and current balance\r\n  const loadTodaysSummary = useCallback(async () => {\r\n    setIsLoadingSummary(true);\r\n    try {\r\n      const summary = await getDailySummary(new Date(), account.id);\r\n      setTodaysSummary(summary);\r\n    } catch (error) {\r\n      console.error('Error loading today\\'s summary:', error);\r\n    } finally {\r\n      setIsLoadingSummary(false);\r\n    }\r\n  }, [getDailySummary, account.id]);\r\n\r\n  useEffect(() => {\r\n    loadTodaysSummary();\r\n  }, [loadTodaysSummary]);\r\n\r\n  // Memoized handlers\r\n  const handleDelete = useCallback(async () => {\r\n    console.log('Delete button clicked for account:', account.id);\r\n\r\n    try {\r\n      const result = await deleteAccount(account.id, onAccountDeleted);\r\n      console.log('Delete result:', result);\r\n\r\n      if (result && typeof result === 'object' && 'hasTransactions' in result) {\r\n        if (result.hasTransactions) {\r\n          console.log('Account has transactions, showing dialog');\r\n          // Show dialog with transaction count and details\r\n          setTransactionCount(result.transactionCount || 0);\r\n          setDeleteDetails(result.details || '');\r\n          setDeleteDialogOpen(true);\r\n        } else if (result.success) {\r\n          console.log('Account deleted successfully without dialog');\r\n          // Account was deleted successfully\r\n        } else {\r\n          console.log('Account deletion failed');\r\n          // Deletion failed, error was already shown in toast\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Unexpected error during deletion:', error);\r\n    }\r\n  }, [deleteAccount, account.id, onAccountDeleted]);\r\n\r\n  const handleConfirmDelete = useCallback(async (deleteTransactions: boolean) => {\r\n    console.log('Confirm delete called with deleteTransactions:', deleteTransactions);\r\n\r\n    try {\r\n      const success = await deleteAccountWithTransactions(account.id, deleteTransactions, onAccountDeleted);\r\n      console.log('Delete with transactions result:', success);\r\n\r\n      if (success) {\r\n        setDeleteDialogOpen(false);\r\n        console.log('Deletion successful, dialog closed');\r\n      } else {\r\n        console.log('Deletion failed');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error in handleConfirmDelete:', error);\r\n    }\r\n  }, [deleteAccountWithTransactions, account.id, onAccountDeleted]);\r\n\r\n  const handleCardClick = useCallback(() => {\r\n    navigate(`/cash/${account.id}`);\r\n  }, [navigate, account.id]);\r\n\r\n  return (\r\n    <>\r\n      <Card className={`hover:shadow-lg transition-all duration-200 cursor-pointer ${isMobile ? 'shadow-sm border-gray-200' : 'hover:shadow-md'}`}>\r\n        <CardHeader className={`flex flex-row items-center justify-between space-y-0 ${isMobile ? 'pb-3' : 'pb-2'}`}>\r\n          <CardTitle className={`${isMobile ? 'text-base' : 'text-sm'} font-semibold flex items-center gap-2 text-gray-900`}>\r\n            <Wallet className={`${isMobile ? 'h-5 w-5' : 'h-4 w-4'} text-primary`} />\r\n            <span className=\"truncate\">{account.name}</span>\r\n            {account.isDefault && (\r\n              <Badge variant=\"secondary\" className={`${isMobile ? 'text-xs px-2 py-0.5' : 'text-xs'} bg-primary/10 text-primary border-primary/20`}>\r\n                Default\r\n              </Badge>\r\n            )}\r\n          </CardTitle>\r\n          <DropdownMenu>\r\n            <DropdownMenuTrigger asChild>\r\n              <Button variant=\"ghost\" className={`${isMobile ? 'h-8 w-8' : 'h-8 w-8'} p-0 hover:bg-gray-100`}>\r\n                <MoreHorizontal className=\"h-4 w-4 text-gray-500\" />\r\n              </Button>\r\n            </DropdownMenuTrigger>\r\n            <DropdownMenuContent align=\"end\" className=\"bg-white border border-gray-200 shadow-lg\">\r\n              <DropdownMenuItem\r\n                onClick={handleCardClick}\r\n                className=\"hover:bg-gray-50\"\r\n              >\r\n                View Details\r\n              </DropdownMenuItem>\r\n              {canDelete && (\r\n                <DropdownMenuItem\r\n                  onClick={handleDelete}\r\n                  className=\"text-red-600 hover:bg-red-50\"\r\n                >\r\n                  Delete Account\r\n                </DropdownMenuItem>\r\n              )}\r\n            </DropdownMenuContent>\r\n          </DropdownMenu>\r\n        </CardHeader>\r\n        <CardContent\r\n          onClick={handleCardClick}\r\n          className={isMobile ? 'px-4 pb-4' : ''}\r\n        >\r\n          <div className={`space-y-${isMobile ? '4' : '3'}`}>\r\n            <div className={isMobile ? 'space-y-1' : ''}>\r\n              <div className={`${isMobile ? 'text-2xl' : 'text-2xl'} font-bold text-gray-900 flex items-center`}>\r\n                {isLoadingSummary ? (\r\n                  <Loader2 className=\"h-6 w-6 animate-spin text-muted-foreground\" />\r\n                ) : (\r\n                  canManageFinanceAccounts ? formatCurrency(todaysSummary.closingBalance) : ''\r\n                )}\r\n              </div>\r\n              <p className={`${isMobile ? 'text-sm' : 'text-xs'} text-gray-500 font-medium`}>\r\n                Current Balance\r\n              </p>\r\n            </div>\r\n\r\n            {account.description && (\r\n              <p className={`${isMobile ? 'text-sm leading-relaxed' : 'text-sm'} text-gray-600 line-clamp-2`}>\r\n                {account.description}\r\n              </p>\r\n            )}\r\n\r\n            <div className={`grid grid-cols-1 ${isMobile ? 'gap-3' : 'gap-2'} ${isMobile ? 'text-sm' : 'text-sm'}`}>\r\n              <div className=\"flex items-center justify-between p-2 bg-green-50 rounded-md\">\r\n                <div className=\"flex items-center gap-2 text-green-700\">\r\n                  <ArrowUpRight className=\"h-4 w-4\" />\r\n                  <span className=\"font-medium\">Opening</span>\r\n                </div>\r\n                <span className=\"font-semibold text-green-800 flex items-center\">\r\n                  {isLoadingSummary ? (\r\n                    <Loader2 className=\"h-4 w-4 animate-spin text-green-600\" />\r\n                  ) : (\r\n                    canManageFinanceAccounts ? formatCurrency(todaysSummary.openingBalance) : ''\r\n                  )}\r\n                </span>\r\n              </div>\r\n              <div className=\"flex items-center justify-between p-2 bg-blue-50 rounded-md\">\r\n                <div className=\"flex items-center gap-2 text-blue-700\">\r\n                  <ArrowDownRight className=\"h-4 w-4\" />\r\n                  <span className=\"font-medium\">Today's Close</span>\r\n                </div>\r\n                <span className=\"font-semibold text-blue-800 flex items-center\">\r\n                  {isLoadingSummary ? (\r\n                    <Loader2 className=\"h-4 w-4 animate-spin text-blue-600\" />\r\n                  ) : (\r\n                    canManageFinanceAccounts ? formatCurrency(todaysSummary.closingBalance) : ''\r\n                  )}\r\n                </span>\r\n              </div>\r\n            </div>\r\n\r\n            <div className={`${isMobile ? 'pt-2' : 'pt-2'}`}>\r\n              <Button\r\n                variant=\"outline\"\r\n                size={isMobile ? \"default\" : \"sm\"}\r\n                className={`w-full font-medium hover:bg-primary hover:text-white transition-colors ${isMobile ? 'h-10' : ''}`}\r\n                onClick={(e) => {\r\n                  e.stopPropagation();\r\n                  handleCardClick();\r\n                }}\r\n              >\r\n                Manage Account\r\n              </Button>\r\n            </div>\r\n          </div>\r\n        </CardContent>\r\n      </Card>\r\n\r\n      <DeleteCashAccountDialog\r\n        open={deleteDialogOpen}\r\n        onOpenChange={setDeleteDialogOpen}\r\n        account={account}\r\n        transactionCount={transactionCount}\r\n        details={deleteDetails}\r\n        onConfirm={handleConfirmDelete}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\nexport default CashAccountCard;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2323, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/cash/CashAccountsList.tsx"],"sourcesContent":["import React from 'react';\r\nimport { Plus } from 'lucide-react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { useIsMobile } from '@/hooks/use-mobile';\r\nimport CashAccountCard from '@/components/cash/CashAccountCard';\r\nimport { CashAccount } from '@/types/cash';\r\n\r\ninterface CashAccountsListProps {\r\n  accounts: CashAccount[];\r\n  isLoading: boolean;\r\n  onCreateAccount: () => void;\r\n  onAccountDeleted: () => Promise<void>;\r\n  canCreate?: boolean;\r\n}\r\n\r\nconst CashAccountsList: React.FC<CashAccountsListProps> = ({\r\n  accounts,\r\n  isLoading,\r\n  onCreateAccount,\r\n  onAccountDeleted,\r\n  canCreate = true\r\n}) => {\r\n  const isMobile = useIsMobile();\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6\">\r\n        {[1, 2, 3].map((i) => (\r\n          <div key={i} className=\"h-64 bg-gray-100 animate-pulse rounded-lg\" />\r\n        ))}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (accounts.length === 0) {\r\n    return (\r\n      <div className=\"text-center py-12\">\r\n        <h3 className=\"text-lg font-medium text-gray-900 mb-2\">No cash accounts</h3>\r\n        <p className=\"text-gray-500 mb-4\">Get started by creating your first cash account.</p>\r\n        {canCreate && (\r\n          <Button onClick={onCreateAccount} className=\"gap-2\">\r\n            <Plus className=\"h-4 w-4\" />\r\n            Create Cash Account\r\n          </Button>\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6\">\r\n      {accounts.map((account) => (\r\n        <CashAccountCard\r\n          key={account.id}\r\n          account={account}\r\n          onAccountDeleted={onAccountDeleted}\r\n        />\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CashAccountsList;"],"names":[],"mappings":";;;;;AACA;AACA;AACA;AACA;;;;;;;AAWA,MAAM,mBAAoD,CAAC,EACzD,QAAQ,EACR,SAAS,EACT,eAAe,EACf,gBAAgB,EAChB,YAAY,IAAI,EACjB;;IACC,MAAM,WAAW,IAAA,gJAAW;IAE5B,IAAI,WAAW;QACb,qBACE,6LAAC;YAAI,WAAU;sBACZ;gBAAC;gBAAG;gBAAG;aAAE,CAAC,GAAG,CAAC,CAAC,kBACd,6LAAC;oBAAY,WAAU;mBAAb;;;;;;;;;;IAIlB;IAEA,IAAI,SAAS,MAAM,KAAK,GAAG;QACzB,qBACE,6LAAC;YAAI,WAAU;;8BACb,6LAAC;oBAAG,WAAU;8BAAyC;;;;;;8BACvD,6LAAC;oBAAE,WAAU;8BAAqB;;;;;;gBACjC,2BACC,6LAAC,+IAAM;oBAAC,SAAS;oBAAiB,WAAU;;sCAC1C,6LAAC,6MAAI;4BAAC,WAAU;;;;;;wBAAY;;;;;;;;;;;;;IAMtC;IAEA,qBACE,6LAAC;QAAI,WAAU;kBACZ,SAAS,GAAG,CAAC,CAAC,wBACb,6LAAC,2JAAe;gBAEd,SAAS;gBACT,kBAAkB;eAFb,QAAQ,EAAE;;;;;;;;;;AAOzB;GA7CM;;QAOa,gJAAW;;;KAPxB;uCA+CS"}},
    {"offset": {"line": 2438, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/textarea.tsx"],"sourcesContent":["import * as React from \"react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nexport interface TextareaProps\r\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\r\n\r\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\r\n  ({ className, ...props }, ref) => {\r\n    return (\r\n      <textarea\r\n        className={cn(\r\n          \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\r\n          className\r\n        )}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    )\r\n  }\r\n)\r\nTextarea.displayName = \"Textarea\"\r\n\r\nexport { Textarea }\r\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAKA,MAAM,yBAAW,2KAAgB,MAC/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE;IACxB,qBACE,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,wSACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;;AAEF,SAAS,WAAW,GAAG"}},
    {"offset": {"line": 2472, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/checkbox.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\r\nimport { Check } from \"lucide-react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Checkbox = React.forwardRef<\r\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\r\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\r\n>(({ className, ...props }, ref) => (\r\n  <CheckboxPrimitive.Root\r\n    ref={ref}\r\n    className={cn(\r\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\r\n      className\r\n    )}\r\n    {...props}\r\n  >\r\n    <CheckboxPrimitive.Indicator\r\n      className={cn(\"flex items-center justify-center text-current\")}\r\n    >\r\n      <Check className=\"h-4 w-4\" />\r\n    </CheckboxPrimitive.Indicator>\r\n  </CheckboxPrimitive.Root>\r\n))\r\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\r\n\r\nexport { Checkbox }\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,yBAAW,2KAAgB,MAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,+KAAsB;QACrB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,kTACA;QAED,GAAG,KAAK;kBAET,cAAA,6LAAC,oLAA2B;YAC1B,WAAW,IAAA,4HAAE,EAAC;sBAEd,cAAA,6LAAC,gNAAK;gBAAC,WAAU;;;;;;;;;;;;;;;;;AAIvB,SAAS,WAAW,GAAG,+KAAsB,CAAC,WAAW"}},
    {"offset": {"line": 2522, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/cash/CashAccountDialog.tsx"],"sourcesContent":["\r\nimport React from 'react';\r\nimport { useForm } from 'react-hook-form';\r\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Label } from '@/components/ui/label';\r\nimport { Textarea } from '@/components/ui/textarea';\r\nimport { Checkbox } from '@/components/ui/checkbox';\r\nimport { CashAccountFormData } from '@/types/cash';\r\nimport { useBusinessSettings } from '@/hooks/useBusinessSettings';\r\n\r\ninterface CashAccountDialogProps {\r\n  open: boolean;\r\n  onOpenChange: (open: boolean) => void;\r\n  onSubmit: (data: CashAccountFormData) => void;\r\n  title: string;\r\n  initialData?: Partial<CashAccountFormData>;\r\n  isSubmitting?: boolean;\r\n}\r\n\r\nconst CashAccountDialog: React.FC<CashAccountDialogProps> = ({\r\n  open,\r\n  onOpenChange,\r\n  onSubmit,\r\n  title,\r\n  initialData,\r\n  isSubmitting = false\r\n}) => {\r\n  const { settings } = useBusinessSettings();\r\n  const { register, handleSubmit, formState: { errors }, reset, watch, setValue } = useForm<CashAccountFormData>({\r\n    defaultValues: {\r\n      name: '',\r\n      description: '',\r\n      isDefault: false,\r\n      ...initialData\r\n    }\r\n  });\r\n\r\n  React.useEffect(() => {\r\n    if (open && initialData) {\r\n      reset({\r\n        name: initialData.name || '',\r\n        description: initialData.description || '',\r\n        openingBalance: initialData.openingBalance || 0,\r\n        isDefault: initialData.isDefault || false\r\n      });\r\n    } else if (open) {\r\n      reset({\r\n        name: '',\r\n        description: '',\r\n        openingBalance: undefined as any,\r\n        isDefault: false\r\n      });\r\n    }\r\n  }, [open, initialData, reset]);\r\n\r\n  const isDefault = watch('isDefault');\r\n\r\n  const handleFormSubmit = (data: CashAccountFormData) => {\r\n    onSubmit(data);\r\n  };\r\n\r\n  // Use business settings currency, default to UGX if not set\r\n  const currency = settings.currency || 'UGX';\r\n\r\n  return (\r\n    <Dialog open={open} onOpenChange={onOpenChange}>\r\n      <DialogContent className=\"sm:max-w-[425px]\">\r\n        <DialogHeader>\r\n          <DialogTitle>{title}</DialogTitle>\r\n        </DialogHeader>\r\n        <form onSubmit={handleSubmit(handleFormSubmit)} className=\"space-y-4\">\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"name\">Account Name</Label>\r\n            <Input\r\n              id=\"name\"\r\n              {...register('name', { required: 'Account name is required' })}\r\n              placeholder=\"e.g., Main Cash, Petty Cash\"\r\n              disabled={isSubmitting}\r\n            />\r\n            {errors.name && (\r\n              <p className=\"text-sm text-red-600\">{errors.name.message}</p>\r\n            )}\r\n          </div>\r\n\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"description\">Description (Optional)</Label>\r\n            <Textarea\r\n              id=\"description\"\r\n              {...register('description')}\r\n              placeholder=\"Brief description of this account\"\r\n              rows={3}\r\n              disabled={isSubmitting}\r\n            />\r\n          </div>\r\n\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"openingBalance\">Opening Balance ({currency})</Label>\r\n            <Input\r\n              id=\"openingBalance\"\r\n              type=\"number\"\r\n              step=\"0.01\"\r\n              {...register('openingBalance', {\r\n                required: 'Opening balance is required',\r\n                min: { value: 0, message: 'Opening balance cannot be negative' }\r\n              })}\r\n              placeholder=\"0.00\"\r\n              disabled={isSubmitting}\r\n            />\r\n            {errors.openingBalance && (\r\n              <p className=\"text-sm text-red-600\">{errors.openingBalance.message}</p>\r\n            )}\r\n          </div>\r\n\r\n          <div className=\"flex items-center space-x-2\">\r\n            <Checkbox\r\n              id=\"isDefault\"\r\n              checked={isDefault}\r\n              onCheckedChange={(checked) => setValue('isDefault', checked as boolean)}\r\n              disabled={isSubmitting}\r\n            />\r\n            <Label htmlFor=\"isDefault\" className=\"text-sm\">\r\n              Set as default account\r\n            </Label>\r\n          </div>\r\n\r\n          <div className=\"flex justify-end space-x-2 pt-4\">\r\n            <Button type=\"button\" variant=\"outline\" onClick={() => onOpenChange(false)} disabled={isSubmitting}>\r\n              Cancel\r\n            </Button>\r\n            <Button type=\"submit\" disabled={isSubmitting}>\r\n              {isSubmitting\r\n                ? (initialData ? 'Updating...' : 'Creating...')\r\n                : (initialData ? 'Update Account' : 'Create Account')\r\n              }\r\n            </Button>\r\n          </div>\r\n        </form>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n};\r\n\r\nexport default CashAccountDialog;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2814, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/types/index.ts"],"sourcesContent":["// Sale item type definition\r\nexport interface SaleItem {\r\n  description: string;\r\n  quantity: number;\r\n  price: number;\r\n  cost: number;\r\n  productId?: string;\r\n  discountPercentage?: number;\r\n  discountType?: 'percentage' | 'amount';\r\n  discountAmount?: number;\r\n}\r\n\r\nexport interface SalesCategory {\r\n  id: string;\r\n  user_id: string;\r\n  location_id?: string;\r\n  name: string;\r\n  is_default: boolean;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface Sale {\r\n  id: string;\r\n  receiptNumber: string;\r\n  customerName: string;\r\n  customerAddress?: string;\r\n  customerContact?: string;\r\n  customerId?: string;\r\n  items: SaleItem[];\r\n  paymentStatus: 'Paid' | 'NOT PAID' | 'Quote' | 'Installment Sale';\r\n  profit: number;\r\n  date: Date;\r\n  taxRate?: number;\r\n  cashTransactionId?: string;\r\n  amountPaid?: number;\r\n  amountDue?: number;\r\n  notes?: string;\r\n  categoryId?: string;\r\n  installments?: Array<{\r\n    date?: string | Date;\r\n    amountPaid?: number;\r\n  }>;\r\n  createdAt: Date;\r\n}\r\n\r\n// Supabase database schema and Json type\r\nexport type Json =\r\n  | string\r\n  | number\r\n  | boolean\r\n  | null\r\n  | { [key: string]: Json | undefined }\r\n  | Json[];\r\n\r\n// Supabase database sale structure\r\nexport interface DbSale {\r\n  id: string;\r\n  user_id: string;\r\n  location_id: string;\r\n  receipt_number: string;\r\n  customer_name: string;\r\n  customer_address?: string | null;\r\n  customer_contact?: string | null;\r\n  customer_id?: string | null;\r\n  items: Json;\r\n  payment_status: string;\r\n  profit: number;\r\n  date: string;\r\n  tax_rate?: number | null;\r\n  created_at: string;\r\n  updated_at: string;\r\n  cash_transaction_id?: string | null;\r\n  amount_paid?: number | null;\r\n  amount_due?: number | null;\r\n  notes?: string | null;\r\n  category_id?: string | null;\r\n}\r\n\r\n// Expense interface - add cashTransactionId field\r\nexport interface Expense {\r\n  id: string;\r\n  amount: number;\r\n  description: string;\r\n  category: string | null;\r\n  date: Date;\r\n  paymentMethod: string | null;\r\n  personInCharge: string | null;\r\n  receiptImage: string | null;\r\n  cashAccountId: string | null;\r\n  cashTransactionId: string | null; // Add this field\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\n// Supabase database expense structure\r\nexport interface DbExpense {\r\n  id: string;\r\n  user_id: string;\r\n  amount: number;\r\n  description: string;\r\n  category: string | null;\r\n  date: string;\r\n  payment_method: string | null;\r\n  person_in_charge: string | null;\r\n  receipt_image: string | null;\r\n  cash_account_id: string | null;\r\n  cash_transaction_id: string | null; // Add this field\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface SaleFormData {\r\n  customerName: string;\r\n  customerAddress: string;\r\n  customerContact: string;\r\n  customerId?: string; // Added customerId field\r\n  items: SaleItem[];\r\n  paymentStatus: \"Paid\" | \"NOT PAID\" | \"Quote\" | \"Installment Sale\";\r\n  receiptNumber?: string;\r\n  taxRate?: number | null;\r\n  amountPaid?: number;\r\n  amountDue?: number;\r\n  notes?: string;\r\n  categoryId?: string;\r\n}\r\n\r\n// Analytics data type\r\nexport interface AnalyticsData {\r\n  totalSales: number;\r\n  totalProfit: number;\r\n  totalCost: number;\r\n  paidSalesCount: number;\r\n  pendingSalesCount: number;\r\n}\r\n\r\n// Form validation errors\r\nexport interface FormErrors {\r\n  customerName?: string;\r\n  customerAddress?: string;\r\n  customerContact?: string;\r\n  itemDescription?: string;\r\n  quantity?: string;\r\n  salePrice?: string;\r\n  costOfProduction?: string;\r\n  taxRate?: string;\r\n}\r\n\r\n// BusinessSettings interface to include paymentInfo\r\nexport interface BusinessSettings {\r\n  businessName: string;\r\n  businessAddress: string;\r\n  businessPhone: string;\r\n  businessEmail: string;\r\n  businessLogo?: string;\r\n  currency: string;\r\n  signature?: string;\r\n  paymentInfo?: string; // Added payment information field\r\n  defaultPrintFormat?: 'standard' | 'thermal'; // Added default print format\r\n  defaultPrinterName?: string; // Added default printer name\r\n  defaultPrinterType?: 'USB' | 'Bluetooth'; // Added default printer type\r\n}\r\n\r\n// Database business settings structure\r\nexport interface DbBusinessSettings {\r\n  id?: string;\r\n  user_id: string; // Make sure this is required, not optional\r\n  business_name: string;\r\n  business_address: string;\r\n  business_phone: string;\r\n  business_email: string;\r\n  business_logo?: string;\r\n  currency: string;\r\n  signature?: string;\r\n  metadata?: Json | null; // Add metadata field\r\n  created_at?: string;\r\n  updated_at?: string;\r\n}\r\n\r\n// Updated UserProfile interface to match the Supabase database structure\r\nexport interface UserProfile {\r\n  id: string;\r\n  full_name: string | null;\r\n  display_name: string | null;\r\n  avatar_url: string | null;\r\n  created_at: string | null;\r\n  updated_at: string | null;\r\n}\r\n\r\n// New interfaces for Product management - ADDED itemNumber\r\nexport interface Product {\r\n  id: string;\r\n  itemNumber: string; // Added item number field\r\n  barcode: string | null; // Added barcode field\r\n  manufacturerBarcode: string | null; // Added manufacturer barcode field\r\n  name: string;\r\n  description: string | null;\r\n  category: string;\r\n  quantity: number;\r\n  costPrice: number;\r\n  sellingPrice: number;\r\n  supplier: string | null;\r\n  imageUrl: string | null;\r\n  minimumStock: number;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface DbProduct {\r\n  id: string;\r\n  user_id: string;\r\n  item_number: string; // Added item number field\r\n  barcode: string | null; // Added barcode field\r\n  manufacturer_barcode: string | null; // Added manufacturer barcode field\r\n  name: string;\r\n  description: string | null;\r\n  category: string;\r\n  quantity: number;\r\n  cost_price: number;\r\n  selling_price: number;\r\n  supplier: string | null;\r\n  image_url: string | null;\r\n  minimum_stock: number;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface ProductFormData {\r\n  name: string;\r\n  barcode?: string; // Added barcode field\r\n  manufacturerBarcode?: string; // Added manufacturer barcode field\r\n  description?: string;\r\n  category?: string;\r\n  quantity: number; // Always a number, never undefined\r\n  costPrice?: number;\r\n  sellingPrice?: number;\r\n  supplier?: string;\r\n  minimumStock?: number;\r\n  imageFile?: File | null;\r\n  imageUrl?: string | null;\r\n  createdAt?: Date; // Added created date field\r\n}\r\n\r\nexport interface ProductCategory {\r\n  id: string;\r\n  name: string;\r\n}\r\n\r\nexport interface DbProductCategory {\r\n  id: string;\r\n  user_id: string;\r\n  name: string;\r\n  created_at: string;\r\n}\r\n\r\nexport interface StockHistoryEntry {\r\n  id: string;\r\n  productId: string;\r\n  oldQuantity: number;\r\n  newQuantity: number;\r\n  changeReason: string;\r\n  referenceId?: string | null;\r\n  receiptNumber?: string;\r\n  createdAt: Date;\r\n  product?: {\r\n    name: string;\r\n    costPrice: number;\r\n    sellingPrice: number;\r\n    itemNumber: string;\r\n  };\r\n}\r\n\r\nexport interface DbStockHistoryEntry {\r\n  id: string;\r\n  user_id: string;\r\n  product_id: string;\r\n  previous_quantity: number;\r\n  new_quantity: number;\r\n  change_reason: string;\r\n  reference_id?: string | null;\r\n  created_at: string;\r\n}\r\n\r\nexport interface ProductFilters {\r\n  search: string;\r\n  category: string;\r\n  stockStatus: 'all' | 'inStock' | 'lowStock' | 'outOfStock';\r\n}\r\n\r\n// Customer management types\r\nexport interface Customer {\r\n  id: string;\r\n  fullName: string;\r\n  email: string | null;\r\n  phoneNumber: string | null;\r\n  birthday: Date | null;\r\n  location: string | null;\r\n  categoryId: string | null; // Added category relationship\r\n  socialMedia: {\r\n    facebook?: string;\r\n    instagram?: string;\r\n    twitter?: string;\r\n    linkedin?: string;\r\n    other?: string;\r\n  } | null;\r\n  gender: string | null;\r\n  tags: string[] | null;\r\n  notes: string | null;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface DbCustomer {\r\n  id: string;\r\n  user_id: string;\r\n  full_name: string;\r\n  email: string | null;\r\n  phone_number: string | null;\r\n  birthday: string | null;\r\n  location: string | null;\r\n  category_id: string | null; // Added category relationship\r\n  social_media: Json | null;\r\n  gender: string | null;\r\n  tags: string[] | null;\r\n  notes: string | null;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface CustomerFormData {\r\n  fullName: string;\r\n  email: string;\r\n  phoneNumber: string;\r\n  birthday: Date | null;\r\n  location: string;\r\n  categoryId: string | null; // Added category field\r\n  socialMedia: {\r\n    facebook?: string;\r\n    instagram?: string;\r\n    twitter?: string;\r\n    linkedin?: string;\r\n    other?: string;\r\n  };\r\n  gender: string;\r\n  tags: string[];\r\n  notes: string;\r\n}\r\n\r\n// Utility functions for database conversions\r\nexport const mapDbSaleToSale = (dbSale: DbSale): Sale => {\r\n  // Parse items and ensure numeric fields are numbers, not strings\r\n  // This is critical for discount calculations to work correctly\r\n  const items = (Array.isArray(dbSale.items) ? dbSale.items : []).map((item: any) => {\r\n    const discountPercentage = item.discountPercentage !== undefined ? Number(item.discountPercentage) : undefined;\r\n    const discountAmount = item.discountAmount !== undefined ? Number(item.discountAmount) : undefined;\r\n\r\n    // Infer discountType if missing (for legacy data)\r\n    let discountType = item.discountType as 'percentage' | 'amount' | undefined;\r\n    if (!discountType) {\r\n      if (discountPercentage && discountPercentage > 0) {\r\n        discountType = 'percentage';\r\n      } else if (discountAmount && discountAmount > 0) {\r\n        discountType = 'amount';\r\n      }\r\n    }\r\n\r\n    return {\r\n      description: item.description || '',\r\n      quantity: Number(item.quantity) || 0,\r\n      price: Number(item.price) || 0,\r\n      cost: Number(item.cost) || 0,\r\n      productId: item.productId || undefined,\r\n      discountType,\r\n      discountPercentage,\r\n      discountAmount,\r\n      createdAt: item.createdAt || undefined,\r\n    };\r\n  }) as SaleItem[];\r\n\r\n  return {\r\n    id: dbSale.id,\r\n    receiptNumber: dbSale.receipt_number,\r\n    customerName: dbSale.customer_name,\r\n    customerAddress: dbSale.customer_address || '',\r\n    customerContact: dbSale.customer_contact || '',\r\n    customerId: dbSale.customer_id || undefined,\r\n    items,\r\n    paymentStatus: dbSale.payment_status as 'Paid' | 'NOT PAID' | 'Quote' | 'Installment Sale',\r\n    profit: Number(dbSale.profit),\r\n    date: new Date(dbSale.date),\r\n    taxRate: dbSale.tax_rate ? Number(dbSale.tax_rate) : 0,\r\n    cashTransactionId: dbSale.cash_transaction_id || undefined,\r\n    amountPaid: dbSale.amount_paid ? Number(dbSale.amount_paid) : undefined,\r\n    amountDue: dbSale.amount_due ? Number(dbSale.amount_due) : undefined,\r\n    notes: dbSale.notes || '',\r\n    categoryId: dbSale.category_id || undefined,\r\n    createdAt: new Date(dbSale.created_at),\r\n  };\r\n};\r\n\r\nexport const mapSaleToDbSale = (\r\n  saleData: SaleFormData,\r\n  selectedDate: Date,\r\n  profit: number,\r\n  receiptNumber: string,\r\n  userId: string,\r\n  locationId: string,\r\n  cashTransactionId?: string | null\r\n): Omit<DbSale, 'id' | 'created_at' | 'updated_at'> => {\r\n  return {\r\n    user_id: userId,\r\n    location_id: locationId,\r\n    receipt_number: receiptNumber,\r\n    customer_name: saleData.customerName,\r\n    customer_address: saleData.customerAddress || null,\r\n    customer_contact: saleData.customerContact || null,\r\n    customer_id: saleData.customerId || null, // Include customer_id\r\n    items: (saleData.items as unknown) as Json,\r\n    payment_status: saleData.paymentStatus,\r\n    profit: profit,\r\n    date: selectedDate.toISOString().split('T')[0],\r\n    tax_rate: saleData.taxRate || 0,\r\n    cash_transaction_id: cashTransactionId || null,\r\n    amount_paid: saleData.amountPaid || null,\r\n    amount_due: saleData.amountDue || null,\r\n    notes: saleData.notes || null,\r\n    category_id: saleData.categoryId || null,\r\n  };\r\n};\r\n\r\n// Conversion functions for business settings\r\nexport const mapDbBusinessSettingsToBusinessSettings = (dbSettings: DbBusinessSettings): BusinessSettings => {\r\n  return {\r\n    businessName: dbSettings.business_name,\r\n    businessAddress: dbSettings.business_address,\r\n    businessPhone: dbSettings.business_phone,\r\n    businessEmail: dbSettings.business_email,\r\n    businessLogo: dbSettings.business_logo,\r\n    currency: dbSettings.currency,\r\n    signature: dbSettings.signature,\r\n    paymentInfo: dbSettings.metadata && typeof dbSettings.metadata === 'object' ?\r\n      (dbSettings.metadata as Record<string, unknown>).payment_info as string || '' : '',\r\n    defaultPrintFormat: dbSettings.metadata && typeof dbSettings.metadata === 'object' ?\r\n      (dbSettings.metadata as Record<string, unknown>).default_print_format as 'standard' | 'thermal' || 'standard' : 'standard',\r\n    defaultPrinterName: dbSettings.metadata && typeof dbSettings.metadata === 'object' ?\r\n      (dbSettings.metadata as Record<string, unknown>).default_printer_name as string || '' : '',\r\n    defaultPrinterType: dbSettings.metadata && typeof dbSettings.metadata === 'object' ?\r\n      (dbSettings.metadata as Record<string, unknown>).default_printer_type as 'USB' | 'Bluetooth' || 'USB' : 'USB'\r\n  };\r\n};\r\n\r\nexport const mapBusinessSettingsToDbBusinessSettings = (\r\n  settings: BusinessSettings,\r\n  userId: string\r\n): DbBusinessSettings => {\r\n  // Create metadata object with payment_info\r\n  const metadata: Json = {\r\n    payment_info: settings.paymentInfo || '',\r\n    default_print_format: settings.defaultPrintFormat || 'standard',\r\n    default_printer_name: settings.defaultPrinterName || '',\r\n    default_printer_type: settings.defaultPrinterType || 'USB'\r\n  };\r\n\r\n  return {\r\n    user_id: userId,\r\n    business_name: settings.businessName,\r\n    business_address: settings.businessAddress,\r\n    business_phone: settings.businessPhone,\r\n    business_email: settings.businessEmail,\r\n    business_logo: settings.businessLogo,\r\n    currency: settings.currency,\r\n    signature: settings.signature,\r\n    metadata: metadata, // Include metadata in the return object\r\n    updated_at: new Date().toISOString()\r\n  };\r\n};\r\n\r\n// Conversion functions for products and categories - ADDED itemNumber\r\nexport const mapDbProductToProduct = (dbProduct: DbProduct): Product => {\r\n  return {\r\n    id: dbProduct.id,\r\n    itemNumber: dbProduct.item_number, // Added item number mapping\r\n    barcode: dbProduct.barcode, // Added barcode mapping\r\n    manufacturerBarcode: dbProduct.manufacturer_barcode, // Added manufacturer barcode mapping\r\n    name: dbProduct.name,\r\n    description: dbProduct.description,\r\n    category: dbProduct.category,\r\n    quantity: dbProduct.quantity,\r\n    costPrice: Number(dbProduct.cost_price),\r\n    sellingPrice: Number(dbProduct.selling_price),\r\n    supplier: dbProduct.supplier,\r\n    imageUrl: dbProduct.image_url,\r\n    minimumStock: dbProduct.minimum_stock,\r\n    createdAt: new Date(dbProduct.created_at),\r\n    updatedAt: new Date(dbProduct.updated_at)\r\n  };\r\n};\r\n\r\nexport const mapProductToDbProduct = (product: Partial<Product>, userId: string): Partial<DbProduct> => {\r\n  const result: Partial<DbProduct> = {\r\n    user_id: userId\r\n  };\r\n\r\n  if (product.id) result.id = product.id;\r\n  if (product.itemNumber) result.item_number = product.itemNumber; // Added item number mapping\r\n  if (product.barcode !== undefined) result.barcode = product.barcode; // Added barcode mapping\r\n  if (product.manufacturerBarcode !== undefined) result.manufacturer_barcode = product.manufacturerBarcode; // Added manufacturer barcode mapping\r\n  if (product.name) result.name = product.name;\r\n  result.description = product.description;\r\n  if (product.category) result.category = product.category;\r\n  if (product.quantity !== undefined) result.quantity = product.quantity;\r\n  if (product.costPrice !== undefined) {\r\n    result.cost_price = product.costPrice;\r\n    console.log(`DEBUG: Mapping costPrice ${product.costPrice} to cost_price`);\r\n  }\r\n  if (product.sellingPrice !== undefined) {\r\n    result.selling_price = product.sellingPrice;\r\n    console.log(`DEBUG: Mapping sellingPrice ${product.sellingPrice} to selling_price`);\r\n  }\r\n  result.supplier = product.supplier;\r\n  result.image_url = product.imageUrl;\r\n  if (product.minimumStock !== undefined) result.minimum_stock = product.minimumStock;\r\n\r\n  return result;\r\n};\r\n\r\nexport const mapDbProductCategoryToProductCategory = (dbCategory: DbProductCategory): ProductCategory => {\r\n  return {\r\n    id: dbCategory.id,\r\n    name: dbCategory.name\r\n  };\r\n};\r\n\r\nexport const mapDbStockHistoryToStockHistory = (dbHistory: DbStockHistoryEntry): StockHistoryEntry => {\r\n  return {\r\n    id: dbHistory.id,\r\n    productId: dbHistory.product_id,\r\n    oldQuantity: dbHistory.previous_quantity,\r\n    newQuantity: dbHistory.new_quantity,\r\n    changeReason: dbHistory.change_reason,\r\n    referenceId: dbHistory.reference_id || null,\r\n    createdAt: new Date(dbHistory.created_at)\r\n  };\r\n};\r\n\r\n// Updated Customer mapping functions to include categoryId\r\nexport const mapDbCustomerToCustomer = (dbCustomer: DbCustomer): Customer => {\r\n  let birthday = null;\r\n\r\n  if (dbCustomer.birthday) {\r\n    try {\r\n      const birthdayStr = String(dbCustomer.birthday);\r\n      const [year, month, day] = birthdayStr.split('-').map(Number);\r\n\r\n      if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {\r\n        birthday = new Date(Date.UTC(year, month - 1, day, 12, 0, 0));\r\n\r\n        console.log(\r\n          'Converting DB birthday to Date object:',\r\n          dbCustomer.birthday,\r\n          '',\r\n          birthday,\r\n          '(UTC string:',\r\n          birthday.toISOString(),\r\n          ')'\r\n        );\r\n      } else {\r\n        console.error('Invalid date components in birthday:', dbCustomer.birthday);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error parsing birthday:', error, dbCustomer.birthday);\r\n    }\r\n  }\r\n\r\n  return {\r\n    id: dbCustomer.id,\r\n    fullName: dbCustomer.full_name,\r\n    email: dbCustomer.email,\r\n    phoneNumber: dbCustomer.phone_number,\r\n    birthday: birthday,\r\n    location: dbCustomer.location,\r\n    categoryId: dbCustomer.category_id, // Added category mapping\r\n    socialMedia: dbCustomer.social_media as any,\r\n    gender: dbCustomer.gender,\r\n    tags: dbCustomer.tags,\r\n    notes: dbCustomer.notes,\r\n    createdAt: new Date(dbCustomer.created_at),\r\n    updatedAt: new Date(dbCustomer.updated_at)\r\n  };\r\n};\r\n\r\nexport const mapCustomerToDbCustomer = (customer: Partial<Customer>, userId: string): Partial<DbCustomer> => {\r\n  const result: Partial<DbCustomer> = {\r\n    user_id: userId\r\n  };\r\n\r\n  if (customer.id) result.id = customer.id;\r\n  if (customer.fullName) result.full_name = customer.fullName;\r\n  result.email = customer.email;\r\n  result.phone_number = customer.phoneNumber;\r\n  if (customer.birthday) result.birthday = customer.birthday.toISOString().split('T')[0];\r\n  result.location = customer.location;\r\n  result.category_id = customer.categoryId; // Added category mapping\r\n  result.social_media = customer.socialMedia as Json;\r\n  result.gender = customer.gender;\r\n  result.tags = customer.tags;\r\n  result.notes = customer.notes;\r\n\r\n  return result;\r\n};\r\n\r\n// Conversion functions for expenses\r\nexport const mapDbExpenseToExpense = (dbExpense: DbExpense): Expense => {\r\n  return {\r\n    id: dbExpense.id,\r\n    amount: Number(dbExpense.amount),\r\n    description: dbExpense.description,\r\n    category: dbExpense.category,\r\n    date: new Date(dbExpense.date),\r\n    paymentMethod: dbExpense.payment_method,\r\n    personInCharge: dbExpense.person_in_charge,\r\n    receiptImage: dbExpense.receipt_image,\r\n    cashAccountId: dbExpense.cash_account_id,\r\n    cashTransactionId: dbExpense.cash_transaction_id,\r\n    createdAt: new Date(dbExpense.created_at),\r\n    updatedAt: new Date(dbExpense.updated_at)\r\n  };\r\n};\r\n\r\nexport const mapExpenseToDbExpense = (expense: Partial<Expense>, userId: string): Partial<DbExpense> => {\r\n  const result: Partial<DbExpense> = {\r\n    user_id: userId\r\n  };\r\n\r\n  if (expense.id) result.id = expense.id;\r\n  if (expense.amount !== undefined) result.amount = expense.amount;\r\n  if (expense.description) result.description = expense.description;\r\n  result.category = expense.category;\r\n  if (expense.date) result.date = expense.date.toISOString().split('T')[0];\r\n  result.payment_method = expense.paymentMethod;\r\n  result.person_in_charge = expense.personInCharge;\r\n  result.receipt_image = expense.receiptImage;\r\n  result.cash_account_id = expense.cashAccountId;\r\n  result.cash_transaction_id = expense.cashTransactionId;\r\n\r\n  return result;\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3100, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map(h => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map(e => e.productId))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAOsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,yDAAA"}},
    {"offset": {"line": 3117, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map(h => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map(e => e.productId))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoDsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 3134, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map(h => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map(e => e.productId))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsFsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 3151, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map(h => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map(e => e.productId))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsIsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,8EAAA"}},
    {"offset": {"line": 3168, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useStockHistory.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\nimport { StockHistoryEntry } from '@/types';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport {\r\n  getStockHistoryAction,\r\n  createStockHistoryAction,\r\n  recalculateStockChainAction,\r\n  deleteStockHistoryEntriesByReferenceAction\r\n} from '@/app/actions/inventory';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\n\r\nexport interface ChainRepairBreakEntry {\r\n  entryId: string;\r\n  createdAt: string;\r\n  changeReason: string;\r\n  currentPrevQty: number;\r\n  currentNewQty: number;\r\n  fixedPrevQty: number;\r\n  fixedNewQty: number;\r\n}\r\n\r\nexport interface ChainRepairPreview {\r\n  productId: string;\r\n  productName: string;\r\n  totalEntries: number;\r\n  brokenEntries: ChainRepairBreakEntry[];\r\n  finalFixedQty: number;\r\n  currentProductQty: number;\r\n}\r\n\r\nexport const useStockHistory = (userId: string | undefined, productId?: string) => {\r\n  const [stockHistory, setStockHistory] = useState<StockHistoryEntry[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const { currentBusiness } = useBusiness();\r\n  const { user } = useAuth();\r\n\r\n  const loadStockHistory = useCallback(async () => {\r\n    if (!userId || !currentBusiness) {\r\n      setStockHistory([]);\r\n      setIsLoading(false);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setIsLoading(true);\r\n      const result = await getStockHistoryAction(currentBusiness.id, productId);\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error || 'Failed to fetch stock history');\r\n      }\r\n\r\n      const formattedHistory: StockHistoryEntry[] = result.data.map((entry: any) => ({\r\n        id: entry.id,\r\n        productId: entry.productId,\r\n        oldQuantity: entry.oldQuantity,\r\n        newQuantity: entry.newQuantity,\r\n        changeReason: entry.changeReason,\r\n        createdAt: new Date(entry.createdAt),\r\n        referenceId: entry.referenceId,\r\n        receiptNumber: entry.receiptNumber,\r\n        product: entry.product\r\n      }));\r\n\r\n      setStockHistory(formattedHistory);\r\n    } catch (error) {\r\n      console.error('Error loading stock history:', error);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [userId, currentBusiness?.id, productId]);\r\n\r\n  useEffect(() => {\r\n    loadStockHistory();\r\n  }, [loadStockHistory]);\r\n\r\n  const createStockHistoryEntry = async (\r\n    targetProductId: string,\r\n    previousQuantity: number,\r\n    newQuantity: number,\r\n    reason: string,\r\n    referenceId?: string,\r\n    entryDate?: Date,\r\n    receiptNumber?: string,\r\n    productName?: string\r\n  ) => {\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      const snapshottedReason = productName\r\n        ? `[${productName}] | ${reason}`\r\n        : reason;\r\n\r\n      const result = await createStockHistoryAction({\r\n        userId,\r\n        locationId: currentBusiness.id,\r\n        productId: targetProductId,\r\n        previousQuantity,\r\n        newQuantity,\r\n        changeReason: snapshottedReason,\r\n        referenceId,\r\n        receiptNumber,\r\n        createdAt: entryDate?.toISOString()\r\n      });\r\n\r\n      if (!result.success) {\r\n        console.error('Error creating stock history entry:', result.error);\r\n        return false;\r\n      }\r\n\r\n      await loadStockHistory();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error creating stock history:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteMultipleStockHistoryEntriesByReference = async (referenceId: string) => {\r\n    try {\r\n      if (!currentBusiness) return false;\r\n      const result = await deleteStockHistoryEntriesByReferenceAction(referenceId, currentBusiness.id);\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      await loadStockHistory();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting stock history entries:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const recalculateStockChain = async (targetProductId: string) => {\r\n    try {\r\n      if (!currentBusiness) return false;\r\n      const result = await recalculateStockChainAction(targetProductId, currentBusiness.id);\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      await loadStockHistory();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error recalculating stock chain:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Remaining repair functions (previewStockChainRepairs, repairStockChain, repairAllStockChains)\r\n  // are complex and could be moved to server incrementally.\r\n  // For now, I've simplified the core history management.\r\n\r\n  return {\r\n    stockHistory,\r\n    isLoading,\r\n    createStockHistoryEntry,\r\n    deleteMultipleStockHistoryEntriesByReference,\r\n    recalculateStockChain,\r\n    refreshHistory: loadStockHistory\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3310, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/utils/searchUtils.ts"],"sourcesContent":["import { Product } from '@/types';\r\n\r\n/**\r\n * Checks if a search term (possibly containing multiple words in any order) matches a product.\r\n * Returns true if every word in the search term is found in at least one searchable field of the product.\r\n */\r\nexport const matchProductSearch = (product: Product, searchTerm: string): boolean => {\r\n    if (!searchTerm || !searchTerm.trim()) return true;\r\n\r\n    const words = searchTerm.toLowerCase().trim().split(/\\s+/);\r\n\r\n    const searchableText = [\r\n        String(product.name || ''),\r\n        String(product.description || ''),\r\n        String(product.category || ''),\r\n        String(product.supplier || ''),\r\n        String(product.itemNumber || ''),\r\n        String(product.barcode || ''),\r\n        String(product.manufacturerBarcode || '')\r\n    ].map(s => s.toLowerCase());\r\n\r\n    // Every word in the search must match at least one searchable field\r\n    return words.every(word =>\r\n        searchableText.some(field => field.includes(word))\r\n    );\r\n};\r\n"],"names":[],"mappings":";;;;AAMO,MAAM,qBAAqB,CAAC,SAAkB;IACjD,IAAI,CAAC,cAAc,CAAC,WAAW,IAAI,IAAI,OAAO;IAE9C,MAAM,QAAQ,WAAW,WAAW,GAAG,IAAI,GAAG,KAAK,CAAC;IAEpD,MAAM,iBAAiB;QACnB,OAAO,QAAQ,IAAI,IAAI;QACvB,OAAO,QAAQ,WAAW,IAAI;QAC9B,OAAO,QAAQ,QAAQ,IAAI;QAC3B,OAAO,QAAQ,QAAQ,IAAI;QAC3B,OAAO,QAAQ,UAAU,IAAI;QAC7B,OAAO,QAAQ,OAAO,IAAI;QAC1B,OAAO,QAAQ,mBAAmB,IAAI;KACzC,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,WAAW;IAExB,oEAAoE;IACpE,OAAO,MAAM,KAAK,CAAC,CAAA,OACf,eAAe,IAAI,CAAC,CAAA,QAAS,MAAM,QAAQ,CAAC;AAEpD"}},
    {"offset": {"line": 3336, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useProductFilters.ts"],"sourcesContent":["import { useState, useMemo, useEffect, useCallback } from 'react';\r\nimport { Product, ProductFilters } from '@/types';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { matchProductSearch } from '@/utils/searchUtils';\r\n\r\n/**\r\n * Hook for filtering products based on search, category, and stock status\r\n */\r\nexport const useProductFilters = (products: Product[]) => {\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const FILTER_STORAGE_KEY = useMemo(() =>\r\n    currentBusiness?.id ? `productFilters_${currentBusiness.id}` : 'productFilters'\r\n    , [currentBusiness?.id]);\r\n\r\n  // Load initial filters from localStorage or use defaults\r\n  const loadFiltersFromStorage = useCallback((): ProductFilters => {\r\n    try {\r\n      const stored = localStorage.getItem(FILTER_STORAGE_KEY);\r\n      if (stored) {\r\n        const parsed = JSON.parse(stored);\r\n        return {\r\n          search: parsed.search || '',\r\n          category: parsed.category || '',\r\n          stockStatus: parsed.stockStatus || 'all'\r\n        };\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to load filters from localStorage:', error);\r\n    }\r\n\r\n    return {\r\n      search: '',\r\n      category: '',\r\n      stockStatus: 'all'\r\n    };\r\n  }, [FILTER_STORAGE_KEY]);\r\n\r\n  const [filters, setFiltersState] = useState<ProductFilters>(loadFiltersFromStorage);\r\n\r\n  // Reload filters when business changes\r\n  useEffect(() => {\r\n    if (currentBusiness?.id) {\r\n      setFiltersState(loadFiltersFromStorage());\r\n    }\r\n  }, [currentBusiness?.id, loadFiltersFromStorage]);\r\n\r\n  // Save filters to localStorage whenever they change\r\n  useEffect(() => {\r\n    try {\r\n      localStorage.setItem(FILTER_STORAGE_KEY, JSON.stringify(filters));\r\n    } catch (error) {\r\n      console.error('Failed to save filters to localStorage:', error);\r\n    }\r\n  }, [filters, FILTER_STORAGE_KEY]);\r\n\r\n  // Wrapper function to update filters\r\n  const setFilters = (newFilters: ProductFilters) => {\r\n    setFiltersState(newFilters);\r\n  };\r\n\r\n  const applyFilters = (products: Product[], filters: ProductFilters): Product[] => {\r\n    return products.filter(product => {\r\n      // Search filter - now uses multi-word matching\r\n      if (filters.search) {\r\n        if (!matchProductSearch(product, filters.search)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Category filter\r\n      if (filters.category && filters.category !== product.category) {\r\n        return false;\r\n      }\r\n\r\n      // Stock status filter\r\n      if (filters.stockStatus !== 'all') {\r\n        if (filters.stockStatus === 'inStock' && product.quantity <= product.minimumStock) {\r\n          return false;\r\n        }\r\n        if (filters.stockStatus === 'lowStock' && (product.quantity === 0 || product.quantity > product.minimumStock)) {\r\n          return false;\r\n        }\r\n        if (filters.stockStatus === 'outOfStock' && product.quantity > 0) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    });\r\n  };\r\n\r\n  const filteredProducts = useMemo(() => {\r\n    return applyFilters(products, filters);\r\n  }, [products, filters]);\r\n\r\n  return {\r\n    filters,\r\n    setFilters,\r\n    filteredProducts,\r\n    applyFilters\r\n  };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;AAEA;AACA;;;;;AAKO,MAAM,oBAAoB,CAAC;;IAChC,MAAM,EAAE,eAAe,EAAE,GAAG,IAAA,qJAAW;IAEvC,MAAM,qBAAqB,IAAA,wKAAO;yDAAC,IACjC,iBAAiB,KAAK,CAAC,eAAe,EAAE,gBAAgB,EAAE,EAAE,GAAG;wDAC7D;QAAC,iBAAiB;KAAG;IAEzB,yDAAyD;IACzD,MAAM,yBAAyB,IAAA,4KAAW;iEAAC;YACzC,IAAI;gBACF,MAAM,SAAS,aAAa,OAAO,CAAC;gBACpC,IAAI,QAAQ;oBACV,MAAM,SAAS,KAAK,KAAK,CAAC;oBAC1B,OAAO;wBACL,QAAQ,OAAO,MAAM,IAAI;wBACzB,UAAU,OAAO,QAAQ,IAAI;wBAC7B,aAAa,OAAO,WAAW,IAAI;oBACrC;gBACF;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,6CAA6C;YAC7D;YAEA,OAAO;gBACL,QAAQ;gBACR,UAAU;gBACV,aAAa;YACf;QACF;gEAAG;QAAC;KAAmB;IAEvB,MAAM,CAAC,SAAS,gBAAgB,GAAG,IAAA,yKAAQ,EAAiB;IAE5D,uCAAuC;IACvC,IAAA,0KAAS;uCAAC;YACR,IAAI,iBAAiB,IAAI;gBACvB,gBAAgB;YAClB;QACF;sCAAG;QAAC,iBAAiB;QAAI;KAAuB;IAEhD,oDAAoD;IACpD,IAAA,0KAAS;uCAAC;YACR,IAAI;gBACF,aAAa,OAAO,CAAC,oBAAoB,KAAK,SAAS,CAAC;YAC1D,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,2CAA2C;YAC3D;QACF;sCAAG;QAAC;QAAS;KAAmB;IAEhC,qCAAqC;IACrC,MAAM,aAAa,CAAC;QAClB,gBAAgB;IAClB;IAEA,MAAM,eAAe,CAAC,UAAqB;QACzC,OAAO,SAAS,MAAM,CAAC,CAAA;YACrB,+CAA+C;YAC/C,IAAI,QAAQ,MAAM,EAAE;gBAClB,IAAI,CAAC,IAAA,oJAAkB,EAAC,SAAS,QAAQ,MAAM,GAAG;oBAChD,OAAO;gBACT;YACF;YAEA,kBAAkB;YAClB,IAAI,QAAQ,QAAQ,IAAI,QAAQ,QAAQ,KAAK,QAAQ,QAAQ,EAAE;gBAC7D,OAAO;YACT;YAEA,sBAAsB;YACtB,IAAI,QAAQ,WAAW,KAAK,OAAO;gBACjC,IAAI,QAAQ,WAAW,KAAK,aAAa,QAAQ,QAAQ,IAAI,QAAQ,YAAY,EAAE;oBACjF,OAAO;gBACT;gBACA,IAAI,QAAQ,WAAW,KAAK,cAAc,CAAC,QAAQ,QAAQ,KAAK,KAAK,QAAQ,QAAQ,GAAG,QAAQ,YAAY,GAAG;oBAC7G,OAAO;gBACT;gBACA,IAAI,QAAQ,WAAW,KAAK,gBAAgB,QAAQ,QAAQ,GAAG,GAAG;oBAChE,OAAO;gBACT;YACF;YAEA,OAAO;QACT;IACF;IAEA,MAAM,mBAAmB,IAAA,wKAAO;uDAAC;YAC/B,OAAO,aAAa,UAAU;QAChC;sDAAG;QAAC;QAAU;KAAQ;IAEtB,OAAO;QACL;QACA;QACA;QACA;IACF;AACF;GA9Fa;;QACiB,qJAAW"}},
    {"offset": {"line": 3463, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/utils/inventoryCacheUtils.ts"],"sourcesContent":["import { QueryClient } from \"@tanstack/react-query\";\r\n\r\n/**\r\n * Utility to clear inventory-related caches (both localStorage and React Query)\r\n * to ensure real-time data accuracy.\r\n */\r\nexport const clearInventoryCaches = (queryClient?: QueryClient) => {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    // 1. Clear LocalStorage (Legacy / Manual caches)\r\n    const keys = Object.keys(localStorage);\r\n    const patterns = [\r\n        'allProductsStats_',\r\n        'stockSummary_',\r\n        'soldItems_',\r\n        'dashboardData_',\r\n        'analyticsData_'\r\n    ];\r\n\r\n    let clearedCount = 0;\r\n    keys.forEach(key => {\r\n        if (patterns.some(pattern => key.startsWith(pattern))) {\r\n            localStorage.removeItem(key);\r\n            clearedCount++;\r\n        }\r\n    });\r\n\r\n    if (clearedCount > 0) {\r\n        console.log(`[Cache] Cleared ${clearedCount} inventory-related localStorage entries.`);\r\n    }\r\n\r\n    // 2. Invalidate React Query Keys (Modern State)\r\n    if (queryClient) {\r\n        console.log('[Cache] Invalidating React Query inventory keys...');\r\n        // Invalidate specific keys used in the inventory module\r\n        queryClient.invalidateQueries({ queryKey: ['inventory_global_stats'] });\r\n        queryClient.invalidateQueries({ queryKey: ['stockSummary'] });\r\n        queryClient.invalidateQueries({ queryKey: ['products'] });\r\n        queryClient.invalidateQueries({ queryKey: ['sales'] });\r\n        queryClient.invalidateQueries({ queryKey: ['all-products-for-scanner'] });\r\n        queryClient.invalidateQueries({ queryKey: ['all-products'] });\r\n    }\r\n};\r\n"],"names":[],"mappings":";;;;AAMO,MAAM,uBAAuB,CAAC;IACjC;;IAEA,iDAAiD;IACjD,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,MAAM,WAAW;QACb;QACA;QACA;QACA;QACA;KACH;IAED,IAAI,eAAe;IACnB,KAAK,OAAO,CAAC,CAAA;QACT,IAAI,SAAS,IAAI,CAAC,CAAA,UAAW,IAAI,UAAU,CAAC,WAAW;YACnD,aAAa,UAAU,CAAC;YACxB;QACJ;IACJ;IAEA,IAAI,eAAe,GAAG;QAClB,QAAQ,GAAG,CAAC,CAAC,gBAAgB,EAAE,aAAa,wCAAwC,CAAC;IACzF;IAEA,gDAAgD;IAChD,IAAI,aAAa;QACb,QAAQ,GAAG,CAAC;QACZ,wDAAwD;QACxD,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAyB;QAAC;QACrE,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAe;QAAC;QAC3D,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAW;QAAC;QACvD,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAQ;QAAC;QACpD,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAA2B;QAAC;QACvE,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAe;QAAC;IAC/D;AACJ"}},
    {"offset": {"line": 3532, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const updated = await db.product.update({\r\n      where: { id },\r\n      data: {\r\n        name: updates.name,\r\n        description: updates.description,\r\n        ...(updates.categoryId !== undefined && { categoryId: updates.categoryId }),\r\n        ...(updates.supplierId !== undefined && { supplierId: updates.supplierId }),\r\n        sku: updates.itemNumber || updates.sku,\r\n        barcode: updates.barcode,\r\n        image: updates.imageUrl,\r\n        costPrice: updates.costPrice,\r\n        sellingPrice: updates.sellingPrice,\r\n        stock: updates.quantity,\r\n        minStock: updates.minimumStock,\r\n      }\r\n    });\r\n\r\n    // revalidatePath('/inventory/products');\r\n\r\n    return updated;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qDAAA"}},
    {"offset": {"line": 3549, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const updated = await db.product.update({\r\n      where: { id },\r\n      data: {\r\n        name: updates.name,\r\n        description: updates.description,\r\n        ...(updates.categoryId !== undefined && { categoryId: updates.categoryId }),\r\n        ...(updates.supplierId !== undefined && { supplierId: updates.supplierId }),\r\n        sku: updates.itemNumber || updates.sku,\r\n        barcode: updates.barcode,\r\n        image: updates.imageUrl,\r\n        costPrice: updates.costPrice,\r\n        sellingPrice: updates.sellingPrice,\r\n        stock: updates.quantity,\r\n        minStock: updates.minimumStock,\r\n      }\r\n    });\r\n\r\n    // revalidatePath('/inventory/products');\r\n\r\n    return updated;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgJsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 3566, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const updated = await db.product.update({\r\n      where: { id },\r\n      data: {\r\n        name: updates.name,\r\n        description: updates.description,\r\n        ...(updates.categoryId !== undefined && { categoryId: updates.categoryId }),\r\n        ...(updates.supplierId !== undefined && { supplierId: updates.supplierId }),\r\n        sku: updates.itemNumber || updates.sku,\r\n        barcode: updates.barcode,\r\n        image: updates.imageUrl,\r\n        costPrice: updates.costPrice,\r\n        sellingPrice: updates.sellingPrice,\r\n        stock: updates.quantity,\r\n        minStock: updates.minimumStock,\r\n      }\r\n    });\r\n\r\n    // revalidatePath('/inventory/products');\r\n\r\n    return updated;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA+NsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 3583, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const updated = await db.product.update({\r\n      where: { id },\r\n      data: {\r\n        name: updates.name,\r\n        description: updates.description,\r\n        ...(updates.categoryId !== undefined && { categoryId: updates.categoryId }),\r\n        ...(updates.supplierId !== undefined && { supplierId: updates.supplierId }),\r\n        sku: updates.itemNumber || updates.sku,\r\n        barcode: updates.barcode,\r\n        image: updates.imageUrl,\r\n        costPrice: updates.costPrice,\r\n        sellingPrice: updates.sellingPrice,\r\n        stock: updates.quantity,\r\n        minStock: updates.minimumStock,\r\n      }\r\n    });\r\n\r\n    // revalidatePath('/inventory/products');\r\n\r\n    return updated;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA2PsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 3600, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const updated = await db.product.update({\r\n      where: { id },\r\n      data: {\r\n        name: updates.name,\r\n        description: updates.description,\r\n        ...(updates.categoryId !== undefined && { categoryId: updates.categoryId }),\r\n        ...(updates.supplierId !== undefined && { supplierId: updates.supplierId }),\r\n        sku: updates.itemNumber || updates.sku,\r\n        barcode: updates.barcode,\r\n        image: updates.imageUrl,\r\n        costPrice: updates.costPrice,\r\n        sellingPrice: updates.sellingPrice,\r\n        stock: updates.quantity,\r\n        minStock: updates.minimumStock,\r\n      }\r\n    });\r\n\r\n    // revalidatePath('/inventory/products');\r\n\r\n    return updated;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAwQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 3617, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useProducts.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useMemo } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct, ProductFilters } from '@/types';\r\nimport { useBusinessSettings } from './useBusinessSettings';\r\nimport { useStockHistory } from './useStockHistory';\r\nimport { useProductFilters } from './useProductFilters';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { clearInventoryCaches } from '@/utils/inventoryCacheUtils';\r\n\r\n// Import our new Server Actions\r\nimport { getProductsAction, createProductAction, updateProductAction, deleteProductAction, updateProductsBulkAction } from '@/app/actions/products';\r\n\r\nexport const useProducts = (userId: string | undefined, initialPageSize: number = 50) => {\r\n  const [products, setProducts] = useState<Product[]>([]);\r\n  const [page, setPage] = useState(1);\r\n  const [pageSize, setPageSize] = useState(initialPageSize);\r\n  const [totalCount, setTotalCount] = useState(0);\r\n  const [isTyping, setIsTyping] = useState(false);\r\n  const { settings } = useBusinessSettings();\r\n  const { createStockHistoryEntry } = useStockHistory(userId);\r\n  const { currentBusiness } = useBusiness();\r\n  const queryClient = useQueryClient();\r\n\r\n  const { filters, setFilters, filteredProducts } = useProductFilters(products);\r\n  const [typingTimer, setTypingTimer] = useState<NodeJS.Timeout | null>(null);\r\n\r\n  const setFiltersWithTypingState = useCallback((newFilters: ProductFilters) => {\r\n    if (newFilters.search !== filters.search) {\r\n      setIsTyping(true);\r\n      if (typingTimer) clearTimeout(typingTimer);\r\n      const timer = setTimeout(() => {\r\n        setIsTyping(false);\r\n      }, 600);\r\n      setTypingTimer(timer);\r\n    }\r\n    setFilters(newFilters);\r\n  }, [filters.search, typingTimer, setFilters]);\r\n\r\n  // Use Server Action instead of Supabase\r\n  const loadProducts = useCallback(async (): Promise<{ products: Product[], count: number }> => {\r\n    if (!userId || !currentBusiness) {\r\n      return { products: [], count: 0 };\r\n    }\r\n\r\n    try {\r\n      // Server Action call\r\n      const result = await getProductsAction({\r\n        userId,\r\n        businessId: currentBusiness.id,\r\n        page,\r\n        pageSize,\r\n        search: filters.search,\r\n        category: filters.category,\r\n        stockStatus: filters.stockStatus,\r\n      });\r\n      return result;\r\n    } catch (error) {\r\n      console.error('Error loading products from server action:', error);\r\n      return { products: [], count: 0 };\r\n    }\r\n  }, [userId, currentBusiness?.id, page, pageSize, filters.search, filters.category, filters.stockStatus]);\r\n\r\n  const baseQueryKey = useMemo(() => ['products', userId, currentBusiness?.id], [userId, currentBusiness?.id]);\r\n  const queryKey = useMemo(() => [...baseQueryKey, page, pageSize, filters.search, filters.category, filters.stockStatus], [baseQueryKey, page, pageSize, filters.search, filters.category, filters.stockStatus]);\r\n\r\n  const { data: queriedData, isLoading: isQueryLoading, isFetching, refetch } = useQuery({\r\n    queryKey,\r\n    queryFn: loadProducts,\r\n    enabled: !!userId && !!currentBusiness?.id,\r\n    staleTime: 30_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: true,\r\n    refetchOnReconnect: true,\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (queriedData) {\r\n      setProducts(queriedData.products);\r\n      setTotalCount(queriedData.count);\r\n    }\r\n  }, [queriedData]);\r\n\r\n  const isLoading = (isQueryLoading && !queriedData) && !isTyping;\r\n\r\n  // Supabase Storage remains untouched since Prisma doesn't do file storage\r\n  const uploadProductImage = async (imageFile: File): Promise<string | null> => {\r\n    try {\r\n      if (!userId) return null;\r\n      const fileExt = imageFile.name.split('.').pop();\r\n      const fileName = `${Date.now()}.${fileExt}`;\r\n      const filePath = `${userId}/${fileName}`;\r\n\r\n      const { error: uploadError } = await supabase.storage\r\n        .from('product-images')\r\n        .upload(filePath, imageFile, { upsert: true });\r\n\r\n      if (uploadError) {\r\n        console.error('Error uploading image:', uploadError);\r\n        return null;\r\n      }\r\n\r\n      const { data: { publicUrl } } = supabase.storage\r\n        .from('product-images')\r\n        .getPublicUrl(filePath);\r\n\r\n      return publicUrl;\r\n    } catch (error) {\r\n      console.error('Error in uploadProductImage:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const createProduct = async (productData: ProductFormData): Promise<Product | null> => {\r\n    try {\r\n      if (!userId || !currentBusiness) return null;\r\n\r\n      // Assuming createProductAction exists and is fully implemented:\r\n      const newProduct = await createProductAction({\r\n        ...productData,\r\n        userId,\r\n        businessId: currentBusiness.id\r\n      });\r\n\r\n      if (!newProduct) return null;\r\n\r\n      if (newProduct.quantity > 0) {\r\n        await createStockHistoryEntry(\r\n          newProduct.id,\r\n          0,\r\n          newProduct.quantity,\r\n          'Initial stock',\r\n          undefined,\r\n          productData.createdAt,\r\n          undefined,\r\n          newProduct.name\r\n        );\r\n      }\r\n\r\n      setProducts(prev => [newProduct, ...prev]);\r\n      setTotalCount(c => c + 1);\r\n\r\n      queryClient.setQueryData(queryKey, (oldData: any) => {\r\n        if (!oldData) return { products: [newProduct], count: 1 };\r\n        return {\r\n          products: [newProduct, ...oldData.products],\r\n          count: (oldData.count || 0) + 1\r\n        };\r\n      });\r\n\r\n      clearInventoryCaches(queryClient);\r\n\r\n      return newProduct;\r\n    } catch (error) {\r\n      console.error('Error creating product:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updateProduct = async (\r\n    id: string,\r\n    updates: Partial<Product>,\r\n    imageFile?: File | null,\r\n    isFromSale = false,\r\n    customChangeReason?: string,\r\n    adjustmentDate?: Date,\r\n    referenceId?: string,\r\n    receiptNumber?: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      if (!userId) return false;\r\n\r\n      let currentProduct = products.find(p => p.id === id);\r\n      if (!currentProduct) return false;\r\n\r\n      let imageUrl = updates.imageUrl;\r\n      if (imageFile) {\r\n        imageUrl = await uploadProductImage(imageFile);\r\n      }\r\n\r\n      const updatedData = { ...updates, imageUrl, barcode: updates.barcode !== undefined ? updates.barcode : currentProduct.barcode };\r\n\r\n      // We will create the update updateProductAction next\r\n      await updateProductAction(id, { ...updatedData, userId, businessId: currentBusiness?.id });\r\n\r\n      setProducts(prev => prev.map(p => p.id === id ? { ...p, ...updatedData } : p));\r\n      queryClient.setQueryData(queryKey, (oldData: any) => {\r\n        if (!oldData) return oldData;\r\n        return {\r\n          ...oldData,\r\n          products: oldData.products.map((p: Product) =>\r\n            p.id === id ? { ...p, ...updatedData } : p\r\n          )\r\n        };\r\n      });\r\n\r\n      if (updates.quantity !== undefined && updates.quantity !== currentProduct.quantity && customChangeReason !== 'skip-history') {\r\n        let changeReason = customChangeReason || (isFromSale ? 'Sale' : (updates.quantity > currentProduct.quantity ? 'Manual stock addition' : 'Manual stock reduction'));\r\n        await createStockHistoryEntry(\r\n          id,\r\n          currentProduct.quantity,\r\n          updates.quantity,\r\n          changeReason,\r\n          referenceId,\r\n          adjustmentDate,\r\n          receiptNumber,\r\n          currentProduct.name\r\n        );\r\n      }\r\n\r\n      queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n      clearInventoryCaches(queryClient);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating product:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteProduct = async (id: string): Promise<boolean> => {\r\n    try {\r\n      if (!userId) return false;\r\n\r\n      await deleteProductAction(id);\r\n\r\n      setProducts(prev => prev.filter(p => p.id !== id));\r\n      queryClient.setQueryData(queryKey, (old: any) => {\r\n        if (!old) return old;\r\n        const { products: oldProducts, count } = old;\r\n        const newProducts = (oldProducts as Product[]).filter(p => p.id !== id);\r\n        return { products: newProducts, count: Math.max(0, (count || 0) - 1) };\r\n      });\r\n\r\n      queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n      clearInventoryCaches(queryClient);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting product:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    // In Prisma, we either use WebSockets, polling, or React Query's built-in focus/refetch handlers\r\n    // Disabled Supabase Realtime Channels since we moved off the raw Supabase client for data fetches\r\n  }, [userId, currentBusiness?.id, baseQueryKey]);\r\n\r\n  const updateProductsBulk = async (\r\n    updates: Array<{ id: string; updated: Partial<Product>; imageFile?: File | null }>,\r\n    userIdForHistory?: string,\r\n    changeReason?: string,\r\n    referenceId?: string,\r\n    adjustmentDate?: Date,\r\n    receiptNumber?: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      // Basic implementation without handling independent image uploads for bulk right now\r\n      const success = await updateProductsBulkAction(\r\n        updates.map(u => ({ id: u.id, updated: u.updated })),\r\n        currentBusiness.id\r\n      );\r\n\r\n      if (success) {\r\n        // Optimistically update UI\r\n        setProducts(prev => {\r\n          const updatedMap = new Map(updates.map(u => [u.id, u.updated]));\r\n          return prev.map(p => {\r\n            const updatedItem = updatedMap.get(p.id);\r\n            return updatedItem ? { ...p, ...updatedItem } as Product : p;\r\n          });\r\n        });\r\n\r\n        // Add history for quantity changes\r\n        for (const update of updates) {\r\n          const currentProduct = products.find(p => p.id === update.id);\r\n          if (currentProduct && update.updated.quantity !== undefined && update.updated.quantity !== currentProduct.quantity) {\r\n            await createStockHistoryEntry(\r\n              update.id,\r\n              currentProduct.quantity,\r\n              update.updated.quantity,\r\n              changeReason || 'Bulk update',\r\n              referenceId,\r\n              adjustmentDate,\r\n              receiptNumber,\r\n              currentProduct.name\r\n            );\r\n          }\r\n        }\r\n\r\n        queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n        clearInventoryCaches(queryClient);\r\n      }\r\n\r\n      return success;\r\n    } catch (error) {\r\n      console.error('Error in bulk update:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  return {\r\n    products,\r\n    isLoading,\r\n    loadProducts,\r\n    page,\r\n    setPage,\r\n    pageSize,\r\n    setPageSize,\r\n    totalCount,\r\n    createProduct,\r\n    updateProduct,\r\n    updateProductsBulk,\r\n    deleteProduct,\r\n    uploadProductImage,\r\n    refetch,\r\n    isFetching,\r\n    filters,\r\n    setFilters: setFiltersWithTypingState,\r\n    filteredProducts\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3985, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const updated = await db.product.update({\r\n      where: { id },\r\n      data: {\r\n        name: updates.name,\r\n        description: updates.description,\r\n        ...(updates.categoryId !== undefined && { categoryId: updates.categoryId }),\r\n        ...(updates.supplierId !== undefined && { supplierId: updates.supplierId }),\r\n        sku: updates.itemNumber || updates.sku,\r\n        barcode: updates.barcode,\r\n        image: updates.imageUrl,\r\n        costPrice: updates.costPrice,\r\n        sellingPrice: updates.sellingPrice,\r\n        stock: updates.quantity,\r\n        minStock: updates.minimumStock,\r\n      }\r\n    });\r\n\r\n    // revalidatePath('/inventory/products');\r\n\r\n    return updated;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0GsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,0DAAA"}},
    {"offset": {"line": 4002, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useInventoryActions.ts"],"sourcesContent":["import { useProducts } from './useProducts';\r\nimport { SaleItem, Product } from '@/types';\r\nimport { toast } from 'sonner';\r\nimport { getProductsByIdsAction } from '@/app/actions/products';\r\n\r\nexport const useInventoryActions = (userId: string | undefined) => {\r\n    const { updateProductsBulk } = useProducts(userId);\r\n\r\n    /**\r\n     * Helper to fetch fresh product data from DB to avoid race conditions/stale data\r\n     */\r\n    const fetchFreshProducts = async (productIds: string[], locationId?: string) => {\r\n        if (!productIds.length) return [];\r\n\r\n        try {\r\n            const result = await getProductsByIdsAction(productIds, locationId);\r\n            return result as Product[];\r\n        } catch (error) {\r\n            console.error('Error fetching fresh products:', error);\r\n            throw error;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Deduct stock for a new sale\r\n     */\r\n    const deductStockForSale = async (\r\n        items: SaleItem[],\r\n        saleId?: string,\r\n        saleDate?: Date,\r\n        receiptNumber?: string,\r\n        locationId?: string\r\n    ): Promise<boolean> => {\r\n        if (!userId) return false;\r\n\r\n        try {\r\n            const itemsWithProductIds = items.filter(item => item.productId);\r\n            if (itemsWithProductIds.length === 0) return true;\r\n\r\n            const uniqueIds = [...new Set(itemsWithProductIds.map(item => item.productId!))];\r\n            const freshProducts = await fetchFreshProducts(uniqueIds, locationId);\r\n\r\n            if (freshProducts.length === 0) return false;\r\n\r\n            // Calculate total quantity to deduct per product\r\n            const quantityChanges = new Map<string, number>();\r\n            for (const item of itemsWithProductIds) {\r\n                const existing = quantityChanges.get(item.productId!) || 0;\r\n                quantityChanges.set(item.productId!, existing + item.quantity);\r\n            }\r\n\r\n            const bulkUpdates = [];\r\n            for (const [productId, quantityToDeduct] of quantityChanges.entries()) {\r\n                const product = freshProducts.find(p => p.id === productId);\r\n                if (!product) continue;\r\n\r\n                const newQuantity = product.quantity - quantityToDeduct;\r\n\r\n                bulkUpdates.push({\r\n                    id: productId,\r\n                    updated: { ...product, quantity: newQuantity }\r\n                });\r\n\r\n                if (newQuantity < 0) {\r\n                    toast.warning(`${product.name} inventory is now negative (${newQuantity}). Please restock soon.`);\r\n                }\r\n            }\r\n\r\n            if (bulkUpdates.length > 0) {\r\n                await updateProductsBulk(bulkUpdates, userId, 'Sale', saleId, saleDate, receiptNumber);\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error deducting stock for sale:', error);\r\n            return false;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Restore stock (e.g. when deleting a sale)\r\n     */\r\n    const restoreStockForSale = async (\r\n        items: SaleItem[],\r\n        saleId?: string, // Reference ID for history\r\n        receiptNumber?: string, // Reference receipt number\r\n        locationId?: string\r\n    ): Promise<boolean> => {\r\n        if (!userId) return false;\r\n\r\n        try {\r\n            const itemsWithProductIds = items.filter(item => item.productId);\r\n            if (itemsWithProductIds.length === 0) return true;\r\n\r\n            const uniqueIds = [...new Set(itemsWithProductIds.map(item => item.productId!))];\r\n            const freshProducts = await fetchFreshProducts(uniqueIds, locationId);\r\n\r\n            // Calculate total quantity to restore\r\n            const quantityChanges = new Map<string, number>();\r\n            for (const item of itemsWithProductIds) {\r\n                const existing = quantityChanges.get(item.productId!) || 0;\r\n                quantityChanges.set(item.productId!, existing + item.quantity);\r\n            }\r\n\r\n            const bulkUpdates = [];\r\n            for (const [productId, quantityToRestore] of quantityChanges.entries()) {\r\n                const product = freshProducts.find(p => p.id === productId);\r\n                if (!product) continue;\r\n\r\n                const newQuantity = product.quantity + quantityToRestore;\r\n\r\n                bulkUpdates.push({\r\n                    id: productId,\r\n                    updated: { ...product, quantity: newQuantity }\r\n                });\r\n            }\r\n\r\n            if (bulkUpdates.length > 0) {\r\n                await updateProductsBulk(bulkUpdates, userId, 'Deleted Sale', saleId, undefined, receiptNumber);\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error restoring stock for sale:', error);\r\n            return false;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Adjust stock for an edited sale (Handle both adding and removing items)\r\n     */\r\n    const adjustStockForEditedSale = async (\r\n        originalItems: SaleItem[],\r\n        newItems: SaleItem[],\r\n        saleId?: string,\r\n        saleDate?: Date,\r\n        receiptNumber?: string,\r\n        locationId?: string\r\n    ): Promise<boolean> => {\r\n        if (!userId) return false;\r\n\r\n        try {\r\n            const allProductIds = [\r\n                ...originalItems.filter(i => i.productId).map(i => i.productId!),\r\n                ...newItems.filter(i => i.productId).map(i => i.productId!)\r\n            ];\r\n            const uniqueIds = [...new Set(allProductIds)];\r\n            if (uniqueIds.length === 0) return true;\r\n\r\n            const freshProducts = await fetchFreshProducts(uniqueIds, locationId);\r\n\r\n            const productNetChanges = new Map<string, number>();\r\n\r\n            // 1. Restore original items (add back to stock)\r\n            for (const item of originalItems.filter(i => i.productId)) {\r\n                const current = productNetChanges.get(item.productId!) || 0;\r\n                productNetChanges.set(item.productId!, current + item.quantity);\r\n            }\r\n\r\n            // 2. Deduct new items (remove from stock)\r\n            for (const item of newItems.filter(i => i.productId)) {\r\n                const current = productNetChanges.get(item.productId!) || 0;\r\n                productNetChanges.set(item.productId!, current - item.quantity);\r\n            }\r\n\r\n            const bulkUpdates = [];\r\n            for (const [productId, netChange] of productNetChanges.entries()) {\r\n                if (netChange === 0) continue;\r\n\r\n                const product = freshProducts.find(p => p.id === productId);\r\n                if (!product) continue;\r\n\r\n                const newQuantity = product.quantity + netChange;\r\n\r\n                bulkUpdates.push({\r\n                    id: productId,\r\n                    updated: { ...product, quantity: newQuantity }\r\n                });\r\n\r\n                if (newQuantity < 0) {\r\n                    toast.warning(`${product.name} inventory is now negative (${newQuantity}). Please restock soon.`);\r\n                }\r\n            }\r\n\r\n            if (bulkUpdates.length > 0) {\r\n                await updateProductsBulk(bulkUpdates, userId, 'Sale Status/Qty Edit', saleId, saleDate, receiptNumber);\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error adjusting stock for edited sale:', error);\r\n            return false;\r\n        }\r\n    };\r\n\r\n    return {\r\n        deductStockForSale,\r\n        restoreStockForSale,\r\n        adjustStockForEditedSale\r\n    };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4179, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/sales.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getSalesAction(businessId: string, sortOrder: 'asc' | 'desc' = 'desc', pageSize?: number) {\r\n    try {\r\n        const queryOptions: any = {\r\n            where: {\r\n                branchId: businessId,\r\n            },\r\n            orderBy: {\r\n                createdAt: sortOrder,\r\n            },\r\n            include: {\r\n                cashTransaction: true,\r\n            }\r\n        };\r\n\r\n        if (pageSize && pageSize > 0) {\r\n            queryOptions.take = pageSize;\r\n        }\r\n\r\n        const sales = await db.sale.findMany(queryOptions);\r\n\r\n        // Provide default mappings to existing React components\r\n        return sales.map((item: any) => ({\r\n            id: item.id,\r\n            user_id: item.userId,\r\n            location_id: item.branchId,\r\n            receipt_number: item.receiptNumber,\r\n            customer_name: item.customerName,\r\n            customer_address: item.customerAddress,\r\n            customer_contact: item.customerContact,\r\n            customer_id: item.customerId,\r\n            items: item.items as any, // jsonb type\r\n            payment_status: item.paymentStatus,\r\n            profit: item.profit,\r\n            date: item.date.toISOString(),\r\n            tax_rate: item.taxRate ? Number(item.taxRate) : 0,\r\n            created_at: item.createdAt.toISOString(),\r\n            updated_at: item.updatedAt.toISOString(),\r\n            cash_transaction_id: item.cashTransactionId,\r\n            amount_paid: item.amountPaid,\r\n            amount_due: item.amountDue,\r\n            category_id: item.categoryId,\r\n            notes: item.notes\r\n        }));\r\n    } catch (error) {\r\n        console.error('Error fetching sales:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function deleteSaleAction(id: string, businessId: string) {\r\n    try {\r\n        const sale = await db.sale.findUnique({\r\n            where: { id },\r\n            include: { cashTransaction: true, installments: true }\r\n        });\r\n\r\n        if (!sale || sale.branchId !== businessId) {\r\n            return { success: false, error: 'Sale not found or unauthorized' };\r\n        }\r\n\r\n        // Delete installments\r\n        if (sale.installments && sale.installments.length > 0) {\r\n            await db.installmentPayment.deleteMany({\r\n                where: { saleId: id }\r\n            });\r\n        }\r\n\r\n        // Delete associated cash transaction\r\n        if (sale.cashTransactionId) {\r\n            await db.cashTransaction.delete({\r\n                where: { id: sale.cashTransactionId }\r\n            });\r\n        }\r\n\r\n        // Delete the sale itself\r\n        await db.sale.delete({\r\n            where: { id }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            sale: {\r\n                receiptNumber: sale.receiptNumber,\r\n                customerName: sale.customerName,\r\n                customerAddress: sale.customerAddress,\r\n                customerContact: sale.customerContact,\r\n                paymentStatus: sale.paymentStatus,\r\n                cashTransactionId: sale.cashTransactionId,\r\n                items: sale.items as any,\r\n                amountPaid: sale.amountPaid,\r\n                amountDue: sale.amountDue,\r\n                profit: sale.profit,\r\n                taxRate: sale.taxRate,\r\n                notes: sale.notes\r\n            }\r\n        };\r\n    } catch (error) {\r\n        console.error('Error deleting sale:', error);\r\n        return { success: false, error: 'Failed to delete sale' };\r\n    }\r\n}\r\n\r\nexport async function upsertSaleAction(saleDbData: any, isUpdate: boolean, updateId?: string) {\r\n    try {\r\n        const prismaData = {\r\n            userId: saleDbData.user_id,\r\n            branchId: saleDbData.location_id,\r\n            receiptNumber: saleDbData.receipt_number,\r\n            customerName: saleDbData.customer_name,\r\n            customerAddress: saleDbData.customer_address,\r\n            customerContact: saleDbData.customer_contact,\r\n            customerId: saleDbData.customer_id,\r\n            items: saleDbData.items,\r\n            paymentStatus: saleDbData.payment_status,\r\n            profit: saleDbData.profit,\r\n            date: new Date(saleDbData.date),\r\n            taxRate: saleDbData.tax_rate,\r\n            cashTransactionId: saleDbData.cash_transaction_id,\r\n            amountPaid: saleDbData.amount_paid,\r\n            amountDue: saleDbData.amount_due,\r\n            categoryId: saleDbData.category_id,\r\n            notes: saleDbData.notes\r\n        };\r\n\r\n        if (isUpdate && updateId) {\r\n            const updated = await db.sale.update({\r\n                where: { id: updateId },\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: updated };\r\n        } else {\r\n            const created = await db.sale.create({\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: created };\r\n        }\r\n    } catch (error: any) {\r\n        console.error('Error upserting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to preserve sale' };\r\n    }\r\n}\r\n\r\nexport async function createReceiptAction(saleData: any, businessId: string, userId: string) {\r\n    try {\r\n        const created = await db.sale.create({\r\n            data: {\r\n                userId: userId,\r\n                branchId: businessId,\r\n                receiptNumber: saleData.receiptNumber,\r\n                customerName: saleData.customerName,\r\n                customerId: saleData.customerId,\r\n                date: new Date(saleData.date),\r\n                items: saleData.items,\r\n                paymentStatus: saleData.paymentStatus,\r\n                profit: saleData.profit,\r\n                amountPaid: saleData.amountPaid,\r\n                amountDue: saleData.amountDue,\r\n                cashAccountId: saleData.cashAccountId,\r\n                notes: saleData.notes\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        revalidatePath('/customers');\r\n\r\n        return { success: true, data: created };\r\n    } catch (error: any) {\r\n        console.error('Error creating receipt:', error);\r\n        return { success: false, error: error.message || 'Failed to create receipt' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,kDAAA"}},
    {"offset": {"line": 4196, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/sales.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getSalesAction(businessId: string, sortOrder: 'asc' | 'desc' = 'desc', pageSize?: number) {\r\n    try {\r\n        const queryOptions: any = {\r\n            where: {\r\n                branchId: businessId,\r\n            },\r\n            orderBy: {\r\n                createdAt: sortOrder,\r\n            },\r\n            include: {\r\n                cashTransaction: true,\r\n            }\r\n        };\r\n\r\n        if (pageSize && pageSize > 0) {\r\n            queryOptions.take = pageSize;\r\n        }\r\n\r\n        const sales = await db.sale.findMany(queryOptions);\r\n\r\n        // Provide default mappings to existing React components\r\n        return sales.map((item: any) => ({\r\n            id: item.id,\r\n            user_id: item.userId,\r\n            location_id: item.branchId,\r\n            receipt_number: item.receiptNumber,\r\n            customer_name: item.customerName,\r\n            customer_address: item.customerAddress,\r\n            customer_contact: item.customerContact,\r\n            customer_id: item.customerId,\r\n            items: item.items as any, // jsonb type\r\n            payment_status: item.paymentStatus,\r\n            profit: item.profit,\r\n            date: item.date.toISOString(),\r\n            tax_rate: item.taxRate ? Number(item.taxRate) : 0,\r\n            created_at: item.createdAt.toISOString(),\r\n            updated_at: item.updatedAt.toISOString(),\r\n            cash_transaction_id: item.cashTransactionId,\r\n            amount_paid: item.amountPaid,\r\n            amount_due: item.amountDue,\r\n            category_id: item.categoryId,\r\n            notes: item.notes\r\n        }));\r\n    } catch (error) {\r\n        console.error('Error fetching sales:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function deleteSaleAction(id: string, businessId: string) {\r\n    try {\r\n        const sale = await db.sale.findUnique({\r\n            where: { id },\r\n            include: { cashTransaction: true, installments: true }\r\n        });\r\n\r\n        if (!sale || sale.branchId !== businessId) {\r\n            return { success: false, error: 'Sale not found or unauthorized' };\r\n        }\r\n\r\n        // Delete installments\r\n        if (sale.installments && sale.installments.length > 0) {\r\n            await db.installmentPayment.deleteMany({\r\n                where: { saleId: id }\r\n            });\r\n        }\r\n\r\n        // Delete associated cash transaction\r\n        if (sale.cashTransactionId) {\r\n            await db.cashTransaction.delete({\r\n                where: { id: sale.cashTransactionId }\r\n            });\r\n        }\r\n\r\n        // Delete the sale itself\r\n        await db.sale.delete({\r\n            where: { id }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            sale: {\r\n                receiptNumber: sale.receiptNumber,\r\n                customerName: sale.customerName,\r\n                customerAddress: sale.customerAddress,\r\n                customerContact: sale.customerContact,\r\n                paymentStatus: sale.paymentStatus,\r\n                cashTransactionId: sale.cashTransactionId,\r\n                items: sale.items as any,\r\n                amountPaid: sale.amountPaid,\r\n                amountDue: sale.amountDue,\r\n                profit: sale.profit,\r\n                taxRate: sale.taxRate,\r\n                notes: sale.notes\r\n            }\r\n        };\r\n    } catch (error) {\r\n        console.error('Error deleting sale:', error);\r\n        return { success: false, error: 'Failed to delete sale' };\r\n    }\r\n}\r\n\r\nexport async function upsertSaleAction(saleDbData: any, isUpdate: boolean, updateId?: string) {\r\n    try {\r\n        const prismaData = {\r\n            userId: saleDbData.user_id,\r\n            branchId: saleDbData.location_id,\r\n            receiptNumber: saleDbData.receipt_number,\r\n            customerName: saleDbData.customer_name,\r\n            customerAddress: saleDbData.customer_address,\r\n            customerContact: saleDbData.customer_contact,\r\n            customerId: saleDbData.customer_id,\r\n            items: saleDbData.items,\r\n            paymentStatus: saleDbData.payment_status,\r\n            profit: saleDbData.profit,\r\n            date: new Date(saleDbData.date),\r\n            taxRate: saleDbData.tax_rate,\r\n            cashTransactionId: saleDbData.cash_transaction_id,\r\n            amountPaid: saleDbData.amount_paid,\r\n            amountDue: saleDbData.amount_due,\r\n            categoryId: saleDbData.category_id,\r\n            notes: saleDbData.notes\r\n        };\r\n\r\n        if (isUpdate && updateId) {\r\n            const updated = await db.sale.update({\r\n                where: { id: updateId },\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: updated };\r\n        } else {\r\n            const created = await db.sale.create({\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: created };\r\n        }\r\n    } catch (error: any) {\r\n        console.error('Error upserting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to preserve sale' };\r\n    }\r\n}\r\n\r\nexport async function createReceiptAction(saleData: any, businessId: string, userId: string) {\r\n    try {\r\n        const created = await db.sale.create({\r\n            data: {\r\n                userId: userId,\r\n                branchId: businessId,\r\n                receiptNumber: saleData.receiptNumber,\r\n                customerName: saleData.customerName,\r\n                customerId: saleData.customerId,\r\n                date: new Date(saleData.date),\r\n                items: saleData.items,\r\n                paymentStatus: saleData.paymentStatus,\r\n                profit: saleData.profit,\r\n                amountPaid: saleData.amountPaid,\r\n                amountDue: saleData.amountDue,\r\n                cashAccountId: saleData.cashAccountId,\r\n                notes: saleData.notes\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        revalidatePath('/customers');\r\n\r\n        return { success: true, data: created };\r\n    } catch (error: any) {\r\n        console.error('Error creating receipt:', error);\r\n        return { success: false, error: error.message || 'Failed to create receipt' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsDsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,oDAAA"}},
    {"offset": {"line": 4213, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useSalesData.ts"],"sourcesContent":["import { useState, useEffect, useMemo, useCallback } from 'react';\r\nimport { Sale, DbSale, mapDbSaleToSale } from '@/types';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { useActivityLogger } from '@/hooks/useActivityLogger';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useProducts } from '@/hooks/useProducts';\r\nimport { useInventoryActions } from '@/hooks/useInventoryActions';\r\nimport { clearInventoryCaches } from '@/utils/inventoryCacheUtils';\r\nimport { getSalesAction, deleteSaleAction } from '@/app/actions/sales';\r\n\r\nexport interface TopCustomer {\r\n  id?: string;\r\n  name: string;\r\n  totalPurchases: number;\r\n  orderCount: number;\r\n}\r\n\r\nexport const useSalesData = (userId: string | undefined, sortOrder: string = 'desc', pageSize?: number) => {\r\n\r\n  const queryClient = useQueryClient();\r\n  const { toast } = useToast();\r\n  const { logActivity } = useActivityLogger();\r\n  const { currentBusiness } = useBusiness();\r\n  const { restoreStockForSale } = useInventoryActions(userId);\r\n\r\n  const loadSales = useCallback(async (): Promise<Sale[]> => {\r\n    try {\r\n      if (!userId || !currentBusiness) {\r\n        return [];\r\n      }\r\n\r\n      // If pageSize is specified, load only that many records\r\n      const salesData = await getSalesAction(currentBusiness.id, sortOrder as any, pageSize);\r\n\r\n      const formattedSales: Sale[] = salesData ? salesData.map((item: any) => {\r\n        const dbSale: DbSale = {\r\n          id: item.id,\r\n          user_id: item.user_id,\r\n          location_id: item.location_id,\r\n          receipt_number: item.receipt_number,\r\n          customer_name: item.customer_name,\r\n          customer_address: item.customer_address,\r\n          customer_contact: item.customer_contact,\r\n          customer_id: item.customer_id,\r\n          items: item.items as any,\r\n          payment_status: item.payment_status,\r\n          profit: item.profit ? Number(item.profit) : 0,\r\n          date: item.date,\r\n          tax_rate: item.tax_rate || 0,\r\n          created_at: item.created_at,\r\n          updated_at: item.updated_at,\r\n          cash_transaction_id: item.cash_transaction_id,\r\n          amount_paid: item.amount_paid ? Number(item.amount_paid) : undefined,\r\n          amount_due: item.amount_due ? Number(item.amount_due) : undefined,\r\n          category_id: item.category_id,\r\n          notes: item.notes\r\n        };\r\n        return mapDbSaleToSale(dbSale);\r\n      }) : [];\r\n\r\n      return formattedSales;\r\n\r\n    } catch (error) {\r\n      console.error('Error loading sales:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load sales data. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return [];\r\n    }\r\n  }, [userId, currentBusiness?.id, sortOrder, pageSize, toast]);\r\n\r\n  // React Query caching with persistent storage for improved performance\r\n  const baseQueryKey = useMemo(() => ['sales', currentBusiness?.id, userId], [currentBusiness?.id, userId]);\r\n  const queryKey = useMemo(() => [...baseQueryKey, sortOrder, pageSize], [baseQueryKey, sortOrder, pageSize]);\r\n\r\n  const {\r\n    data: sales = [],\r\n    isLoading: isQueryLoading,\r\n    isFetching,\r\n    refetch\r\n  } = useQuery({\r\n    queryKey,\r\n    queryFn: loadSales,\r\n    enabled: !!userId && !!currentBusiness?.id,\r\n    staleTime: 30_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: true,\r\n    refetchOnReconnect: true,\r\n  });\r\n\r\n  // Derived loading state\r\n  const isLoading = isQueryLoading || (isFetching && sales.length === 0);\r\n\r\n  const getTopCustomers = useMemo((): TopCustomer[] => {\r\n    // Skip quotes since they're not actual purchases\r\n    const nonQuoteSales = sales.filter(sale => sale.paymentStatus !== \"Quote\");\r\n\r\n    // Group sales by customer name\r\n    const customerMap = new Map<string, { total: number, count: number, customerId?: string }>();\r\n\r\n    nonQuoteSales.forEach(sale => {\r\n      const customerName = sale.customerName;\r\n      const saleTotal = sale.items.reduce((sum, item) => sum + (item.price * item.quantity), 0);\r\n\r\n      if (!customerMap.has(customerName)) {\r\n        customerMap.set(customerName, {\r\n          total: saleTotal,\r\n          count: 1,\r\n          customerId: sale.customerId\r\n        });\r\n      } else {\r\n        const current = customerMap.get(customerName)!;\r\n        customerMap.set(customerName, {\r\n          total: current.total + saleTotal,\r\n          count: current.count + 1,\r\n          customerId: current.customerId || sale.customerId\r\n        });\r\n      }\r\n    });\r\n\r\n    // Convert map to array and sort by total purchases\r\n    return Array.from(customerMap.entries())\r\n      .map(([name, data]) => ({\r\n        id: data.customerId,\r\n        name,\r\n        totalPurchases: data.total,\r\n        orderCount: data.count\r\n      }))\r\n      .sort((a, b) => b.totalPurchases - a.totalPurchases);\r\n  }, [sales]);\r\n\r\n  // Memoize customer lifetime purchases function\r\n  const getCustomerLifetimePurchases = useMemo(() => {\r\n    return (customerName: string) => {\r\n      // Filter sales by customer name and exclude quotes\r\n      const customerSales = sales.filter(sale =>\r\n        sale.customerName.toLowerCase() === customerName.toLowerCase() &&\r\n        sale.paymentStatus !== \"Quote\"\r\n      );\r\n\r\n      // Calculate total purchase amount and count\r\n      const total = customerSales.reduce((sum, sale) =>\r\n        sum + sale.items.reduce((itemSum, item) => itemSum + (item.price * item.quantity), 0), 0\r\n      );\r\n\r\n      return {\r\n        total,\r\n        count: customerSales.length\r\n      };\r\n    };\r\n  }, [sales]);\r\n\r\n  const deleteSale = async (id: string) => {\r\n    try {\r\n      // First, find the sale to get its details for logging\r\n      const saleToDelete = sales.find(sale => sale.id === id);\r\n      if (!saleToDelete) {\r\n        throw new Error('Sale not found');\r\n      }\r\n\r\n      // Restore product quantities back to inventory (Only if it wasn't a quote which doesn't deduct stock)\r\n      if (saleToDelete.paymentStatus !== 'Quote' && saleToDelete.items.length > 0) {\r\n        console.log('Restoring product quantities via useInventoryActions...');\r\n        const success = await restoreStockForSale(saleToDelete.items, id, saleToDelete.receiptNumber, currentBusiness?.id);\r\n\r\n        if (!success) {\r\n          toast({\r\n            title: \"Inventory Update Warning\",\r\n            description: \"Sale deleted, but inventory restoration might have failed. Please check your stock levels.\",\r\n            variant: \"destructive\"\r\n          });\r\n        }\r\n      }\r\n\r\n      // Proceed to delete the sale via API Action\r\n      if (!currentBusiness?.id) {\r\n        throw new Error('Business context missing for deletion');\r\n      }\r\n\r\n      const result = await deleteSaleAction(id, currentBusiness.id);\r\n\r\n      if (!result.success) {\r\n        throw new Error(result.error);\r\n      }\r\n\r\n      // Update React Query cache\r\n      queryClient.setQueryData(queryKey, (oldData: Sale[] | undefined) => {\r\n        return oldData ? oldData.filter(sale => sale.id !== id) : [];\r\n      });\r\n      queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n\r\n      // Clear sold items cache after deletion\r\n      clearSoldItemsCache();\r\n\r\n      // Log activity for sale deletion\r\n      await logActivity({\r\n        activityType: 'DELETE',\r\n        module: 'SALES',\r\n        entityType: 'sale',\r\n        entityId: id,\r\n        entityName: `Sale #${saleToDelete.receiptNumber}`,\r\n        description: `Deleted sale for ${saleToDelete.customerName} - Total: UGX ${((saleToDelete.amountPaid || 0) + (saleToDelete.amountDue || 0)).toLocaleString()} (Stock restored)`,\r\n        metadata: {\r\n          receiptNumber: saleToDelete.receiptNumber,\r\n          customerName: saleToDelete.customerName,\r\n          customerAddress: saleToDelete.customerAddress,\r\n          customerContact: saleToDelete.customerContact,\r\n          totalAmount: (saleToDelete.amountPaid || 0) + (saleToDelete.amountDue || 0),\r\n          amountPaid: saleToDelete.amountPaid,\r\n          profit: saleToDelete.profit,\r\n          paymentStatus: saleToDelete.paymentStatus,\r\n          taxRate: saleToDelete.taxRate,\r\n          itemCount: saleToDelete.items.length,\r\n          items: saleToDelete.items.map(item => ({\r\n            description: item.description,\r\n            quantity: item.quantity,\r\n            price: item.price,\r\n            cost: item.cost,\r\n            total: item.quantity * item.price,\r\n            discountPercentage: item.discountPercentage,\r\n            discountAmount: item.discountAmount\r\n          })),\r\n          notes: saleToDelete.notes,\r\n          cashTransactionDeleted: !!saleToDelete.cashTransactionId\r\n        }\r\n      });\r\n\r\n      toast({\r\n        title: \"Sale Deleted\",\r\n        description: \"The sale record and associated data have been successfully deleted.\"\r\n      });\r\n\r\n      clearInventoryCaches();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting sale:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete sale. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const clearSoldItemsCache = useCallback(() => {\r\n    if (!currentBusiness?.id) return;\r\n    const key = `soldItemsFilters_${currentBusiness.id}`;\r\n    localStorage.removeItem(key);\r\n\r\n    // Also clear legacy keys for safety\r\n    localStorage.removeItem('soldItemsFilters');\r\n  }, [currentBusiness?.id]);\r\n\r\n  const addSale = useCallback((newSale: Sale) => {\r\n    queryClient.setQueryData(queryKey, (oldData: Sale[] | undefined) => {\r\n      return oldData ? [newSale, ...oldData] : [newSale];\r\n    });\r\n    queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n    clearSoldItemsCache();\r\n    clearInventoryCaches();\r\n  }, [queryClient, queryKey, baseQueryKey, clearSoldItemsCache, clearInventoryCaches]);\r\n\r\n  const updateSale = useCallback((updatedSale: Sale) => {\r\n    queryClient.setQueryData(queryKey, (oldData: Sale[] | undefined) => {\r\n      return oldData ? oldData.map(s => s.id === updatedSale.id ? updatedSale : s) : [updatedSale];\r\n    });\r\n    queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n    clearSoldItemsCache();\r\n    clearInventoryCaches();\r\n  }, [queryClient, queryKey, baseQueryKey, clearSoldItemsCache, clearInventoryCaches]);\r\n\r\n  return {\r\n    sales,\r\n    isLoading,\r\n    deleteSale,\r\n    addSale,\r\n    updateSale,\r\n    getTopCustomers,\r\n    getCustomerLifetimePurchases,\r\n    clearSoldItemsCache,\r\n    refetch,\r\n    isFetching\r\n  };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;AASO,MAAM,eAAe,CAAC,QAA4B,YAAoB,MAAM,EAAE;;IAEnF,MAAM,cAAc,IAAA,2MAAc;IAClC,MAAM,EAAE,KAAK,EAAE,GAAG,IAAA,2IAAQ;IAC1B,MAAM,EAAE,WAAW,EAAE,GAAG,IAAA,yJAAiB;IACzC,MAAM,EAAE,eAAe,EAAE,GAAG,IAAA,qJAAW;IACvC,MAAM,EAAE,mBAAmB,EAAE,GAAG,IAAA,6JAAmB,EAAC;IAEpD,MAAM,YAAY,IAAA,4KAAW;+CAAC;YAC5B,IAAI;gBACF,IAAI,CAAC,UAAU,CAAC,iBAAiB;oBAC/B,OAAO,EAAE;gBACX;gBAEA,wDAAwD;gBACxD,MAAM,YAAY,MAAM,IAAA,kLAAc,EAAC,gBAAgB,EAAE,EAAE,WAAkB;gBAE7E,MAAM,iBAAyB,YAAY,UAAU,GAAG;2DAAC,CAAC;wBACxD,MAAM,SAAiB;4BACrB,IAAI,KAAK,EAAE;4BACX,SAAS,KAAK,OAAO;4BACrB,aAAa,KAAK,WAAW;4BAC7B,gBAAgB,KAAK,cAAc;4BACnC,eAAe,KAAK,aAAa;4BACjC,kBAAkB,KAAK,gBAAgB;4BACvC,kBAAkB,KAAK,gBAAgB;4BACvC,aAAa,KAAK,WAAW;4BAC7B,OAAO,KAAK,KAAK;4BACjB,gBAAgB,KAAK,cAAc;4BACnC,QAAQ,KAAK,MAAM,GAAG,OAAO,KAAK,MAAM,IAAI;4BAC5C,MAAM,KAAK,IAAI;4BACf,UAAU,KAAK,QAAQ,IAAI;4BAC3B,YAAY,KAAK,UAAU;4BAC3B,YAAY,KAAK,UAAU;4BAC3B,qBAAqB,KAAK,mBAAmB;4BAC7C,aAAa,KAAK,WAAW,GAAG,OAAO,KAAK,WAAW,IAAI;4BAC3D,YAAY,KAAK,UAAU,GAAG,OAAO,KAAK,UAAU,IAAI;4BACxD,aAAa,KAAK,WAAW;4BAC7B,OAAO,KAAK,KAAK;wBACnB;wBACA,OAAO,IAAA,2IAAe,EAAC;oBACzB;4DAAK,EAAE;gBAEP,OAAO;YAET,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,wBAAwB;gBACtC,MAAM;oBACJ,OAAO;oBACP,aAAa;oBACb,SAAS;gBACX;gBACA,OAAO,EAAE;YACX;QACF;8CAAG;QAAC;QAAQ,iBAAiB;QAAI;QAAW;QAAU;KAAM;IAE5D,uEAAuE;IACvE,MAAM,eAAe,IAAA,wKAAO;8CAAC,IAAM;gBAAC;gBAAS,iBAAiB;gBAAI;aAAO;6CAAE;QAAC,iBAAiB;QAAI;KAAO;IACxG,MAAM,WAAW,IAAA,wKAAO;0CAAC,IAAM;mBAAI;gBAAc;gBAAW;aAAS;yCAAE;QAAC;QAAc;QAAW;KAAS;IAE1G,MAAM,EACJ,MAAM,QAAQ,EAAE,EAChB,WAAW,cAAc,EACzB,UAAU,EACV,OAAO,EACR,GAAG,IAAA,0LAAQ,EAAC;QACX;QACA,SAAS;QACT,SAAS,CAAC,CAAC,UAAU,CAAC,CAAC,iBAAiB;QACxC,WAAW;QACX,QAAQ,KAAK;QACb,sBAAsB;QACtB,oBAAoB;IACtB;IAEA,wBAAwB;IACxB,MAAM,YAAY,kBAAmB,cAAc,MAAM,MAAM,KAAK;IAEpE,MAAM,kBAAkB,IAAA,wKAAO;iDAAC;YAC9B,iDAAiD;YACjD,MAAM,gBAAgB,MAAM,MAAM;uEAAC,CAAA,OAAQ,KAAK,aAAa,KAAK;;YAElE,+BAA+B;YAC/B,MAAM,cAAc,IAAI;YAExB,cAAc,OAAO;yDAAC,CAAA;oBACpB,MAAM,eAAe,KAAK,YAAY;oBACtC,MAAM,YAAY,KAAK,KAAK,CAAC,MAAM;2EAAC,CAAC,KAAK,OAAS,MAAO,KAAK,KAAK,GAAG,KAAK,QAAQ;0EAAG;oBAEvF,IAAI,CAAC,YAAY,GAAG,CAAC,eAAe;wBAClC,YAAY,GAAG,CAAC,cAAc;4BAC5B,OAAO;4BACP,OAAO;4BACP,YAAY,KAAK,UAAU;wBAC7B;oBACF,OAAO;wBACL,MAAM,UAAU,YAAY,GAAG,CAAC;wBAChC,YAAY,GAAG,CAAC,cAAc;4BAC5B,OAAO,QAAQ,KAAK,GAAG;4BACvB,OAAO,QAAQ,KAAK,GAAG;4BACvB,YAAY,QAAQ,UAAU,IAAI,KAAK,UAAU;wBACnD;oBACF;gBACF;;YAEA,mDAAmD;YACnD,OAAO,MAAM,IAAI,CAAC,YAAY,OAAO,IAClC,GAAG;yDAAC,CAAC,CAAC,MAAM,KAAK,GAAK,CAAC;wBACtB,IAAI,KAAK,UAAU;wBACnB;wBACA,gBAAgB,KAAK,KAAK;wBAC1B,YAAY,KAAK,KAAK;oBACxB,CAAC;wDACA,IAAI;yDAAC,CAAC,GAAG,IAAM,EAAE,cAAc,GAAG,EAAE,cAAc;;QACvD;gDAAG;QAAC;KAAM;IAEV,+CAA+C;IAC/C,MAAM,+BAA+B,IAAA,wKAAO;8DAAC;YAC3C;sEAAO,CAAC;oBACN,mDAAmD;oBACnD,MAAM,gBAAgB,MAAM,MAAM;4FAAC,CAAA,OACjC,KAAK,YAAY,CAAC,WAAW,OAAO,aAAa,WAAW,MAC5D,KAAK,aAAa,KAAK;;oBAGzB,4CAA4C;oBAC5C,MAAM,QAAQ,cAAc,MAAM;oFAAC,CAAC,KAAK,OACvC,MAAM,KAAK,KAAK,CAAC,MAAM;4FAAC,CAAC,SAAS,OAAS,UAAW,KAAK,KAAK,GAAG,KAAK,QAAQ;2FAAG;mFAAI;oBAGzF,OAAO;wBACL;wBACA,OAAO,cAAc,MAAM;oBAC7B;gBACF;;QACF;6DAAG;QAAC;KAAM;IAEV,MAAM,aAAa,OAAO;QACxB,IAAI;YACF,sDAAsD;YACtD,MAAM,eAAe,MAAM,IAAI,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;YACpD,IAAI,CAAC,cAAc;gBACjB,MAAM,IAAI,MAAM;YAClB;YAEA,sGAAsG;YACtG,IAAI,aAAa,aAAa,KAAK,WAAW,aAAa,KAAK,CAAC,MAAM,GAAG,GAAG;gBAC3E,QAAQ,GAAG,CAAC;gBACZ,MAAM,UAAU,MAAM,oBAAoB,aAAa,KAAK,EAAE,IAAI,aAAa,aAAa,EAAE,iBAAiB;gBAE/G,IAAI,CAAC,SAAS;oBACZ,MAAM;wBACJ,OAAO;wBACP,aAAa;wBACb,SAAS;oBACX;gBACF;YACF;YAEA,4CAA4C;YAC5C,IAAI,CAAC,iBAAiB,IAAI;gBACxB,MAAM,IAAI,MAAM;YAClB;YAEA,MAAM,SAAS,MAAM,IAAA,oLAAgB,EAAC,IAAI,gBAAgB,EAAE;YAE5D,IAAI,CAAC,OAAO,OAAO,EAAE;gBACnB,MAAM,IAAI,MAAM,OAAO,KAAK;YAC9B;YAEA,2BAA2B;YAC3B,YAAY,YAAY,CAAC,UAAU,CAAC;gBAClC,OAAO,UAAU,QAAQ,MAAM,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK,MAAM,EAAE;YAC9D;YACA,YAAY,iBAAiB,CAAC;gBAAE,UAAU;YAAa;YAEvD,wCAAwC;YACxC;YAEA,iCAAiC;YACjC,MAAM,YAAY;gBAChB,cAAc;gBACd,QAAQ;gBACR,YAAY;gBACZ,UAAU;gBACV,YAAY,CAAC,MAAM,EAAE,aAAa,aAAa,EAAE;gBACjD,aAAa,CAAC,iBAAiB,EAAE,aAAa,YAAY,CAAC,cAAc,EAAE,CAAC,CAAC,aAAa,UAAU,IAAI,CAAC,IAAI,CAAC,aAAa,SAAS,IAAI,CAAC,CAAC,EAAE,cAAc,GAAG,iBAAiB,CAAC;gBAC/K,UAAU;oBACR,eAAe,aAAa,aAAa;oBACzC,cAAc,aAAa,YAAY;oBACvC,iBAAiB,aAAa,eAAe;oBAC7C,iBAAiB,aAAa,eAAe;oBAC7C,aAAa,CAAC,aAAa,UAAU,IAAI,CAAC,IAAI,CAAC,aAAa,SAAS,IAAI,CAAC;oBAC1E,YAAY,aAAa,UAAU;oBACnC,QAAQ,aAAa,MAAM;oBAC3B,eAAe,aAAa,aAAa;oBACzC,SAAS,aAAa,OAAO;oBAC7B,WAAW,aAAa,KAAK,CAAC,MAAM;oBACpC,OAAO,aAAa,KAAK,CAAC,GAAG,CAAC,CAAA,OAAQ,CAAC;4BACrC,aAAa,KAAK,WAAW;4BAC7B,UAAU,KAAK,QAAQ;4BACvB,OAAO,KAAK,KAAK;4BACjB,MAAM,KAAK,IAAI;4BACf,OAAO,KAAK,QAAQ,GAAG,KAAK,KAAK;4BACjC,oBAAoB,KAAK,kBAAkB;4BAC3C,gBAAgB,KAAK,cAAc;wBACrC,CAAC;oBACD,OAAO,aAAa,KAAK;oBACzB,wBAAwB,CAAC,CAAC,aAAa,iBAAiB;gBAC1D;YACF;YAEA,MAAM;gBACJ,OAAO;gBACP,aAAa;YACf;YAEA,IAAA,8JAAoB;YACpB,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wBAAwB;YACtC,MAAM;gBACJ,OAAO;gBACP,aAAa;gBACb,SAAS;YACX;YACA,OAAO;QACT;IACF;IAEA,MAAM,sBAAsB,IAAA,4KAAW;yDAAC;YACtC,IAAI,CAAC,iBAAiB,IAAI;YAC1B,MAAM,MAAM,CAAC,iBAAiB,EAAE,gBAAgB,EAAE,EAAE;YACpD,aAAa,UAAU,CAAC;YAExB,oCAAoC;YACpC,aAAa,UAAU,CAAC;QAC1B;wDAAG;QAAC,iBAAiB;KAAG;IAExB,MAAM,UAAU,IAAA,4KAAW;6CAAC,CAAC;YAC3B,YAAY,YAAY,CAAC;qDAAU,CAAC;oBAClC,OAAO,UAAU;wBAAC;2BAAY;qBAAQ,GAAG;wBAAC;qBAAQ;gBACpD;;YACA,YAAY,iBAAiB,CAAC;gBAAE,UAAU;YAAa;YACvD;YACA,IAAA,8JAAoB;QACtB;4CAAG;QAAC;QAAa;QAAU;QAAc;QAAqB,8JAAoB;KAAC;IAEnF,MAAM,aAAa,IAAA,4KAAW;gDAAC,CAAC;YAC9B,YAAY,YAAY,CAAC;wDAAU,CAAC;oBAClC,OAAO,UAAU,QAAQ,GAAG;gEAAC,CAAA,IAAK,EAAE,EAAE,KAAK,YAAY,EAAE,GAAG,cAAc;iEAAK;wBAAC;qBAAY;gBAC9F;;YACA,YAAY,iBAAiB,CAAC;gBAAE,UAAU;YAAa;YACvD;YACA,IAAA,8JAAoB;QACtB;+CAAG;QAAC;QAAa;QAAU;QAAc;QAAqB,8JAAoB;KAAC;IAEnF,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF;GA7Qa;;QAES,2MAAc;QAChB,2IAAQ;QACF,yJAAiB;QACb,qJAAW;QACP,6JAAmB;QA2D/C,0LAAQ"}},
    {"offset": {"line": 4575, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map(e => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map(t => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA2EsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qDAAA"}},
    {"offset": {"line": 4592, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map(e => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map(t => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoBsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 4609, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map(e => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map(t => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqGsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 4626, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map(e => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map(t => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoLsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 4643, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useExpenses.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport {\r\n  getExpensesAction,\r\n  createExpenseAction,\r\n  updateExpenseAction,\r\n  deleteExpenseAction,\r\n  createBulkCashTransactionsAction,\r\n  ExpenseInput\r\n} from '@/app/actions/finance';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\n\r\nexport interface Expense {\r\n  id: string;\r\n  amount: number;\r\n  description: string;\r\n  category?: string;\r\n  date: Date;\r\n  paymentMethod?: string;\r\n  personInCharge?: string;\r\n  receiptImage?: string;\r\n  cashAccountId?: string;\r\n  cashTransactionId?: string;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport const useExpenses = () => {\r\n  const [expenses, setExpenses] = useState<Expense[]>([]);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n  const { user } = useAuth();\r\n  const queryClient = useQueryClient();\r\n\r\n  const loadExpenses = useCallback(async (): Promise<Expense[]> => {\r\n    if (!currentBusiness) {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const result = await getExpensesAction(currentBusiness.id);\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error || 'Failed to fetch expenses');\r\n      }\r\n\r\n      const formattedExpenses: Expense[] = result.data.map((expense: any) => ({\r\n        id: expense.id,\r\n        amount: Number(expense.amount),\r\n        description: expense.description,\r\n        category: expense.category,\r\n        date: new Date(expense.date),\r\n        paymentMethod: expense.paymentMethod,\r\n        personInCharge: expense.personInCharge,\r\n        receiptImage: expense.receiptImage,\r\n        cashAccountId: expense.cashAccountId,\r\n        cashTransactionId: expense.cashTransactionId,\r\n        createdAt: new Date(expense.createdAt),\r\n        updatedAt: new Date(expense.updatedAt)\r\n      }));\r\n\r\n      return formattedExpenses;\r\n    } catch (error) {\r\n      console.error('Error loading expenses:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load expenses. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return [];\r\n    }\r\n  }, [currentBusiness?.id, toast]);\r\n\r\n  // React Query caching\r\n  const queryKey = ['expenses', currentBusiness?.id];\r\n  const { data: queriedExpenses, isLoading: isQueryLoading, isFetching } = useQuery({\r\n    queryKey,\r\n    queryFn: loadExpenses,\r\n    enabled: !!currentBusiness?.id,\r\n    staleTime: 5 * 60_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: false,\r\n    refetchOnReconnect: false,\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (queriedExpenses) {\r\n      setExpenses(queriedExpenses);\r\n    }\r\n  }, [queriedExpenses]);\r\n\r\n  // Only report loading when there is no cached data yet to avoid skeleton flash\r\n  const isLoading = isQueryLoading && !queriedExpenses;\r\n\r\n  const createExpense = async (expenseData: {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    linkToCash?: boolean;\r\n    cashAccountId?: string;\r\n  }) => {\r\n    if (!currentBusiness || !user) {\r\n      toast({\r\n        title: \"Error\",\r\n        description: !currentBusiness ? \"No business selected\" : \"User not authenticated\",\r\n        variant: \"destructive\"\r\n      });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const input: ExpenseInput = {\r\n        amount: expenseData.amount,\r\n        description: expenseData.description,\r\n        category: expenseData.category,\r\n        date: expenseData.date,\r\n        paymentMethod: expenseData.paymentMethod,\r\n        personInCharge: expenseData.personInCharge,\r\n        receiptImage: expenseData.receiptImage,\r\n        cashAccountId: expenseData.cashAccountId,\r\n        userId: user.id,\r\n        locationId: currentBusiness.id\r\n      };\r\n\r\n      const result = await createExpenseAction(input, !!expenseData.linkToCash);\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error);\r\n      }\r\n\r\n      const data = result.data;\r\n      const newExpense: Expense = {\r\n        id: data.id,\r\n        amount: Number(data.amount),\r\n        description: data.description,\r\n        category: data.category,\r\n        date: new Date(data.date),\r\n        paymentMethod: data.paymentMethod,\r\n        personInCharge: data.personInCharge,\r\n        receiptImage: data.receiptImage,\r\n        cashAccountId: data.cashAccountId,\r\n        cashTransactionId: data.cashTransactionId,\r\n        createdAt: new Date(data.createdAt),\r\n        updatedAt: new Date(data.updatedAt)\r\n      };\r\n\r\n      // Update local state and cache\r\n      setExpenses(prev => [newExpense, ...prev]);\r\n      queryClient.setQueryData(queryKey, (oldData: Expense[] | undefined) => {\r\n        return oldData ? [newExpense, ...oldData] : [newExpense];\r\n      });\r\n\r\n      queryClient.invalidateQueries({ queryKey });\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Expense created successfully\"\r\n      });\r\n\r\n      return newExpense;\r\n    } catch (error) {\r\n      console.error('Error creating expense:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to create expense. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n    }\r\n  };\r\n\r\n  const updateExpense = async (id: string, updates: Partial<Expense & { linkToCash?: boolean }>) => {\r\n    try {\r\n      const currentExpense = expenses.find(exp => exp.id === id);\r\n      if (!currentExpense) throw new Error('Expense not found');\r\n\r\n      // Prepare update payload\r\n      const updatePayload = {\r\n        amount: updates.amount !== undefined ? updates.amount : currentExpense.amount,\r\n        description: updates.description !== undefined ? updates.description : currentExpense.description,\r\n        category: updates.category !== undefined ? updates.category : currentExpense.category,\r\n        date: updates.date !== undefined ? updates.date : currentExpense.date,\r\n        paymentMethod: updates.paymentMethod !== undefined ? updates.paymentMethod : currentExpense.paymentMethod,\r\n        personInCharge: updates.personInCharge !== undefined ? updates.personInCharge : currentExpense.personInCharge,\r\n        receiptImage: updates.receiptImage !== undefined ? updates.receiptImage : currentExpense.receiptImage,\r\n        cashAccountId: updates.linkToCash ? updates.cashAccountId : (updates.linkToCash === false ? null : currentExpense.cashAccountId)\r\n      };\r\n\r\n      const result = await updateExpenseAction(id, updatePayload, currentExpense);\r\n\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      queryClient.invalidateQueries({ queryKey });\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Expense updated successfully\"\r\n      });\r\n    } catch (error) {\r\n      console.error('Error updating expense:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update expense. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n    }\r\n  };\r\n\r\n  const deleteExpense = async (id: string) => {\r\n    try {\r\n      const result = await deleteExpenseAction(id);\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      // Optimistic update\r\n      setExpenses(prev => prev.filter(e => e.id !== id));\r\n      queryClient.setQueryData(queryKey, (old: any) => {\r\n        if (!old) return old;\r\n        return (old as Expense[]).filter(e => e.id !== id);\r\n      });\r\n      queryClient.invalidateQueries({ queryKey });\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Expense deleted successfully\"\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting expense:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete expense. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const refreshExpenses = async () => {\r\n    queryClient.invalidateQueries({ queryKey });\r\n  };\r\n\r\n  const createBulkExpenses = async (expensesData: {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    linkToCash?: boolean;\r\n    cashAccountId?: string;\r\n  }[]) => {\r\n    if (!currentBusiness || !user) {\r\n      toast({\r\n        title: \"Error\",\r\n        description: !currentBusiness ? \"No business selected\" : \"User not authenticated\",\r\n        variant: \"destructive\"\r\n      });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const bulkResults: Expense[] = [];\r\n\r\n      // For bulk, since each might need individual linking logic in the action, \r\n      // we'll loop calling the createExpenseAction or we could implement a bulk action.\r\n      // Reusing createExpenseAction is simpler for now as it handles the transaction.\r\n      for (const data of expensesData) {\r\n        const input: ExpenseInput = {\r\n          amount: data.amount,\r\n          description: data.description,\r\n          category: data.category,\r\n          date: data.date,\r\n          paymentMethod: data.paymentMethod,\r\n          personInCharge: data.personInCharge,\r\n          receiptImage: data.receiptImage,\r\n          cashAccountId: data.cashAccountId,\r\n          userId: user.id,\r\n          locationId: currentBusiness.id\r\n        };\r\n\r\n        const result = await createExpenseAction(input, !!data.linkToCash);\r\n\r\n        if (result.success && result.data) {\r\n          const e = result.data;\r\n          bulkResults.push({\r\n            id: e.id,\r\n            amount: Number(e.amount),\r\n            description: e.description,\r\n            category: e.category,\r\n            date: new Date(e.date),\r\n            paymentMethod: e.paymentMethod,\r\n            personInCharge: e.personInCharge,\r\n            receiptImage: e.receiptImage,\r\n            cashAccountId: e.cashAccountId,\r\n            cashTransactionId: e.cashTransactionId,\r\n            createdAt: new Date(e.createdAt),\r\n            updatedAt: new Date(e.updatedAt)\r\n          });\r\n        }\r\n      }\r\n\r\n      queryClient.invalidateQueries({ queryKey });\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: `Successfully created ${bulkResults.length} expenses`\r\n      });\r\n\r\n      return bulkResults;\r\n    } catch (error) {\r\n      console.error('Error creating bulk expenses:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to create bulk expenses. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  return {\r\n    expenses,\r\n    isLoading,\r\n    createExpense,\r\n    createBulkExpenses,\r\n    updateExpense,\r\n    deleteExpense,\r\n    refreshExpenses\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4964, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useStockSummaryData.ts"],"sourcesContent":["import { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { supabase } from '@/integrations/supabase/client';\r\n\r\nexport interface StockSummaryData {\r\n  productId: string;\r\n  productName: string;\r\n  itemNumber: string;\r\n  imageUrl?: string | null;\r\n  costPrice: number;\r\n  sellingPrice: number;\r\n  category?: string;\r\n  openingStock: number;\r\n  itemsSold: number;\r\n  stockIn: number;\r\n  transferOut: number;\r\n  returnIn: number;\r\n  returnOut: number;\r\n  returnOut: number;\r\n  adjustmentsIn: number;\r\n  adjustmentsOut: number;\r\n  closingStock: number;\r\n  revaluation: number;\r\n}\r\n\r\nexport const useStockSummaryData = (\r\n  dateRange: { from: Date | undefined; to: Date | undefined }\r\n) => {\r\n  const { user } = useAuth();\r\n  const { currentBusiness } = useBusiness();\r\n  const queryClient = useQueryClient();\r\n\r\n  const fetchStockSummary = async (): Promise<StockSummaryData[]> => {\r\n    if (!user?.id || !currentBusiness?.id || !dateRange?.from || !dateRange?.to) return [];\r\n\r\n    console.log('[StockSummary] Fetching report...', {\r\n      location: currentBusiness.id,\r\n      from: dateRange.from.toISOString(),\r\n      to: dateRange.to.toISOString()\r\n    });\r\n\r\n    // We use \"as any\" to bypass strict type checking during this debug phase\r\n    const { data, error } = await (supabase.rpc as any)('get_stock_summary_report', {\r\n      p_location_id: currentBusiness.id,\r\n      p_start_date: dateRange.from.toISOString(),\r\n      p_end_date: dateRange.to.toISOString()\r\n    });\r\n\r\n    if (error) {\r\n      // LOG AS STRING SO IT IS VISIBLE IN THE USER LOGS\r\n      console.error('[StockSummary] CRITICAL ERROR MESSAGE:', error.message);\r\n      console.error('[StockSummary] FULL ERROR OBJECT:', JSON.stringify(error, null, 2));\r\n      throw error;\r\n    }\r\n\r\n    console.log('[StockSummary] SUCCESS. Rows received:', data?.length || 0);\r\n    return (data || []) as StockSummaryData[];\r\n  };\r\n\r\n  const { data: stockSummaryData = [], isLoading, refetch } = useQuery({\r\n    queryKey: ['stockSummary', currentBusiness?.id, dateRange.from?.toISOString(), dateRange.to?.toISOString()],\r\n    queryFn: fetchStockSummary,\r\n    enabled: !!user?.id && !!currentBusiness?.id && !!dateRange?.from && !!dateRange?.to,\r\n    staleTime: 5 * 60 * 1000,\r\n    gcTime: 30 * 60 * 1000,\r\n  });\r\n\r\n  return {\r\n    stockSummaryData,\r\n    isLoading,\r\n    loadStockSummaryData: refetch,\r\n    clearCache: () => {\r\n      queryClient.invalidateQueries({ queryKey: ['stockSummary'] });\r\n    },\r\n    clearAllLocationCaches: () => {\r\n      queryClient.invalidateQueries({ queryKey: ['stockSummary'] });\r\n    }\r\n  };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AAAA;AACA;;;;;;AAuBO,MAAM,sBAAsB,CACjC;;IAEA,MAAM,EAAE,IAAI,EAAE,GAAG,IAAA,wJAAO;IACxB,MAAM,EAAE,eAAe,EAAE,GAAG,IAAA,qJAAW;IACvC,MAAM,cAAc,IAAA,2MAAc;IAElC,MAAM,oBAAoB;QACxB,IAAI,CAAC,MAAM,MAAM,CAAC,iBAAiB,MAAM,CAAC,WAAW,QAAQ,CAAC,WAAW,IAAI,OAAO,EAAE;QAEtF,QAAQ,GAAG,CAAC,qCAAqC;YAC/C,UAAU,gBAAgB,EAAE;YAC5B,MAAM,UAAU,IAAI,CAAC,WAAW;YAChC,IAAI,UAAU,EAAE,CAAC,WAAW;QAC9B;QAEA,yEAAyE;QACzE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,AAAC,wJAAQ,CAAC,GAAG,CAAS,4BAA4B;YAC9E,eAAe,gBAAgB,EAAE;YACjC,cAAc,UAAU,IAAI,CAAC,WAAW;YACxC,YAAY,UAAU,EAAE,CAAC,WAAW;QACtC;QAEA,IAAI,OAAO;YACT,kDAAkD;YAClD,QAAQ,KAAK,CAAC,0CAA0C,MAAM,OAAO;YACrE,QAAQ,KAAK,CAAC,qCAAqC,KAAK,SAAS,CAAC,OAAO,MAAM;YAC/E,MAAM;QACR;QAEA,QAAQ,GAAG,CAAC,0CAA0C,MAAM,UAAU;QACtE,OAAQ,QAAQ,EAAE;IACpB;IAEA,MAAM,EAAE,MAAM,mBAAmB,EAAE,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,IAAA,0LAAQ,EAAC;QACnE,UAAU;YAAC;YAAgB,iBAAiB;YAAI,UAAU,IAAI,EAAE;YAAe,UAAU,EAAE,EAAE;SAAc;QAC3G,SAAS;QACT,SAAS,CAAC,CAAC,MAAM,MAAM,CAAC,CAAC,iBAAiB,MAAM,CAAC,CAAC,WAAW,QAAQ,CAAC,CAAC,WAAW;QAClF,WAAW,IAAI,KAAK;QACpB,QAAQ,KAAK,KAAK;IACpB;IAEA,OAAO;QACL;QACA;QACA,sBAAsB;QACtB,YAAY;YACV,YAAY,iBAAiB,CAAC;gBAAE,UAAU;oBAAC;iBAAe;YAAC;QAC7D;QACA,wBAAwB;YACtB,YAAY,iBAAiB,CAAC;gBAAE,UAAU;oBAAC;iBAAe;YAAC;QAC7D;IACF;AACF;GArDa;;QAGM,wJAAO;QACI,qJAAW;QACnB,2MAAc;QA6B0B,0LAAQ"}},
    {"offset": {"line": 5052, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useCarriageInwards.ts"],"sourcesContent":["\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useToast } from '@/hooks/use-toast';\r\n\r\nexport interface CarriageInward {\r\n  id: string;\r\n  userId: string;\r\n  locationId: string;\r\n  supplierName: string;\r\n  details: string;\r\n  amount: number;\r\n  date: Date;\r\n  cashAccountId?: string;\r\n  cashTransactionId?: string;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface CarriageInwardFormData {\r\n  supplierName: string;\r\n  details: string;\r\n  amount: number;\r\n  date: Date;\r\n  cashAccountId?: string;\r\n}\r\n\r\nexport const useCarriageInwards = () => {\r\n  const [carriageInwards, setCarriageInwards] = useState<CarriageInward[]>([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const { user } = useAuth();\r\n  const { currentBusiness } = useBusiness();\r\n  const { toast } = useToast();\r\n\r\n  const loadCarriageInwards = useCallback(async () => {\r\n    try {\r\n      if (!user || !currentBusiness) {\r\n        setCarriageInwards([]);\r\n        setIsLoading(false);\r\n        return;\r\n      }\r\n\r\n      setIsLoading(true);\r\n      \r\n      const { data, error } = await supabase\r\n        .from('carriage_inwards')\r\n        .select('*')\r\n        .eq('location_id', currentBusiness.id)\r\n        .order('date', { ascending: false })\r\n        .order('created_at', { ascending: false });\r\n\r\n      if (error) throw error;\r\n\r\n      const formattedData: CarriageInward[] = data?.map(item => ({\r\n        id: item.id,\r\n        userId: item.user_id,\r\n        locationId: item.location_id,\r\n        supplierName: item.supplier_name,\r\n        details: item.details,\r\n        amount: Number(item.amount),\r\n        date: new Date(item.date),\r\n        cashAccountId: item.cash_account_id,\r\n        cashTransactionId: item.cash_transaction_id,\r\n        createdAt: new Date(item.created_at),\r\n        updatedAt: new Date(item.updated_at)\r\n      })) || [];\r\n\r\n      setCarriageInwards(formattedData);\r\n    } catch (error) {\r\n      console.error('Error loading carriage inwards:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load carriage inwards records. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [user, currentBusiness?.id, toast]);\r\n\r\n  const createCarriageInward = async (data: CarriageInwardFormData) => {\r\n    try {\r\n      if (!user || !currentBusiness) throw new Error('User not authenticated or no business selected');\r\n\r\n      let cashTransactionId = null;\r\n\r\n      // Create cash transaction if cash account is selected\r\n      if (data.cashAccountId) {\r\n        const { data: cashTransaction, error: cashError } = await supabase\r\n          .from('cash_transactions')\r\n          .insert({\r\n            user_id: user.id,\r\n            location_id: currentBusiness.id,\r\n            account_id: data.cashAccountId,\r\n            amount: data.amount,\r\n            transaction_type: 'cash_out',\r\n            category: 'Transport',\r\n            description: `Carriage inwards - ${data.supplierName}: ${data.details}`,\r\n            date: data.date.toISOString().split('T')[0]\r\n          })\r\n          .select()\r\n          .single();\r\n\r\n        if (cashError) throw cashError;\r\n        cashTransactionId = cashTransaction.id;\r\n      }\r\n\r\n      const { data: carriageData, error } = await supabase\r\n        .from('carriage_inwards')\r\n        .insert({\r\n          user_id: user.id,\r\n          location_id: currentBusiness.id,\r\n          supplier_name: data.supplierName,\r\n          details: data.details,\r\n          amount: data.amount,\r\n          date: data.date.toISOString().split('T')[0],\r\n          cash_account_id: data.cashAccountId || null,\r\n          cash_transaction_id: cashTransactionId\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) throw error;\r\n\r\n      await loadCarriageInwards();\r\n      \r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Carriage inwards record created successfully\"\r\n      });\r\n\r\n      return carriageData;\r\n    } catch (error) {\r\n      console.error('Error creating carriage inwards:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to create carriage inwards record. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const updateCarriageInward = async (id: string, updates: Partial<CarriageInwardFormData>) => {\r\n    try {\r\n      if (!currentBusiness) throw new Error('No business selected');\r\n\r\n      const updateData: any = {};\r\n      \r\n      if (updates.supplierName !== undefined) updateData.supplier_name = updates.supplierName;\r\n      if (updates.details !== undefined) updateData.details = updates.details;\r\n      if (updates.amount !== undefined) updateData.amount = updates.amount;\r\n      if (updates.date !== undefined) updateData.date = updates.date.toISOString().split('T')[0];\r\n\r\n      const { error } = await supabase\r\n        .from('carriage_inwards')\r\n        .update(updateData)\r\n        .eq('id', id)\r\n        .eq('location_id', currentBusiness.id);\r\n\r\n      if (error) throw error;\r\n\r\n      await loadCarriageInwards();\r\n      \r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Carriage inwards record updated successfully\"\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating carriage inwards:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update carriage inwards record. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteCarriageInward = async (id: string) => {\r\n    try {\r\n      if (!currentBusiness) throw new Error('No business selected');\r\n\r\n      // Get the record to check if it has an associated cash transaction\r\n      const { data: record, error: fetchError } = await supabase\r\n        .from('carriage_inwards')\r\n        .select('cash_transaction_id')\r\n        .eq('id', id)\r\n        .eq('location_id', currentBusiness.id)\r\n        .single();\r\n\r\n      if (fetchError) throw fetchError;\r\n\r\n      // Delete associated cash transaction if exists\r\n      if (record.cash_transaction_id) {\r\n        const { error: cashError } = await supabase\r\n          .from('cash_transactions')\r\n          .delete()\r\n          .eq('id', record.cash_transaction_id)\r\n          .eq('location_id', currentBusiness.id);\r\n\r\n        if (cashError) throw cashError;\r\n      }\r\n\r\n      // Delete the carriage inwards record\r\n      const { error } = await supabase\r\n        .from('carriage_inwards')\r\n        .delete()\r\n        .eq('id', id)\r\n        .eq('location_id', currentBusiness.id);\r\n\r\n      if (error) throw error;\r\n\r\n      await loadCarriageInwards();\r\n      \r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Carriage inwards record deleted successfully\"\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting carriage inwards:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete carriage inwards record. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    loadCarriageInwards();\r\n  }, [loadCarriageInwards]);\r\n\r\n  return {\r\n    carriageInwards,\r\n    isLoading,\r\n    createCarriageInward,\r\n    updateCarriageInward,\r\n    deleteCarriageInward,\r\n    refreshCarriageInwards: loadCarriageInwards\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5253, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/utils/dateFilters.ts"],"sourcesContent":["\r\nimport { startOfDay, endOfDay, startOfWeek, endOfWeek, startOfMonth, endOfMonth, startOfYear, endOfYear, subDays, subWeeks, subMonths } from 'date-fns';\r\n\r\nexport const getDateRangeFromFilter = (filter: string): { from: Date; to: Date } => {\r\n  const now = new Date();\r\n  const today = startOfDay(now);\r\n  \r\n  switch (filter) {\r\n    case 'today':\r\n      return {\r\n        from: today,\r\n        to: endOfDay(now)\r\n      };\r\n    case 'yesterday':\r\n      const yesterday = subDays(today, 1);\r\n      return {\r\n        from: yesterday,\r\n        to: endOfDay(yesterday)\r\n      };\r\n    case 'this-week':\r\n      return {\r\n        from: startOfWeek(now),\r\n        to: endOfWeek(now)\r\n      };\r\n    case 'last-week':\r\n      const lastWeekStart = startOfWeek(subWeeks(now, 1));\r\n      return {\r\n        from: lastWeekStart,\r\n        to: endOfWeek(lastWeekStart)\r\n      };\r\n    case 'this-month':\r\n      return {\r\n        from: startOfMonth(now),\r\n        to: endOfMonth(now)\r\n      };\r\n    case 'last-month':\r\n      const lastMonthStart = startOfMonth(subMonths(now, 1));\r\n      return {\r\n        from: lastMonthStart,\r\n        to: endOfMonth(lastMonthStart)\r\n      };\r\n    case 'this-year':\r\n      return {\r\n        from: startOfYear(now),\r\n        to: endOfYear(now)\r\n      };\r\n    default:\r\n      // For 'all' or any other case, return a very wide range\r\n      return {\r\n        from: new Date(2000, 0, 1),\r\n        to: endOfDay(now)\r\n      };\r\n  }\r\n};\r\n\r\nexport const isDateInRange = (date: Date, from: Date | undefined, to: Date | undefined): boolean => {\r\n  if (!from && !to) return true;\r\n  if (!from) return date <= to!;\r\n  if (!to) return date >= from;\r\n  return date >= from && date <= to;\r\n};\r\n"],"names":[],"mappings":";;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEO,MAAM,yBAAyB,CAAC;IACrC,MAAM,MAAM,IAAI;IAChB,MAAM,QAAQ,IAAA,0JAAU,EAAC;IAEzB,OAAQ;QACN,KAAK;YACH,OAAO;gBACL,MAAM;gBACN,IAAI,IAAA,sJAAQ,EAAC;YACf;QACF,KAAK;YACH,MAAM,YAAY,IAAA,oJAAO,EAAC,OAAO;YACjC,OAAO;gBACL,MAAM;gBACN,IAAI,IAAA,sJAAQ,EAAC;YACf;QACF,KAAK;YACH,OAAO;gBACL,MAAM,IAAA,4JAAW,EAAC;gBAClB,IAAI,IAAA,wJAAS,EAAC;YAChB;QACF,KAAK;YACH,MAAM,gBAAgB,IAAA,4JAAW,EAAC,IAAA,sJAAQ,EAAC,KAAK;YAChD,OAAO;gBACL,MAAM;gBACN,IAAI,IAAA,wJAAS,EAAC;YAChB;QACF,KAAK;YACH,OAAO;gBACL,MAAM,IAAA,8JAAY,EAAC;gBACnB,IAAI,IAAA,0JAAU,EAAC;YACjB;QACF,KAAK;YACH,MAAM,iBAAiB,IAAA,8JAAY,EAAC,IAAA,wJAAS,EAAC,KAAK;YACnD,OAAO;gBACL,MAAM;gBACN,IAAI,IAAA,0JAAU,EAAC;YACjB;QACF,KAAK;YACH,OAAO;gBACL,MAAM,IAAA,4JAAW,EAAC;gBAClB,IAAI,IAAA,wJAAS,EAAC;YAChB;QACF;YACE,wDAAwD;YACxD,OAAO;gBACL,MAAM,IAAI,KAAK,MAAM,GAAG;gBACxB,IAAI,IAAA,sJAAQ,EAAC;YACf;IACJ;AACF;AAEO,MAAM,gBAAgB,CAAC,MAAY,MAAwB;IAChE,IAAI,CAAC,QAAQ,CAAC,IAAI,OAAO;IACzB,IAAI,CAAC,MAAM,OAAO,QAAQ;IAC1B,IAAI,CAAC,IAAI,OAAO,QAAQ;IACxB,OAAO,QAAQ,QAAQ,QAAQ;AACjC"}},
    {"offset": {"line": 5334, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useProfitLossData.ts"],"sourcesContent":["\r\nimport { useState, useEffect, useMemo } from 'react';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useSalesData } from '@/hooks/useSalesData';\r\nimport { useExpenses } from '@/hooks/useExpenses';\r\nimport { useStockSummaryData } from '@/hooks/useStockSummaryData';\r\nimport { useCarriageInwards } from '@/hooks/useCarriageInwards';\r\nimport { getDateRangeFromFilter } from '@/utils/dateFilters';\r\nimport { isSameDay } from 'date-fns';\r\n\r\nexport interface ProfitLossData {\r\n  sales: number;\r\n  salesReturns: number;\r\n  netSales: number;\r\n  openingStock: number;\r\n  purchases: number;\r\n  carriageInwards: number;\r\n  closingStock: number;\r\n  totalCostSales: number; // Added for new COGS calculation\r\n  totalCOGS: number;\r\n  grossProfit: number;\r\n  expensesByCategory: { [key: string]: number };\r\n  totalExpenses: number;\r\n  netProfitLoss: number;\r\n  taxPercentage: number;\r\n  taxAmount: number;\r\n  finalProfitAfterTax: number;\r\n}\r\n\r\nexport const useProfitLossData = (\r\n  dateFilter: string,\r\n  dateRange: { from: Date | undefined; to: Date | undefined },\r\n  specificDate: Date | undefined,\r\n  taxPercentage: number = 0\r\n) => {\r\n  const { user } = useAuth();\r\n  const { currentBusiness } = useBusiness();\r\n  const [isLoading, setIsLoading] = useState(false);\r\n\r\n  // Get data from existing hooks\r\n  const { sales, isLoading: salesLoading } = useSalesData(user?.id);\r\n  const { expenses, isLoading: expensesLoading } = useExpenses();\r\n  const { stockSummaryData, isLoading: stockLoading } = useStockSummaryData(dateRange);\r\n  const { carriageInwards, isLoading: carriageLoading } = useCarriageInwards();\r\n\r\n  const profitLossData = useMemo((): ProfitLossData => {\r\n    // Calculate date range using the same logic as sold items report\r\n    let from: Date, to: Date;\r\n\r\n    if (dateFilter === 'specific' && specificDate) {\r\n      from = new Date(specificDate);\r\n      from.setHours(0, 0, 0, 0);\r\n      to = new Date(specificDate);\r\n      to.setHours(23, 59, 59, 999);\r\n    } else if (dateFilter === 'custom' && dateRange.from && dateRange.to) {\r\n      from = dateRange.from;\r\n      to = dateRange.to;\r\n    } else {\r\n      const range = getDateRangeFromFilter(dateFilter);\r\n      from = range.from;\r\n      to = range.to;\r\n    }\r\n\r\n    // Filter sales by date range and exclude quotes using same logic as sold items report\r\n    const filteredSales = sales.filter(sale => {\r\n      const saleDate = new Date(sale.date);\r\n      \r\n      if (dateFilter === 'specific' && specificDate) {\r\n        return isSameDay(saleDate, specificDate) && sale.paymentStatus !== 'Quote';\r\n      }\r\n      \r\n      return saleDate >= from && saleDate <= to && sale.paymentStatus !== 'Quote';\r\n    });\r\n\r\n    // Filter expenses by date range using same logic\r\n    const filteredExpenses = expenses.filter(expense => {\r\n      const expenseDate = new Date(expense.date);\r\n      \r\n      if (dateFilter === 'specific' && specificDate) {\r\n        return isSameDay(expenseDate, specificDate);\r\n      }\r\n      \r\n      return expenseDate >= from && expenseDate <= to;\r\n    });\r\n\r\n    // Filter carriage inwards by date range using same logic\r\n    const filteredCarriageInwards = carriageInwards.filter(record => {\r\n      const recordDate = new Date(record.date);\r\n      \r\n      if (dateFilter === 'specific' && specificDate) {\r\n        return isSameDay(recordDate, specificDate);\r\n      }\r\n      \r\n      return recordDate >= from && recordDate <= to;\r\n    });\r\n\r\n    // Calculate Sales/Revenue\r\n    const totalSales = filteredSales.reduce((sum, sale) => {\r\n      return sum + sale.items.reduce((itemSum, item) => itemSum + (item.price * item.quantity), 0);\r\n    }, 0);\r\n\r\n    // Calculate Sales Returns (Return In using selling price)\r\n    const totalSalesReturns = stockSummaryData.reduce((sum, item) => {\r\n      return sum + (item.returnIn * item.sellingPrice);\r\n    }, 0);\r\n\r\n    // Net Sales\r\n    const netSales = totalSales - totalSalesReturns;\r\n\r\n    // Calculate Opening Stock value (using cost price)\r\n    const totalOpeningStock = stockSummaryData.reduce((sum, item) => {\r\n      return sum + (item.openingStock * item.costPrice);\r\n    }, 0);\r\n\r\n    // Calculate Purchases (Stock In value using cost price)\r\n    const totalPurchases = stockSummaryData.reduce((sum, item) => {\r\n      return sum + (item.stockIn * item.costPrice);\r\n    }, 0);\r\n\r\n    // Calculate Carriage Inwards\r\n    const totalCarriageInwards = filteredCarriageInwards.reduce((sum, record) => {\r\n      return sum + record.amount;\r\n    }, 0);\r\n\r\n    // Calculate Closing Stock value (using cost price)\r\n    const totalClosingStock = stockSummaryData.reduce((sum, item) => {\r\n      return sum + (item.closingStock * item.costPrice);\r\n    }, 0);\r\n\r\n    // Calculate Total Cost of Sales (cost price of all items sold)\r\n    const totalCostSales = filteredSales.reduce((sum, sale) => {\r\n      return sum + sale.items.reduce((itemSum, item) => itemSum + ((item.cost || 0) * item.quantity), 0);\r\n    }, 0);\r\n\r\n    // Total COGS = Total Cost Sales + Carriage Inwards\r\n    const totalCOGS = totalCostSales + totalCarriageInwards;\r\n\r\n    // Gross Profit\r\n    const grossProfit = netSales - totalCOGS;\r\n\r\n    // Group expenses by category\r\n    const expensesByCategory: { [key: string]: number } = {};\r\n    filteredExpenses.forEach(expense => {\r\n      const category = expense.category || 'Uncategorized';\r\n      expensesByCategory[category] = (expensesByCategory[category] || 0) + expense.amount;\r\n    });\r\n\r\n    // Total Expenses\r\n    const totalExpenses = Object.values(expensesByCategory).reduce((sum, amount) => sum + amount, 0);\r\n\r\n    // Net Profit/Loss\r\n    const netProfitLoss = grossProfit - totalExpenses;\r\n\r\n    // Tax calculations\r\n    const taxAmount = netProfitLoss > 0 ? (netProfitLoss * taxPercentage) / 100 : 0;\r\n    const finalProfitAfterTax = netProfitLoss - taxAmount;\r\n\r\n    return {\r\n      sales: totalSales,\r\n      salesReturns: totalSalesReturns,\r\n      netSales,\r\n      openingStock: totalOpeningStock,\r\n      purchases: totalPurchases,\r\n      carriageInwards: totalCarriageInwards,\r\n      closingStock: totalClosingStock,\r\n      totalCostSales,\r\n      totalCOGS,\r\n      grossProfit,\r\n      expensesByCategory,\r\n      totalExpenses,\r\n      netProfitLoss,\r\n      taxPercentage,\r\n      taxAmount,\r\n      finalProfitAfterTax\r\n    };\r\n  }, [sales, expenses, stockSummaryData, carriageInwards, dateFilter, dateRange, specificDate, taxPercentage]);\r\n\r\n  const loading = useMemo(() => {\r\n    return salesLoading || expensesLoading || stockLoading || carriageLoading;\r\n  }, [salesLoading, expensesLoading, stockLoading, carriageLoading]);\r\n\r\n  return {\r\n    profitLossData,\r\n    isLoading: loading\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5544, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/popover.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Popover = PopoverPrimitive.Root\r\n\r\nconst PopoverTrigger = PopoverPrimitive.Trigger\r\n\r\nconst PopoverContent = React.forwardRef<\r\n  React.ElementRef<typeof PopoverPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\r\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\r\n  <PopoverPrimitive.Portal>\r\n    <PopoverPrimitive.Content\r\n      ref={ref}\r\n      align={align}\r\n      sideOffset={sideOffset}\r\n      className={cn(\r\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\r\n        className\r\n      )}\r\n      {...props}\r\n    />\r\n  </PopoverPrimitive.Portal>\r\n))\r\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\r\n\r\nexport { Popover, PopoverTrigger, PopoverContent }\r\n"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,UAAU,8KAAqB;AAErC,MAAM,iBAAiB,iLAAwB;AAE/C,MAAM,+BAAiB,2KAAgB,MAGrC,CAAC,EAAE,SAAS,EAAE,QAAQ,QAAQ,EAAE,aAAa,CAAC,EAAE,GAAG,OAAO,EAAE,oBAC5D,6LAAC,gLAAuB;kBACtB,cAAA,6LAAC,iLAAwB;YACvB,KAAK;YACL,OAAO;YACP,YAAY;YACZ,WAAW,IAAA,4HAAE,EACX,8aACA;YAED,GAAG,KAAK;;;;;;;;;;;;AAIf,eAAe,WAAW,GAAG,iLAAwB,CAAC,WAAW"}},
    {"offset": {"line": 5592, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/calendar.tsx"],"sourcesContent":["\r\nimport * as React from \"react\";\r\nimport { ChevronLeft, ChevronRight } from \"lucide-react\";\r\nimport { DayPicker } from \"react-day-picker\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\nimport { buttonVariants } from \"@/components/ui/button\";\r\n\r\nexport type CalendarProps = React.ComponentProps<typeof DayPicker>;\r\n\r\nfunction Calendar({\r\n  className,\r\n  classNames,\r\n  showOutsideDays = true,\r\n  ...props\r\n}: CalendarProps) {\r\n  return (\r\n    <DayPicker\r\n      showOutsideDays={showOutsideDays}\r\n      className={cn(\"p-3 pointer-events-auto\", className)}\r\n      classNames={{\r\n        months: \"flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0\",\r\n        month: \"space-y-4\",\r\n        caption: \"flex justify-center pt-1 relative items-center\",\r\n        caption_label: \"text-sm font-medium\",\r\n        caption_dropdowns: \"flex justify-center gap-1\",\r\n        nav: \"space-x-1 flex items-center\",\r\n        nav_button: cn(\r\n          buttonVariants({ variant: \"outline\" }),\r\n          \"h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100\"\r\n        ),\r\n        nav_button_previous: \"absolute left-1\",\r\n        nav_button_next: \"absolute right-1\",\r\n        table: \"w-full border-collapse space-y-1\",\r\n        head_row: \"flex\",\r\n        head_cell:\r\n          \"text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]\",\r\n        row: \"flex w-full mt-2\",\r\n        cell: \"h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20\",\r\n        day: cn(\r\n          buttonVariants({ variant: \"ghost\" }),\r\n          \"h-9 w-9 p-0 font-normal aria-selected:opacity-100\"\r\n        ),\r\n        day_range_end: \"day-range-end\",\r\n        day_selected:\r\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground\",\r\n        day_today: \"bg-accent text-accent-foreground\",\r\n        day_outside:\r\n          \"day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30\",\r\n        day_disabled: \"text-muted-foreground opacity-50\",\r\n        day_range_middle:\r\n          \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\r\n        day_hidden: \"invisible\",\r\n        dropdown: \"bg-background rounded-md border p-1 shadow-md\",\r\n        dropdown_month: \"w-[var(--rdp-caption-dropdown-month-width)]\",\r\n        dropdown_year: \"w-[var(--rdp-caption-dropdown-year-width)]\",\r\n        dropdown_icon: \"w-4 h-4\",\r\n        button_reset: \"appearance-none bg-transparent border-none p-0 m-0\",\r\n        vhidden: \"sr-only\",\r\n        ...classNames,\r\n      }}\r\n      components={{\r\n        IconLeft: ({ ..._props }) => <ChevronLeft className=\"h-4 w-4\" />,\r\n        IconRight: ({ ..._props }) => <ChevronRight className=\"h-4 w-4\" />,\r\n      }}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\nCalendar.displayName = \"Calendar\";\r\n\r\nexport { Calendar };\r\n"],"names":[],"mappings":";;;;;AAEA;AAAA;AACA;AAEA;AACA;;;;;;AAIA,SAAS,SAAS,EAChB,SAAS,EACT,UAAU,EACV,kBAAkB,IAAI,EACtB,GAAG,OACW;IACd,qBACE,6LAAC,8KAAS;QACR,iBAAiB;QACjB,WAAW,IAAA,4HAAE,EAAC,2BAA2B;QACzC,YAAY;YACV,QAAQ;YACR,OAAO;YACP,SAAS;YACT,eAAe;YACf,mBAAmB;YACnB,KAAK;YACL,YAAY,IAAA,4HAAE,EACZ,IAAA,uJAAc,EAAC;gBAAE,SAAS;YAAU,IACpC;YAEF,qBAAqB;YACrB,iBAAiB;YACjB,OAAO;YACP,UAAU;YACV,WACE;YACF,KAAK;YACL,MAAM;YACN,KAAK,IAAA,4HAAE,EACL,IAAA,uJAAc,EAAC;gBAAE,SAAS;YAAQ,IAClC;YAEF,eAAe;YACf,cACE;YACF,WAAW;YACX,aACE;YACF,cAAc;YACd,kBACE;YACF,YAAY;YACZ,UAAU;YACV,gBAAgB;YAChB,eAAe;YACf,eAAe;YACf,cAAc;YACd,SAAS;YACT,GAAG,UAAU;QACf;QACA,YAAY;YACV,UAAU,CAAC,EAAE,GAAG,QAAQ,iBAAK,6LAAC,sOAAW;oBAAC,WAAU;;;;;;YACpD,WAAW,CAAC,EAAE,GAAG,QAAQ,iBAAK,6LAAC,yOAAY;oBAAC,WAAU;;;;;;QACxD;QACC,GAAG,KAAK;;;;;;AAGf;KA1DS;AA2DT,SAAS,WAAW,GAAG"}},
    {"offset": {"line": 5681, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/analytics/DateRangeFilter.tsx"],"sourcesContent":["\r\nimport React from 'react';\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Calendar as CalendarIcon } from \"lucide-react\";\r\nimport { Popover, PopoverContent, PopoverTrigger } from \"@/components/ui/popover\";\r\nimport { Calendar } from \"@/components/ui/calendar\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { format } from \"date-fns\";\r\n\r\ninterface DateRangeFilterProps {\r\n  dateFilter: string;\r\n  dateRange: { from: Date | undefined; to: Date | undefined; };\r\n  specificDate?: Date | undefined;\r\n  isCustomRange: boolean;\r\n  isSpecificDate?: boolean;\r\n  onDateFilterChange: (value: string) => void;\r\n  onDateRangeChange: (range: { from: Date | undefined; to: Date | undefined; }) => void;\r\n  onSpecificDateChange?: (date: Date | undefined) => void;\r\n}\r\n\r\nconst DateRangeFilter: React.FC<DateRangeFilterProps> = ({\r\n  dateFilter,\r\n  dateRange,\r\n  specificDate,\r\n  isCustomRange,\r\n  isSpecificDate = false,\r\n  onDateFilterChange,\r\n  onDateRangeChange,\r\n  onSpecificDateChange\r\n}) => {\r\n  // Simplified event prevention\r\n  const preventPropagation = (e: React.MouseEvent | React.TouchEvent) => {\r\n    e.stopPropagation();\r\n  };\r\n  \r\n  return (\r\n    <div \r\n      className=\"flex gap-4 items-center flex-wrap mb-4\"\r\n      onClick={preventPropagation}\r\n    >\r\n      <div className=\"w-[240px] relative\">\r\n        <Select value={dateFilter} onValueChange={onDateFilterChange}>\r\n          <SelectTrigger className=\"bg-white shadow-sm\">\r\n            <SelectValue placeholder=\"Select date range\" />\r\n          </SelectTrigger>\r\n          <SelectContent className=\"z-[9999] bg-white shadow-lg border border-border/50\">\r\n            <SelectItem value=\"today\">Today</SelectItem>\r\n            <SelectItem value=\"yesterday\">Yesterday</SelectItem>\r\n            <SelectItem value=\"this-week\">This Week</SelectItem>\r\n            <SelectItem value=\"last-week\">Last Week</SelectItem>\r\n            <SelectItem value=\"this-month\">This Month</SelectItem>\r\n            <SelectItem value=\"last-month\">Last Month</SelectItem>\r\n            <SelectItem value=\"this-year\">This Year</SelectItem>\r\n            <SelectItem value=\"all\">All Time</SelectItem>\r\n            <SelectItem value=\"specific\">Specific Date</SelectItem>\r\n            <SelectItem value=\"custom\">Custom Range</SelectItem>\r\n          </SelectContent>\r\n        </Select>\r\n      </div>\r\n\r\n      {isSpecificDate && onSpecificDateChange && (\r\n        <div className=\"flex items-center\">\r\n          <Popover>\r\n            <PopoverTrigger asChild>\r\n              <Button\r\n                variant=\"outline\"\r\n                className=\"bg-white flex items-center gap-2 h-10 pl-3 text-left font-normal\"\r\n              >\r\n                <CalendarIcon className=\"h-4 w-4\" />\r\n                <span>{specificDate ? format(specificDate, \"MMM d, yyyy\") : \"Select Date\"}</span>\r\n              </Button>\r\n            </PopoverTrigger>\r\n            <PopoverContent className=\"w-auto p-0 z-[9999] bg-white shadow-lg\" align=\"start\">\r\n              <Calendar\r\n                initialFocus\r\n                mode=\"single\"\r\n                defaultMonth={specificDate}\r\n                selected={specificDate}\r\n                onSelect={onSpecificDateChange}\r\n                className=\"p-3 pointer-events-auto\"\r\n                showOutsideDays={true}\r\n              />\r\n            </PopoverContent>\r\n          </Popover>\r\n        </div>\r\n      )}\r\n\r\n      {isCustomRange && (\r\n        <div className=\"flex items-center space-x-2\">\r\n          <Popover>\r\n            <PopoverTrigger asChild>\r\n              <Button\r\n                variant=\"outline\"\r\n                className=\"bg-white flex items-center gap-2 h-10 pl-3 text-left font-normal\"\r\n              >\r\n                <CalendarIcon className=\"h-4 w-4\" />\r\n                <span>{dateRange.from ? format(dateRange.from, \"MMM d, yyyy\") : \"Start Date\"}</span>\r\n              </Button>\r\n            </PopoverTrigger>\r\n            <PopoverContent className=\"w-auto p-0 z-[9999] bg-white shadow-lg\" align=\"start\">\r\n              <Calendar\r\n                initialFocus\r\n                mode=\"single\"\r\n                defaultMonth={dateRange?.from}\r\n                selected={dateRange?.from}\r\n                onSelect={(date) => onDateRangeChange({ ...dateRange, from: date })}\r\n                className=\"p-3 pointer-events-auto\"\r\n                showOutsideDays={true}\r\n              />\r\n            </PopoverContent>\r\n          </Popover>\r\n          \r\n          <span className=\"text-muted-foreground\">to</span>\r\n          \r\n          <Popover>\r\n            <PopoverTrigger asChild>\r\n              <Button\r\n                variant=\"outline\"\r\n                className=\"bg-white flex items-center gap-2 h-10 pl-3 text-left font-normal\"\r\n              >\r\n                <CalendarIcon className=\"h-4 w-4\" />\r\n                <span>{dateRange.to ? format(dateRange.to, \"MMM d, yyyy\") : \"End Date\"}</span>\r\n              </Button>\r\n            </PopoverTrigger>\r\n            <PopoverContent className=\"w-auto p-0 z-[9999] bg-white shadow-lg\" align=\"start\">\r\n              <Calendar\r\n                initialFocus\r\n                mode=\"single\"\r\n                defaultMonth={dateRange?.to}\r\n                selected={dateRange?.to}\r\n                onSelect={(date) => onDateRangeChange({ ...dateRange, to: date })}\r\n                className=\"p-3 pointer-events-auto\"\r\n                showOutsideDays={true}\r\n              />\r\n            </PopoverContent>\r\n          </Popover>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default DateRangeFilter;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6056, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/table.tsx"],"sourcesContent":["import * as React from \"react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Table = React.forwardRef<\r\n  HTMLTableElement,\r\n  React.HTMLAttributes<HTMLTableElement>\r\n>(({ className, ...props }, ref) => (\r\n  <div className=\"relative w-full overflow-auto\">\r\n    <table\r\n      ref={ref}\r\n      className={cn(\"w-full caption-bottom text-sm\", className)}\r\n      {...props}\r\n    />\r\n  </div>\r\n))\r\nTable.displayName = \"Table\"\r\n\r\nconst TableHeader = React.forwardRef<\r\n  HTMLTableSectionElement,\r\n  React.HTMLAttributes<HTMLTableSectionElement>\r\n>(({ className, ...props }, ref) => (\r\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\r\n))\r\nTableHeader.displayName = \"TableHeader\"\r\n\r\nconst TableBody = React.forwardRef<\r\n  HTMLTableSectionElement,\r\n  React.HTMLAttributes<HTMLTableSectionElement>\r\n>(({ className, ...props }, ref) => (\r\n  <tbody\r\n    ref={ref}\r\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\r\n    {...props}\r\n  />\r\n))\r\nTableBody.displayName = \"TableBody\"\r\n\r\nconst TableFooter = React.forwardRef<\r\n  HTMLTableSectionElement,\r\n  React.HTMLAttributes<HTMLTableSectionElement>\r\n>(({ className, ...props }, ref) => (\r\n  <tfoot\r\n    ref={ref}\r\n    className={cn(\r\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTableFooter.displayName = \"TableFooter\"\r\n\r\nconst TableRow = React.forwardRef<\r\n  HTMLTableRowElement,\r\n  React.HTMLAttributes<HTMLTableRowElement>\r\n>(({ className, ...props }, ref) => (\r\n  <tr\r\n    ref={ref}\r\n    className={cn(\r\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTableRow.displayName = \"TableRow\"\r\n\r\nconst TableHead = React.forwardRef<\r\n  HTMLTableCellElement,\r\n  React.ThHTMLAttributes<HTMLTableCellElement>\r\n>(({ className, ...props }, ref) => (\r\n  <th\r\n    ref={ref}\r\n    className={cn(\r\n      \"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTableHead.displayName = \"TableHead\"\r\n\r\nconst TableCell = React.forwardRef<\r\n  HTMLTableCellElement,\r\n  React.TdHTMLAttributes<HTMLTableCellElement>\r\n>(({ className, ...props }, ref) => (\r\n  <td\r\n    ref={ref}\r\n    className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", className)}\r\n    {...props}\r\n  />\r\n))\r\nTableCell.displayName = \"TableCell\"\r\n\r\nconst TableCaption = React.forwardRef<\r\n  HTMLTableCaptionElement,\r\n  React.HTMLAttributes<HTMLTableCaptionElement>\r\n>(({ className, ...props }, ref) => (\r\n  <caption\r\n    ref={ref}\r\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\r\n    {...props}\r\n  />\r\n))\r\nTableCaption.displayName = \"TableCaption\"\r\n\r\nexport {\r\n  Table,\r\n  TableHeader,\r\n  TableBody,\r\n  TableFooter,\r\n  TableHead,\r\n  TableRow,\r\n  TableCell,\r\n  TableCaption,\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,sBAAQ,2KAAgB,MAG5B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QAAI,WAAU;kBACb,cAAA,6LAAC;YACC,KAAK;YACL,WAAW,IAAA,4HAAE,EAAC,iCAAiC;YAC9C,GAAG,KAAK;;;;;;;;;;;;AAIf,MAAM,WAAW,GAAG;AAEpB,MAAM,4BAAc,2KAAgB,OAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QAAM,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,mBAAmB;QAAa,GAAG,KAAK;;;;;;;AAEzE,YAAY,WAAW,GAAG;AAE1B,MAAM,0BAAY,2KAAgB,OAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,8BAA8B;QAC3C,GAAG,KAAK;;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,4BAAc,2KAAgB,OAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,2DACA;QAED,GAAG,KAAK;;;;;;;AAGb,YAAY,WAAW,GAAG;AAE1B,MAAM,yBAAW,2KAAgB,OAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,+EACA;QAED,GAAG,KAAK;;;;;;;AAGb,SAAS,WAAW,GAAG;AAEvB,MAAM,0BAAY,2KAAgB,QAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,oGACA;QAED,GAAG,KAAK;;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,0BAAY,2KAAgB,QAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,kDAAkD;QAC/D,GAAG,KAAK;;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,6BAAe,2KAAgB,QAGnC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,sCAAsC;QACnD,GAAG,KAAK;;;;;;;AAGb,aAAa,WAAW,GAAG"}},
    {"offset": {"line": 6200, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/cash/TaxCalculator.tsx"],"sourcesContent":["\r\nimport React from 'react';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Label } from '@/components/ui/label';\r\n\r\ninterface TaxCalculatorProps {\r\n  taxPercentage: number;\r\n  onTaxChange: (percentage: number) => void;\r\n  netProfitLoss: number;\r\n  formatCurrency: (amount: number) => string;\r\n}\r\n\r\nconst TaxCalculator: React.FC<TaxCalculatorProps> = ({\r\n  taxPercentage,\r\n  onTaxChange,\r\n  netProfitLoss,\r\n  formatCurrency\r\n}) => {\r\n  const handleTaxChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const value = parseFloat(e.target.value) || 0;\r\n    onTaxChange(Math.max(0, Math.min(100, value))); // Clamp between 0-100\r\n  };\r\n\r\n  const taxAmount = netProfitLoss > 0 ? (netProfitLoss * taxPercentage) / 100 : 0;\r\n\r\n  return (\r\n    <div className=\"flex items-center gap-4 p-4 bg-gray-50 rounded-lg\">\r\n      <div className=\"flex items-center gap-2\">\r\n        <Label htmlFor=\"tax-percentage\" className=\"text-sm font-medium\">\r\n          Tax %:\r\n        </Label>\r\n        <Input\r\n          id=\"tax-percentage\"\r\n          type=\"number\"\r\n          min=\"0\"\r\n          max=\"100\"\r\n          step=\"0.1\"\r\n          value={taxPercentage}\r\n          onChange={handleTaxChange}\r\n          className=\"w-20 h-8 text-center\"\r\n        />\r\n      </div>\r\n      <div className=\"text-sm\">\r\n        <span className=\"text-muted-foreground\">Tax Amount: </span>\r\n        <span className=\"font-medium\">{formatCurrency(taxAmount)}</span>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TaxCalculator;\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;;;;AASA,MAAM,gBAA8C,CAAC,EACnD,aAAa,EACb,WAAW,EACX,aAAa,EACb,cAAc,EACf;IACC,MAAM,kBAAkB,CAAC;QACvB,MAAM,QAAQ,WAAW,EAAE,MAAM,CAAC,KAAK,KAAK;QAC5C,YAAY,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,KAAK,UAAU,sBAAsB;IACxE;IAEA,MAAM,YAAY,gBAAgB,IAAI,AAAC,gBAAgB,gBAAiB,MAAM;IAE9E,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC;gBAAI,WAAU;;kCACb,6LAAC,6IAAK;wBAAC,SAAQ;wBAAiB,WAAU;kCAAsB;;;;;;kCAGhE,6LAAC,6IAAK;wBACJ,IAAG;wBACH,MAAK;wBACL,KAAI;wBACJ,KAAI;wBACJ,MAAK;wBACL,OAAO;wBACP,UAAU;wBACV,WAAU;;;;;;;;;;;;0BAGd,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;wBAAK,WAAU;kCAAwB;;;;;;kCACxC,6LAAC;wBAAK,WAAU;kCAAe,eAAe;;;;;;;;;;;;;;;;;;AAItD;KApCM;uCAsCS"}},
    {"offset": {"line": 6294, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/utils/exportProfitLossToCSV.ts"],"sourcesContent":["\r\nimport { ProfitLossData } from '@/hooks/useProfitLossData';\r\nimport { format } from 'date-fns';\r\n\r\ninterface ExportPLCSVOptions {\r\n  data: ProfitLossData;\r\n  dateRange: { from: Date | undefined; to: Date | undefined };\r\n  currency: string;\r\n  businessName?: string;\r\n  dateFilter?: string;\r\n}\r\n\r\nconst getPeriodDescription = (dateFilter: string | undefined, dateRange: { from: Date | undefined; to: Date | undefined }) => {\r\n  if (dateRange.from && dateRange.to) {\r\n    const isSameMonth = dateRange.from.getMonth() === dateRange.to.getMonth() && \r\n                       dateRange.from.getFullYear() === dateRange.to.getFullYear();\r\n    const isSameDay = dateRange.from.toDateString() === dateRange.to.toDateString();\r\n    \r\n    if (isSameDay) {\r\n      return format(dateRange.from, 'MMM dd, yyyy');\r\n    } else if (isSameMonth && dateFilter === 'this-month') {\r\n      return format(dateRange.from, 'MMMM yyyy');\r\n    } else if (dateFilter === 'this-year') {\r\n      return format(dateRange.from, 'yyyy');\r\n    } else if (dateFilter === 'last-month') {\r\n      return format(dateRange.from, 'MMMM yyyy');\r\n    } else if (dateFilter === 'this-week' || dateFilter === 'last-week') {\r\n      return `Week of ${format(dateRange.from, 'MMM dd')} - ${format(dateRange.to, 'MMM dd, yyyy')}`;\r\n    } else {\r\n      return `Custom Period: ${format(dateRange.from, 'MM/dd/yyyy')} - ${format(dateRange.to, 'MM/dd/yyyy')}`;\r\n    }\r\n  } else if (dateRange.from) {\r\n    return format(dateRange.from, 'MMM dd, yyyy');\r\n  } else {\r\n    return 'All Periods';\r\n  }\r\n};\r\n\r\nexport const exportProfitLossToCSV = (options: ExportPLCSVOptions) => {\r\n  const { data, dateRange, currency, businessName, dateFilter } = options;\r\n\r\n  const formatAmount = (amount: number, showNegativeSign: boolean = false) => {\r\n    if (showNegativeSign && amount < 0) {\r\n      return `-${Math.abs(amount).toFixed(0)}`;\r\n    }\r\n    return amount.toFixed(0);\r\n  };\r\n\r\n  const csvRows: string[] = [];\r\n\r\n  // Header information\r\n  csvRows.push('PROFIT & LOSS ACCOUNT');\r\n  csvRows.push('');\r\n  if (businessName) {\r\n    csvRows.push(`Business,${businessName}`);\r\n  }\r\n  csvRows.push(`Period,${getPeriodDescription(dateFilter, dateRange)}`);\r\n  csvRows.push(`Generated,${format(new Date(), 'MMM dd yyyy HH:mm')}`);\r\n  csvRows.push(`Currency,${currency}`);\r\n  csvRows.push('');\r\n\r\n  // Table headers\r\n  csvRows.push('DETAILS,AMOUNT');\r\n\r\n  // SALES/REVENUE Section\r\n  csvRows.push('');\r\n  csvRows.push('SALES/REVENUE,');\r\n  csvRows.push(`Sales/Revenue,${formatAmount(data.sales)}`);\r\n  csvRows.push(`Sales Returns,(${formatAmount(data.salesReturns)})`);\r\n  csvRows.push(`NET SALES,${formatAmount(data.netSales)}`);\r\n\r\n  // COST OF GOODS SOLD Section\r\n  csvRows.push('');\r\n  csvRows.push('COST OF GOODS SOLD (COGS),');\r\n  csvRows.push(`Total Cost Sales,${formatAmount(data.totalCostSales)}`);\r\n  csvRows.push(`Carriage Inwards,${formatAmount(data.carriageInwards)}`);\r\n  csvRows.push(`TOTAL COST OF GOODS SOLD (COGS),${formatAmount(data.totalCOGS)}`);\r\n\r\n  // GROSS PROFIT\r\n  csvRows.push('');\r\n  csvRows.push(`GROSS PROFIT,${formatAmount(data.grossProfit, true)}`);\r\n\r\n  // EXPENSES Section\r\n  csvRows.push('');\r\n  csvRows.push('EXPENSES,');\r\n  Object.entries(data.expensesByCategory).forEach(([category, amount]) => {\r\n    const categoryName = category.charAt(0).toUpperCase() + category.slice(1).toLowerCase();\r\n    csvRows.push(`${categoryName},${formatAmount(amount)}`);\r\n  });\r\n  csvRows.push(`TOTAL EXPENSES,${formatAmount(data.totalExpenses)}`);\r\n\r\n  // FINAL CALCULATIONS\r\n  csvRows.push('');\r\n  csvRows.push(`NET PROFIT / LOSS,${formatAmount(data.netProfitLoss, true)}`);\r\n  csvRows.push(`Tax (${data.taxPercentage}%),${formatAmount(data.taxAmount)}`);\r\n  csvRows.push(`FINAL PROFIT AFTER TAX,${formatAmount(data.finalProfitAfterTax, true)}`);\r\n\r\n  // Create and download CSV\r\n  const csvContent = csvRows.join('\\n');\r\n  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\r\n  const link = document.createElement('a');\r\n  \r\n  if (link.download !== undefined) {\r\n    const url = URL.createObjectURL(blob);\r\n    link.setAttribute('href', url);\r\n    const fileName = `profit_loss_${dateRange.from ? format(dateRange.from, 'yyyy-MM-dd') : 'current'}_to_${dateRange.to ? format(dateRange.to, 'yyyy-MM-dd') : 'current'}.csv`;\r\n    link.setAttribute('download', fileName);\r\n    link.style.visibility = 'hidden';\r\n    document.body.appendChild(link);\r\n    link.click();\r\n    document.body.removeChild(link);\r\n  }\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6398, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/utils/exportProfitLossToPDF.ts"],"sourcesContent":["import jsPDF from 'jspdf';\r\nimport { ProfitLossData } from '@/hooks/useProfitLossData';\r\nimport { format } from 'date-fns';\r\n\r\ninterface ExportPLPDFOptions {\r\n  data: ProfitLossData;\r\n  dateRange: { from: Date | undefined; to: Date | undefined };\r\n  currency: string;\r\n  businessName?: string;\r\n  businessLogo?: string;\r\n  dateFilter?: string;\r\n}\r\n\r\nconst getPeriodDescription = (dateFilter: string | undefined, dateRange: { from: Date | undefined; to: Date | undefined }) => {\r\n  if (dateRange.from && dateRange.to) {\r\n    const isSameMonth = dateRange.from.getMonth() === dateRange.to.getMonth() && \r\n                       dateRange.from.getFullYear() === dateRange.to.getFullYear();\r\n    const isSameDay = dateRange.from.toDateString() === dateRange.to.toDateString();\r\n    \r\n    if (isSameDay) {\r\n      return format(dateRange.from, 'MMM dd, yyyy');\r\n    } else if (isSameMonth && dateFilter === 'this-month') {\r\n      return format(dateRange.from, 'MMMM yyyy');\r\n    } else if (dateFilter === 'this-year') {\r\n      return format(dateRange.from, 'yyyy');\r\n    } else if (dateFilter === 'last-month') {\r\n      return format(dateRange.from, 'MMMM yyyy');\r\n    } else if (dateFilter === 'this-week' || dateFilter === 'last-week') {\r\n      return `Week of ${format(dateRange.from, 'MMM dd')} - ${format(dateRange.to, 'MMM dd, yyyy')}`;\r\n    } else {\r\n      return `Custom Period: ${format(dateRange.from, 'MM/dd/yyyy')} - ${format(dateRange.to, 'MM/dd/yyyy')}`;\r\n    }\r\n  } else if (dateRange.from) {\r\n    return format(dateRange.from, 'MMM dd, yyyy');\r\n  } else {\r\n    return 'All Periods';\r\n  }\r\n};\r\n\r\nexport const exportProfitLossToPDF = async (options: ExportPLPDFOptions) => {\r\n  const { data, dateRange, currency, businessName, dateFilter } = options;\r\n\r\n  const pdf = new jsPDF({\r\n    orientation: 'portrait',\r\n    unit: 'mm',\r\n    format: 'a4'\r\n  });\r\n\r\n  const pageWidth = pdf.internal.pageSize.getWidth();\r\n  const pageHeight = pdf.internal.pageSize.getHeight();\r\n  const margins = { top: 20, right: 20, bottom: 20, left: 20 };\r\n  \r\n  let currentY = margins.top;\r\n\r\n  // Function to add watermark to current page\r\n  const addWatermark = () => {\r\n    pdf.setFontSize(8);\r\n    pdf.setFont('helvetica', 'normal');\r\n    pdf.setTextColor(150, 150, 150); // Light gray color\r\n    pdf.text('Created By Gonza Systems', pageWidth / 2, pageHeight - 10, { align: 'center' });\r\n    pdf.setTextColor(0, 0, 0); // Reset to black\r\n  };\r\n\r\n  const formatCurrency = (amount: number) => {\r\n    return `${currency} ${amount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;\r\n  };\r\n\r\n  // Business name - centered and bold\r\n  if (businessName) {\r\n    pdf.setFontSize(18);\r\n    pdf.setFont('helvetica', 'bold');\r\n    const businessNameWidth = pdf.getTextWidth(businessName);\r\n    pdf.text(businessName, (pageWidth - businessNameWidth) / 2, currentY);\r\n    currentY += 10; // Reduced from 12\r\n  }\r\n\r\n  // Report title - centered and bold\r\n  pdf.setFontSize(16);\r\n  pdf.setFont('helvetica', 'bold');\r\n  const title = 'Profit & Loss Account';\r\n  const titleWidth = pdf.getTextWidth(title);\r\n  pdf.text(title, (pageWidth - titleWidth) / 2, currentY);\r\n  currentY += 8; // Reduced from 10\r\n\r\n  // Date range - centered (This is the report period, not generation date)\r\n  pdf.setFontSize(11);\r\n  pdf.setFont('helvetica', 'normal');\r\n  const periodText = getPeriodDescription(dateFilter, dateRange);\r\n  const periodWidth = pdf.getTextWidth(periodText);\r\n  pdf.text(periodText, (pageWidth - periodWidth) / 2, currentY);\r\n  currentY += 15;\r\n\r\n  // Helper function to add a section header\r\n  const addSectionHeader = (title: string) => {\r\n    if (currentY > pageHeight - 40) {\r\n      addWatermark(); // Add watermark to current page before creating new one\r\n      pdf.addPage();\r\n      currentY = margins.top;\r\n    }\r\n    \r\n    pdf.setFontSize(12);\r\n    pdf.setFont('helvetica', 'bold');\r\n    pdf.text(title, margins.left, currentY);\r\n    currentY += 6; // Reduced from 8\r\n  };\r\n\r\n  // Helper function to add a row\r\n  const addRow = (label: string, amount: number | null, options: { \r\n    isBold?: boolean; \r\n    isSubtraction?: boolean; \r\n    isTotal?: boolean;\r\n    indent?: boolean;\r\n    showNegativeSign?: boolean;\r\n  } = {}) => {\r\n    const { isBold = false, isSubtraction = false, isTotal = false, indent = false, showNegativeSign = false } = options;\r\n    \r\n    if (currentY > pageHeight - 25) { // Reduced threshold from 30\r\n      addWatermark(); // Add watermark to current page before creating new one\r\n      pdf.addPage();\r\n      currentY = margins.top;\r\n    }\r\n\r\n    pdf.setFontSize(10);\r\n    pdf.setFont('helvetica', isBold ? 'bold' : 'normal');\r\n    \r\n    const labelX = indent ? margins.left + 10 : margins.left;\r\n    pdf.text(label, labelX, currentY);\r\n    \r\n    if (amount !== null) {\r\n      let amountText;\r\n      if (showNegativeSign && amount < 0) {\r\n        amountText = `-${formatCurrency(Math.abs(amount))}`;\r\n      } else if (isSubtraction) {\r\n        amountText = `(${formatCurrency(Math.abs(amount))})`;\r\n      } else {\r\n        amountText = formatCurrency(Math.abs(amount));\r\n      }\r\n      const amountWidth = pdf.getTextWidth(amountText);\r\n      pdf.text(amountText, pageWidth - margins.right - amountWidth, currentY);\r\n    }\r\n    \r\n    // Add line for totals\r\n    if (isTotal) {\r\n      pdf.setLineWidth(0.3);\r\n      pdf.line(margins.left, currentY + 2, pageWidth - margins.right, currentY + 2);\r\n      currentY += 2; // Reduced from 3\r\n    }\r\n    \r\n    currentY += 5; // Reduced from 6\r\n  };\r\n\r\n  // Add spacer with reduced height\r\n  const addSpacer = (height: number = 3) => { // Reduced default from 4\r\n    currentY += height;\r\n  };\r\n\r\n  // SALES/REVENUE Section\r\n  addSectionHeader('SALES/REVENUE');\r\n  addRow('Sales/Revenue', data.sales, { indent: true });\r\n  addRow('Sales Returns', data.salesReturns, { isSubtraction: true, indent: true });\r\n  addRow('NET SALES', data.netSales, { isBold: true, isTotal: true });\r\n  \r\n  addSpacer(5); // Reduced from 8\r\n  \r\n  // COST OF GOODS SOLD Section\r\n  addSectionHeader('COST OF GOODS SOLD (COGS)');\r\n  addRow('Total Cost Sales', data.totalCostSales, { indent: true });\r\n  addRow('Carriage Inwards', data.carriageInwards, { indent: true });\r\n  addRow('TOTAL COST OF GOODS SOLD (COGS)', data.totalCOGS, { isBold: true, isTotal: true });\r\n  \r\n  addSpacer(5); // Reduced from 8\r\n  \r\n  // GROSS PROFIT\r\n  addRow('GROSS PROFIT', data.grossProfit, { isBold: true, isTotal: true, showNegativeSign: true });\r\n  \r\n  addSpacer(3); // Reduced from 4\r\n  \r\n  // EXPENSES Section\r\n  addSectionHeader('EXPENSES');\r\n  Object.entries(data.expensesByCategory).forEach(([category, amount]) => {\r\n    addRow(category.charAt(0).toUpperCase() + category.slice(1).toLowerCase(), amount, { indent: true });\r\n  });\r\n  addRow('TOTAL EXPENSES', data.totalExpenses, { isBold: true, isTotal: true });\r\n  \r\n  addSpacer(5); // Reduced from 8\r\n  \r\n  // FINAL CALCULATIONS\r\n  addRow('NET PROFIT / LOSS', data.netProfitLoss, { isBold: true, isTotal: true, showNegativeSign: true });\r\n  addRow(`Tax (${data.taxPercentage}%)`, data.taxAmount, { indent: true });\r\n  addRow('FINAL PROFIT AFTER TAX', data.finalProfitAfterTax, { isBold: true, isTotal: true, showNegativeSign: true });\r\n\r\n  // Add watermark to the final page\r\n  addWatermark();\r\n\r\n  // Save the PDF\r\n  const fileName = `profit_loss_${dateRange.from ? format(dateRange.from, 'yyyy-MM-dd') : 'current'}_to_${dateRange.to ? format(dateRange.to, 'yyyy-MM-dd') : 'current'}.pdf`;\r\n  pdf.save(fileName);\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6604, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/cash/PLExportButton.tsx"],"sourcesContent":["\r\nimport React, { useState } from 'react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';\r\nimport { Download, FileText, File } from 'lucide-react';\r\nimport { ProfitLossData } from '@/hooks/useProfitLossData';\r\nimport { exportProfitLossToCSV } from '@/utils/exportProfitLossToCSV';\r\nimport { exportProfitLossToPDF } from '@/utils/exportProfitLossToPDF';\r\nimport { useToast } from '@/hooks/use-toast';\r\n\r\ninterface PLExportButtonProps {\r\n  data: ProfitLossData;\r\n  dateRange: { from: Date | undefined; to: Date | undefined };\r\n  currency: string;\r\n  businessName?: string;\r\n  businessLogo?: string;\r\n  dateFilter?: string;\r\n}\r\n\r\nconst PLExportButton: React.FC<PLExportButtonProps> = ({ \r\n  data, \r\n  dateRange, \r\n  currency, \r\n  businessName, \r\n  businessLogo,\r\n  dateFilter \r\n}) => {\r\n  const [isExporting, setIsExporting] = useState(false);\r\n  const { toast } = useToast();\r\n\r\n  const handleExportCSV = async () => {\r\n    try {\r\n      setIsExporting(true);\r\n      exportProfitLossToCSV({\r\n        data,\r\n        dateRange,\r\n        currency,\r\n        businessName,\r\n        dateFilter\r\n      });\r\n      toast({\r\n        title: \"Export Successful\",\r\n        description: \"Profit & Loss Account exported to CSV successfully.\",\r\n      });\r\n    } catch (error) {\r\n      console.error('Error exporting CSV:', error);\r\n      toast({\r\n        title: \"Export Failed\",\r\n        description: \"Failed to export Profit & Loss Account to CSV.\",\r\n        variant: \"destructive\",\r\n      });\r\n    } finally {\r\n      setIsExporting(false);\r\n    }\r\n  };\r\n\r\n  const handleExportPDF = async () => {\r\n    try {\r\n      setIsExporting(true);\r\n      await exportProfitLossToPDF({\r\n        data,\r\n        dateRange,\r\n        currency,\r\n        businessName,\r\n        businessLogo,\r\n        dateFilter\r\n      });\r\n      toast({\r\n        title: \"Export Successful\",\r\n        description: \"Profit & Loss Account exported to PDF successfully.\",\r\n      });\r\n    } catch (error) {\r\n      console.error('Error exporting PDF:', error);\r\n      toast({\r\n        title: \"Export Failed\",\r\n        description: \"Failed to export Profit & Loss Account to PDF.\",\r\n        variant: \"destructive\",\r\n      });\r\n    } finally {\r\n      setIsExporting(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <DropdownMenu>\r\n      <DropdownMenuTrigger asChild>\r\n        <Button variant=\"outline\" size=\"sm\" disabled={isExporting}>\r\n          <Download className=\"h-4 w-4 mr-2\" />\r\n          Export\r\n        </Button>\r\n      </DropdownMenuTrigger>\r\n      <DropdownMenuContent>\r\n        <DropdownMenuItem onClick={handleExportCSV} disabled={isExporting}>\r\n          <File className=\"h-4 w-4 mr-2\" />\r\n          Export as CSV\r\n        </DropdownMenuItem>\r\n        <DropdownMenuItem onClick={handleExportPDF} disabled={isExporting}>\r\n          <FileText className=\"h-4 w-4 mr-2\" />\r\n          Export as PDF\r\n        </DropdownMenuItem>\r\n      </DropdownMenuContent>\r\n    </DropdownMenu>\r\n  );\r\n};\r\n\r\nexport default PLExportButton;\r\n"],"names":[],"mappings":";;;;;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;;;;;;;;;;AAWA,MAAM,iBAAgD,CAAC,EACrD,IAAI,EACJ,SAAS,EACT,QAAQ,EACR,YAAY,EACZ,YAAY,EACZ,UAAU,EACX;;IACC,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,yKAAQ,EAAC;IAC/C,MAAM,EAAE,KAAK,EAAE,GAAG,IAAA,2IAAQ;IAE1B,MAAM,kBAAkB;QACtB,IAAI;YACF,eAAe;YACf,IAAA,iKAAqB,EAAC;gBACpB;gBACA;gBACA;gBACA;gBACA;YACF;YACA,MAAM;gBACJ,OAAO;gBACP,aAAa;YACf;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wBAAwB;YACtC,MAAM;gBACJ,OAAO;gBACP,aAAa;gBACb,SAAS;YACX;QACF,SAAU;YACR,eAAe;QACjB;IACF;IAEA,MAAM,kBAAkB;QACtB,IAAI;YACF,eAAe;YACf,MAAM,IAAA,iKAAqB,EAAC;gBAC1B;gBACA;gBACA;gBACA;gBACA;gBACA;YACF;YACA,MAAM;gBACJ,OAAO;gBACP,aAAa;YACf;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wBAAwB;YACtC,MAAM;gBACJ,OAAO;gBACP,aAAa;gBACb,SAAS;YACX;QACF,SAAU;YACR,eAAe;QACjB;IACF;IAEA,qBACE,6LAAC,+JAAY;;0BACX,6LAAC,sKAAmB;gBAAC,OAAO;0BAC1B,cAAA,6LAAC,+IAAM;oBAAC,SAAQ;oBAAU,MAAK;oBAAK,UAAU;;sCAC5C,6LAAC,yNAAQ;4BAAC,WAAU;;;;;;wBAAiB;;;;;;;;;;;;0BAIzC,6LAAC,sKAAmB;;kCAClB,6LAAC,mKAAgB;wBAAC,SAAS;wBAAiB,UAAU;;0CACpD,6LAAC,6MAAI;gCAAC,WAAU;;;;;;4BAAiB;;;;;;;kCAGnC,6LAAC,mKAAgB;wBAAC,SAAS;wBAAiB,UAAU;;0CACpD,6LAAC,6NAAQ;gCAAC,WAAU;;;;;;4BAAiB;;;;;;;;;;;;;;;;;;;AAM/C;GApFM;;QASc,2IAAQ;;;KATtB;uCAsFS"}},
    {"offset": {"line": 6777, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/cash/ProfitLossTable.tsx"],"sourcesContent":["\r\nimport React from 'react';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';\r\nimport { Skeleton } from '@/components/ui/skeleton';\r\nimport { ProfitLossData } from '@/hooks/useProfitLossData';\r\nimport TaxCalculator from './TaxCalculator';\r\nimport PLExportButton from './PLExportButton';\r\n\r\ninterface ProfitLossTableProps {\r\n  data: ProfitLossData;\r\n  isLoading: boolean;\r\n  formatCurrency: (amount: number) => string;\r\n  onTaxChange: (percentage: number) => void;\r\n  dateRange: { from: Date | undefined; to: Date | undefined };\r\n  businessName?: string;\r\n  businessLogo?: string;\r\n  currency: string;\r\n  dateFilter?: string;\r\n}\r\n\r\nconst ProfitLossTable: React.FC<ProfitLossTableProps> = ({ \r\n  data, \r\n  isLoading, \r\n  formatCurrency, \r\n  onTaxChange, \r\n  dateRange, \r\n  businessName, \r\n  businessLogo, \r\n  currency,\r\n  dateFilter \r\n}) => {\r\n  if (isLoading) {\r\n    return (\r\n      <Card>\r\n        <CardHeader>\r\n          <CardTitle>Profit & Loss Account</CardTitle>\r\n        </CardHeader>\r\n        <CardContent>\r\n          <div className=\"space-y-3\">\r\n            {[...Array(15)].map((_, i) => (\r\n              <Skeleton key={i} className=\"h-8 w-full\" />\r\n            ))}\r\n          </div>\r\n        </CardContent>\r\n      </Card>\r\n    );\r\n  }\r\n\r\n  const tableRows = [\r\n    // Sales Section\r\n    { detail: 'SALES/REVENUE', amount: data.sales, isBold: true },\r\n    { detail: 'SALES RETURNS', amount: data.salesReturns, isSubtraction: true },\r\n    { detail: 'NET SALES', amount: data.netSales, isBold: true, isTotal: true },\r\n    \r\n    // Spacer\r\n    { detail: '', amount: null, isSpacer: true },\r\n    \r\n    // COGS Section - Updated structure with new formula\r\n    { detail: 'COST OF GOODS SOLD (COGS)', amount: null, isHeader: true },\r\n    { detail: 'TOTAL COST SALES', amount: data.totalCostSales },\r\n    { detail: 'CARRIAGE INWARDS', amount: data.carriageInwards },\r\n    { detail: 'TOTAL COST OF GOODS SOLD (COGS)', amount: data.totalCOGS, isBold: true, isTotal: true },\r\n    \r\n    // Spacer\r\n    { detail: '', amount: null, isSpacer: true },\r\n    \r\n    // Gross Profit\r\n    { detail: 'GROSS PROFIT', amount: data.grossProfit, isBold: true, isTotal: true },\r\n    \r\n    // Spacer\r\n    { detail: '', amount: null, isSpacer: true },\r\n    \r\n    // Expenses Section\r\n    { detail: 'EXPENSES', amount: null, isHeader: true },\r\n  ];\r\n\r\n  // Add expense categories\r\n  Object.entries(data.expensesByCategory).forEach(([category, amount]) => {\r\n    tableRows.push({\r\n      detail: category.toUpperCase(),\r\n      amount: amount\r\n    });\r\n  });\r\n\r\n  // Continue with totals\r\n  tableRows.push(\r\n    { detail: 'TOTAL EXPENSES', amount: data.totalExpenses, isBold: true, isTotal: true },\r\n    { detail: '', amount: null, isSpacer: true },\r\n    { detail: 'NET PROFIT / LOSS', amount: data.netProfitLoss, isBold: true, isTotal: true },\r\n    { detail: 'TAX', amount: data.taxAmount },\r\n    { detail: 'FINAL PROFIT AFTER TAX', amount: data.finalProfitAfterTax, isBold: true, isTotal: true }\r\n  );\r\n\r\n  const getRowColor = (row: any) => {\r\n    if (row.amount < 0) return 'text-red-600';\r\n    if (row.detail?.includes('PROFIT') && row.amount > 0) return 'text-green-600';\r\n    if (row.detail?.includes('EXPENSE') || row.detail?.includes('TAX')) return 'text-red-600';\r\n    return 'text-gray-900';\r\n  };\r\n\r\n  return (\r\n    <Card>\r\n      <CardHeader>\r\n        <div className=\"flex justify-between items-center\">\r\n          <CardTitle>Profit & Loss Account</CardTitle>\r\n              <PLExportButton\r\n                data={data}\r\n                dateRange={dateRange}\r\n                currency={currency}\r\n                businessName={businessName}\r\n                businessLogo={businessLogo}\r\n                dateFilter={dateFilter}\r\n              />\r\n        </div>\r\n      </CardHeader>\r\n      <CardContent className=\"space-y-4\">\r\n        <TaxCalculator\r\n          taxPercentage={data.taxPercentage}\r\n          onTaxChange={onTaxChange}\r\n          netProfitLoss={data.netProfitLoss}\r\n          formatCurrency={formatCurrency}\r\n        />\r\n        \r\n        <div className=\"overflow-x-auto\">\r\n          <Table>\r\n            <TableHeader>\r\n              <TableRow>\r\n                <TableHead className=\"font-bold text-left\">DETAILS</TableHead>\r\n                <TableHead className=\"font-bold text-right\">AMOUNT</TableHead>\r\n              </TableRow>\r\n            </TableHeader>\r\n            <TableBody>\r\n              {tableRows.map((row, index) => {\r\n                if (row.isSpacer) {\r\n                  return (\r\n                    <TableRow key={index}>\r\n                      <TableCell colSpan={2} className=\"h-4 border-0\"></TableCell>\r\n                    </TableRow>\r\n                  );\r\n                }\r\n\r\n                if (row.isHeader) {\r\n                  return (\r\n                    <TableRow key={index}>\r\n                      <TableCell colSpan={2} className=\"font-bold text-gray-800 bg-gray-50 border-0\">\r\n                        {row.detail}\r\n                      </TableCell>\r\n                    </TableRow>\r\n                  );\r\n                }\r\n\r\n                return (\r\n                  <TableRow key={index} className={row.isTotal ? 'border-t-2 border-gray-300' : ''}>\r\n                    <TableCell className={`${row.isBold ? 'font-bold' : ''} ${getRowColor(row)}`}>\r\n                      {row.detail}\r\n                    </TableCell>\r\n                    <TableCell className={`text-right ${row.isBold ? 'font-bold' : ''} ${getRowColor(row)}`}>\r\n                      {row.amount !== null ? (\r\n                        <span>\r\n                          {row.isSubtraction && '('}\r\n                          {formatCurrency(Math.abs(row.amount))}\r\n                          {row.isSubtraction && ')'}\r\n                        </span>\r\n                      ) : null}\r\n                    </TableCell>\r\n                  </TableRow>\r\n                );\r\n              })}\r\n            </TableBody>\r\n          </Table>\r\n        </div>\r\n        \r\n        {/* Summary Cards */}\r\n        <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4 mt-6\">\r\n          <Card className=\"border-blue-200 bg-blue-50\">\r\n            <CardContent className=\"p-4 text-center\">\r\n              <p className=\"text-sm text-blue-600 font-medium\">Gross Profit</p>\r\n              <p className=\"text-lg font-bold text-blue-800\">{formatCurrency(data.grossProfit)}</p>\r\n            </CardContent>\r\n          </Card>\r\n          \r\n          <Card className={`border-${data.netProfitLoss >= 0 ? 'green' : 'red'}-200 bg-${data.netProfitLoss >= 0 ? 'green' : 'red'}-50`}>\r\n            <CardContent className=\"p-4 text-center\">\r\n              <p className={`text-sm text-${data.netProfitLoss >= 0 ? 'green' : 'red'}-600 font-medium`}>\r\n                Net {data.netProfitLoss >= 0 ? 'Profit' : 'Loss'}\r\n              </p>\r\n              <p className={`text-lg font-bold text-${data.netProfitLoss >= 0 ? 'green' : 'red'}-800`}>\r\n                {formatCurrency(Math.abs(data.netProfitLoss))}\r\n              </p>\r\n            </CardContent>\r\n          </Card>\r\n          \r\n          <Card className={`border-${data.finalProfitAfterTax >= 0 ? 'green' : 'red'}-200 bg-${data.finalProfitAfterTax >= 0 ? 'green' : 'red'}-50`}>\r\n            <CardContent className=\"p-4 text-center\">\r\n              <p className={`text-sm text-${data.finalProfitAfterTax >= 0 ? 'green' : 'red'}-600 font-medium`}>\r\n                Final {data.finalProfitAfterTax >= 0 ? 'Profit' : 'Loss'} After Tax\r\n              </p>\r\n              <p className={`text-lg font-bold text-${data.finalProfitAfterTax >= 0 ? 'green' : 'red'}-800`}>\r\n                {formatCurrency(Math.abs(data.finalProfitAfterTax))}\r\n              </p>\r\n            </CardContent>\r\n          </Card>\r\n        </div>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n};\r\n\r\nexport default ProfitLossTable;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7252, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/cash/ProfitLossTab.tsx"],"sourcesContent":["\r\nimport React, { useState, useMemo, useEffect } from 'react';\r\nimport { useProfitLossData } from '@/hooks/useProfitLossData';\r\nimport { useBusinessSettings } from '@/hooks/useBusinessSettings';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport DateRangeFilter from '@/components/analytics/DateRangeFilter';\r\nimport ProfitLossTable from './ProfitLossTable';\r\nimport { getDateRangeFromFilter } from '@/utils/dateFilters';\r\n\r\nconst ProfitLossTab = () => {\r\n  const { currentBusiness } = useBusiness();\r\n  const { settings } = useBusinessSettings();\r\n  \r\n  // Date filter state - default to current month\r\n  const [dateFilter, setDateFilter] = useState('this-month');\r\n  const [dateRange, setDateRange] = useState<{ from: Date | undefined; to: Date | undefined }>({ from: undefined, to: undefined });\r\n  const [specificDate, setSpecificDate] = useState<Date | undefined>(undefined);\r\n\r\n  // Tax percentage state\r\n  const [taxPercentage, setTaxPercentage] = useState(0);\r\n\r\n  // Calculate derived states based on dateFilter\r\n  const isCustomRange = dateFilter === 'custom';\r\n  const isSpecificDate = dateFilter === 'specific';\r\n\r\n  // Reset relevant states when filter changes\r\n  useEffect(() => {\r\n    if (dateFilter === 'custom') {\r\n      // Clear specific date when switching to custom\r\n      setSpecificDate(undefined);\r\n    } else if (dateFilter === 'specific') {\r\n      // Clear date range when switching to specific\r\n      setDateRange({ from: undefined, to: undefined });\r\n    } else {\r\n      // Clear both when switching to predefined filters\r\n      setDateRange({ from: undefined, to: undefined });\r\n      setSpecificDate(undefined);\r\n    }\r\n  }, [dateFilter]);\r\n\r\n  // Get the currency from settings, defaulting to USD only if settings is null\r\n  const currency = settings?.currency || 'USD';\r\n\r\n  // Get profit & loss data using same parameters as sold items report\r\n  const { profitLossData, isLoading } = useProfitLossData(dateFilter, dateRange, specificDate, taxPercentage);\r\n\r\n  // Calculate the effective date range for exports (either custom range or calculated from filter)\r\n  const effectiveDateRange = useMemo(() => {\r\n    if (dateFilter === 'custom' && dateRange.from && dateRange.to) {\r\n      return dateRange;\r\n    } else if (dateFilter === 'specific' && specificDate) {\r\n      return { from: specificDate, to: specificDate };\r\n    } else if (dateFilter !== 'custom' && dateFilter !== 'specific') {\r\n      return getDateRangeFromFilter(dateFilter);\r\n    }\r\n    return { from: undefined, to: undefined };\r\n  }, [dateFilter, dateRange, specificDate]);\r\n\r\n  // Format currency function using the settings currency\r\n  const formatCurrency = (amount: number) => {\r\n    return new Intl.NumberFormat('en-US', {\r\n      style: 'currency',\r\n      currency: currency,\r\n      minimumFractionDigits: 2,\r\n    }).format(amount);\r\n  };\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      <div>\r\n        <h2 className=\"text-xl font-semibold mb-4\">Profit & Loss Account</h2>\r\n        <DateRangeFilter\r\n          dateFilter={dateFilter}\r\n          dateRange={dateRange}\r\n          specificDate={specificDate}\r\n          isCustomRange={isCustomRange}\r\n          isSpecificDate={isSpecificDate}\r\n          onDateFilterChange={setDateFilter}\r\n          onDateRangeChange={setDateRange}\r\n          onSpecificDateChange={setSpecificDate}\r\n        />\r\n      </div>\r\n\r\n      <ProfitLossTable\r\n        data={profitLossData}\r\n        isLoading={isLoading}\r\n        formatCurrency={formatCurrency}\r\n        onTaxChange={setTaxPercentage}\r\n        dateRange={effectiveDateRange}\r\n        businessName={currentBusiness?.name}\r\n        businessLogo={settings?.businessLogo}\r\n        currency={currency}\r\n        dateFilter={dateFilter}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ProfitLossTab;\r\n"],"names":[],"mappings":";;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAEA,MAAM,gBAAgB;;IACpB,MAAM,EAAE,eAAe,EAAE,GAAG,IAAA,qJAAW;IACvC,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAA,6JAAmB;IAExC,+CAA+C;IAC/C,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,yKAAQ,EAAC;IAC7C,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAmD;QAAE,MAAM;QAAW,IAAI;IAAU;IAC9H,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,yKAAQ,EAAmB;IAEnE,uBAAuB;IACvB,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,yKAAQ,EAAC;IAEnD,+CAA+C;IAC/C,MAAM,gBAAgB,eAAe;IACrC,MAAM,iBAAiB,eAAe;IAEtC,4CAA4C;IAC5C,IAAA,0KAAS;mCAAC;YACR,IAAI,eAAe,UAAU;gBAC3B,+CAA+C;gBAC/C,gBAAgB;YAClB,OAAO,IAAI,eAAe,YAAY;gBACpC,8CAA8C;gBAC9C,aAAa;oBAAE,MAAM;oBAAW,IAAI;gBAAU;YAChD,OAAO;gBACL,kDAAkD;gBAClD,aAAa;oBAAE,MAAM;oBAAW,IAAI;gBAAU;gBAC9C,gBAAgB;YAClB;QACF;kCAAG;QAAC;KAAW;IAEf,6EAA6E;IAC7E,MAAM,WAAW,UAAU,YAAY;IAEvC,oEAAoE;IACpE,MAAM,EAAE,cAAc,EAAE,SAAS,EAAE,GAAG,IAAA,yJAAiB,EAAC,YAAY,WAAW,cAAc;IAE7F,iGAAiG;IACjG,MAAM,qBAAqB,IAAA,wKAAO;qDAAC;YACjC,IAAI,eAAe,YAAY,UAAU,IAAI,IAAI,UAAU,EAAE,EAAE;gBAC7D,OAAO;YACT,OAAO,IAAI,eAAe,cAAc,cAAc;gBACpD,OAAO;oBAAE,MAAM;oBAAc,IAAI;gBAAa;YAChD,OAAO,IAAI,eAAe,YAAY,eAAe,YAAY;gBAC/D,OAAO,IAAA,wJAAsB,EAAC;YAChC;YACA,OAAO;gBAAE,MAAM;gBAAW,IAAI;YAAU;QAC1C;oDAAG;QAAC;QAAY;QAAW;KAAa;IAExC,uDAAuD;IACvD,MAAM,iBAAiB,CAAC;QACtB,OAAO,IAAI,KAAK,YAAY,CAAC,SAAS;YACpC,OAAO;YACP,UAAU;YACV,uBAAuB;QACzB,GAAG,MAAM,CAAC;IACZ;IAEA,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC;;kCACC,6LAAC;wBAAG,WAAU;kCAA6B;;;;;;kCAC3C,6LAAC,gKAAe;wBACd,YAAY;wBACZ,WAAW;wBACX,cAAc;wBACd,eAAe;wBACf,gBAAgB;wBAChB,oBAAoB;wBACpB,mBAAmB;wBACnB,sBAAsB;;;;;;;;;;;;0BAI1B,6LAAC,2JAAe;gBACd,MAAM;gBACN,WAAW;gBACX,gBAAgB;gBAChB,aAAa;gBACb,WAAW;gBACX,cAAc,iBAAiB;gBAC/B,cAAc,UAAU;gBACxB,UAAU;gBACV,YAAY;;;;;;;;;;;;AAIpB;GAvFM;;QACwB,qJAAW;QAClB,6JAAmB;QAiCF,yJAAiB;;;KAnCnD;uCAyFS"}},
    {"offset": {"line": 7421, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/cash/CashContent.tsx"],"sourcesContent":["import React from 'react';\r\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\r\nimport CashAccountsHeader from '@/components/cash/CashAccountsHeader';\r\nimport CashAccountsList from '@/components/cash/CashAccountsList';\r\nimport CashAccountDialog from '@/components/cash/CashAccountDialog';\r\nimport ProfitLossTab from '@/components/cash/ProfitLossTab';\r\nimport { CashAccount, CashAccountFormData } from '@/types/cash';\r\n\r\ninterface CashContentProps {\r\n  accounts: CashAccount[];\r\n  isLoading: boolean;\r\n  isDialogOpen: boolean;\r\n  onDialogOpenChange: (open: boolean) => void;\r\n  onCreateAccount: (data: CashAccountFormData) => Promise<void>;\r\n  onAccountDeleted: () => Promise<void>;\r\n  canCreate?: boolean;\r\n}\r\n\r\nconst CashContent: React.FC<CashContentProps> = ({\r\n  accounts,\r\n  isLoading,\r\n  isDialogOpen,\r\n  onDialogOpenChange,\r\n  onCreateAccount,\r\n  onAccountDeleted,\r\n  canCreate = true\r\n}) => {\r\n  const [isSubmitting, setIsSubmitting] = React.useState(false);\r\n\r\n  const handleOpenDialog = () => onDialogOpenChange(true);\r\n\r\n  const handleCreateAccount = async (data: CashAccountFormData) => {\r\n    setIsSubmitting(true);\r\n    try {\r\n      await onCreateAccount(data);\r\n    } finally {\r\n      setIsSubmitting(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Tabs defaultValue=\"cash-accounts\" className=\"w-full\">\r\n      <TabsList className=\"grid w-full grid-cols-2\">\r\n        <TabsTrigger value=\"cash-accounts\">Cash Accounts</TabsTrigger>\r\n        <TabsTrigger value=\"profit-loss\">Profit & Loss</TabsTrigger>\r\n      </TabsList>\r\n\r\n      <TabsContent value=\"cash-accounts\" className=\"space-y-6\">\r\n        <CashAccountsHeader onCreateAccount={handleOpenDialog} canCreate={canCreate} />\r\n\r\n        <CashAccountsList\r\n          accounts={accounts}\r\n          isLoading={isLoading}\r\n          onCreateAccount={handleOpenDialog}\r\n          onAccountDeleted={onAccountDeleted}\r\n          canCreate={canCreate}\r\n        />\r\n\r\n        <CashAccountDialog\r\n          open={isDialogOpen}\r\n          onOpenChange={onDialogOpenChange}\r\n          onSubmit={handleCreateAccount}\r\n          title=\"Create New Cash Account\"\r\n          isSubmitting={isSubmitting}\r\n        />\r\n      </TabsContent>\r\n\r\n      <TabsContent value=\"profit-loss\">\r\n        <ProfitLossTab />\r\n      </TabsContent>\r\n    </Tabs>\r\n  );\r\n};\r\n\r\nexport default CashContent;"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAaA,MAAM,cAA0C,CAAC,EAC/C,QAAQ,EACR,SAAS,EACT,YAAY,EACZ,kBAAkB,EAClB,eAAe,EACf,gBAAgB,EAChB,YAAY,IAAI,EACjB;;IACC,MAAM,CAAC,cAAc,gBAAgB,GAAG,wKAAK,CAAC,QAAQ,CAAC;IAEvD,MAAM,mBAAmB,IAAM,mBAAmB;IAElD,MAAM,sBAAsB,OAAO;QACjC,gBAAgB;QAChB,IAAI;YACF,MAAM,gBAAgB;QACxB,SAAU;YACR,gBAAgB;QAClB;IACF;IAEA,qBACE,6LAAC,2IAAI;QAAC,cAAa;QAAgB,WAAU;;0BAC3C,6LAAC,+IAAQ;gBAAC,WAAU;;kCAClB,6LAAC,kJAAW;wBAAC,OAAM;kCAAgB;;;;;;kCACnC,6LAAC,kJAAW;wBAAC,OAAM;kCAAc;;;;;;;;;;;;0BAGnC,6LAAC,kJAAW;gBAAC,OAAM;gBAAgB,WAAU;;kCAC3C,6LAAC,8JAAkB;wBAAC,iBAAiB;wBAAkB,WAAW;;;;;;kCAElE,6LAAC,4JAAgB;wBACf,UAAU;wBACV,WAAW;wBACX,iBAAiB;wBACjB,kBAAkB;wBAClB,WAAW;;;;;;kCAGb,6LAAC,6JAAiB;wBAChB,MAAM;wBACN,cAAc;wBACd,UAAU;wBACV,OAAM;wBACN,cAAc;;;;;;;;;;;;0BAIlB,6LAAC,kJAAW;gBAAC,OAAM;0BACjB,cAAA,6LAAC,yJAAa;;;;;;;;;;;;;;;;AAItB;GAtDM;KAAA;uCAwDS"}},
    {"offset": {"line": 7552, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useCashAccountRedirect.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { CashAccount } from '@/types/cash';\r\n\r\nexport const useCashAccountRedirect = (accounts: CashAccount[]) => {\r\n  const navigate = useNavigate();\r\n  const [hasCheckedRedirect, setHasCheckedRedirect] = useState(false);\r\n\r\n  // Check for last visited cash account and redirect if found\r\n  useEffect(() => {\r\n    if (!hasCheckedRedirect && accounts.length > 0) {\r\n      const lastVisitedAccountId = localStorage.getItem('lastVisitedCashAccount');\r\n      const lastVisitedUrl = localStorage.getItem('lastVisitedCashAccountUrl');\r\n      \r\n      if (lastVisitedAccountId && lastVisitedUrl) {\r\n        // Verify the account still exists\r\n        const accountExists = accounts.some(acc => acc.id === lastVisitedAccountId);\r\n        if (accountExists) {\r\n          // Use the complete URL to preserve filters and pagination\r\n          navigate(lastVisitedUrl.replace(window.location.origin, ''));\r\n          return;\r\n        } else {\r\n          // Clean up invalid stored account data\r\n          localStorage.removeItem('lastVisitedCashAccount');\r\n          localStorage.removeItem('lastVisitedCashAccountUrl');\r\n        }\r\n      }\r\n      setHasCheckedRedirect(true);\r\n    }\r\n  }, [accounts, hasCheckedRedirect, navigate]);\r\n\r\n  return { hasCheckedRedirect };\r\n};"],"names":[],"mappings":";;;;AAAA;AACA;;;;AAGO,MAAM,yBAAyB,CAAC;;IACrC,MAAM,WAAW,IAAA,kLAAW;IAC5B,MAAM,CAAC,oBAAoB,sBAAsB,GAAG,IAAA,yKAAQ,EAAC;IAE7D,4DAA4D;IAC5D,IAAA,0KAAS;4CAAC;YACR,IAAI,CAAC,sBAAsB,SAAS,MAAM,GAAG,GAAG;gBAC9C,MAAM,uBAAuB,aAAa,OAAO,CAAC;gBAClD,MAAM,iBAAiB,aAAa,OAAO,CAAC;gBAE5C,IAAI,wBAAwB,gBAAgB;oBAC1C,kCAAkC;oBAClC,MAAM,gBAAgB,SAAS,IAAI;0EAAC,CAAA,MAAO,IAAI,EAAE,KAAK;;oBACtD,IAAI,eAAe;wBACjB,0DAA0D;wBAC1D,SAAS,eAAe,OAAO,CAAC,OAAO,QAAQ,CAAC,MAAM,EAAE;wBACxD;oBACF,OAAO;wBACL,uCAAuC;wBACvC,aAAa,UAAU,CAAC;wBACxB,aAAa,UAAU,CAAC;oBAC1B;gBACF;gBACA,sBAAsB;YACxB;QACF;2CAAG;QAAC;QAAU;QAAoB;KAAS;IAE3C,OAAO;QAAE;IAAmB;AAC9B;GA5Ba;;QACM,kLAAW"}},
    {"offset": {"line": 7610, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/pages/Cash.tsx"],"sourcesContent":["\r\nimport React, { useState } from 'react';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useCashAccounts } from '@/hooks/useCashAccounts';\r\nimport CashContent from '@/components/cash/CashContent';\r\nimport { CashAccountFormData } from '@/types/cash';\r\nimport { useCashAccountRedirect } from '@/hooks/useCashAccountRedirect';\r\nimport { useProfiles } from '@/contexts/ProfileContext';\r\nimport { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';\r\nimport { Button } from '@/components/ui/button';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { AlertCircle } from 'lucide-react';\r\n\r\nconst Cash = () => {\r\n  const { currentBusiness, isLoading: businessLoading } = useBusiness();\r\n  const navigate = useNavigate();\r\n  const { accounts, isLoading, createAccount, refreshAccounts } = useCashAccounts();\r\n  const { hasPermission, isLoading: profilesLoading } = useProfiles();\r\n  const [isDialogOpen, setIsDialogOpen] = useState(false);\r\n\r\n  // Handle redirect to last visited cash account\r\n  useCashAccountRedirect(accounts);\r\n\r\n  const handleCreateAccount = async (data: CashAccountFormData) => {\r\n    try {\r\n      await createAccount(data);\r\n      setIsDialogOpen(false);\r\n    } catch (error) {\r\n      console.error('Error creating account:', error);\r\n    }\r\n  };\r\n\r\n  const handleAccountDeleted = async () => {\r\n    // Refresh accounts list when an account is deleted\r\n    await refreshAccounts();\r\n  };\r\n\r\n  if (businessLoading || isLoading || profilesLoading) {\r\n    return (\r\n      <div className=\"flex items-center justify-center min-h-[400px]\">\r\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary\"></div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!hasPermission('finance', 'view')) {\r\n    return (\r\n      <div className=\"max-w-4xl mx-auto p-6\">\r\n        <Alert variant=\"destructive\">\r\n          <AlertCircle className=\"h-4 w-4\" />\r\n          <AlertTitle>Access Denied</AlertTitle>\r\n          <AlertDescription>\r\n            You do not have permission to view finance/cash accounts.\r\n            Please contact your administrator if you believe this is an error.\r\n          </AlertDescription>\r\n        </Alert>\r\n        <div className=\"mt-4\">\r\n          <Button onClick={() => navigate('/')} variant=\"outline\">\r\n            Back to Dashboard\r\n          </Button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const canCreate = hasPermission('finance', 'create');\r\n\r\n  return (\r\n    <div className=\"space-y-6 p-4 md:p-0\">\r\n      <h1 className=\"text-2xl md:text-3xl font-bold\">Finance</h1>\r\n\r\n      <CashContent\r\n        accounts={accounts}\r\n        isLoading={businessLoading || !currentBusiness || isLoading}\r\n        isDialogOpen={isDialogOpen}\r\n        onDialogOpenChange={setIsDialogOpen}\r\n        onCreateAccount={handleCreateAccount}\r\n        onAccountDeleted={handleAccountDeleted}\r\n        canCreate={canCreate}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Cash;\r\n"],"names":[],"mappings":";;;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAEA,MAAM,OAAO;;IACX,MAAM,EAAE,eAAe,EAAE,WAAW,eAAe,EAAE,GAAG,IAAA,qJAAW;IACnE,MAAM,WAAW,IAAA,kLAAW;IAC5B,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,aAAa,EAAE,eAAe,EAAE,GAAG,IAAA,qJAAe;IAC/E,MAAM,EAAE,aAAa,EAAE,WAAW,eAAe,EAAE,GAAG,IAAA,oJAAW;IACjE,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,yKAAQ,EAAC;IAEjD,+CAA+C;IAC/C,IAAA,mKAAsB,EAAC;IAEvB,MAAM,sBAAsB,OAAO;QACjC,IAAI;YACF,MAAM,cAAc;YACpB,gBAAgB;QAClB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2BAA2B;QAC3C;IACF;IAEA,MAAM,uBAAuB;QAC3B,mDAAmD;QACnD,MAAM;IACR;IAEA,IAAI,mBAAmB,aAAa,iBAAiB;QACnD,qBACE,6LAAC;YAAI,WAAU;sBACb,cAAA,6LAAC;gBAAI,WAAU;;;;;;;;;;;IAGrB;IAEA,IAAI,CAAC,cAAc,WAAW,SAAS;QACrC,qBACE,6LAAC;YAAI,WAAU;;8BACb,6LAAC,6IAAK;oBAAC,SAAQ;;sCACb,6LAAC,sOAAW;4BAAC,WAAU;;;;;;sCACvB,6LAAC,kJAAU;sCAAC;;;;;;sCACZ,6LAAC,wJAAgB;sCAAC;;;;;;;;;;;;8BAKpB,6LAAC;oBAAI,WAAU;8BACb,cAAA,6LAAC,+IAAM;wBAAC,SAAS,IAAM,SAAS;wBAAM,SAAQ;kCAAU;;;;;;;;;;;;;;;;;IAMhE;IAEA,MAAM,YAAY,cAAc,WAAW;IAE3C,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC;gBAAG,WAAU;0BAAiC;;;;;;0BAE/C,6LAAC,uJAAW;gBACV,UAAU;gBACV,WAAW,mBAAmB,CAAC,mBAAmB;gBAClD,cAAc;gBACd,oBAAoB;gBACpB,iBAAiB;gBACjB,kBAAkB;gBAClB,WAAW;;;;;;;;;;;;AAInB;GArEM;;QACoD,qJAAW;QAClD,kLAAW;QACoC,qJAAe;QACzB,oJAAW;QAIjE,mKAAsB;;;KARlB;uCAuES"}}]
}