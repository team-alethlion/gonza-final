{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgCsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/customers.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getCustomerStatsAction(userId: string, branchId: string) {\r\n    try {\r\n        const thisMonth = new Date();\r\n        const startOfMonth = new Date(thisMonth.getFullYear(), thisMonth.getMonth(), 1);\r\n\r\n        // 1. Count customers created this month\r\n        const thisMonthCount = await db.customer.count({\r\n            where: {\r\n                // Assuming we use agencyId for userId if they are an owner, or it's connected somehow\r\n                // For now, focusing on branchId as that's normally the tenant isolation in the schema\r\n                branchId: branchId,\r\n                createdAt: {\r\n                    gte: startOfMonth\r\n                }\r\n            }\r\n        });\r\n\r\n        // 2. Count customers with upcoming backgrounds (for now just count those who have a birthday set)\r\n        const withBirthdays = await db.customer.count({\r\n            where: {\r\n                branchId: branchId,\r\n                birthday: {\r\n                    not: null\r\n                }\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                withBirthdays,\r\n                thisMonth: thisMonthCount\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function mergeCustomersAction(primaryCustomerId: string, duplicateIds: string[]) {\r\n    try {\r\n        if (!primaryCustomerId || duplicateIds.length === 0) {\r\n            return { success: false, error: 'Invalid selection' };\r\n        }\r\n\r\n        // Use a transaction to ensure all operations succeed or fail together\r\n        await db.$transaction(async (tx: any) => {\r\n            // 1. Update sales to point to primary customer\r\n            // In Prisma, assuming relation is through customerId\r\n            await tx.sale.updateMany({\r\n                where: {\r\n                    customerId: {\r\n                        in: duplicateIds\r\n                    }\r\n                },\r\n                data: {\r\n                    customerId: primaryCustomerId\r\n                }\r\n            });\r\n\r\n            // Note: The original code also updated messages. \r\n            // If there's a Message model connected to customers, add it here.\r\n            // await tx.message.updateMany({\r\n            //     where: { customerId: { in: duplicateIds } },\r\n            //     data: { customerId: primaryCustomerId }\r\n            // });\r\n\r\n            // 3. Delete duplicate customers\r\n            await tx.customer.deleteMany({\r\n                where: {\r\n                    id: {\r\n                        in: duplicateIds\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Revalidate customers list\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error merging customers:', error);\r\n        return { success: false, error: error.message || 'Failed to merge customers' };\r\n    }\r\n}\r\n\r\nexport async function getCustomersAction(branchId: string) {\r\n    try {\r\n        const customers = await db.customer.findMany({\r\n            where: { branchId },\r\n            orderBy: { fullName: 'asc' }\r\n        });\r\n\r\n        const count = await db.customer.count({\r\n            where: { branchId }\r\n        });\r\n\r\n        // Map Prisma Customer model to the shape expected by useCustomers hook\r\n        const mappedCustomers = customers.map((c: any) => ({\r\n            id: c.id,\r\n            fullName: c.fullName,\r\n            phoneNumber: c.phoneNumber,\r\n            email: c.email,\r\n            birthday: c.birthday ? c.birthday.toISOString() : null,\r\n            gender: c.gender,\r\n            location: c.location,\r\n            categoryId: c.categoryId,\r\n            notes: c.notes,\r\n            tags: c.tags || [],\r\n            socialMedia: c.socialMedia || null,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: { customers: mappedCustomers, count } };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customers:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerAction(branchId: string, userId: string, data: any) {\r\n    try {\r\n        const newCustomer = await db.customer.create({\r\n            data: {\r\n                branchId: branchId,\r\n                userId: userId, // Assuming user who created it\r\n                fullName: data.fullName,\r\n                phoneNumber: data.phoneNumber || null,\r\n                email: data.email || null,\r\n                birthday: data.birthday ? new Date(data.birthday) : null,\r\n                gender: data.gender || null,\r\n                location: data.location || null,\r\n                categoryId: data.categoryId || null,\r\n                notes: data.notes || null,\r\n                tags: data.tags || [],\r\n                socialMedia: data.socialMedia || null\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerAction(customerId: string, data: any) {\r\n    try {\r\n        const updateData: any = {};\r\n        if (data.fullName !== undefined) updateData.fullName = data.fullName;\r\n        if (data.phoneNumber !== undefined) updateData.phoneNumber = data.phoneNumber;\r\n        if (data.email !== undefined) updateData.email = data.email;\r\n        if (data.birthday !== undefined) updateData.birthday = data.birthday ? new Date(data.birthday) : null;\r\n        if (data.gender !== undefined) updateData.gender = data.gender;\r\n        if (data.location !== undefined) updateData.location = data.location;\r\n        if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;\r\n        if (data.notes !== undefined) updateData.notes = data.notes;\r\n        if (data.tags !== undefined) updateData.tags = data.tags;\r\n        if (data.socialMedia !== undefined) updateData.socialMedia = data.socialMedia;\r\n\r\n        const updatedCustomer = await db.customer.update({\r\n            where: { id: customerId },\r\n            data: updateData\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerAction(customerId: string) {\r\n    try {\r\n        await db.customer.delete({\r\n            where: { id: customerId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCustomerCategoriesAction(branchId: string) {\r\n    try {\r\n        const categories = await db.customerCategory.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const formattedCategories = categories.map((c: any) => ({\r\n            id: c.id,\r\n            name: c.name,\r\n            isDefault: c.isDefault,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: formattedCategories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerCategoryAction(branchId: string, userId: string, name: string) {\r\n    try {\r\n        const newCategory = await db.customerCategory.create({\r\n            data: {\r\n                branchId: branchId,\r\n                name: name.trim(),\r\n                isDefault: false,\r\n                userId: userId\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCategory };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerCategoryAction(categoryId: string, name: string) {\r\n    try {\r\n        const updatedCategory = await db.customerCategory.update({\r\n            where: { id: categoryId },\r\n            data: { name: name.trim() }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCategory };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerCategoryAction(categoryId: string) {\r\n    try {\r\n        await db.customerCategory.delete({\r\n            where: { id: categoryId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA4FsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,sDAAA"}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/customers.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getCustomerStatsAction(userId: string, branchId: string) {\r\n    try {\r\n        const thisMonth = new Date();\r\n        const startOfMonth = new Date(thisMonth.getFullYear(), thisMonth.getMonth(), 1);\r\n\r\n        // 1. Count customers created this month\r\n        const thisMonthCount = await db.customer.count({\r\n            where: {\r\n                // Assuming we use agencyId for userId if they are an owner, or it's connected somehow\r\n                // For now, focusing on branchId as that's normally the tenant isolation in the schema\r\n                branchId: branchId,\r\n                createdAt: {\r\n                    gte: startOfMonth\r\n                }\r\n            }\r\n        });\r\n\r\n        // 2. Count customers with upcoming backgrounds (for now just count those who have a birthday set)\r\n        const withBirthdays = await db.customer.count({\r\n            where: {\r\n                branchId: branchId,\r\n                birthday: {\r\n                    not: null\r\n                }\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                withBirthdays,\r\n                thisMonth: thisMonthCount\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function mergeCustomersAction(primaryCustomerId: string, duplicateIds: string[]) {\r\n    try {\r\n        if (!primaryCustomerId || duplicateIds.length === 0) {\r\n            return { success: false, error: 'Invalid selection' };\r\n        }\r\n\r\n        // Use a transaction to ensure all operations succeed or fail together\r\n        await db.$transaction(async (tx: any) => {\r\n            // 1. Update sales to point to primary customer\r\n            // In Prisma, assuming relation is through customerId\r\n            await tx.sale.updateMany({\r\n                where: {\r\n                    customerId: {\r\n                        in: duplicateIds\r\n                    }\r\n                },\r\n                data: {\r\n                    customerId: primaryCustomerId\r\n                }\r\n            });\r\n\r\n            // Note: The original code also updated messages. \r\n            // If there's a Message model connected to customers, add it here.\r\n            // await tx.message.updateMany({\r\n            //     where: { customerId: { in: duplicateIds } },\r\n            //     data: { customerId: primaryCustomerId }\r\n            // });\r\n\r\n            // 3. Delete duplicate customers\r\n            await tx.customer.deleteMany({\r\n                where: {\r\n                    id: {\r\n                        in: duplicateIds\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Revalidate customers list\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error merging customers:', error);\r\n        return { success: false, error: error.message || 'Failed to merge customers' };\r\n    }\r\n}\r\n\r\nexport async function getCustomersAction(branchId: string) {\r\n    try {\r\n        const customers = await db.customer.findMany({\r\n            where: { branchId },\r\n            orderBy: { fullName: 'asc' }\r\n        });\r\n\r\n        const count = await db.customer.count({\r\n            where: { branchId }\r\n        });\r\n\r\n        // Map Prisma Customer model to the shape expected by useCustomers hook\r\n        const mappedCustomers = customers.map((c: any) => ({\r\n            id: c.id,\r\n            fullName: c.fullName,\r\n            phoneNumber: c.phoneNumber,\r\n            email: c.email,\r\n            birthday: c.birthday ? c.birthday.toISOString() : null,\r\n            gender: c.gender,\r\n            location: c.location,\r\n            categoryId: c.categoryId,\r\n            notes: c.notes,\r\n            tags: c.tags || [],\r\n            socialMedia: c.socialMedia || null,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: { customers: mappedCustomers, count } };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customers:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerAction(branchId: string, userId: string, data: any) {\r\n    try {\r\n        const newCustomer = await db.customer.create({\r\n            data: {\r\n                branchId: branchId,\r\n                userId: userId, // Assuming user who created it\r\n                fullName: data.fullName,\r\n                phoneNumber: data.phoneNumber || null,\r\n                email: data.email || null,\r\n                birthday: data.birthday ? new Date(data.birthday) : null,\r\n                gender: data.gender || null,\r\n                location: data.location || null,\r\n                categoryId: data.categoryId || null,\r\n                notes: data.notes || null,\r\n                tags: data.tags || [],\r\n                socialMedia: data.socialMedia || null\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerAction(customerId: string, data: any) {\r\n    try {\r\n        const updateData: any = {};\r\n        if (data.fullName !== undefined) updateData.fullName = data.fullName;\r\n        if (data.phoneNumber !== undefined) updateData.phoneNumber = data.phoneNumber;\r\n        if (data.email !== undefined) updateData.email = data.email;\r\n        if (data.birthday !== undefined) updateData.birthday = data.birthday ? new Date(data.birthday) : null;\r\n        if (data.gender !== undefined) updateData.gender = data.gender;\r\n        if (data.location !== undefined) updateData.location = data.location;\r\n        if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;\r\n        if (data.notes !== undefined) updateData.notes = data.notes;\r\n        if (data.tags !== undefined) updateData.tags = data.tags;\r\n        if (data.socialMedia !== undefined) updateData.socialMedia = data.socialMedia;\r\n\r\n        const updatedCustomer = await db.customer.update({\r\n            where: { id: customerId },\r\n            data: updateData\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerAction(customerId: string) {\r\n    try {\r\n        await db.customer.delete({\r\n            where: { id: customerId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCustomerCategoriesAction(branchId: string) {\r\n    try {\r\n        const categories = await db.customerCategory.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const formattedCategories = categories.map((c: any) => ({\r\n            id: c.id,\r\n            name: c.name,\r\n            isDefault: c.isDefault,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: formattedCategories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerCategoryAction(branchId: string, userId: string, name: string) {\r\n    try {\r\n        const newCategory = await db.customerCategory.create({\r\n            data: {\r\n                branchId: branchId,\r\n                name: name.trim(),\r\n                isDefault: false,\r\n                userId: userId\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCategory };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerCategoryAction(categoryId: string, name: string) {\r\n    try {\r\n        const updatedCategory = await db.customerCategory.update({\r\n            where: { id: categoryId },\r\n            data: { name: name.trim() }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCategory };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerCategoryAction(categoryId: string) {\r\n    try {\r\n        await db.customerCategory.delete({\r\n            where: { id: categoryId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA+HsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/customers.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getCustomerStatsAction(userId: string, branchId: string) {\r\n    try {\r\n        const thisMonth = new Date();\r\n        const startOfMonth = new Date(thisMonth.getFullYear(), thisMonth.getMonth(), 1);\r\n\r\n        // 1. Count customers created this month\r\n        const thisMonthCount = await db.customer.count({\r\n            where: {\r\n                // Assuming we use agencyId for userId if they are an owner, or it's connected somehow\r\n                // For now, focusing on branchId as that's normally the tenant isolation in the schema\r\n                branchId: branchId,\r\n                createdAt: {\r\n                    gte: startOfMonth\r\n                }\r\n            }\r\n        });\r\n\r\n        // 2. Count customers with upcoming backgrounds (for now just count those who have a birthday set)\r\n        const withBirthdays = await db.customer.count({\r\n            where: {\r\n                branchId: branchId,\r\n                birthday: {\r\n                    not: null\r\n                }\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                withBirthdays,\r\n                thisMonth: thisMonthCount\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function mergeCustomersAction(primaryCustomerId: string, duplicateIds: string[]) {\r\n    try {\r\n        if (!primaryCustomerId || duplicateIds.length === 0) {\r\n            return { success: false, error: 'Invalid selection' };\r\n        }\r\n\r\n        // Use a transaction to ensure all operations succeed or fail together\r\n        await db.$transaction(async (tx: any) => {\r\n            // 1. Update sales to point to primary customer\r\n            // In Prisma, assuming relation is through customerId\r\n            await tx.sale.updateMany({\r\n                where: {\r\n                    customerId: {\r\n                        in: duplicateIds\r\n                    }\r\n                },\r\n                data: {\r\n                    customerId: primaryCustomerId\r\n                }\r\n            });\r\n\r\n            // Note: The original code also updated messages. \r\n            // If there's a Message model connected to customers, add it here.\r\n            // await tx.message.updateMany({\r\n            //     where: { customerId: { in: duplicateIds } },\r\n            //     data: { customerId: primaryCustomerId }\r\n            // });\r\n\r\n            // 3. Delete duplicate customers\r\n            await tx.customer.deleteMany({\r\n                where: {\r\n                    id: {\r\n                        in: duplicateIds\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Revalidate customers list\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error merging customers:', error);\r\n        return { success: false, error: error.message || 'Failed to merge customers' };\r\n    }\r\n}\r\n\r\nexport async function getCustomersAction(branchId: string) {\r\n    try {\r\n        const customers = await db.customer.findMany({\r\n            where: { branchId },\r\n            orderBy: { fullName: 'asc' }\r\n        });\r\n\r\n        const count = await db.customer.count({\r\n            where: { branchId }\r\n        });\r\n\r\n        // Map Prisma Customer model to the shape expected by useCustomers hook\r\n        const mappedCustomers = customers.map((c: any) => ({\r\n            id: c.id,\r\n            fullName: c.fullName,\r\n            phoneNumber: c.phoneNumber,\r\n            email: c.email,\r\n            birthday: c.birthday ? c.birthday.toISOString() : null,\r\n            gender: c.gender,\r\n            location: c.location,\r\n            categoryId: c.categoryId,\r\n            notes: c.notes,\r\n            tags: c.tags || [],\r\n            socialMedia: c.socialMedia || null,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: { customers: mappedCustomers, count } };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customers:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerAction(branchId: string, userId: string, data: any) {\r\n    try {\r\n        const newCustomer = await db.customer.create({\r\n            data: {\r\n                branchId: branchId,\r\n                userId: userId, // Assuming user who created it\r\n                fullName: data.fullName,\r\n                phoneNumber: data.phoneNumber || null,\r\n                email: data.email || null,\r\n                birthday: data.birthday ? new Date(data.birthday) : null,\r\n                gender: data.gender || null,\r\n                location: data.location || null,\r\n                categoryId: data.categoryId || null,\r\n                notes: data.notes || null,\r\n                tags: data.tags || [],\r\n                socialMedia: data.socialMedia || null\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerAction(customerId: string, data: any) {\r\n    try {\r\n        const updateData: any = {};\r\n        if (data.fullName !== undefined) updateData.fullName = data.fullName;\r\n        if (data.phoneNumber !== undefined) updateData.phoneNumber = data.phoneNumber;\r\n        if (data.email !== undefined) updateData.email = data.email;\r\n        if (data.birthday !== undefined) updateData.birthday = data.birthday ? new Date(data.birthday) : null;\r\n        if (data.gender !== undefined) updateData.gender = data.gender;\r\n        if (data.location !== undefined) updateData.location = data.location;\r\n        if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;\r\n        if (data.notes !== undefined) updateData.notes = data.notes;\r\n        if (data.tags !== undefined) updateData.tags = data.tags;\r\n        if (data.socialMedia !== undefined) updateData.socialMedia = data.socialMedia;\r\n\r\n        const updatedCustomer = await db.customer.update({\r\n            where: { id: customerId },\r\n            data: updateData\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerAction(customerId: string) {\r\n    try {\r\n        await db.customer.delete({\r\n            where: { id: customerId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCustomerCategoriesAction(branchId: string) {\r\n    try {\r\n        const categories = await db.customerCategory.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const formattedCategories = categories.map((c: any) => ({\r\n            id: c.id,\r\n            name: c.name,\r\n            isDefault: c.isDefault,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: formattedCategories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerCategoryAction(branchId: string, userId: string, name: string) {\r\n    try {\r\n        const newCategory = await db.customerCategory.create({\r\n            data: {\r\n                branchId: branchId,\r\n                name: name.trim(),\r\n                isDefault: false,\r\n                userId: userId\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCategory };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerCategoryAction(categoryId: string, name: string) {\r\n    try {\r\n        const updatedCategory = await db.customerCategory.update({\r\n            where: { id: categoryId },\r\n            data: { name: name.trim() }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCategory };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerCategoryAction(categoryId: string) {\r\n    try {\r\n        await db.customerCategory.delete({\r\n            where: { id: categoryId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAyJsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/customers.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getCustomerStatsAction(userId: string, branchId: string) {\r\n    try {\r\n        const thisMonth = new Date();\r\n        const startOfMonth = new Date(thisMonth.getFullYear(), thisMonth.getMonth(), 1);\r\n\r\n        // 1. Count customers created this month\r\n        const thisMonthCount = await db.customer.count({\r\n            where: {\r\n                // Assuming we use agencyId for userId if they are an owner, or it's connected somehow\r\n                // For now, focusing on branchId as that's normally the tenant isolation in the schema\r\n                branchId: branchId,\r\n                createdAt: {\r\n                    gte: startOfMonth\r\n                }\r\n            }\r\n        });\r\n\r\n        // 2. Count customers with upcoming backgrounds (for now just count those who have a birthday set)\r\n        const withBirthdays = await db.customer.count({\r\n            where: {\r\n                branchId: branchId,\r\n                birthday: {\r\n                    not: null\r\n                }\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                withBirthdays,\r\n                thisMonth: thisMonthCount\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function mergeCustomersAction(primaryCustomerId: string, duplicateIds: string[]) {\r\n    try {\r\n        if (!primaryCustomerId || duplicateIds.length === 0) {\r\n            return { success: false, error: 'Invalid selection' };\r\n        }\r\n\r\n        // Use a transaction to ensure all operations succeed or fail together\r\n        await db.$transaction(async (tx: any) => {\r\n            // 1. Update sales to point to primary customer\r\n            // In Prisma, assuming relation is through customerId\r\n            await tx.sale.updateMany({\r\n                where: {\r\n                    customerId: {\r\n                        in: duplicateIds\r\n                    }\r\n                },\r\n                data: {\r\n                    customerId: primaryCustomerId\r\n                }\r\n            });\r\n\r\n            // Note: The original code also updated messages. \r\n            // If there's a Message model connected to customers, add it here.\r\n            // await tx.message.updateMany({\r\n            //     where: { customerId: { in: duplicateIds } },\r\n            //     data: { customerId: primaryCustomerId }\r\n            // });\r\n\r\n            // 3. Delete duplicate customers\r\n            await tx.customer.deleteMany({\r\n                where: {\r\n                    id: {\r\n                        in: duplicateIds\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Revalidate customers list\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error merging customers:', error);\r\n        return { success: false, error: error.message || 'Failed to merge customers' };\r\n    }\r\n}\r\n\r\nexport async function getCustomersAction(branchId: string) {\r\n    try {\r\n        const customers = await db.customer.findMany({\r\n            where: { branchId },\r\n            orderBy: { fullName: 'asc' }\r\n        });\r\n\r\n        const count = await db.customer.count({\r\n            where: { branchId }\r\n        });\r\n\r\n        // Map Prisma Customer model to the shape expected by useCustomers hook\r\n        const mappedCustomers = customers.map((c: any) => ({\r\n            id: c.id,\r\n            fullName: c.fullName,\r\n            phoneNumber: c.phoneNumber,\r\n            email: c.email,\r\n            birthday: c.birthday ? c.birthday.toISOString() : null,\r\n            gender: c.gender,\r\n            location: c.location,\r\n            categoryId: c.categoryId,\r\n            notes: c.notes,\r\n            tags: c.tags || [],\r\n            socialMedia: c.socialMedia || null,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: { customers: mappedCustomers, count } };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customers:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerAction(branchId: string, userId: string, data: any) {\r\n    try {\r\n        const newCustomer = await db.customer.create({\r\n            data: {\r\n                branchId: branchId,\r\n                userId: userId, // Assuming user who created it\r\n                fullName: data.fullName,\r\n                phoneNumber: data.phoneNumber || null,\r\n                email: data.email || null,\r\n                birthday: data.birthday ? new Date(data.birthday) : null,\r\n                gender: data.gender || null,\r\n                location: data.location || null,\r\n                categoryId: data.categoryId || null,\r\n                notes: data.notes || null,\r\n                tags: data.tags || [],\r\n                socialMedia: data.socialMedia || null\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerAction(customerId: string, data: any) {\r\n    try {\r\n        const updateData: any = {};\r\n        if (data.fullName !== undefined) updateData.fullName = data.fullName;\r\n        if (data.phoneNumber !== undefined) updateData.phoneNumber = data.phoneNumber;\r\n        if (data.email !== undefined) updateData.email = data.email;\r\n        if (data.birthday !== undefined) updateData.birthday = data.birthday ? new Date(data.birthday) : null;\r\n        if (data.gender !== undefined) updateData.gender = data.gender;\r\n        if (data.location !== undefined) updateData.location = data.location;\r\n        if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;\r\n        if (data.notes !== undefined) updateData.notes = data.notes;\r\n        if (data.tags !== undefined) updateData.tags = data.tags;\r\n        if (data.socialMedia !== undefined) updateData.socialMedia = data.socialMedia;\r\n\r\n        const updatedCustomer = await db.customer.update({\r\n            where: { id: customerId },\r\n            data: updateData\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerAction(customerId: string) {\r\n    try {\r\n        await db.customer.delete({\r\n            where: { id: customerId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCustomerCategoriesAction(branchId: string) {\r\n    try {\r\n        const categories = await db.customerCategory.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const formattedCategories = categories.map((c: any) => ({\r\n            id: c.id,\r\n            name: c.name,\r\n            isDefault: c.isDefault,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: formattedCategories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerCategoryAction(branchId: string, userId: string, name: string) {\r\n    try {\r\n        const newCategory = await db.customerCategory.create({\r\n            data: {\r\n                branchId: branchId,\r\n                name: name.trim(),\r\n                isDefault: false,\r\n                userId: userId\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCategory };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerCategoryAction(categoryId: string, name: string) {\r\n    try {\r\n        const updatedCategory = await db.customerCategory.update({\r\n            where: { id: categoryId },\r\n            data: { name: name.trim() }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCategory };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerCategoryAction(categoryId: string) {\r\n    try {\r\n        await db.customerCategory.delete({\r\n            where: { id: categoryId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAmLsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            locationId: updates.businessId,\r\n            productId: updated.id,\r\n            previousQuantity: current.stock,\r\n            newQuantity: updates.quantity,\r\n            changeReason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qDAAA"}},
    {"offset": {"line": 123, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            locationId: updates.businessId,\r\n            productId: updated.id,\r\n            previousQuantity: current.stock,\r\n            newQuantity: updates.quantity,\r\n            changeReason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgJsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            locationId: updates.businessId,\r\n            productId: updated.id,\r\n            previousQuantity: current.stock,\r\n            newQuantity: updates.quantity,\r\n            changeReason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA+NsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            locationId: updates.businessId,\r\n            productId: updated.id,\r\n            previousQuantity: current.stock,\r\n            newQuantity: updates.quantity,\r\n            changeReason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA8RsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 174, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            locationId: updates.businessId,\r\n            productId: updated.id,\r\n            previousQuantity: current.stock,\r\n            newQuantity: updates.quantity,\r\n            changeReason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA2SsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            locationId: updates.businessId,\r\n            productId: updated.id,\r\n            previousQuantity: current.stock,\r\n            newQuantity: updates.quantity,\r\n            changeReason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0GsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,0DAAA"}},
    {"offset": {"line": 208, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/sales.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getSalesAction(businessId: string, sortOrder: 'asc' | 'desc' = 'desc', pageSize?: number) {\r\n    try {\r\n        const queryOptions: any = {\r\n            where: {\r\n                branchId: businessId,\r\n            },\r\n            orderBy: {\r\n                createdAt: sortOrder,\r\n            },\r\n            include: {\r\n                cashTransaction: true,\r\n            }\r\n        };\r\n\r\n        if (pageSize && pageSize > 0) {\r\n            queryOptions.take = pageSize;\r\n        }\r\n\r\n        const sales = await db.sale.findMany(queryOptions);\r\n\r\n        // Provide default mappings to existing React components\r\n        return sales.map((item: any) => ({\r\n            id: item.id,\r\n            user_id: item.userId,\r\n            location_id: item.branchId,\r\n            receipt_number: item.receiptNumber,\r\n            customer_name: item.customerName,\r\n            customer_address: item.customerAddress,\r\n            customer_contact: item.customerContact,\r\n            customer_id: item.customerId,\r\n            items: item.items as any, // jsonb type\r\n            payment_status: item.paymentStatus,\r\n            profit: item.profit,\r\n            date: item.date.toISOString(),\r\n            tax_rate: item.taxRate ? Number(item.taxRate) : 0,\r\n            created_at: item.createdAt.toISOString(),\r\n            updated_at: item.updatedAt.toISOString(),\r\n            cash_transaction_id: item.cashTransactionId,\r\n            amount_paid: item.amountPaid,\r\n            amount_due: item.amountDue,\r\n            category_id: item.categoryId,\r\n            notes: item.notes\r\n        }));\r\n    } catch (error) {\r\n        console.error('Error fetching sales:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function deleteSaleAction(id: string, businessId: string) {\r\n    try {\r\n        const sale = await db.sale.findUnique({\r\n            where: { id },\r\n            include: { cashTransaction: true, installments: true }\r\n        });\r\n\r\n        if (!sale || sale.branchId !== businessId) {\r\n            return { success: false, error: 'Sale not found or unauthorized' };\r\n        }\r\n\r\n        // Delete installments\r\n        if (sale.installments && sale.installments.length > 0) {\r\n            await db.installmentPayment.deleteMany({\r\n                where: { saleId: id }\r\n            });\r\n        }\r\n\r\n        // Delete associated cash transaction\r\n        if (sale.cashTransactionId) {\r\n            await db.cashTransaction.delete({\r\n                where: { id: sale.cashTransactionId }\r\n            });\r\n        }\r\n\r\n        // Delete the sale itself\r\n        await db.sale.delete({\r\n            where: { id }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            sale: {\r\n                receiptNumber: sale.receiptNumber,\r\n                customerName: sale.customerName,\r\n                customerAddress: sale.customerAddress,\r\n                customerContact: sale.customerContact,\r\n                paymentStatus: sale.paymentStatus,\r\n                cashTransactionId: sale.cashTransactionId,\r\n                items: sale.items as any,\r\n                amountPaid: sale.amountPaid,\r\n                amountDue: sale.amountDue,\r\n                profit: sale.profit,\r\n                taxRate: sale.taxRate,\r\n                notes: sale.notes\r\n            }\r\n        };\r\n    } catch (error) {\r\n        console.error('Error deleting sale:', error);\r\n        return { success: false, error: 'Failed to delete sale' };\r\n    }\r\n}\r\n\r\nexport async function upsertSaleAction(saleDbData: any, isUpdate: boolean, updateId?: string) {\r\n    try {\r\n        const prismaData = {\r\n            userId: saleDbData.user_id,\r\n            branchId: saleDbData.location_id,\r\n            receiptNumber: saleDbData.receipt_number,\r\n            customerName: saleDbData.customer_name,\r\n            customerAddress: saleDbData.customer_address,\r\n            customerContact: saleDbData.customer_contact,\r\n            customerId: saleDbData.customer_id,\r\n            items: saleDbData.items,\r\n            paymentStatus: saleDbData.payment_status,\r\n            profit: saleDbData.profit,\r\n            date: new Date(saleDbData.date),\r\n            taxRate: saleDbData.tax_rate,\r\n            cashTransactionId: saleDbData.cash_transaction_id,\r\n            amountPaid: saleDbData.amount_paid,\r\n            amountDue: saleDbData.amount_due,\r\n            categoryId: saleDbData.category_id,\r\n            notes: saleDbData.notes\r\n        };\r\n\r\n        if (isUpdate && updateId) {\r\n            const updated = await db.sale.update({\r\n                where: { id: updateId },\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: updated };\r\n        } else {\r\n            const created = await db.sale.create({\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: created };\r\n        }\r\n    } catch (error: any) {\r\n        console.error('Error upserting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to preserve sale' };\r\n    }\r\n}\r\n\r\nexport async function createReceiptAction(saleData: any, businessId: string, userId: string) {\r\n    try {\r\n        const created = await db.sale.create({\r\n            data: {\r\n                userId: userId,\r\n                branchId: businessId,\r\n                receiptNumber: saleData.receiptNumber,\r\n                customerName: saleData.customerName,\r\n                customerId: saleData.customerId,\r\n                date: new Date(saleData.date),\r\n                items: saleData.items,\r\n                paymentStatus: saleData.paymentStatus,\r\n                profit: saleData.profit,\r\n                amountPaid: saleData.amountPaid,\r\n                amountDue: saleData.amountDue,\r\n                cashAccountId: saleData.cashAccountId,\r\n                notes: saleData.notes\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        revalidatePath('/customers');\r\n\r\n        return { success: true, data: created };\r\n    } catch (error: any) {\r\n        console.error('Error creating receipt:', error);\r\n        return { success: false, error: error.message || 'Failed to create receipt' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,kDAAA"}},
    {"offset": {"line": 225, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/sales.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getSalesAction(businessId: string, sortOrder: 'asc' | 'desc' = 'desc', pageSize?: number) {\r\n    try {\r\n        const queryOptions: any = {\r\n            where: {\r\n                branchId: businessId,\r\n            },\r\n            orderBy: {\r\n                createdAt: sortOrder,\r\n            },\r\n            include: {\r\n                cashTransaction: true,\r\n            }\r\n        };\r\n\r\n        if (pageSize && pageSize > 0) {\r\n            queryOptions.take = pageSize;\r\n        }\r\n\r\n        const sales = await db.sale.findMany(queryOptions);\r\n\r\n        // Provide default mappings to existing React components\r\n        return sales.map((item: any) => ({\r\n            id: item.id,\r\n            user_id: item.userId,\r\n            location_id: item.branchId,\r\n            receipt_number: item.receiptNumber,\r\n            customer_name: item.customerName,\r\n            customer_address: item.customerAddress,\r\n            customer_contact: item.customerContact,\r\n            customer_id: item.customerId,\r\n            items: item.items as any, // jsonb type\r\n            payment_status: item.paymentStatus,\r\n            profit: item.profit,\r\n            date: item.date.toISOString(),\r\n            tax_rate: item.taxRate ? Number(item.taxRate) : 0,\r\n            created_at: item.createdAt.toISOString(),\r\n            updated_at: item.updatedAt.toISOString(),\r\n            cash_transaction_id: item.cashTransactionId,\r\n            amount_paid: item.amountPaid,\r\n            amount_due: item.amountDue,\r\n            category_id: item.categoryId,\r\n            notes: item.notes\r\n        }));\r\n    } catch (error) {\r\n        console.error('Error fetching sales:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function deleteSaleAction(id: string, businessId: string) {\r\n    try {\r\n        const sale = await db.sale.findUnique({\r\n            where: { id },\r\n            include: { cashTransaction: true, installments: true }\r\n        });\r\n\r\n        if (!sale || sale.branchId !== businessId) {\r\n            return { success: false, error: 'Sale not found or unauthorized' };\r\n        }\r\n\r\n        // Delete installments\r\n        if (sale.installments && sale.installments.length > 0) {\r\n            await db.installmentPayment.deleteMany({\r\n                where: { saleId: id }\r\n            });\r\n        }\r\n\r\n        // Delete associated cash transaction\r\n        if (sale.cashTransactionId) {\r\n            await db.cashTransaction.delete({\r\n                where: { id: sale.cashTransactionId }\r\n            });\r\n        }\r\n\r\n        // Delete the sale itself\r\n        await db.sale.delete({\r\n            where: { id }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            sale: {\r\n                receiptNumber: sale.receiptNumber,\r\n                customerName: sale.customerName,\r\n                customerAddress: sale.customerAddress,\r\n                customerContact: sale.customerContact,\r\n                paymentStatus: sale.paymentStatus,\r\n                cashTransactionId: sale.cashTransactionId,\r\n                items: sale.items as any,\r\n                amountPaid: sale.amountPaid,\r\n                amountDue: sale.amountDue,\r\n                profit: sale.profit,\r\n                taxRate: sale.taxRate,\r\n                notes: sale.notes\r\n            }\r\n        };\r\n    } catch (error) {\r\n        console.error('Error deleting sale:', error);\r\n        return { success: false, error: 'Failed to delete sale' };\r\n    }\r\n}\r\n\r\nexport async function upsertSaleAction(saleDbData: any, isUpdate: boolean, updateId?: string) {\r\n    try {\r\n        const prismaData = {\r\n            userId: saleDbData.user_id,\r\n            branchId: saleDbData.location_id,\r\n            receiptNumber: saleDbData.receipt_number,\r\n            customerName: saleDbData.customer_name,\r\n            customerAddress: saleDbData.customer_address,\r\n            customerContact: saleDbData.customer_contact,\r\n            customerId: saleDbData.customer_id,\r\n            items: saleDbData.items,\r\n            paymentStatus: saleDbData.payment_status,\r\n            profit: saleDbData.profit,\r\n            date: new Date(saleDbData.date),\r\n            taxRate: saleDbData.tax_rate,\r\n            cashTransactionId: saleDbData.cash_transaction_id,\r\n            amountPaid: saleDbData.amount_paid,\r\n            amountDue: saleDbData.amount_due,\r\n            categoryId: saleDbData.category_id,\r\n            notes: saleDbData.notes\r\n        };\r\n\r\n        if (isUpdate && updateId) {\r\n            const updated = await db.sale.update({\r\n                where: { id: updateId },\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: updated };\r\n        } else {\r\n            const created = await db.sale.create({\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: created };\r\n        }\r\n    } catch (error: any) {\r\n        console.error('Error upserting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to preserve sale' };\r\n    }\r\n}\r\n\r\nexport async function createReceiptAction(saleData: any, businessId: string, userId: string) {\r\n    try {\r\n        const created = await db.sale.create({\r\n            data: {\r\n                userId: userId,\r\n                branchId: businessId,\r\n                receiptNumber: saleData.receiptNumber,\r\n                customerName: saleData.customerName,\r\n                customerId: saleData.customerId,\r\n                date: new Date(saleData.date),\r\n                items: saleData.items,\r\n                paymentStatus: saleData.paymentStatus,\r\n                profit: saleData.profit,\r\n                amountPaid: saleData.amountPaid,\r\n                amountDue: saleData.amountDue,\r\n                cashAccountId: saleData.cashAccountId,\r\n                notes: saleData.notes\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        revalidatePath('/customers');\r\n\r\n        return { success: true, data: created };\r\n    } catch (error: any) {\r\n        console.error('Error creating receipt:', error);\r\n        return { success: false, error: error.message || 'Failed to create receipt' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsDsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,oDAAA"}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            // If we need to create a cash transaction\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                person_in_charge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoesB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,0DAAA"}},
    {"offset": {"line": 259, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            // If we need to create a cash transaction\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                person_in_charge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA6fsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 276, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            // If we need to create a cash transaction\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                person_in_charge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAkhBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            // If we need to create a cash transaction\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                person_in_charge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsiBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 310, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            // If we need to create a cash transaction\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                person_in_charge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAykBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4EAAA"}},
    {"offset": {"line": 327, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            // If we need to create a cash transaction\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                person_in_charge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgnBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 344, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            // If we need to create a cash transaction\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                person_in_charge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAipBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,8DAAA"}},
    {"offset": {"line": 361, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            // If we need to create a cash transaction\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                person_in_charge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgrBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 378, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            // If we need to create a cash transaction\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                person_in_charge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqxBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 395, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            // If we need to create a cash transaction\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                person_in_charge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA2yBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,mEAAA"}},
    {"offset": {"line": 412, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            // If we need to create a cash transaction\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                person_in_charge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAyzBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qEAAA"}},
    {"offset": {"line": 429, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAOsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,yDAAA"}},
    {"offset": {"line": 446, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoDsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 463, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsFsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 480, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsIsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,8EAAA"}},
    {"offset": {"line": 497, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/sales.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getSalesAction(businessId: string, sortOrder: 'asc' | 'desc' = 'desc', pageSize?: number) {\r\n    try {\r\n        const queryOptions: any = {\r\n            where: {\r\n                branchId: businessId,\r\n            },\r\n            orderBy: {\r\n                createdAt: sortOrder,\r\n            },\r\n            include: {\r\n                cashTransaction: true,\r\n            }\r\n        };\r\n\r\n        if (pageSize && pageSize > 0) {\r\n            queryOptions.take = pageSize;\r\n        }\r\n\r\n        const sales = await db.sale.findMany(queryOptions);\r\n\r\n        // Provide default mappings to existing React components\r\n        return sales.map((item: any) => ({\r\n            id: item.id,\r\n            user_id: item.userId,\r\n            location_id: item.branchId,\r\n            receipt_number: item.receiptNumber,\r\n            customer_name: item.customerName,\r\n            customer_address: item.customerAddress,\r\n            customer_contact: item.customerContact,\r\n            customer_id: item.customerId,\r\n            items: item.items as any, // jsonb type\r\n            payment_status: item.paymentStatus,\r\n            profit: item.profit,\r\n            date: item.date.toISOString(),\r\n            tax_rate: item.taxRate ? Number(item.taxRate) : 0,\r\n            created_at: item.createdAt.toISOString(),\r\n            updated_at: item.updatedAt.toISOString(),\r\n            cash_transaction_id: item.cashTransactionId,\r\n            amount_paid: item.amountPaid,\r\n            amount_due: item.amountDue,\r\n            category_id: item.categoryId,\r\n            notes: item.notes\r\n        }));\r\n    } catch (error) {\r\n        console.error('Error fetching sales:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function deleteSaleAction(id: string, businessId: string) {\r\n    try {\r\n        const sale = await db.sale.findUnique({\r\n            where: { id },\r\n            include: { cashTransaction: true, installments: true }\r\n        });\r\n\r\n        if (!sale || sale.branchId !== businessId) {\r\n            return { success: false, error: 'Sale not found or unauthorized' };\r\n        }\r\n\r\n        // Delete installments\r\n        if (sale.installments && sale.installments.length > 0) {\r\n            await db.installmentPayment.deleteMany({\r\n                where: { saleId: id }\r\n            });\r\n        }\r\n\r\n        // Delete associated cash transaction\r\n        if (sale.cashTransactionId) {\r\n            await db.cashTransaction.delete({\r\n                where: { id: sale.cashTransactionId }\r\n            });\r\n        }\r\n\r\n        // Delete the sale itself\r\n        await db.sale.delete({\r\n            where: { id }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            sale: {\r\n                receiptNumber: sale.receiptNumber,\r\n                customerName: sale.customerName,\r\n                customerAddress: sale.customerAddress,\r\n                customerContact: sale.customerContact,\r\n                paymentStatus: sale.paymentStatus,\r\n                cashTransactionId: sale.cashTransactionId,\r\n                items: sale.items as any,\r\n                amountPaid: sale.amountPaid,\r\n                amountDue: sale.amountDue,\r\n                profit: sale.profit,\r\n                taxRate: sale.taxRate,\r\n                notes: sale.notes\r\n            }\r\n        };\r\n    } catch (error) {\r\n        console.error('Error deleting sale:', error);\r\n        return { success: false, error: 'Failed to delete sale' };\r\n    }\r\n}\r\n\r\nexport async function upsertSaleAction(saleDbData: any, isUpdate: boolean, updateId?: string) {\r\n    try {\r\n        const prismaData = {\r\n            userId: saleDbData.user_id,\r\n            branchId: saleDbData.location_id,\r\n            receiptNumber: saleDbData.receipt_number,\r\n            customerName: saleDbData.customer_name,\r\n            customerAddress: saleDbData.customer_address,\r\n            customerContact: saleDbData.customer_contact,\r\n            customerId: saleDbData.customer_id,\r\n            items: saleDbData.items,\r\n            paymentStatus: saleDbData.payment_status,\r\n            profit: saleDbData.profit,\r\n            date: new Date(saleDbData.date),\r\n            taxRate: saleDbData.tax_rate,\r\n            cashTransactionId: saleDbData.cash_transaction_id,\r\n            amountPaid: saleDbData.amount_paid,\r\n            amountDue: saleDbData.amount_due,\r\n            categoryId: saleDbData.category_id,\r\n            notes: saleDbData.notes\r\n        };\r\n\r\n        if (isUpdate && updateId) {\r\n            const updated = await db.sale.update({\r\n                where: { id: updateId },\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: updated };\r\n        } else {\r\n            const created = await db.sale.create({\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: created };\r\n        }\r\n    } catch (error: any) {\r\n        console.error('Error upserting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to preserve sale' };\r\n    }\r\n}\r\n\r\nexport async function createReceiptAction(saleData: any, businessId: string, userId: string) {\r\n    try {\r\n        const created = await db.sale.create({\r\n            data: {\r\n                userId: userId,\r\n                branchId: businessId,\r\n                receiptNumber: saleData.receiptNumber,\r\n                customerName: saleData.customerName,\r\n                customerId: saleData.customerId,\r\n                date: new Date(saleData.date),\r\n                items: saleData.items,\r\n                paymentStatus: saleData.paymentStatus,\r\n                profit: saleData.profit,\r\n                amountPaid: saleData.amountPaid,\r\n                amountDue: saleData.amountDue,\r\n                cashAccountId: saleData.cashAccountId,\r\n                notes: saleData.notes\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        revalidatePath('/customers');\r\n\r\n        return { success: true, data: created };\r\n    } catch (error: any) {\r\n        console.error('Error creating receipt:', error);\r\n        return { success: false, error: error.message || 'Failed to create receipt' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA2GsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,oDAAA"}},
    {"offset": {"line": 514, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/customers.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getCustomerStatsAction(userId: string, branchId: string) {\r\n    try {\r\n        const thisMonth = new Date();\r\n        const startOfMonth = new Date(thisMonth.getFullYear(), thisMonth.getMonth(), 1);\r\n\r\n        // 1. Count customers created this month\r\n        const thisMonthCount = await db.customer.count({\r\n            where: {\r\n                // Assuming we use agencyId for userId if they are an owner, or it's connected somehow\r\n                // For now, focusing on branchId as that's normally the tenant isolation in the schema\r\n                branchId: branchId,\r\n                createdAt: {\r\n                    gte: startOfMonth\r\n                }\r\n            }\r\n        });\r\n\r\n        // 2. Count customers with upcoming backgrounds (for now just count those who have a birthday set)\r\n        const withBirthdays = await db.customer.count({\r\n            where: {\r\n                branchId: branchId,\r\n                birthday: {\r\n                    not: null\r\n                }\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                withBirthdays,\r\n                thisMonth: thisMonthCount\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function mergeCustomersAction(primaryCustomerId: string, duplicateIds: string[]) {\r\n    try {\r\n        if (!primaryCustomerId || duplicateIds.length === 0) {\r\n            return { success: false, error: 'Invalid selection' };\r\n        }\r\n\r\n        // Use a transaction to ensure all operations succeed or fail together\r\n        await db.$transaction(async (tx: any) => {\r\n            // 1. Update sales to point to primary customer\r\n            // In Prisma, assuming relation is through customerId\r\n            await tx.sale.updateMany({\r\n                where: {\r\n                    customerId: {\r\n                        in: duplicateIds\r\n                    }\r\n                },\r\n                data: {\r\n                    customerId: primaryCustomerId\r\n                }\r\n            });\r\n\r\n            // Note: The original code also updated messages. \r\n            // If there's a Message model connected to customers, add it here.\r\n            // await tx.message.updateMany({\r\n            //     where: { customerId: { in: duplicateIds } },\r\n            //     data: { customerId: primaryCustomerId }\r\n            // });\r\n\r\n            // 3. Delete duplicate customers\r\n            await tx.customer.deleteMany({\r\n                where: {\r\n                    id: {\r\n                        in: duplicateIds\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Revalidate customers list\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error merging customers:', error);\r\n        return { success: false, error: error.message || 'Failed to merge customers' };\r\n    }\r\n}\r\n\r\nexport async function getCustomersAction(branchId: string) {\r\n    try {\r\n        const customers = await db.customer.findMany({\r\n            where: { branchId },\r\n            orderBy: { fullName: 'asc' }\r\n        });\r\n\r\n        const count = await db.customer.count({\r\n            where: { branchId }\r\n        });\r\n\r\n        // Map Prisma Customer model to the shape expected by useCustomers hook\r\n        const mappedCustomers = customers.map((c: any) => ({\r\n            id: c.id,\r\n            fullName: c.fullName,\r\n            phoneNumber: c.phoneNumber,\r\n            email: c.email,\r\n            birthday: c.birthday ? c.birthday.toISOString() : null,\r\n            gender: c.gender,\r\n            location: c.location,\r\n            categoryId: c.categoryId,\r\n            notes: c.notes,\r\n            tags: c.tags || [],\r\n            socialMedia: c.socialMedia || null,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: { customers: mappedCustomers, count } };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customers:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerAction(branchId: string, userId: string, data: any) {\r\n    try {\r\n        const newCustomer = await db.customer.create({\r\n            data: {\r\n                branchId: branchId,\r\n                userId: userId, // Assuming user who created it\r\n                fullName: data.fullName,\r\n                phoneNumber: data.phoneNumber || null,\r\n                email: data.email || null,\r\n                birthday: data.birthday ? new Date(data.birthday) : null,\r\n                gender: data.gender || null,\r\n                location: data.location || null,\r\n                categoryId: data.categoryId || null,\r\n                notes: data.notes || null,\r\n                tags: data.tags || [],\r\n                socialMedia: data.socialMedia || null\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerAction(customerId: string, data: any) {\r\n    try {\r\n        const updateData: any = {};\r\n        if (data.fullName !== undefined) updateData.fullName = data.fullName;\r\n        if (data.phoneNumber !== undefined) updateData.phoneNumber = data.phoneNumber;\r\n        if (data.email !== undefined) updateData.email = data.email;\r\n        if (data.birthday !== undefined) updateData.birthday = data.birthday ? new Date(data.birthday) : null;\r\n        if (data.gender !== undefined) updateData.gender = data.gender;\r\n        if (data.location !== undefined) updateData.location = data.location;\r\n        if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;\r\n        if (data.notes !== undefined) updateData.notes = data.notes;\r\n        if (data.tags !== undefined) updateData.tags = data.tags;\r\n        if (data.socialMedia !== undefined) updateData.socialMedia = data.socialMedia;\r\n\r\n        const updatedCustomer = await db.customer.update({\r\n            where: { id: customerId },\r\n            data: updateData\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerAction(customerId: string) {\r\n    try {\r\n        await db.customer.delete({\r\n            where: { id: customerId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCustomerCategoriesAction(branchId: string) {\r\n    try {\r\n        const categories = await db.customerCategory.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const formattedCategories = categories.map((c: any) => ({\r\n            id: c.id,\r\n            name: c.name,\r\n            isDefault: c.isDefault,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: formattedCategories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerCategoryAction(branchId: string, userId: string, name: string) {\r\n    try {\r\n        const newCategory = await db.customerCategory.create({\r\n            data: {\r\n                branchId: branchId,\r\n                name: name.trim(),\r\n                isDefault: false,\r\n                userId: userId\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCategory };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerCategoryAction(categoryId: string, name: string) {\r\n    try {\r\n        const updatedCategory = await db.customerCategory.update({\r\n            where: { id: categoryId },\r\n            data: { name: name.trim() }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCategory };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerCategoryAction(categoryId: string) {\r\n    try {\r\n        await db.customerCategory.delete({\r\n            where: { id: categoryId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgMsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 531, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/customers.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getCustomerStatsAction(userId: string, branchId: string) {\r\n    try {\r\n        const thisMonth = new Date();\r\n        const startOfMonth = new Date(thisMonth.getFullYear(), thisMonth.getMonth(), 1);\r\n\r\n        // 1. Count customers created this month\r\n        const thisMonthCount = await db.customer.count({\r\n            where: {\r\n                // Assuming we use agencyId for userId if they are an owner, or it's connected somehow\r\n                // For now, focusing on branchId as that's normally the tenant isolation in the schema\r\n                branchId: branchId,\r\n                createdAt: {\r\n                    gte: startOfMonth\r\n                }\r\n            }\r\n        });\r\n\r\n        // 2. Count customers with upcoming backgrounds (for now just count those who have a birthday set)\r\n        const withBirthdays = await db.customer.count({\r\n            where: {\r\n                branchId: branchId,\r\n                birthday: {\r\n                    not: null\r\n                }\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                withBirthdays,\r\n                thisMonth: thisMonthCount\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function mergeCustomersAction(primaryCustomerId: string, duplicateIds: string[]) {\r\n    try {\r\n        if (!primaryCustomerId || duplicateIds.length === 0) {\r\n            return { success: false, error: 'Invalid selection' };\r\n        }\r\n\r\n        // Use a transaction to ensure all operations succeed or fail together\r\n        await db.$transaction(async (tx: any) => {\r\n            // 1. Update sales to point to primary customer\r\n            // In Prisma, assuming relation is through customerId\r\n            await tx.sale.updateMany({\r\n                where: {\r\n                    customerId: {\r\n                        in: duplicateIds\r\n                    }\r\n                },\r\n                data: {\r\n                    customerId: primaryCustomerId\r\n                }\r\n            });\r\n\r\n            // Note: The original code also updated messages. \r\n            // If there's a Message model connected to customers, add it here.\r\n            // await tx.message.updateMany({\r\n            //     where: { customerId: { in: duplicateIds } },\r\n            //     data: { customerId: primaryCustomerId }\r\n            // });\r\n\r\n            // 3. Delete duplicate customers\r\n            await tx.customer.deleteMany({\r\n                where: {\r\n                    id: {\r\n                        in: duplicateIds\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Revalidate customers list\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error merging customers:', error);\r\n        return { success: false, error: error.message || 'Failed to merge customers' };\r\n    }\r\n}\r\n\r\nexport async function getCustomersAction(branchId: string) {\r\n    try {\r\n        const customers = await db.customer.findMany({\r\n            where: { branchId },\r\n            orderBy: { fullName: 'asc' }\r\n        });\r\n\r\n        const count = await db.customer.count({\r\n            where: { branchId }\r\n        });\r\n\r\n        // Map Prisma Customer model to the shape expected by useCustomers hook\r\n        const mappedCustomers = customers.map((c: any) => ({\r\n            id: c.id,\r\n            fullName: c.fullName,\r\n            phoneNumber: c.phoneNumber,\r\n            email: c.email,\r\n            birthday: c.birthday ? c.birthday.toISOString() : null,\r\n            gender: c.gender,\r\n            location: c.location,\r\n            categoryId: c.categoryId,\r\n            notes: c.notes,\r\n            tags: c.tags || [],\r\n            socialMedia: c.socialMedia || null,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: { customers: mappedCustomers, count } };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customers:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerAction(branchId: string, userId: string, data: any) {\r\n    try {\r\n        const newCustomer = await db.customer.create({\r\n            data: {\r\n                branchId: branchId,\r\n                userId: userId, // Assuming user who created it\r\n                fullName: data.fullName,\r\n                phoneNumber: data.phoneNumber || null,\r\n                email: data.email || null,\r\n                birthday: data.birthday ? new Date(data.birthday) : null,\r\n                gender: data.gender || null,\r\n                location: data.location || null,\r\n                categoryId: data.categoryId || null,\r\n                notes: data.notes || null,\r\n                tags: data.tags || [],\r\n                socialMedia: data.socialMedia || null\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerAction(customerId: string, data: any) {\r\n    try {\r\n        const updateData: any = {};\r\n        if (data.fullName !== undefined) updateData.fullName = data.fullName;\r\n        if (data.phoneNumber !== undefined) updateData.phoneNumber = data.phoneNumber;\r\n        if (data.email !== undefined) updateData.email = data.email;\r\n        if (data.birthday !== undefined) updateData.birthday = data.birthday ? new Date(data.birthday) : null;\r\n        if (data.gender !== undefined) updateData.gender = data.gender;\r\n        if (data.location !== undefined) updateData.location = data.location;\r\n        if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;\r\n        if (data.notes !== undefined) updateData.notes = data.notes;\r\n        if (data.tags !== undefined) updateData.tags = data.tags;\r\n        if (data.socialMedia !== undefined) updateData.socialMedia = data.socialMedia;\r\n\r\n        const updatedCustomer = await db.customer.update({\r\n            where: { id: customerId },\r\n            data: updateData\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerAction(customerId: string) {\r\n    try {\r\n        await db.customer.delete({\r\n            where: { id: customerId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCustomerCategoriesAction(branchId: string) {\r\n    try {\r\n        const categories = await db.customerCategory.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const formattedCategories = categories.map((c: any) => ({\r\n            id: c.id,\r\n            name: c.name,\r\n            isDefault: c.isDefault,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: formattedCategories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerCategoryAction(branchId: string, userId: string, name: string) {\r\n    try {\r\n        const newCategory = await db.customerCategory.create({\r\n            data: {\r\n                branchId: branchId,\r\n                name: name.trim(),\r\n                isDefault: false,\r\n                userId: userId\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCategory };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerCategoryAction(categoryId: string, name: string) {\r\n    try {\r\n        const updatedCategory = await db.customerCategory.update({\r\n            where: { id: categoryId },\r\n            data: { name: name.trim() }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCategory };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerCategoryAction(categoryId: string) {\r\n    try {\r\n        await db.customerCategory.delete({\r\n            where: { id: categoryId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsNsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 548, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/customers.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getCustomerStatsAction(userId: string, branchId: string) {\r\n    try {\r\n        const thisMonth = new Date();\r\n        const startOfMonth = new Date(thisMonth.getFullYear(), thisMonth.getMonth(), 1);\r\n\r\n        // 1. Count customers created this month\r\n        const thisMonthCount = await db.customer.count({\r\n            where: {\r\n                // Assuming we use agencyId for userId if they are an owner, or it's connected somehow\r\n                // For now, focusing on branchId as that's normally the tenant isolation in the schema\r\n                branchId: branchId,\r\n                createdAt: {\r\n                    gte: startOfMonth\r\n                }\r\n            }\r\n        });\r\n\r\n        // 2. Count customers with upcoming backgrounds (for now just count those who have a birthday set)\r\n        const withBirthdays = await db.customer.count({\r\n            where: {\r\n                branchId: branchId,\r\n                birthday: {\r\n                    not: null\r\n                }\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                withBirthdays,\r\n                thisMonth: thisMonthCount\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function mergeCustomersAction(primaryCustomerId: string, duplicateIds: string[]) {\r\n    try {\r\n        if (!primaryCustomerId || duplicateIds.length === 0) {\r\n            return { success: false, error: 'Invalid selection' };\r\n        }\r\n\r\n        // Use a transaction to ensure all operations succeed or fail together\r\n        await db.$transaction(async (tx: any) => {\r\n            // 1. Update sales to point to primary customer\r\n            // In Prisma, assuming relation is through customerId\r\n            await tx.sale.updateMany({\r\n                where: {\r\n                    customerId: {\r\n                        in: duplicateIds\r\n                    }\r\n                },\r\n                data: {\r\n                    customerId: primaryCustomerId\r\n                }\r\n            });\r\n\r\n            // Note: The original code also updated messages. \r\n            // If there's a Message model connected to customers, add it here.\r\n            // await tx.message.updateMany({\r\n            //     where: { customerId: { in: duplicateIds } },\r\n            //     data: { customerId: primaryCustomerId }\r\n            // });\r\n\r\n            // 3. Delete duplicate customers\r\n            await tx.customer.deleteMany({\r\n                where: {\r\n                    id: {\r\n                        in: duplicateIds\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Revalidate customers list\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error merging customers:', error);\r\n        return { success: false, error: error.message || 'Failed to merge customers' };\r\n    }\r\n}\r\n\r\nexport async function getCustomersAction(branchId: string) {\r\n    try {\r\n        const customers = await db.customer.findMany({\r\n            where: { branchId },\r\n            orderBy: { fullName: 'asc' }\r\n        });\r\n\r\n        const count = await db.customer.count({\r\n            where: { branchId }\r\n        });\r\n\r\n        // Map Prisma Customer model to the shape expected by useCustomers hook\r\n        const mappedCustomers = customers.map((c: any) => ({\r\n            id: c.id,\r\n            fullName: c.fullName,\r\n            phoneNumber: c.phoneNumber,\r\n            email: c.email,\r\n            birthday: c.birthday ? c.birthday.toISOString() : null,\r\n            gender: c.gender,\r\n            location: c.location,\r\n            categoryId: c.categoryId,\r\n            notes: c.notes,\r\n            tags: c.tags || [],\r\n            socialMedia: c.socialMedia || null,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: { customers: mappedCustomers, count } };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customers:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerAction(branchId: string, userId: string, data: any) {\r\n    try {\r\n        const newCustomer = await db.customer.create({\r\n            data: {\r\n                branchId: branchId,\r\n                userId: userId, // Assuming user who created it\r\n                fullName: data.fullName,\r\n                phoneNumber: data.phoneNumber || null,\r\n                email: data.email || null,\r\n                birthday: data.birthday ? new Date(data.birthday) : null,\r\n                gender: data.gender || null,\r\n                location: data.location || null,\r\n                categoryId: data.categoryId || null,\r\n                notes: data.notes || null,\r\n                tags: data.tags || [],\r\n                socialMedia: data.socialMedia || null\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerAction(customerId: string, data: any) {\r\n    try {\r\n        const updateData: any = {};\r\n        if (data.fullName !== undefined) updateData.fullName = data.fullName;\r\n        if (data.phoneNumber !== undefined) updateData.phoneNumber = data.phoneNumber;\r\n        if (data.email !== undefined) updateData.email = data.email;\r\n        if (data.birthday !== undefined) updateData.birthday = data.birthday ? new Date(data.birthday) : null;\r\n        if (data.gender !== undefined) updateData.gender = data.gender;\r\n        if (data.location !== undefined) updateData.location = data.location;\r\n        if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;\r\n        if (data.notes !== undefined) updateData.notes = data.notes;\r\n        if (data.tags !== undefined) updateData.tags = data.tags;\r\n        if (data.socialMedia !== undefined) updateData.socialMedia = data.socialMedia;\r\n\r\n        const updatedCustomer = await db.customer.update({\r\n            where: { id: customerId },\r\n            data: updateData\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerAction(customerId: string) {\r\n    try {\r\n        await db.customer.delete({\r\n            where: { id: customerId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCustomerCategoriesAction(branchId: string) {\r\n    try {\r\n        const categories = await db.customerCategory.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const formattedCategories = categories.map((c: any) => ({\r\n            id: c.id,\r\n            name: c.name,\r\n            isDefault: c.isDefault,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: formattedCategories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerCategoryAction(branchId: string, userId: string, name: string) {\r\n    try {\r\n        const newCategory = await db.customerCategory.create({\r\n            data: {\r\n                branchId: branchId,\r\n                name: name.trim(),\r\n                isDefault: false,\r\n                userId: userId\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCategory };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerCategoryAction(categoryId: string, name: string) {\r\n    try {\r\n        const updatedCategory = await db.customerCategory.update({\r\n            where: { id: categoryId },\r\n            data: { name: name.trim() }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCategory };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerCategoryAction(categoryId: string) {\r\n    try {\r\n        await db.customerCategory.delete({\r\n            where: { id: categoryId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAwOsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 565, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/customers.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getCustomerStatsAction(userId: string, branchId: string) {\r\n    try {\r\n        const thisMonth = new Date();\r\n        const startOfMonth = new Date(thisMonth.getFullYear(), thisMonth.getMonth(), 1);\r\n\r\n        // 1. Count customers created this month\r\n        const thisMonthCount = await db.customer.count({\r\n            where: {\r\n                // Assuming we use agencyId for userId if they are an owner, or it's connected somehow\r\n                // For now, focusing on branchId as that's normally the tenant isolation in the schema\r\n                branchId: branchId,\r\n                createdAt: {\r\n                    gte: startOfMonth\r\n                }\r\n            }\r\n        });\r\n\r\n        // 2. Count customers with upcoming backgrounds (for now just count those who have a birthday set)\r\n        const withBirthdays = await db.customer.count({\r\n            where: {\r\n                branchId: branchId,\r\n                birthday: {\r\n                    not: null\r\n                }\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                withBirthdays,\r\n                thisMonth: thisMonthCount\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function mergeCustomersAction(primaryCustomerId: string, duplicateIds: string[]) {\r\n    try {\r\n        if (!primaryCustomerId || duplicateIds.length === 0) {\r\n            return { success: false, error: 'Invalid selection' };\r\n        }\r\n\r\n        // Use a transaction to ensure all operations succeed or fail together\r\n        await db.$transaction(async (tx: any) => {\r\n            // 1. Update sales to point to primary customer\r\n            // In Prisma, assuming relation is through customerId\r\n            await tx.sale.updateMany({\r\n                where: {\r\n                    customerId: {\r\n                        in: duplicateIds\r\n                    }\r\n                },\r\n                data: {\r\n                    customerId: primaryCustomerId\r\n                }\r\n            });\r\n\r\n            // Note: The original code also updated messages. \r\n            // If there's a Message model connected to customers, add it here.\r\n            // await tx.message.updateMany({\r\n            //     where: { customerId: { in: duplicateIds } },\r\n            //     data: { customerId: primaryCustomerId }\r\n            // });\r\n\r\n            // 3. Delete duplicate customers\r\n            await tx.customer.deleteMany({\r\n                where: {\r\n                    id: {\r\n                        in: duplicateIds\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Revalidate customers list\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error merging customers:', error);\r\n        return { success: false, error: error.message || 'Failed to merge customers' };\r\n    }\r\n}\r\n\r\nexport async function getCustomersAction(branchId: string) {\r\n    try {\r\n        const customers = await db.customer.findMany({\r\n            where: { branchId },\r\n            orderBy: { fullName: 'asc' }\r\n        });\r\n\r\n        const count = await db.customer.count({\r\n            where: { branchId }\r\n        });\r\n\r\n        // Map Prisma Customer model to the shape expected by useCustomers hook\r\n        const mappedCustomers = customers.map((c: any) => ({\r\n            id: c.id,\r\n            fullName: c.fullName,\r\n            phoneNumber: c.phoneNumber,\r\n            email: c.email,\r\n            birthday: c.birthday ? c.birthday.toISOString() : null,\r\n            gender: c.gender,\r\n            location: c.location,\r\n            categoryId: c.categoryId,\r\n            notes: c.notes,\r\n            tags: c.tags || [],\r\n            socialMedia: c.socialMedia || null,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: { customers: mappedCustomers, count } };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customers:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerAction(branchId: string, userId: string, data: any) {\r\n    try {\r\n        const newCustomer = await db.customer.create({\r\n            data: {\r\n                branchId: branchId,\r\n                userId: userId, // Assuming user who created it\r\n                fullName: data.fullName,\r\n                phoneNumber: data.phoneNumber || null,\r\n                email: data.email || null,\r\n                birthday: data.birthday ? new Date(data.birthday) : null,\r\n                gender: data.gender || null,\r\n                location: data.location || null,\r\n                categoryId: data.categoryId || null,\r\n                notes: data.notes || null,\r\n                tags: data.tags || [],\r\n                socialMedia: data.socialMedia || null\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerAction(customerId: string, data: any) {\r\n    try {\r\n        const updateData: any = {};\r\n        if (data.fullName !== undefined) updateData.fullName = data.fullName;\r\n        if (data.phoneNumber !== undefined) updateData.phoneNumber = data.phoneNumber;\r\n        if (data.email !== undefined) updateData.email = data.email;\r\n        if (data.birthday !== undefined) updateData.birthday = data.birthday ? new Date(data.birthday) : null;\r\n        if (data.gender !== undefined) updateData.gender = data.gender;\r\n        if (data.location !== undefined) updateData.location = data.location;\r\n        if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;\r\n        if (data.notes !== undefined) updateData.notes = data.notes;\r\n        if (data.tags !== undefined) updateData.tags = data.tags;\r\n        if (data.socialMedia !== undefined) updateData.socialMedia = data.socialMedia;\r\n\r\n        const updatedCustomer = await db.customer.update({\r\n            where: { id: customerId },\r\n            data: updateData\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerAction(customerId: string) {\r\n    try {\r\n        await db.customer.delete({\r\n            where: { id: customerId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCustomerCategoriesAction(branchId: string) {\r\n    try {\r\n        const categories = await db.customerCategory.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const formattedCategories = categories.map((c: any) => ({\r\n            id: c.id,\r\n            name: c.name,\r\n            isDefault: c.isDefault,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: formattedCategories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerCategoryAction(branchId: string, userId: string, name: string) {\r\n    try {\r\n        const newCategory = await db.customerCategory.create({\r\n            data: {\r\n                branchId: branchId,\r\n                name: name.trim(),\r\n                isDefault: false,\r\n                userId: userId\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCategory };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerCategoryAction(categoryId: string, name: string) {\r\n    try {\r\n        const updatedCategory = await db.customerCategory.update({\r\n            where: { id: categoryId },\r\n            data: { name: name.trim() }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCategory };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerCategoryAction(categoryId: string) {\r\n    try {\r\n        await db.customerCategory.delete({\r\n            where: { id: categoryId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsPsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}}]
}