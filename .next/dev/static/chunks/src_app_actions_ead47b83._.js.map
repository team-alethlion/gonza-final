{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA4fsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,0DAAA"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqhBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0iBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA8jBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgmBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4EAAA"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAmoBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoqBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,8DAAA"}},
    {"offset": {"line": 123, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAmsBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA+vBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAuyBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 174, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA4zBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,mEAAA"}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA00BsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qEAAA"}},
    {"offset": {"line": 208, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 225, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgCsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}}]
}