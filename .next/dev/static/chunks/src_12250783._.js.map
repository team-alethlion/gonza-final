{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n\r\nexport async function getAccountStatusAction(userId: string) {\r\n    try {\r\n        const user = await db.user.findUnique({\r\n            where: { id: userId },\r\n            select: {\r\n                isFrozen: true,\r\n                createdAt: true,\r\n                subscriptions: {\r\n                    where: { status: 'active' },\r\n                    orderBy: { endDate: 'desc' },\r\n                    take: 1\r\n                },\r\n                branches: {\r\n                    select: { id: true }\r\n                }\r\n            }\r\n        });\r\n\r\n        if (!user) return null;\r\n\r\n        const activeSub = user.subscriptions[0];\r\n        const now = new Date();\r\n        const daysRemaining = activeSub ? Math.ceil((activeSub.endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)) : 0;\r\n\r\n        return {\r\n            is_frozen: user.isFrozen,\r\n            location_limit: 1, // Traditional limit or from subscription\r\n            billing_amount: activeSub ? Number(activeSub.amount) : 50000,\r\n            billing_duration: 'Monthly',\r\n            days_remaining: Math.max(0, daysRemaining),\r\n            next_billing_date: activeSub?.endDate.toISOString() || ''\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching account status:', error);\r\n        return { is_frozen: false, location_limit: 1, billing_amount: 50000, billing_duration: 'Monthly', days_remaining: 30, next_billing_date: '' };\r\n    }\r\n}\r\n\r\nexport async function getOnboardingStatusAction(locationId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId: locationId }\r\n        });\r\n\r\n        if (!settings) return null;\r\n\r\n        return {\r\n            id: settings.id,\r\n            location_id: settings.branchId,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            completed: !!settings.businessName && !!settings.phone, // Simplified completion check\r\n            is_frozen: false // Should come from branch or user status\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching onboarding status:', error);\r\n        return null;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useBusinessSettings.ts"],"sourcesContent":["\r\nimport { useState, useEffect } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { getBusinessSettingsAction, upsertBusinessSettingsAction } from '@/app/actions/business-settings';\r\n\r\nexport interface BusinessSettings {\r\n  id?: string;\r\n  businessName: string;\r\n  businessAddress: string;\r\n  businessPhone: string;\r\n  businessEmail: string;\r\n  businessLogo?: string;\r\n  currency: string;\r\n  signature?: string;\r\n  paymentInfo?: string;\r\n  defaultPrintFormat?: 'standard' | 'thermal';\r\n  defaultPrinterName?: string;\r\n  defaultPrinterType?: 'USB' | 'Bluetooth';\r\n  printerPaperSize?: '58mm' | '80mm';\r\n}\r\n\r\n// Utility function to parse payment info text into structured format\r\nexport const parsePaymentInfo = (paymentInfo: string): { method: string, accountNumber: string, accountName: string }[] => {\r\n  if (!paymentInfo || paymentInfo.trim() === '') {\r\n    return [];\r\n  }\r\n\r\n  const lines = paymentInfo.split('\\n').filter(line => line.trim() !== '');\r\n  const methods: { method: string, accountNumber: string, accountName: string }[] = [];\r\n\r\n  for (let i = 0; i < lines.length; i += 3) {\r\n    if (i + 2 < lines.length) {\r\n      methods.push({\r\n        method: lines[i].trim(),\r\n        accountNumber: lines[i + 1].trim(),\r\n        accountName: lines[i + 2].trim()\r\n      });\r\n    }\r\n  }\r\n\r\n  return methods;\r\n};\r\n\r\n// Utility function to convert payment methods array back to string format\r\nexport const convertPaymentMethodsToString = (paymentMethods: { method: string, accountNumber: string, accountName: string }[]): string => {\r\n  return paymentMethods\r\n    .filter(pm => pm.method.trim() !== '' || pm.accountNumber.trim() !== '' || pm.accountName.trim() !== '')\r\n    .map(pm => `${pm.method}\\n${pm.accountNumber}\\n${pm.accountName}`)\r\n    .join('\\n');\r\n};\r\n\r\n// Default settings for new businesses\r\nconst getDefaultSettings = (): BusinessSettings => ({\r\n  businessName: '',\r\n  businessAddress: '',\r\n  businessPhone: '',\r\n  businessEmail: '',\r\n  currency: 'UGX',\r\n  paymentInfo: '',\r\n  defaultPrintFormat: 'standard'\r\n});\r\n\r\nexport const useBusinessSettings = () => {\r\n  const [settings, setSettings] = useState<BusinessSettings>(getDefaultSettings());\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const loadSettings = async (): Promise<BusinessSettings> => {\r\n    if (!currentBusiness) {\r\n      return getDefaultSettings();\r\n    }\r\n\r\n    try {\r\n      const data = await getBusinessSettingsAction(currentBusiness.id);\r\n\r\n      if (data) {\r\n        // Extract payment info from metadata\r\n        const paymentInfo = data.metadata && typeof data.metadata === 'object' ?\r\n          (data.metadata as Record<string, unknown>).payment_info as string || '' : '';\r\n\r\n        return {\r\n          id: data.id,\r\n          businessName: data.business_name || '',\r\n          businessAddress: data.business_address || '',\r\n          businessPhone: data.business_phone || '',\r\n          businessEmail: data.business_email || '',\r\n          businessLogo: data.business_logo || undefined,\r\n          currency: data.currency || 'UGX',\r\n          signature: data.signature || undefined,\r\n          paymentInfo: paymentInfo,\r\n          defaultPrintFormat: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_print_format as 'standard' | 'thermal' || 'standard' : 'standard',\r\n          defaultPrinterName: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_name as string || '' : '',\r\n          defaultPrinterType: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_type as 'USB' | 'Bluetooth' || 'USB' : 'USB',\r\n          printerPaperSize: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).printer_paper_size as '58mm' | '80mm' || '58mm' : '58mm'\r\n        };\r\n      } else {\r\n        return getDefaultSettings();\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return getDefaultSettings();\r\n    }\r\n  };\r\n\r\n  const updateSettings = async (newSettings: Partial<BusinessSettings>) => {\r\n    if (!currentBusiness) {\r\n      console.error('No business selected for updating settings');\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"No business selected\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const userData = { user: { id: '00000000-0000-0000-0000-000000000000' } }; // Mocked user id for now\r\n\r\n      // Prepare the metadata object with payment info\r\n      const metadata = {\r\n        payment_info: newSettings.hasOwnProperty('paymentInfo') ? newSettings.paymentInfo : settings.paymentInfo || '',\r\n        default_print_format: newSettings.hasOwnProperty('defaultPrintFormat') ? newSettings.defaultPrintFormat : settings.defaultPrintFormat || 'standard',\r\n        default_printer_name: newSettings.hasOwnProperty('defaultPrinterName') ? newSettings.defaultPrinterName : settings.defaultPrinterName || '',\r\n        default_printer_type: newSettings.hasOwnProperty('defaultPrinterType') ? newSettings.defaultPrinterType : settings.defaultPrinterType || 'USB',\r\n        printer_paper_size: newSettings.hasOwnProperty('printerPaperSize') ? newSettings.printerPaperSize : settings.printerPaperSize || '58mm'\r\n      };\r\n\r\n      const updateData = {\r\n        business_name: newSettings.hasOwnProperty('businessName') ? newSettings.businessName : settings.businessName,\r\n        business_address: newSettings.hasOwnProperty('businessAddress') ? newSettings.businessAddress : settings.businessAddress,\r\n        business_phone: newSettings.hasOwnProperty('businessPhone') ? newSettings.businessPhone : settings.businessPhone,\r\n        business_email: newSettings.hasOwnProperty('businessEmail') ? newSettings.businessEmail : settings.businessEmail,\r\n        business_logo: newSettings.hasOwnProperty('businessLogo') ? newSettings.businessLogo : settings.businessLogo,\r\n        currency: newSettings.hasOwnProperty('currency') ? newSettings.currency : settings.currency,\r\n        signature: newSettings.hasOwnProperty('signature') ? newSettings.signature : settings.signature,\r\n        metadata: metadata\r\n      };\r\n\r\n      const response = await upsertBusinessSettingsAction(currentBusiness.id, userData.user.id, updateData);\r\n\r\n      if (!response.success) {\r\n        console.error('Supabase error updating business settings:', response.error);\r\n        throw new Error(response.error);\r\n      }\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Business settings updated successfully\"\r\n      });\r\n\r\n      // Refetch settings after update\r\n      refetch();\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // React Query for settings loading with proper caching\r\n  const { data: queriedData, isLoading: isQueryLoading, isFetching, refetch } = useQuery({\r\n    queryKey: ['businessSettings', currentBusiness?.id],\r\n    queryFn: loadSettings,\r\n    enabled: !!currentBusiness?.id,\r\n    staleTime: 5 * 60_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: false,\r\n    refetchOnReconnect: false,\r\n  });\r\n\r\n  // Sync React Query data with local state\r\n  useEffect(() => {\r\n    if (queriedData) {\r\n      setSettings(queriedData);\r\n    } else if (!currentBusiness) {\r\n      setSettings(getDefaultSettings());\r\n    }\r\n  }, [queriedData, currentBusiness]);\r\n\r\n  // Sync loading state from React Query\r\n  useEffect(() => {\r\n    setIsLoading(isQueryLoading || isFetching);\r\n  }, [isQueryLoading, isFetching]);\r\n\r\n  return {\r\n    settings,\r\n    isLoading,\r\n    updateSettings,\r\n    loadSettings\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/utils/inventoryCacheUtils.ts"],"sourcesContent":["import { QueryClient } from \"@tanstack/react-query\";\r\n\r\n/**\r\n * Utility to clear inventory-related caches (both localStorage and React Query)\r\n * to ensure real-time data accuracy.\r\n */\r\nexport const clearInventoryCaches = (queryClient?: QueryClient) => {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    // 1. Clear LocalStorage (Legacy / Manual caches)\r\n    const keys = Object.keys(localStorage);\r\n    const patterns = [\r\n        'allProductsStats_',\r\n        'stockSummary_',\r\n        'soldItems_',\r\n        'dashboardData_',\r\n        'analyticsData_'\r\n    ];\r\n\r\n    let clearedCount = 0;\r\n    keys.forEach(key => {\r\n        if (patterns.some(pattern => key.startsWith(pattern))) {\r\n            localStorage.removeItem(key);\r\n            clearedCount++;\r\n        }\r\n    });\r\n\r\n    if (clearedCount > 0) {\r\n        console.log(`[Cache] Cleared ${clearedCount} inventory-related localStorage entries.`);\r\n    }\r\n\r\n    // 2. Invalidate React Query Keys (Modern State)\r\n    if (queryClient) {\r\n        console.log('[Cache] Invalidating React Query inventory keys...');\r\n        // Invalidate specific keys used in the inventory module\r\n        queryClient.invalidateQueries({ queryKey: ['inventory_global_stats'] });\r\n        queryClient.invalidateQueries({ queryKey: ['stockSummary'] });\r\n        queryClient.invalidateQueries({ queryKey: ['products'] });\r\n        queryClient.invalidateQueries({ queryKey: ['sales'] });\r\n        queryClient.invalidateQueries({ queryKey: ['all-products-for-scanner'] });\r\n        queryClient.invalidateQueries({ queryKey: ['all-products'] });\r\n    }\r\n};\r\n"],"names":[],"mappings":";;;;AAMO,MAAM,uBAAuB,CAAC;IACjC;;IAEA,iDAAiD;IACjD,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,MAAM,WAAW;QACb;QACA;QACA;QACA;QACA;KACH;IAED,IAAI,eAAe;IACnB,KAAK,OAAO,CAAC,CAAA;QACT,IAAI,SAAS,IAAI,CAAC,CAAA,UAAW,IAAI,UAAU,CAAC,WAAW;YACnD,aAAa,UAAU,CAAC;YACxB;QACJ;IACJ;IAEA,IAAI,eAAe,GAAG;QAClB,QAAQ,GAAG,CAAC,CAAC,gBAAgB,EAAE,aAAa,wCAAwC,CAAC;IACzF;IAEA,gDAAgD;IAChD,IAAI,aAAa;QACb,QAAQ,GAAG,CAAC;QACZ,wDAAwD;QACxD,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAyB;QAAC;QACrE,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAe;QAAC;QAC3D,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAW;QAAC;QACvD,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAQ;QAAC;QACpD,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAA2B;QAAC;QACvE,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAe;QAAC;IAC/D;AACJ"}},
    {"offset": {"line": 295, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qDAAA"}},
    {"offset": {"line": 312, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqLsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 329, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 346, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqUsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAkVsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 380, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useProducts.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useMemo } from 'react';\r\nimport { Product, ProductFormData, ProductFilters } from '@/types';\r\nimport { useBusinessSettings } from './useBusinessSettings';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { clearInventoryCaches } from '@/utils/inventoryCacheUtils';\r\n\r\n// Import our new Server Actions\r\nimport {\r\n  getProductsAction,\r\n  createProductAction,\r\n  updateProductAction,\r\n  deleteProductAction,\r\n  updateProductsBulkAction\r\n} from '@/app/actions/products';\r\n\r\nexport const useProducts = (userId: string | undefined, initialPageSize: number = 50) => {\r\n  const [products, setProducts] = useState<Product[]>([]);\r\n  const [page, setPage] = useState(1);\r\n  const [pageSize, setPageSize] = useState(initialPageSize);\r\n  const [totalCount, setTotalCount] = useState(0);\r\n  const [isTyping, setIsTyping] = useState(false);\r\n  const { settings } = useBusinessSettings();\r\n  const { currentBusiness } = useBusiness();\r\n  const queryClient = useQueryClient();\r\n\r\n  const [filters, setFilters] = useState<ProductFilters>({\r\n    search: '',\r\n    category: 'all',\r\n    stockStatus: 'all'\r\n  });\r\n\r\n  const [typingTimer, setTypingTimer] = useState<NodeJS.Timeout | null>(null);\r\n\r\n  const setFiltersWithTypingState = useCallback((newFilters: ProductFilters) => {\r\n    if (newFilters.search !== filters.search) {\r\n      setIsTyping(true);\r\n      if (typingTimer) clearTimeout(typingTimer);\r\n      const timer = setTimeout(() => {\r\n        setIsTyping(false);\r\n      }, 600);\r\n      setTypingTimer(timer);\r\n    }\r\n    setFilters(newFilters);\r\n  }, [filters.search, typingTimer]);\r\n\r\n  // Use Server Action instead of Supabase\r\n  const loadProducts = useCallback(async (): Promise<{ products: Product[], count: number }> => {\r\n    if (!userId || !currentBusiness) {\r\n      return { products: [], count: 0 };\r\n    }\r\n\r\n    try {\r\n      // Server Action call\r\n      const result = await getProductsAction({\r\n        userId,\r\n        businessId: currentBusiness.id,\r\n        page,\r\n        pageSize,\r\n        search: filters.search,\r\n        category: filters.category === 'all' ? undefined : filters.category,\r\n        stockStatus: filters.stockStatus,\r\n      });\r\n      return result as { products: Product[], count: number };\r\n    } catch (error) {\r\n      console.error('Error loading products from server action:', error);\r\n      return { products: [], count: 0 };\r\n    }\r\n  }, [userId, currentBusiness?.id, page, pageSize, filters.search, filters.category, filters.stockStatus]);\r\n\r\n  const baseQueryKey = useMemo(() => ['products', userId, currentBusiness?.id], [userId, currentBusiness?.id]);\r\n  const queryKey = useMemo(() => [...baseQueryKey, page, pageSize, filters.search, filters.category, filters.stockStatus], [baseQueryKey, page, pageSize, filters.search, filters.category, filters.stockStatus]);\r\n\r\n  const { data: queriedData, isLoading: isQueryLoading, isFetching, refetch } = useQuery({\r\n    queryKey,\r\n    queryFn: loadProducts,\r\n    enabled: !!userId && !!currentBusiness?.id,\r\n    staleTime: 30_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: true,\r\n    refetchOnReconnect: true,\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (queriedData) {\r\n      setProducts(queriedData.products);\r\n      setTotalCount(queriedData.count);\r\n    }\r\n  }, [queriedData]);\r\n\r\n  const isLoading = (isQueryLoading && !queriedData) && !isTyping;\r\n\r\n  // Supabase Storage remains untouched since Prisma doesn't do file storage\r\n  // but we isolate it here.\r\n  const uploadProductImage = async (imageFile: File): Promise<string | null> => {\r\n    try {\r\n      if (!userId) return null;\r\n\r\n      // We will implement a server action for this. \r\n      // For now, let's assume we have an uploadImageAction.\r\n      // const formData = new FormData();\r\n      // formData.append('file', imageFile);\r\n      // formData.append('userId', userId);\r\n      // const result = await uploadImageAction(formData);\r\n      // return result.url;\r\n\r\n      console.warn('Image upload redirecting to server action (TODO)');\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error in uploadProductImage:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const createProduct = async (productData: ProductFormData): Promise<Product | null> => {\r\n    try {\r\n      if (!userId || !currentBusiness) return null;\r\n\r\n      const result = await createProductAction({\r\n        ...productData,\r\n        userId,\r\n        businessId: currentBusiness.id\r\n      });\r\n\r\n      if (!result) return null;\r\n\r\n      const newProduct = result as Product;\r\n\r\n      setProducts(prev => [newProduct, ...prev]);\r\n      setTotalCount(c => c + 1);\r\n\r\n      queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n      clearInventoryCaches(queryClient);\r\n\r\n      return newProduct;\r\n    } catch (error) {\r\n      console.error('Error creating product:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updateProduct = async (\r\n    id: string,\r\n    updates: Partial<Product>,\r\n    imageFile?: File | null,\r\n    isFromSale = false,\r\n    customChangeReason?: string,\r\n    adjustmentDate?: Date,\r\n    referenceId?: string,\r\n    receiptNumber?: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      let imageUrl = updates.imageUrl;\r\n      if (imageFile) {\r\n        imageUrl = await uploadProductImage(imageFile);\r\n      }\r\n\r\n      const result = await updateProductAction(id, {\r\n        ...updates,\r\n        imageUrl,\r\n        userId,\r\n        businessId: currentBusiness.id,\r\n        isFromSale,\r\n        customChangeReason,\r\n        referenceId\r\n      });\r\n\r\n      if (!result) return false;\r\n\r\n      queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n      clearInventoryCaches(queryClient);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating product:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteProduct = async (id: string): Promise<boolean> => {\r\n    try {\r\n      if (!userId) return false;\r\n\r\n      const success = await deleteProductAction(id);\r\n\r\n      if (success) {\r\n        queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n        clearInventoryCaches(queryClient);\r\n        return true;\r\n      }\r\n      return false;\r\n    } catch (error) {\r\n      console.error('Error deleting product:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const updateProductsBulk = async (\r\n    updates: Array<{ id: string; updated: Partial<Product>; imageFile?: File | null }>,\r\n    userIdForHistory?: string,\r\n    changeReason?: string,\r\n    referenceId?: string,\r\n    adjustmentDate?: Date,\r\n    receiptNumber?: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      const success = await updateProductsBulkAction(\r\n        updates.map(u => ({ id: u.id, updated: u.updated })),\r\n        currentBusiness.id\r\n      );\r\n\r\n      if (success) {\r\n        queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n        clearInventoryCaches(queryClient);\r\n      }\r\n\r\n      return success;\r\n    } catch (error) {\r\n      console.error('Error in bulk update:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  return {\r\n    products,\r\n    isLoading,\r\n    loadProducts,\r\n    page,\r\n    setPage,\r\n    pageSize,\r\n    setPageSize,\r\n    totalCount,\r\n    createProduct,\r\n    updateProduct,\r\n    updateProductsBulk,\r\n    deleteProduct,\r\n    uploadProductImage,\r\n    refetch,\r\n    isFetching,\r\n    filters,\r\n    setFilters: setFiltersWithTypingState,\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 664, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.branchId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title || '',\r\n                items: (req.items as any) || [],\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- STOCK RECONCILIATION & REPAIRS ---\r\n\r\nexport async function getProductReconciliationAction(businessId: string, productId: string) {\r\n    try {\r\n        const product = await db.product.findUnique({\r\n            where: { id: productId },\r\n            include: { category: true }\r\n        });\r\n\r\n        if (!product) return { success: false, error: 'Product not found' };\r\n\r\n        // Fetch all history entries\r\n        const history = await db.productHistory.findMany({\r\n            where: { productId, locationId: businessId },\r\n            orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n        });\r\n\r\n        // Fetch all sales containing this product\r\n        const sales = await db.sale.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const openingStock = history.length > 0 ? history[0].newStock : 0;\r\n        const openingDate = history.length > 0 ? history[0].createdAt : null;\r\n\r\n        const dailyTransactions = new Map<string, any>();\r\n        let excludedSalesQty = 0;\r\n\r\n        sales.forEach(sale => {\r\n            const items = (sale.items as any[]) || [];\r\n            const soldQty = items\r\n                .filter(item => item.productId === productId)\r\n                .reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);\r\n\r\n            if (soldQty > 0) {\r\n                if (openingDate && sale.date < openingDate) {\r\n                    excludedSalesQty += soldQty;\r\n                } else {\r\n                    const dateStr = sale.date.toISOString().split('T')[0];\r\n                    const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n                    day.itemsSold += soldQty;\r\n                    dailyTransactions.set(dateStr, day);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Movements (excluding initial entry)\r\n        const movements = history.slice(1);\r\n        movements.forEach(h => {\r\n            const dateStr = h.createdAt.toISOString().split('T')[0];\r\n            const delta = h.newStock - h.oldStock;\r\n            const reason = (h.changeReason || '').toLowerCase();\r\n\r\n            const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n\r\n            if (h.type === 'RESTOCK' || reason.includes('purchase') || reason.includes('addition')) {\r\n                day.stockAdded += delta;\r\n            } else if (reason.includes('transfer out')) {\r\n                day.transferOut += Math.abs(delta);\r\n            } else if (reason.includes('customer return')) {\r\n                day.returnIn += delta;\r\n            } else if (reason.includes('return to supplier')) {\r\n                day.returnOut += Math.abs(delta);\r\n            } else if (h.type !== 'SALE') {\r\n                day.adjustments += delta;\r\n            }\r\n            dailyTransactions.set(dateStr, day);\r\n        });\r\n\r\n        const sortedDates = Array.from(dailyTransactions.keys()).sort();\r\n        const dailyBreakdown = [];\r\n        let runningStock = openingStock;\r\n\r\n        for (const date of sortedDates) {\r\n            const day = dailyTransactions.get(date);\r\n            const startingStock = runningStock;\r\n            const endingStock = startingStock - day.itemsSold + day.stockAdded - day.transferOut + day.returnIn - day.returnOut + day.adjustments;\r\n\r\n            dailyBreakdown.push({\r\n                date,\r\n                startingStock,\r\n                ...day,\r\n                endingStock\r\n            });\r\n            runningStock = endingStock;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                product: {\r\n                    id: product.id,\r\n                    name: product.name,\r\n                    quantity: product.stock,\r\n                    itemNumber: product.sku\r\n                },\r\n                currentStock: product.stock,\r\n                calculatedStock: runningStock,\r\n                discrepancy: product.stock - runningStock,\r\n                openingStock,\r\n                openingDate: openingDate?.toISOString(),\r\n                excludedSalesQty,\r\n                dailyBreakdown\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error in reconciliation action:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getStockRepairsPreviewAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true, name: true, stock: true }\r\n        });\r\n\r\n        const brokenChains = [];\r\n\r\n        for (const product of products) {\r\n            const history = await db.productHistory.findMany({\r\n                where: { productId: product.id, locationId: businessId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) continue;\r\n\r\n            let runningQuantity = 0;\r\n            const brokenEntries = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newStock - entry.oldStock;\r\n                const expectedPrev = runningQuantity;\r\n                const expectedNext = expectedPrev + change;\r\n\r\n                if (entry.oldStock !== expectedPrev || entry.newStock !== expectedNext) {\r\n                    brokenEntries.push({\r\n                        entryId: entry.id,\r\n                        createdAt: entry.createdAt.toISOString(),\r\n                        changeReason: entry.changeReason,\r\n                        currentPrevQty: entry.oldStock,\r\n                        currentNewQty: entry.newStock,\r\n                        fixedPrevQty: expectedPrev,\r\n                        fixedNewQty: expectedNext\r\n                    });\r\n                }\r\n                runningQuantity = expectedNext;\r\n            }\r\n\r\n            if (brokenEntries.length > 0 || Math.abs(product.stock - runningQuantity) > 0.001) {\r\n                brokenChains.push({\r\n                    productId: product.id,\r\n                    productName: product.name,\r\n                    totalEntries: history.length,\r\n                    brokenEntries,\r\n                    finalFixedQty: runningQuantity,\r\n                    currentProductQty: product.stock\r\n                });\r\n            }\r\n        }\r\n\r\n        return { success: true, data: brokenChains };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function repairStockChainsAction(businessId: string, productIds?: string[]) {\r\n    try {\r\n        const ids = productIds || (await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true }\r\n        })).map(p => p.id);\r\n\r\n        let repaired = 0;\r\n        let failed = 0;\r\n\r\n        for (const id of ids) {\r\n            try {\r\n                await recalculateStockChainAction(id, businessId);\r\n                repaired++;\r\n            } catch (err) {\r\n                failed++;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: { repaired, failed } };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getActivityByEntityIdsAction(entityIds: string[]) {\r\n    try {\r\n        const records = await db.activityHistory.findMany({\r\n            where: { entityId: { in: entityIds } },\r\n            select: { entityId: true, entityName: true }\r\n        });\r\n        return { success: true, data: records };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message, data: [] };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesAction(entryIds: string[], newDate: string) {\r\n    try {\r\n        await db.productHistory.updateMany({\r\n            where: { id: { in: entryIds } },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- RECEIPT NUMBER GENERATION ---\r\n\r\nexport async function getNextReceiptNumberAction(branchId: string) {\r\n    try {\r\n        const lastSale = await db.sale.findFirst({\r\n            where: { branchId },\r\n            orderBy: { createdAt: 'desc' },\r\n            select: { saleNumber: true }\r\n        });\r\n\r\n        let nextNum = 1;\r\n        if (lastSale?.saleNumber) {\r\n            // saleNumber format is \"SAL-YYYY-NNNNNN\" or plain digits\r\n            const parts = lastSale.saleNumber.split('-');\r\n            const lastDigits = parseInt(parts[parts.length - 1], 10);\r\n            if (!isNaN(lastDigits)) nextNum = lastDigits + 1;\r\n        }\r\n\r\n        const formatted = String(nextNum).padStart(6, '0');\r\n        return { success: true, data: formatted };\r\n    } catch (error: any) {\r\n        console.error('Error getting next receipt number:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAOsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,yDAAA"}},
    {"offset": {"line": 681, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.branchId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title || '',\r\n                items: (req.items as any) || [],\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- STOCK RECONCILIATION & REPAIRS ---\r\n\r\nexport async function getProductReconciliationAction(businessId: string, productId: string) {\r\n    try {\r\n        const product = await db.product.findUnique({\r\n            where: { id: productId },\r\n            include: { category: true }\r\n        });\r\n\r\n        if (!product) return { success: false, error: 'Product not found' };\r\n\r\n        // Fetch all history entries\r\n        const history = await db.productHistory.findMany({\r\n            where: { productId, locationId: businessId },\r\n            orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n        });\r\n\r\n        // Fetch all sales containing this product\r\n        const sales = await db.sale.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const openingStock = history.length > 0 ? history[0].newStock : 0;\r\n        const openingDate = history.length > 0 ? history[0].createdAt : null;\r\n\r\n        const dailyTransactions = new Map<string, any>();\r\n        let excludedSalesQty = 0;\r\n\r\n        sales.forEach(sale => {\r\n            const items = (sale.items as any[]) || [];\r\n            const soldQty = items\r\n                .filter(item => item.productId === productId)\r\n                .reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);\r\n\r\n            if (soldQty > 0) {\r\n                if (openingDate && sale.date < openingDate) {\r\n                    excludedSalesQty += soldQty;\r\n                } else {\r\n                    const dateStr = sale.date.toISOString().split('T')[0];\r\n                    const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n                    day.itemsSold += soldQty;\r\n                    dailyTransactions.set(dateStr, day);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Movements (excluding initial entry)\r\n        const movements = history.slice(1);\r\n        movements.forEach(h => {\r\n            const dateStr = h.createdAt.toISOString().split('T')[0];\r\n            const delta = h.newStock - h.oldStock;\r\n            const reason = (h.changeReason || '').toLowerCase();\r\n\r\n            const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n\r\n            if (h.type === 'RESTOCK' || reason.includes('purchase') || reason.includes('addition')) {\r\n                day.stockAdded += delta;\r\n            } else if (reason.includes('transfer out')) {\r\n                day.transferOut += Math.abs(delta);\r\n            } else if (reason.includes('customer return')) {\r\n                day.returnIn += delta;\r\n            } else if (reason.includes('return to supplier')) {\r\n                day.returnOut += Math.abs(delta);\r\n            } else if (h.type !== 'SALE') {\r\n                day.adjustments += delta;\r\n            }\r\n            dailyTransactions.set(dateStr, day);\r\n        });\r\n\r\n        const sortedDates = Array.from(dailyTransactions.keys()).sort();\r\n        const dailyBreakdown = [];\r\n        let runningStock = openingStock;\r\n\r\n        for (const date of sortedDates) {\r\n            const day = dailyTransactions.get(date);\r\n            const startingStock = runningStock;\r\n            const endingStock = startingStock - day.itemsSold + day.stockAdded - day.transferOut + day.returnIn - day.returnOut + day.adjustments;\r\n\r\n            dailyBreakdown.push({\r\n                date,\r\n                startingStock,\r\n                ...day,\r\n                endingStock\r\n            });\r\n            runningStock = endingStock;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                product: {\r\n                    id: product.id,\r\n                    name: product.name,\r\n                    quantity: product.stock,\r\n                    itemNumber: product.sku\r\n                },\r\n                currentStock: product.stock,\r\n                calculatedStock: runningStock,\r\n                discrepancy: product.stock - runningStock,\r\n                openingStock,\r\n                openingDate: openingDate?.toISOString(),\r\n                excludedSalesQty,\r\n                dailyBreakdown\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error in reconciliation action:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getStockRepairsPreviewAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true, name: true, stock: true }\r\n        });\r\n\r\n        const brokenChains = [];\r\n\r\n        for (const product of products) {\r\n            const history = await db.productHistory.findMany({\r\n                where: { productId: product.id, locationId: businessId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) continue;\r\n\r\n            let runningQuantity = 0;\r\n            const brokenEntries = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newStock - entry.oldStock;\r\n                const expectedPrev = runningQuantity;\r\n                const expectedNext = expectedPrev + change;\r\n\r\n                if (entry.oldStock !== expectedPrev || entry.newStock !== expectedNext) {\r\n                    brokenEntries.push({\r\n                        entryId: entry.id,\r\n                        createdAt: entry.createdAt.toISOString(),\r\n                        changeReason: entry.changeReason,\r\n                        currentPrevQty: entry.oldStock,\r\n                        currentNewQty: entry.newStock,\r\n                        fixedPrevQty: expectedPrev,\r\n                        fixedNewQty: expectedNext\r\n                    });\r\n                }\r\n                runningQuantity = expectedNext;\r\n            }\r\n\r\n            if (brokenEntries.length > 0 || Math.abs(product.stock - runningQuantity) > 0.001) {\r\n                brokenChains.push({\r\n                    productId: product.id,\r\n                    productName: product.name,\r\n                    totalEntries: history.length,\r\n                    brokenEntries,\r\n                    finalFixedQty: runningQuantity,\r\n                    currentProductQty: product.stock\r\n                });\r\n            }\r\n        }\r\n\r\n        return { success: true, data: brokenChains };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function repairStockChainsAction(businessId: string, productIds?: string[]) {\r\n    try {\r\n        const ids = productIds || (await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true }\r\n        })).map(p => p.id);\r\n\r\n        let repaired = 0;\r\n        let failed = 0;\r\n\r\n        for (const id of ids) {\r\n            try {\r\n                await recalculateStockChainAction(id, businessId);\r\n                repaired++;\r\n            } catch (err) {\r\n                failed++;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: { repaired, failed } };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getActivityByEntityIdsAction(entityIds: string[]) {\r\n    try {\r\n        const records = await db.activityHistory.findMany({\r\n            where: { entityId: { in: entityIds } },\r\n            select: { entityId: true, entityName: true }\r\n        });\r\n        return { success: true, data: records };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message, data: [] };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesAction(entryIds: string[], newDate: string) {\r\n    try {\r\n        await db.productHistory.updateMany({\r\n            where: { id: { in: entryIds } },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- RECEIPT NUMBER GENERATION ---\r\n\r\nexport async function getNextReceiptNumberAction(branchId: string) {\r\n    try {\r\n        const lastSale = await db.sale.findFirst({\r\n            where: { branchId },\r\n            orderBy: { createdAt: 'desc' },\r\n            select: { saleNumber: true }\r\n        });\r\n\r\n        let nextNum = 1;\r\n        if (lastSale?.saleNumber) {\r\n            // saleNumber format is \"SAL-YYYY-NNNNNN\" or plain digits\r\n            const parts = lastSale.saleNumber.split('-');\r\n            const lastDigits = parseInt(parts[parts.length - 1], 10);\r\n            if (!isNaN(lastDigits)) nextNum = lastDigits + 1;\r\n        }\r\n\r\n        const formatted = String(nextNum).padStart(6, '0');\r\n        return { success: true, data: formatted };\r\n    } catch (error: any) {\r\n        console.error('Error getting next receipt number:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoDsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 698, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.branchId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title || '',\r\n                items: (req.items as any) || [],\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- STOCK RECONCILIATION & REPAIRS ---\r\n\r\nexport async function getProductReconciliationAction(businessId: string, productId: string) {\r\n    try {\r\n        const product = await db.product.findUnique({\r\n            where: { id: productId },\r\n            include: { category: true }\r\n        });\r\n\r\n        if (!product) return { success: false, error: 'Product not found' };\r\n\r\n        // Fetch all history entries\r\n        const history = await db.productHistory.findMany({\r\n            where: { productId, locationId: businessId },\r\n            orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n        });\r\n\r\n        // Fetch all sales containing this product\r\n        const sales = await db.sale.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const openingStock = history.length > 0 ? history[0].newStock : 0;\r\n        const openingDate = history.length > 0 ? history[0].createdAt : null;\r\n\r\n        const dailyTransactions = new Map<string, any>();\r\n        let excludedSalesQty = 0;\r\n\r\n        sales.forEach(sale => {\r\n            const items = (sale.items as any[]) || [];\r\n            const soldQty = items\r\n                .filter(item => item.productId === productId)\r\n                .reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);\r\n\r\n            if (soldQty > 0) {\r\n                if (openingDate && sale.date < openingDate) {\r\n                    excludedSalesQty += soldQty;\r\n                } else {\r\n                    const dateStr = sale.date.toISOString().split('T')[0];\r\n                    const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n                    day.itemsSold += soldQty;\r\n                    dailyTransactions.set(dateStr, day);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Movements (excluding initial entry)\r\n        const movements = history.slice(1);\r\n        movements.forEach(h => {\r\n            const dateStr = h.createdAt.toISOString().split('T')[0];\r\n            const delta = h.newStock - h.oldStock;\r\n            const reason = (h.changeReason || '').toLowerCase();\r\n\r\n            const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n\r\n            if (h.type === 'RESTOCK' || reason.includes('purchase') || reason.includes('addition')) {\r\n                day.stockAdded += delta;\r\n            } else if (reason.includes('transfer out')) {\r\n                day.transferOut += Math.abs(delta);\r\n            } else if (reason.includes('customer return')) {\r\n                day.returnIn += delta;\r\n            } else if (reason.includes('return to supplier')) {\r\n                day.returnOut += Math.abs(delta);\r\n            } else if (h.type !== 'SALE') {\r\n                day.adjustments += delta;\r\n            }\r\n            dailyTransactions.set(dateStr, day);\r\n        });\r\n\r\n        const sortedDates = Array.from(dailyTransactions.keys()).sort();\r\n        const dailyBreakdown = [];\r\n        let runningStock = openingStock;\r\n\r\n        for (const date of sortedDates) {\r\n            const day = dailyTransactions.get(date);\r\n            const startingStock = runningStock;\r\n            const endingStock = startingStock - day.itemsSold + day.stockAdded - day.transferOut + day.returnIn - day.returnOut + day.adjustments;\r\n\r\n            dailyBreakdown.push({\r\n                date,\r\n                startingStock,\r\n                ...day,\r\n                endingStock\r\n            });\r\n            runningStock = endingStock;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                product: {\r\n                    id: product.id,\r\n                    name: product.name,\r\n                    quantity: product.stock,\r\n                    itemNumber: product.sku\r\n                },\r\n                currentStock: product.stock,\r\n                calculatedStock: runningStock,\r\n                discrepancy: product.stock - runningStock,\r\n                openingStock,\r\n                openingDate: openingDate?.toISOString(),\r\n                excludedSalesQty,\r\n                dailyBreakdown\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error in reconciliation action:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getStockRepairsPreviewAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true, name: true, stock: true }\r\n        });\r\n\r\n        const brokenChains = [];\r\n\r\n        for (const product of products) {\r\n            const history = await db.productHistory.findMany({\r\n                where: { productId: product.id, locationId: businessId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) continue;\r\n\r\n            let runningQuantity = 0;\r\n            const brokenEntries = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newStock - entry.oldStock;\r\n                const expectedPrev = runningQuantity;\r\n                const expectedNext = expectedPrev + change;\r\n\r\n                if (entry.oldStock !== expectedPrev || entry.newStock !== expectedNext) {\r\n                    brokenEntries.push({\r\n                        entryId: entry.id,\r\n                        createdAt: entry.createdAt.toISOString(),\r\n                        changeReason: entry.changeReason,\r\n                        currentPrevQty: entry.oldStock,\r\n                        currentNewQty: entry.newStock,\r\n                        fixedPrevQty: expectedPrev,\r\n                        fixedNewQty: expectedNext\r\n                    });\r\n                }\r\n                runningQuantity = expectedNext;\r\n            }\r\n\r\n            if (brokenEntries.length > 0 || Math.abs(product.stock - runningQuantity) > 0.001) {\r\n                brokenChains.push({\r\n                    productId: product.id,\r\n                    productName: product.name,\r\n                    totalEntries: history.length,\r\n                    brokenEntries,\r\n                    finalFixedQty: runningQuantity,\r\n                    currentProductQty: product.stock\r\n                });\r\n            }\r\n        }\r\n\r\n        return { success: true, data: brokenChains };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function repairStockChainsAction(businessId: string, productIds?: string[]) {\r\n    try {\r\n        const ids = productIds || (await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true }\r\n        })).map(p => p.id);\r\n\r\n        let repaired = 0;\r\n        let failed = 0;\r\n\r\n        for (const id of ids) {\r\n            try {\r\n                await recalculateStockChainAction(id, businessId);\r\n                repaired++;\r\n            } catch (err) {\r\n                failed++;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: { repaired, failed } };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getActivityByEntityIdsAction(entityIds: string[]) {\r\n    try {\r\n        const records = await db.activityHistory.findMany({\r\n            where: { entityId: { in: entityIds } },\r\n            select: { entityId: true, entityName: true }\r\n        });\r\n        return { success: true, data: records };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message, data: [] };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesAction(entryIds: string[], newDate: string) {\r\n    try {\r\n        await db.productHistory.updateMany({\r\n            where: { id: { in: entryIds } },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- RECEIPT NUMBER GENERATION ---\r\n\r\nexport async function getNextReceiptNumberAction(branchId: string) {\r\n    try {\r\n        const lastSale = await db.sale.findFirst({\r\n            where: { branchId },\r\n            orderBy: { createdAt: 'desc' },\r\n            select: { saleNumber: true }\r\n        });\r\n\r\n        let nextNum = 1;\r\n        if (lastSale?.saleNumber) {\r\n            // saleNumber format is \"SAL-YYYY-NNNNNN\" or plain digits\r\n            const parts = lastSale.saleNumber.split('-');\r\n            const lastDigits = parseInt(parts[parts.length - 1], 10);\r\n            if (!isNaN(lastDigits)) nextNum = lastDigits + 1;\r\n        }\r\n\r\n        const formatted = String(nextNum).padStart(6, '0');\r\n        return { success: true, data: formatted };\r\n    } catch (error: any) {\r\n        console.error('Error getting next receipt number:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsFsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 715, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.branchId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title || '',\r\n                items: (req.items as any) || [],\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- STOCK RECONCILIATION & REPAIRS ---\r\n\r\nexport async function getProductReconciliationAction(businessId: string, productId: string) {\r\n    try {\r\n        const product = await db.product.findUnique({\r\n            where: { id: productId },\r\n            include: { category: true }\r\n        });\r\n\r\n        if (!product) return { success: false, error: 'Product not found' };\r\n\r\n        // Fetch all history entries\r\n        const history = await db.productHistory.findMany({\r\n            where: { productId, locationId: businessId },\r\n            orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n        });\r\n\r\n        // Fetch all sales containing this product\r\n        const sales = await db.sale.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const openingStock = history.length > 0 ? history[0].newStock : 0;\r\n        const openingDate = history.length > 0 ? history[0].createdAt : null;\r\n\r\n        const dailyTransactions = new Map<string, any>();\r\n        let excludedSalesQty = 0;\r\n\r\n        sales.forEach(sale => {\r\n            const items = (sale.items as any[]) || [];\r\n            const soldQty = items\r\n                .filter(item => item.productId === productId)\r\n                .reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);\r\n\r\n            if (soldQty > 0) {\r\n                if (openingDate && sale.date < openingDate) {\r\n                    excludedSalesQty += soldQty;\r\n                } else {\r\n                    const dateStr = sale.date.toISOString().split('T')[0];\r\n                    const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n                    day.itemsSold += soldQty;\r\n                    dailyTransactions.set(dateStr, day);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Movements (excluding initial entry)\r\n        const movements = history.slice(1);\r\n        movements.forEach(h => {\r\n            const dateStr = h.createdAt.toISOString().split('T')[0];\r\n            const delta = h.newStock - h.oldStock;\r\n            const reason = (h.changeReason || '').toLowerCase();\r\n\r\n            const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n\r\n            if (h.type === 'RESTOCK' || reason.includes('purchase') || reason.includes('addition')) {\r\n                day.stockAdded += delta;\r\n            } else if (reason.includes('transfer out')) {\r\n                day.transferOut += Math.abs(delta);\r\n            } else if (reason.includes('customer return')) {\r\n                day.returnIn += delta;\r\n            } else if (reason.includes('return to supplier')) {\r\n                day.returnOut += Math.abs(delta);\r\n            } else if (h.type !== 'SALE') {\r\n                day.adjustments += delta;\r\n            }\r\n            dailyTransactions.set(dateStr, day);\r\n        });\r\n\r\n        const sortedDates = Array.from(dailyTransactions.keys()).sort();\r\n        const dailyBreakdown = [];\r\n        let runningStock = openingStock;\r\n\r\n        for (const date of sortedDates) {\r\n            const day = dailyTransactions.get(date);\r\n            const startingStock = runningStock;\r\n            const endingStock = startingStock - day.itemsSold + day.stockAdded - day.transferOut + day.returnIn - day.returnOut + day.adjustments;\r\n\r\n            dailyBreakdown.push({\r\n                date,\r\n                startingStock,\r\n                ...day,\r\n                endingStock\r\n            });\r\n            runningStock = endingStock;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                product: {\r\n                    id: product.id,\r\n                    name: product.name,\r\n                    quantity: product.stock,\r\n                    itemNumber: product.sku\r\n                },\r\n                currentStock: product.stock,\r\n                calculatedStock: runningStock,\r\n                discrepancy: product.stock - runningStock,\r\n                openingStock,\r\n                openingDate: openingDate?.toISOString(),\r\n                excludedSalesQty,\r\n                dailyBreakdown\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error in reconciliation action:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getStockRepairsPreviewAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true, name: true, stock: true }\r\n        });\r\n\r\n        const brokenChains = [];\r\n\r\n        for (const product of products) {\r\n            const history = await db.productHistory.findMany({\r\n                where: { productId: product.id, locationId: businessId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) continue;\r\n\r\n            let runningQuantity = 0;\r\n            const brokenEntries = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newStock - entry.oldStock;\r\n                const expectedPrev = runningQuantity;\r\n                const expectedNext = expectedPrev + change;\r\n\r\n                if (entry.oldStock !== expectedPrev || entry.newStock !== expectedNext) {\r\n                    brokenEntries.push({\r\n                        entryId: entry.id,\r\n                        createdAt: entry.createdAt.toISOString(),\r\n                        changeReason: entry.changeReason,\r\n                        currentPrevQty: entry.oldStock,\r\n                        currentNewQty: entry.newStock,\r\n                        fixedPrevQty: expectedPrev,\r\n                        fixedNewQty: expectedNext\r\n                    });\r\n                }\r\n                runningQuantity = expectedNext;\r\n            }\r\n\r\n            if (brokenEntries.length > 0 || Math.abs(product.stock - runningQuantity) > 0.001) {\r\n                brokenChains.push({\r\n                    productId: product.id,\r\n                    productName: product.name,\r\n                    totalEntries: history.length,\r\n                    brokenEntries,\r\n                    finalFixedQty: runningQuantity,\r\n                    currentProductQty: product.stock\r\n                });\r\n            }\r\n        }\r\n\r\n        return { success: true, data: brokenChains };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function repairStockChainsAction(businessId: string, productIds?: string[]) {\r\n    try {\r\n        const ids = productIds || (await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true }\r\n        })).map(p => p.id);\r\n\r\n        let repaired = 0;\r\n        let failed = 0;\r\n\r\n        for (const id of ids) {\r\n            try {\r\n                await recalculateStockChainAction(id, businessId);\r\n                repaired++;\r\n            } catch (err) {\r\n                failed++;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: { repaired, failed } };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getActivityByEntityIdsAction(entityIds: string[]) {\r\n    try {\r\n        const records = await db.activityHistory.findMany({\r\n            where: { entityId: { in: entityIds } },\r\n            select: { entityId: true, entityName: true }\r\n        });\r\n        return { success: true, data: records };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message, data: [] };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesAction(entryIds: string[], newDate: string) {\r\n    try {\r\n        await db.productHistory.updateMany({\r\n            where: { id: { in: entryIds } },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- RECEIPT NUMBER GENERATION ---\r\n\r\nexport async function getNextReceiptNumberAction(branchId: string) {\r\n    try {\r\n        const lastSale = await db.sale.findFirst({\r\n            where: { branchId },\r\n            orderBy: { createdAt: 'desc' },\r\n            select: { saleNumber: true }\r\n        });\r\n\r\n        let nextNum = 1;\r\n        if (lastSale?.saleNumber) {\r\n            // saleNumber format is \"SAL-YYYY-NNNNNN\" or plain digits\r\n            const parts = lastSale.saleNumber.split('-');\r\n            const lastDigits = parseInt(parts[parts.length - 1], 10);\r\n            if (!isNaN(lastDigits)) nextNum = lastDigits + 1;\r\n        }\r\n\r\n        const formatted = String(nextNum).padStart(6, '0');\r\n        return { success: true, data: formatted };\r\n    } catch (error: any) {\r\n        console.error('Error getting next receipt number:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsIsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,8EAAA"}},
    {"offset": {"line": 732, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.branchId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title || '',\r\n                items: (req.items as any) || [],\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- STOCK RECONCILIATION & REPAIRS ---\r\n\r\nexport async function getProductReconciliationAction(businessId: string, productId: string) {\r\n    try {\r\n        const product = await db.product.findUnique({\r\n            where: { id: productId },\r\n            include: { category: true }\r\n        });\r\n\r\n        if (!product) return { success: false, error: 'Product not found' };\r\n\r\n        // Fetch all history entries\r\n        const history = await db.productHistory.findMany({\r\n            where: { productId, locationId: businessId },\r\n            orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n        });\r\n\r\n        // Fetch all sales containing this product\r\n        const sales = await db.sale.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const openingStock = history.length > 0 ? history[0].newStock : 0;\r\n        const openingDate = history.length > 0 ? history[0].createdAt : null;\r\n\r\n        const dailyTransactions = new Map<string, any>();\r\n        let excludedSalesQty = 0;\r\n\r\n        sales.forEach(sale => {\r\n            const items = (sale.items as any[]) || [];\r\n            const soldQty = items\r\n                .filter(item => item.productId === productId)\r\n                .reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);\r\n\r\n            if (soldQty > 0) {\r\n                if (openingDate && sale.date < openingDate) {\r\n                    excludedSalesQty += soldQty;\r\n                } else {\r\n                    const dateStr = sale.date.toISOString().split('T')[0];\r\n                    const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n                    day.itemsSold += soldQty;\r\n                    dailyTransactions.set(dateStr, day);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Movements (excluding initial entry)\r\n        const movements = history.slice(1);\r\n        movements.forEach(h => {\r\n            const dateStr = h.createdAt.toISOString().split('T')[0];\r\n            const delta = h.newStock - h.oldStock;\r\n            const reason = (h.changeReason || '').toLowerCase();\r\n\r\n            const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n\r\n            if (h.type === 'RESTOCK' || reason.includes('purchase') || reason.includes('addition')) {\r\n                day.stockAdded += delta;\r\n            } else if (reason.includes('transfer out')) {\r\n                day.transferOut += Math.abs(delta);\r\n            } else if (reason.includes('customer return')) {\r\n                day.returnIn += delta;\r\n            } else if (reason.includes('return to supplier')) {\r\n                day.returnOut += Math.abs(delta);\r\n            } else if (h.type !== 'SALE') {\r\n                day.adjustments += delta;\r\n            }\r\n            dailyTransactions.set(dateStr, day);\r\n        });\r\n\r\n        const sortedDates = Array.from(dailyTransactions.keys()).sort();\r\n        const dailyBreakdown = [];\r\n        let runningStock = openingStock;\r\n\r\n        for (const date of sortedDates) {\r\n            const day = dailyTransactions.get(date);\r\n            const startingStock = runningStock;\r\n            const endingStock = startingStock - day.itemsSold + day.stockAdded - day.transferOut + day.returnIn - day.returnOut + day.adjustments;\r\n\r\n            dailyBreakdown.push({\r\n                date,\r\n                startingStock,\r\n                ...day,\r\n                endingStock\r\n            });\r\n            runningStock = endingStock;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                product: {\r\n                    id: product.id,\r\n                    name: product.name,\r\n                    quantity: product.stock,\r\n                    itemNumber: product.sku\r\n                },\r\n                currentStock: product.stock,\r\n                calculatedStock: runningStock,\r\n                discrepancy: product.stock - runningStock,\r\n                openingStock,\r\n                openingDate: openingDate?.toISOString(),\r\n                excludedSalesQty,\r\n                dailyBreakdown\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error in reconciliation action:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getStockRepairsPreviewAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true, name: true, stock: true }\r\n        });\r\n\r\n        const brokenChains = [];\r\n\r\n        for (const product of products) {\r\n            const history = await db.productHistory.findMany({\r\n                where: { productId: product.id, locationId: businessId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) continue;\r\n\r\n            let runningQuantity = 0;\r\n            const brokenEntries = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newStock - entry.oldStock;\r\n                const expectedPrev = runningQuantity;\r\n                const expectedNext = expectedPrev + change;\r\n\r\n                if (entry.oldStock !== expectedPrev || entry.newStock !== expectedNext) {\r\n                    brokenEntries.push({\r\n                        entryId: entry.id,\r\n                        createdAt: entry.createdAt.toISOString(),\r\n                        changeReason: entry.changeReason,\r\n                        currentPrevQty: entry.oldStock,\r\n                        currentNewQty: entry.newStock,\r\n                        fixedPrevQty: expectedPrev,\r\n                        fixedNewQty: expectedNext\r\n                    });\r\n                }\r\n                runningQuantity = expectedNext;\r\n            }\r\n\r\n            if (brokenEntries.length > 0 || Math.abs(product.stock - runningQuantity) > 0.001) {\r\n                brokenChains.push({\r\n                    productId: product.id,\r\n                    productName: product.name,\r\n                    totalEntries: history.length,\r\n                    brokenEntries,\r\n                    finalFixedQty: runningQuantity,\r\n                    currentProductQty: product.stock\r\n                });\r\n            }\r\n        }\r\n\r\n        return { success: true, data: brokenChains };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function repairStockChainsAction(businessId: string, productIds?: string[]) {\r\n    try {\r\n        const ids = productIds || (await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true }\r\n        })).map(p => p.id);\r\n\r\n        let repaired = 0;\r\n        let failed = 0;\r\n\r\n        for (const id of ids) {\r\n            try {\r\n                await recalculateStockChainAction(id, businessId);\r\n                repaired++;\r\n            } catch (err) {\r\n                failed++;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: { repaired, failed } };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getActivityByEntityIdsAction(entityIds: string[]) {\r\n    try {\r\n        const records = await db.activityHistory.findMany({\r\n            where: { entityId: { in: entityIds } },\r\n            select: { entityId: true, entityName: true }\r\n        });\r\n        return { success: true, data: records };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message, data: [] };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesAction(entryIds: string[], newDate: string) {\r\n    try {\r\n        await db.productHistory.updateMany({\r\n            where: { id: { in: entryIds } },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- RECEIPT NUMBER GENERATION ---\r\n\r\nexport async function getNextReceiptNumberAction(branchId: string) {\r\n    try {\r\n        const lastSale = await db.sale.findFirst({\r\n            where: { branchId },\r\n            orderBy: { createdAt: 'desc' },\r\n            select: { saleNumber: true }\r\n        });\r\n\r\n        let nextNum = 1;\r\n        if (lastSale?.saleNumber) {\r\n            // saleNumber format is \"SAL-YYYY-NNNNNN\" or plain digits\r\n            const parts = lastSale.saleNumber.split('-');\r\n            const lastDigits = parseInt(parts[parts.length - 1], 10);\r\n            if (!isNaN(lastDigits)) nextNum = lastDigits + 1;\r\n        }\r\n\r\n        const formatted = String(nextNum).padStart(6, '0');\r\n        return { success: true, data: formatted };\r\n    } catch (error: any) {\r\n        console.error('Error getting next receipt number:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4EAAA"}},
    {"offset": {"line": 749, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.branchId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title || '',\r\n                items: (req.items as any) || [],\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- STOCK RECONCILIATION & REPAIRS ---\r\n\r\nexport async function getProductReconciliationAction(businessId: string, productId: string) {\r\n    try {\r\n        const product = await db.product.findUnique({\r\n            where: { id: productId },\r\n            include: { category: true }\r\n        });\r\n\r\n        if (!product) return { success: false, error: 'Product not found' };\r\n\r\n        // Fetch all history entries\r\n        const history = await db.productHistory.findMany({\r\n            where: { productId, locationId: businessId },\r\n            orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n        });\r\n\r\n        // Fetch all sales containing this product\r\n        const sales = await db.sale.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const openingStock = history.length > 0 ? history[0].newStock : 0;\r\n        const openingDate = history.length > 0 ? history[0].createdAt : null;\r\n\r\n        const dailyTransactions = new Map<string, any>();\r\n        let excludedSalesQty = 0;\r\n\r\n        sales.forEach(sale => {\r\n            const items = (sale.items as any[]) || [];\r\n            const soldQty = items\r\n                .filter(item => item.productId === productId)\r\n                .reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);\r\n\r\n            if (soldQty > 0) {\r\n                if (openingDate && sale.date < openingDate) {\r\n                    excludedSalesQty += soldQty;\r\n                } else {\r\n                    const dateStr = sale.date.toISOString().split('T')[0];\r\n                    const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n                    day.itemsSold += soldQty;\r\n                    dailyTransactions.set(dateStr, day);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Movements (excluding initial entry)\r\n        const movements = history.slice(1);\r\n        movements.forEach(h => {\r\n            const dateStr = h.createdAt.toISOString().split('T')[0];\r\n            const delta = h.newStock - h.oldStock;\r\n            const reason = (h.changeReason || '').toLowerCase();\r\n\r\n            const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n\r\n            if (h.type === 'RESTOCK' || reason.includes('purchase') || reason.includes('addition')) {\r\n                day.stockAdded += delta;\r\n            } else if (reason.includes('transfer out')) {\r\n                day.transferOut += Math.abs(delta);\r\n            } else if (reason.includes('customer return')) {\r\n                day.returnIn += delta;\r\n            } else if (reason.includes('return to supplier')) {\r\n                day.returnOut += Math.abs(delta);\r\n            } else if (h.type !== 'SALE') {\r\n                day.adjustments += delta;\r\n            }\r\n            dailyTransactions.set(dateStr, day);\r\n        });\r\n\r\n        const sortedDates = Array.from(dailyTransactions.keys()).sort();\r\n        const dailyBreakdown = [];\r\n        let runningStock = openingStock;\r\n\r\n        for (const date of sortedDates) {\r\n            const day = dailyTransactions.get(date);\r\n            const startingStock = runningStock;\r\n            const endingStock = startingStock - day.itemsSold + day.stockAdded - day.transferOut + day.returnIn - day.returnOut + day.adjustments;\r\n\r\n            dailyBreakdown.push({\r\n                date,\r\n                startingStock,\r\n                ...day,\r\n                endingStock\r\n            });\r\n            runningStock = endingStock;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                product: {\r\n                    id: product.id,\r\n                    name: product.name,\r\n                    quantity: product.stock,\r\n                    itemNumber: product.sku\r\n                },\r\n                currentStock: product.stock,\r\n                calculatedStock: runningStock,\r\n                discrepancy: product.stock - runningStock,\r\n                openingStock,\r\n                openingDate: openingDate?.toISOString(),\r\n                excludedSalesQty,\r\n                dailyBreakdown\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error in reconciliation action:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getStockRepairsPreviewAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true, name: true, stock: true }\r\n        });\r\n\r\n        const brokenChains = [];\r\n\r\n        for (const product of products) {\r\n            const history = await db.productHistory.findMany({\r\n                where: { productId: product.id, locationId: businessId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) continue;\r\n\r\n            let runningQuantity = 0;\r\n            const brokenEntries = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newStock - entry.oldStock;\r\n                const expectedPrev = runningQuantity;\r\n                const expectedNext = expectedPrev + change;\r\n\r\n                if (entry.oldStock !== expectedPrev || entry.newStock !== expectedNext) {\r\n                    brokenEntries.push({\r\n                        entryId: entry.id,\r\n                        createdAt: entry.createdAt.toISOString(),\r\n                        changeReason: entry.changeReason,\r\n                        currentPrevQty: entry.oldStock,\r\n                        currentNewQty: entry.newStock,\r\n                        fixedPrevQty: expectedPrev,\r\n                        fixedNewQty: expectedNext\r\n                    });\r\n                }\r\n                runningQuantity = expectedNext;\r\n            }\r\n\r\n            if (brokenEntries.length > 0 || Math.abs(product.stock - runningQuantity) > 0.001) {\r\n                brokenChains.push({\r\n                    productId: product.id,\r\n                    productName: product.name,\r\n                    totalEntries: history.length,\r\n                    brokenEntries,\r\n                    finalFixedQty: runningQuantity,\r\n                    currentProductQty: product.stock\r\n                });\r\n            }\r\n        }\r\n\r\n        return { success: true, data: brokenChains };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function repairStockChainsAction(businessId: string, productIds?: string[]) {\r\n    try {\r\n        const ids = productIds || (await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true }\r\n        })).map(p => p.id);\r\n\r\n        let repaired = 0;\r\n        let failed = 0;\r\n\r\n        for (const id of ids) {\r\n            try {\r\n                await recalculateStockChainAction(id, businessId);\r\n                repaired++;\r\n            } catch (err) {\r\n                failed++;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: { repaired, failed } };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getActivityByEntityIdsAction(entityIds: string[]) {\r\n    try {\r\n        const records = await db.activityHistory.findMany({\r\n            where: { entityId: { in: entityIds } },\r\n            select: { entityId: true, entityName: true }\r\n        });\r\n        return { success: true, data: records };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message, data: [] };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesAction(entryIds: string[], newDate: string) {\r\n    try {\r\n        await db.productHistory.updateMany({\r\n            where: { id: { in: entryIds } },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- RECEIPT NUMBER GENERATION ---\r\n\r\nexport async function getNextReceiptNumberAction(branchId: string) {\r\n    try {\r\n        const lastSale = await db.sale.findFirst({\r\n            where: { branchId },\r\n            orderBy: { createdAt: 'desc' },\r\n            select: { saleNumber: true }\r\n        });\r\n\r\n        let nextNum = 1;\r\n        if (lastSale?.saleNumber) {\r\n            // saleNumber format is \"SAL-YYYY-NNNNNN\" or plain digits\r\n            const parts = lastSale.saleNumber.split('-');\r\n            const lastDigits = parseInt(parts[parts.length - 1], 10);\r\n            if (!isNaN(lastDigits)) nextNum = lastDigits + 1;\r\n        }\r\n\r\n        const formatted = String(nextNum).padStart(6, '0');\r\n        return { success: true, data: formatted };\r\n    } catch (error: any) {\r\n        console.error('Error getting next receipt number:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0kBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 766, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.branchId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title || '',\r\n                items: (req.items as any) || [],\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- STOCK RECONCILIATION & REPAIRS ---\r\n\r\nexport async function getProductReconciliationAction(businessId: string, productId: string) {\r\n    try {\r\n        const product = await db.product.findUnique({\r\n            where: { id: productId },\r\n            include: { category: true }\r\n        });\r\n\r\n        if (!product) return { success: false, error: 'Product not found' };\r\n\r\n        // Fetch all history entries\r\n        const history = await db.productHistory.findMany({\r\n            where: { productId, locationId: businessId },\r\n            orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n        });\r\n\r\n        // Fetch all sales containing this product\r\n        const sales = await db.sale.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const openingStock = history.length > 0 ? history[0].newStock : 0;\r\n        const openingDate = history.length > 0 ? history[0].createdAt : null;\r\n\r\n        const dailyTransactions = new Map<string, any>();\r\n        let excludedSalesQty = 0;\r\n\r\n        sales.forEach(sale => {\r\n            const items = (sale.items as any[]) || [];\r\n            const soldQty = items\r\n                .filter(item => item.productId === productId)\r\n                .reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);\r\n\r\n            if (soldQty > 0) {\r\n                if (openingDate && sale.date < openingDate) {\r\n                    excludedSalesQty += soldQty;\r\n                } else {\r\n                    const dateStr = sale.date.toISOString().split('T')[0];\r\n                    const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n                    day.itemsSold += soldQty;\r\n                    dailyTransactions.set(dateStr, day);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Movements (excluding initial entry)\r\n        const movements = history.slice(1);\r\n        movements.forEach(h => {\r\n            const dateStr = h.createdAt.toISOString().split('T')[0];\r\n            const delta = h.newStock - h.oldStock;\r\n            const reason = (h.changeReason || '').toLowerCase();\r\n\r\n            const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n\r\n            if (h.type === 'RESTOCK' || reason.includes('purchase') || reason.includes('addition')) {\r\n                day.stockAdded += delta;\r\n            } else if (reason.includes('transfer out')) {\r\n                day.transferOut += Math.abs(delta);\r\n            } else if (reason.includes('customer return')) {\r\n                day.returnIn += delta;\r\n            } else if (reason.includes('return to supplier')) {\r\n                day.returnOut += Math.abs(delta);\r\n            } else if (h.type !== 'SALE') {\r\n                day.adjustments += delta;\r\n            }\r\n            dailyTransactions.set(dateStr, day);\r\n        });\r\n\r\n        const sortedDates = Array.from(dailyTransactions.keys()).sort();\r\n        const dailyBreakdown = [];\r\n        let runningStock = openingStock;\r\n\r\n        for (const date of sortedDates) {\r\n            const day = dailyTransactions.get(date);\r\n            const startingStock = runningStock;\r\n            const endingStock = startingStock - day.itemsSold + day.stockAdded - day.transferOut + day.returnIn - day.returnOut + day.adjustments;\r\n\r\n            dailyBreakdown.push({\r\n                date,\r\n                startingStock,\r\n                ...day,\r\n                endingStock\r\n            });\r\n            runningStock = endingStock;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                product: {\r\n                    id: product.id,\r\n                    name: product.name,\r\n                    quantity: product.stock,\r\n                    itemNumber: product.sku\r\n                },\r\n                currentStock: product.stock,\r\n                calculatedStock: runningStock,\r\n                discrepancy: product.stock - runningStock,\r\n                openingStock,\r\n                openingDate: openingDate?.toISOString(),\r\n                excludedSalesQty,\r\n                dailyBreakdown\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error in reconciliation action:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getStockRepairsPreviewAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true, name: true, stock: true }\r\n        });\r\n\r\n        const brokenChains = [];\r\n\r\n        for (const product of products) {\r\n            const history = await db.productHistory.findMany({\r\n                where: { productId: product.id, locationId: businessId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) continue;\r\n\r\n            let runningQuantity = 0;\r\n            const brokenEntries = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newStock - entry.oldStock;\r\n                const expectedPrev = runningQuantity;\r\n                const expectedNext = expectedPrev + change;\r\n\r\n                if (entry.oldStock !== expectedPrev || entry.newStock !== expectedNext) {\r\n                    brokenEntries.push({\r\n                        entryId: entry.id,\r\n                        createdAt: entry.createdAt.toISOString(),\r\n                        changeReason: entry.changeReason,\r\n                        currentPrevQty: entry.oldStock,\r\n                        currentNewQty: entry.newStock,\r\n                        fixedPrevQty: expectedPrev,\r\n                        fixedNewQty: expectedNext\r\n                    });\r\n                }\r\n                runningQuantity = expectedNext;\r\n            }\r\n\r\n            if (brokenEntries.length > 0 || Math.abs(product.stock - runningQuantity) > 0.001) {\r\n                brokenChains.push({\r\n                    productId: product.id,\r\n                    productName: product.name,\r\n                    totalEntries: history.length,\r\n                    brokenEntries,\r\n                    finalFixedQty: runningQuantity,\r\n                    currentProductQty: product.stock\r\n                });\r\n            }\r\n        }\r\n\r\n        return { success: true, data: brokenChains };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function repairStockChainsAction(businessId: string, productIds?: string[]) {\r\n    try {\r\n        const ids = productIds || (await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true }\r\n        })).map(p => p.id);\r\n\r\n        let repaired = 0;\r\n        let failed = 0;\r\n\r\n        for (const id of ids) {\r\n            try {\r\n                await recalculateStockChainAction(id, businessId);\r\n                repaired++;\r\n            } catch (err) {\r\n                failed++;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: { repaired, failed } };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getActivityByEntityIdsAction(entityIds: string[]) {\r\n    try {\r\n        const records = await db.activityHistory.findMany({\r\n            where: { entityId: { in: entityIds } },\r\n            select: { entityId: true, entityName: true }\r\n        });\r\n        return { success: true, data: records };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message, data: [] };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesAction(entryIds: string[], newDate: string) {\r\n    try {\r\n        await db.productHistory.updateMany({\r\n            where: { id: { in: entryIds } },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- RECEIPT NUMBER GENERATION ---\r\n\r\nexport async function getNextReceiptNumberAction(branchId: string) {\r\n    try {\r\n        const lastSale = await db.sale.findFirst({\r\n            where: { branchId },\r\n            orderBy: { createdAt: 'desc' },\r\n            select: { saleNumber: true }\r\n        });\r\n\r\n        let nextNum = 1;\r\n        if (lastSale?.saleNumber) {\r\n            // saleNumber format is \"SAL-YYYY-NNNNNN\" or plain digits\r\n            const parts = lastSale.saleNumber.split('-');\r\n            const lastDigits = parseInt(parts[parts.length - 1], 10);\r\n            if (!isNaN(lastDigits)) nextNum = lastDigits + 1;\r\n        }\r\n\r\n        const formatted = String(nextNum).padStart(6, '0');\r\n        return { success: true, data: formatted };\r\n    } catch (error: any) {\r\n        console.error('Error getting next receipt number:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAihBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,iEAAA"}},
    {"offset": {"line": 783, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useStockHistory.ts"],"sourcesContent":["\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { StockHistoryEntry } from '@/types';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport {\r\n  getStockHistoryAction,\r\n  createStockHistoryAction,\r\n  recalculateStockChainAction,\r\n  deleteStockHistoryEntriesByReferenceAction,\r\n  updateStockHistoryDatesByReferenceAction,\r\n  repairStockChainsAction,\r\n  getStockRepairsPreviewAction\r\n} from '@/app/actions/inventory';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\n\r\nexport interface ChainRepairBreakEntry {\r\n  entryId: string;\r\n  createdAt: string;\r\n  changeReason: string;\r\n  currentPrevQty: number;\r\n  currentNewQty: number;\r\n  fixedPrevQty: number;\r\n  fixedNewQty: number;\r\n}\r\n\r\nexport interface ChainRepairPreview {\r\n  productId: string;\r\n  productName: string;\r\n  totalEntries: number;\r\n  brokenEntries: ChainRepairBreakEntry[];\r\n  finalFixedQty: number;\r\n  currentProductQty: number;\r\n}\r\n\r\nexport const useStockHistory = (userId: string | undefined, productId?: string) => {\r\n  const [stockHistory, setStockHistory] = useState<StockHistoryEntry[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const loadStockHistory = useCallback(async () => {\r\n    if (!userId || !currentBusiness) {\r\n      setStockHistory([]);\r\n      setIsLoading(false);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setIsLoading(true);\r\n      const result = await getStockHistoryAction(currentBusiness.id, productId);\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error || 'Failed to fetch stock history');\r\n      }\r\n\r\n      const formattedHistory: StockHistoryEntry[] = result.data.map((entry: any) => ({\r\n        id: entry.id,\r\n        productId: entry.productId,\r\n        oldQuantity: entry.oldQuantity,\r\n        newQuantity: entry.newQuantity,\r\n        changeReason: entry.changeReason,\r\n        createdAt: new Date(entry.createdAt),\r\n        referenceId: entry.referenceId,\r\n        receiptNumber: entry.receiptNumber,\r\n        product: entry.product\r\n      }));\r\n\r\n      setStockHistory(formattedHistory);\r\n    } catch (error) {\r\n      console.error('Error loading stock history:', error);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [userId, currentBusiness?.id, productId]);\r\n\r\n  useEffect(() => {\r\n    loadStockHistory();\r\n  }, [loadStockHistory]);\r\n\r\n  const createStockHistoryEntry = async (\r\n    targetProductId: string,\r\n    previousQuantity: number,\r\n    newQuantity: number,\r\n    reason: string,\r\n    referenceId?: string,\r\n    entryDate?: Date,\r\n    receiptNumber?: string,\r\n    productName?: string\r\n  ) => {\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      const snapshottedReason = productName\r\n        ? `[${productName}] | ${reason}`\r\n        : reason;\r\n\r\n      const result = await createStockHistoryAction({\r\n        userId,\r\n        locationId: currentBusiness.id,\r\n        productId: targetProductId,\r\n        previousQuantity,\r\n        newQuantity,\r\n        changeReason: snapshottedReason,\r\n        referenceId,\r\n        receiptNumber,\r\n        createdAt: entryDate?.toISOString()\r\n      });\r\n\r\n      if (!result.success) {\r\n        console.error('Error creating stock history entry:', result.error);\r\n        return false;\r\n      }\r\n\r\n      await loadStockHistory();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error creating stock history:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteMultipleStockHistoryEntriesByReference = async (referenceId: string) => {\r\n    try {\r\n      if (!currentBusiness) return false;\r\n      const result = await deleteStockHistoryEntriesByReferenceAction(referenceId, currentBusiness.id);\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      await loadStockHistory();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting stock history entries:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const recalculateStockChain = async (targetProductId: string) => {\r\n    try {\r\n      if (!currentBusiness) return false;\r\n      const result = await recalculateStockChainAction(targetProductId, currentBusiness.id);\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      await loadStockHistory();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error recalculating stock chain:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const updateStockHistoryDatesBySaleId = async (saleId: string, newDate: Date) => {\r\n    try {\r\n      if (!currentBusiness) return false;\r\n      const result = await updateStockHistoryDatesByReferenceAction(saleId, currentBusiness.id, newDate.toISOString());\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      await loadStockHistory();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating stock history dates:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const repairAllStockChains = async (progressCallback?: (current: number, total: number) => void) => {\r\n    try {\r\n      if (!currentBusiness) return { repaired: 0, failed: 0 };\r\n      const result = await repairStockChainsAction(currentBusiness.id);\r\n      if (result.success && result.data) return result.data;\r\n      return { repaired: 0, failed: 0 };\r\n    } catch (error) {\r\n      console.error('Error repairing all chains:', error);\r\n      return { repaired: 0, failed: 0 };\r\n    }\r\n  }\r\n\r\n  const previewStockChainRepairs = async (progressCallback?: (current: number, total: number) => void) => {\r\n    try {\r\n      if (!currentBusiness) return [];\r\n      const result = await getStockRepairsPreviewAction(currentBusiness.id);\r\n      if (result.success && result.data) return result.data;\r\n      return [];\r\n    } catch (error) {\r\n      console.error('Error previewing repairs:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  return {\r\n    stockHistory,\r\n    isLoading,\r\n    createStockHistoryEntry,\r\n    deleteMultipleStockHistoryEntriesByReference,\r\n    recalculateStockChain,\r\n    updateStockHistoryDatesBySaleId,\r\n    repairAllStockChains,\r\n    previewStockChainRepairs,\r\n    refreshHistory: loadStockHistory\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 967, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.branchId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title || '',\r\n                items: (req.items as any) || [],\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- STOCK RECONCILIATION & REPAIRS ---\r\n\r\nexport async function getProductReconciliationAction(businessId: string, productId: string) {\r\n    try {\r\n        const product = await db.product.findUnique({\r\n            where: { id: productId },\r\n            include: { category: true }\r\n        });\r\n\r\n        if (!product) return { success: false, error: 'Product not found' };\r\n\r\n        // Fetch all history entries\r\n        const history = await db.productHistory.findMany({\r\n            where: { productId, locationId: businessId },\r\n            orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n        });\r\n\r\n        // Fetch all sales containing this product\r\n        const sales = await db.sale.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const openingStock = history.length > 0 ? history[0].newStock : 0;\r\n        const openingDate = history.length > 0 ? history[0].createdAt : null;\r\n\r\n        const dailyTransactions = new Map<string, any>();\r\n        let excludedSalesQty = 0;\r\n\r\n        sales.forEach(sale => {\r\n            const items = (sale.items as any[]) || [];\r\n            const soldQty = items\r\n                .filter(item => item.productId === productId)\r\n                .reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);\r\n\r\n            if (soldQty > 0) {\r\n                if (openingDate && sale.date < openingDate) {\r\n                    excludedSalesQty += soldQty;\r\n                } else {\r\n                    const dateStr = sale.date.toISOString().split('T')[0];\r\n                    const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n                    day.itemsSold += soldQty;\r\n                    dailyTransactions.set(dateStr, day);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Movements (excluding initial entry)\r\n        const movements = history.slice(1);\r\n        movements.forEach(h => {\r\n            const dateStr = h.createdAt.toISOString().split('T')[0];\r\n            const delta = h.newStock - h.oldStock;\r\n            const reason = (h.changeReason || '').toLowerCase();\r\n\r\n            const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n\r\n            if (h.type === 'RESTOCK' || reason.includes('purchase') || reason.includes('addition')) {\r\n                day.stockAdded += delta;\r\n            } else if (reason.includes('transfer out')) {\r\n                day.transferOut += Math.abs(delta);\r\n            } else if (reason.includes('customer return')) {\r\n                day.returnIn += delta;\r\n            } else if (reason.includes('return to supplier')) {\r\n                day.returnOut += Math.abs(delta);\r\n            } else if (h.type !== 'SALE') {\r\n                day.adjustments += delta;\r\n            }\r\n            dailyTransactions.set(dateStr, day);\r\n        });\r\n\r\n        const sortedDates = Array.from(dailyTransactions.keys()).sort();\r\n        const dailyBreakdown = [];\r\n        let runningStock = openingStock;\r\n\r\n        for (const date of sortedDates) {\r\n            const day = dailyTransactions.get(date);\r\n            const startingStock = runningStock;\r\n            const endingStock = startingStock - day.itemsSold + day.stockAdded - day.transferOut + day.returnIn - day.returnOut + day.adjustments;\r\n\r\n            dailyBreakdown.push({\r\n                date,\r\n                startingStock,\r\n                ...day,\r\n                endingStock\r\n            });\r\n            runningStock = endingStock;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                product: {\r\n                    id: product.id,\r\n                    name: product.name,\r\n                    quantity: product.stock,\r\n                    itemNumber: product.sku\r\n                },\r\n                currentStock: product.stock,\r\n                calculatedStock: runningStock,\r\n                discrepancy: product.stock - runningStock,\r\n                openingStock,\r\n                openingDate: openingDate?.toISOString(),\r\n                excludedSalesQty,\r\n                dailyBreakdown\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error in reconciliation action:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getStockRepairsPreviewAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true, name: true, stock: true }\r\n        });\r\n\r\n        const brokenChains = [];\r\n\r\n        for (const product of products) {\r\n            const history = await db.productHistory.findMany({\r\n                where: { productId: product.id, locationId: businessId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) continue;\r\n\r\n            let runningQuantity = 0;\r\n            const brokenEntries = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newStock - entry.oldStock;\r\n                const expectedPrev = runningQuantity;\r\n                const expectedNext = expectedPrev + change;\r\n\r\n                if (entry.oldStock !== expectedPrev || entry.newStock !== expectedNext) {\r\n                    brokenEntries.push({\r\n                        entryId: entry.id,\r\n                        createdAt: entry.createdAt.toISOString(),\r\n                        changeReason: entry.changeReason,\r\n                        currentPrevQty: entry.oldStock,\r\n                        currentNewQty: entry.newStock,\r\n                        fixedPrevQty: expectedPrev,\r\n                        fixedNewQty: expectedNext\r\n                    });\r\n                }\r\n                runningQuantity = expectedNext;\r\n            }\r\n\r\n            if (brokenEntries.length > 0 || Math.abs(product.stock - runningQuantity) > 0.001) {\r\n                brokenChains.push({\r\n                    productId: product.id,\r\n                    productName: product.name,\r\n                    totalEntries: history.length,\r\n                    brokenEntries,\r\n                    finalFixedQty: runningQuantity,\r\n                    currentProductQty: product.stock\r\n                });\r\n            }\r\n        }\r\n\r\n        return { success: true, data: brokenChains };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function repairStockChainsAction(businessId: string, productIds?: string[]) {\r\n    try {\r\n        const ids = productIds || (await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true }\r\n        })).map(p => p.id);\r\n\r\n        let repaired = 0;\r\n        let failed = 0;\r\n\r\n        for (const id of ids) {\r\n            try {\r\n                await recalculateStockChainAction(id, businessId);\r\n                repaired++;\r\n            } catch (err) {\r\n                failed++;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: { repaired, failed } };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getActivityByEntityIdsAction(entityIds: string[]) {\r\n    try {\r\n        const records = await db.activityHistory.findMany({\r\n            where: { entityId: { in: entityIds } },\r\n            select: { entityId: true, entityName: true }\r\n        });\r\n        return { success: true, data: records };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message, data: [] };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesAction(entryIds: string[], newDate: string) {\r\n    try {\r\n        await db.productHistory.updateMany({\r\n            where: { id: { in: entryIds } },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- RECEIPT NUMBER GENERATION ---\r\n\r\nexport async function getNextReceiptNumberAction(branchId: string) {\r\n    try {\r\n        const lastSale = await db.sale.findFirst({\r\n            where: { branchId },\r\n            orderBy: { createdAt: 'desc' },\r\n            select: { saleNumber: true }\r\n        });\r\n\r\n        let nextNum = 1;\r\n        if (lastSale?.saleNumber) {\r\n            // saleNumber format is \"SAL-YYYY-NNNNNN\" or plain digits\r\n            const parts = lastSale.saleNumber.split('-');\r\n            const lastDigits = parseInt(parts[parts.length - 1], 10);\r\n            if (!isNaN(lastDigits)) nextNum = lastDigits + 1;\r\n        }\r\n\r\n        const formatted = String(nextNum).padStart(6, '0');\r\n        return { success: true, data: formatted };\r\n    } catch (error: any) {\r\n        console.error('Error getting next receipt number:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAyUsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 984, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useStockSummaryData.ts"],"sourcesContent":["import { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { getStockSummaryReportAction } from '@/app/actions/inventory';\r\n\r\nexport interface StockSummaryData {\r\n  productId: string;\r\n  productName: string;\r\n  itemNumber: string;\r\n  imageUrl?: string | null;\r\n  costPrice: number;\r\n  sellingPrice: number;\r\n  category?: string;\r\n  openingStock: number;\r\n  itemsSold: number;\r\n  stockIn: number;\r\n  transferOut: number;\r\n  returnIn: number;\r\n  returnOut: number;\r\n  adjustmentsIn: number;\r\n  adjustmentsOut: number;\r\n  closingStock: number;\r\n  revaluation: number;\r\n}\r\n\r\nexport const useStockSummaryData = (\r\n  dateRange: { from: Date | undefined; to: Date | undefined }\r\n) => {\r\n  const { user } = useAuth();\r\n  const { currentBusiness } = useBusiness();\r\n  const queryClient = useQueryClient();\r\n\r\n  const fetchStockSummary = async (): Promise<StockSummaryData[]> => {\r\n    if (!user?.id || !currentBusiness?.id || !dateRange?.from || !dateRange?.to) return [];\r\n\r\n    try {\r\n      const result = await getStockSummaryReportAction(\r\n        currentBusiness.id,\r\n        dateRange.from.toISOString(),\r\n        dateRange.to.toISOString()\r\n      );\r\n\r\n      if (result.success && result.data) {\r\n        return result.data as StockSummaryData[];\r\n      } else {\r\n        throw new Error(result.error);\r\n      }\r\n    } catch (error: any) {\r\n      console.error('[StockSummary] Error fetching report:', error.message);\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const { data: stockSummaryData = [], isLoading, refetch } = useQuery({\r\n    queryKey: ['stockSummary', currentBusiness?.id, dateRange.from?.toISOString(), dateRange.to?.toISOString()],\r\n    queryFn: fetchStockSummary,\r\n    enabled: !!user?.id && !!currentBusiness?.id && !!dateRange?.from && !!dateRange?.to,\r\n    staleTime: 5 * 60 * 1000,\r\n    gcTime: 30 * 60 * 1000,\r\n  });\r\n\r\n  return {\r\n    stockSummaryData,\r\n    isLoading,\r\n    loadStockSummaryData: refetch,\r\n    clearCache: () => {\r\n      queryClient.invalidateQueries({ queryKey: ['stockSummary'] });\r\n    },\r\n    clearAllLocationCaches: () => {\r\n      queryClient.invalidateQueries({ queryKey: ['stockSummary'] });\r\n    }\r\n  };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AAAA;AACA;;;;;;AAsBO,MAAM,sBAAsB,CACjC;;IAEA,MAAM,EAAE,IAAI,EAAE,GAAG,IAAA,wJAAO;IACxB,MAAM,EAAE,eAAe,EAAE,GAAG,IAAA,qJAAW;IACvC,MAAM,cAAc,IAAA,2MAAc;IAElC,MAAM,oBAAoB;QACxB,IAAI,CAAC,MAAM,MAAM,CAAC,iBAAiB,MAAM,CAAC,WAAW,QAAQ,CAAC,WAAW,IAAI,OAAO,EAAE;QAEtF,IAAI;YACF,MAAM,SAAS,MAAM,IAAA,+LAA2B,EAC9C,gBAAgB,EAAE,EAClB,UAAU,IAAI,CAAC,WAAW,IAC1B,UAAU,EAAE,CAAC,WAAW;YAG1B,IAAI,OAAO,OAAO,IAAI,OAAO,IAAI,EAAE;gBACjC,OAAO,OAAO,IAAI;YACpB,OAAO;gBACL,MAAM,IAAI,MAAM,OAAO,KAAK;YAC9B;QACF,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,yCAAyC,MAAM,OAAO;YACpE,MAAM;QACR;IACF;IAEA,MAAM,EAAE,MAAM,mBAAmB,EAAE,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,IAAA,0LAAQ,EAAC;QACnE,UAAU;YAAC;YAAgB,iBAAiB;YAAI,UAAU,IAAI,EAAE;YAAe,UAAU,EAAE,EAAE;SAAc;QAC3G,SAAS;QACT,SAAS,CAAC,CAAC,MAAM,MAAM,CAAC,CAAC,iBAAiB,MAAM,CAAC,CAAC,WAAW,QAAQ,CAAC,CAAC,WAAW;QAClF,WAAW,IAAI,KAAK;QACpB,QAAQ,KAAK,KAAK;IACpB;IAEA,OAAO;QACL;QACA;QACA,sBAAsB;QACtB,YAAY;YACV,YAAY,iBAAiB,CAAC;gBAAE,UAAU;oBAAC;iBAAe;YAAC;QAC7D;QACA,wBAAwB;YACtB,YAAY,iBAAiB,CAAC;gBAAE,UAAU;oBAAC;iBAAe;YAAC;QAC7D;IACF;AACF;GA/Ca;;QAGM,wJAAO;QACI,qJAAW;QACnB,2MAAc;QAuB0B,0LAAQ"}},
    {"offset": {"line": 1064, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/badge.tsx"],"sourcesContent":["\r\nimport * as React from \"react\"\r\nimport { cva, type VariantProps } from \"class-variance-authority\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst badgeVariants = cva(\r\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default:\r\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\r\n        secondary:\r\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        destructive:\r\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\r\n        outline: \"text-foreground\",\r\n        warning:\r\n          \"border-transparent bg-amber-500 text-white hover:bg-amber-600\",\r\n        success:\r\n          \"border-transparent bg-green-600 text-white hover:bg-green-700\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n    },\r\n  }\r\n)\r\n\r\nexport interface BadgeProps\r\n  extends React.HTMLAttributes<HTMLDivElement>,\r\n    VariantProps<typeof badgeVariants> {}\r\n\r\nfunction Badge({ className, variant, ...props }: BadgeProps) {\r\n  return (\r\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\r\n  )\r\n}\r\n\r\nexport { Badge, badgeVariants }\r\n"],"names":[],"mappings":";;;;;;;AAEA;AAEA;;;;AAEA,MAAM,gBAAgB,IAAA,0KAAG,EACvB,0KACA;IACE,UAAU;QACR,SAAS;YACP,SACE;YACF,WACE;YACF,aACE;YACF,SAAS;YACT,SACE;YACF,SACE;QACJ;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAOF,SAAS,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAmB;IACzD,qBACE,6LAAC;QAAI,WAAW,IAAA,4HAAE,EAAC,cAAc;YAAE;QAAQ,IAAI;QAAa,GAAG,KAAK;;;;;;AAExE;KAJS"}},
    {"offset": {"line": 1114, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/utils/exportBarcodeToJPEG.ts"],"sourcesContent":["import React from 'react';\r\nimport html2canvas from 'html2canvas';\r\nimport Barcode from 'react-barcode';\r\nimport { createRoot } from 'react-dom/client';\r\n\r\ninterface BarcodeExportOptions {\r\n    productName: string;\r\n    barcodeValue: string;\r\n    price?: number;\r\n    currency?: string;\r\n    showPrice?: boolean;\r\n}\r\n\r\n/**\r\n * Export a single barcode as a JPEG file\r\n */\r\nexport const exportBarcodeToJPEG = async (options: BarcodeExportOptions): Promise<void> => {\r\n    const { productName, barcodeValue, price, currency = 'KES', showPrice = true } = options;\r\n\r\n    // Create a temporary container\r\n    const container = document.createElement('div');\r\n    container.style.position = 'absolute';\r\n    container.style.left = '-9999px';\r\n    container.style.top = '-9999px';\r\n    container.style.width = '340px'; // Approx 45mm width label (scaled 2x)\r\n    container.style.padding = '20px';\r\n    container.style.backgroundColor = 'white';\r\n    container.style.fontFamily = 'Arial, sans-serif';\r\n    document.body.appendChild(container);\r\n\r\n    try {\r\n        // Create the barcode container with styling\r\n        const barcodeContainer = document.createElement('div');\r\n        barcodeContainer.style.display = 'flex';\r\n        barcodeContainer.style.flexDirection = 'column';\r\n        barcodeContainer.style.alignItems = 'center';\r\n        barcodeContainer.style.gap = '10px';\r\n\r\n        // Product name\r\n        const nameElement = document.createElement('div');\r\n        nameElement.textContent = productName;\r\n        nameElement.style.fontSize = '18px';\r\n        nameElement.style.fontWeight = 'bold';\r\n        nameElement.style.textAlign = 'center';\r\n        nameElement.style.maxWidth = '100%';\r\n        nameElement.style.wordWrap = 'break-word';\r\n        barcodeContainer.appendChild(nameElement);\r\n\r\n        // Barcode SVG container\r\n        const svgContainer = document.createElement('div');\r\n        svgContainer.id = 'barcode-svg-container';\r\n        barcodeContainer.appendChild(svgContainer);\r\n\r\n        // Price (if applicable)\r\n        if (showPrice && price !== undefined) {\r\n            const priceElement = document.createElement('div');\r\n            priceElement.textContent = `${currency} ${price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;\r\n            priceElement.style.fontSize = '18px';\r\n            priceElement.style.fontWeight = 'bold';\r\n            priceElement.style.textAlign = 'center';\r\n            barcodeContainer.appendChild(priceElement);\r\n        }\r\n\r\n        container.appendChild(barcodeContainer);\r\n\r\n        // Render the barcode using React\r\n        const root = createRoot(svgContainer);\r\n        await new Promise<void>((resolve) => {\r\n            const BarcodeComponent = Barcode as any;\r\n            root.render(\r\n                React.createElement(BarcodeComponent, {\r\n                    value: barcodeValue,\r\n                    width: 2,\r\n                    height: 80,\r\n                    fontSize: 16\r\n                })\r\n            );\r\n            // Give React time to render\r\n            setTimeout(() => resolve(), 100);\r\n        });\r\n\r\n        // Convert to canvas\r\n        const canvas = await html2canvas(container, {\r\n            backgroundColor: '#ffffff',\r\n            scale: 2, // Higher quality\r\n        });\r\n\r\n        // Convert canvas to JPEG blob\r\n        canvas.toBlob((blob) => {\r\n            if (blob) {\r\n                const url = URL.createObjectURL(blob);\r\n                const link = document.createElement('a');\r\n                const sanitizedName = productName.replace(/[^a-z0-9]/gi, '_').toLowerCase();\r\n                link.download = `barcode_${sanitizedName}_${Date.now()}.jpg`;\r\n                link.href = url;\r\n                link.click();\r\n                URL.revokeObjectURL(url);\r\n            }\r\n        }, 'image/jpeg', 0.95);\r\n\r\n        // Cleanup\r\n        root.unmount();\r\n    } catch (error) {\r\n        console.error('Error exporting barcode to JPEG:', error);\r\n        throw error;\r\n    } finally {\r\n        // Remove the temporary container\r\n        document.body.removeChild(container);\r\n    }\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1218, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/utils/exportBarcodeToPDF.ts"],"sourcesContent":["import React from 'react';\r\nimport jsPDF from 'jspdf';\r\nimport html2canvas from 'html2canvas';\r\nimport Barcode from 'react-barcode';\r\nimport { createRoot } from 'react-dom/client';\r\nimport { Product } from '@/types';\r\n\r\ninterface BarcodeExportOptions {\r\n    productName: string;\r\n    barcodeValue: string;\r\n    price?: number;\r\n    currency?: string;\r\n    showPrice?: boolean;\r\n}\r\n\r\n/**\r\n * Render barcode to canvas and return image data URL\r\n */\r\nconst renderBarcodeToImage = async (options: BarcodeExportOptions): Promise<string> => {\r\n    const { productName, barcodeValue, price, currency = 'KES', showPrice = true } = options;\r\n\r\n    // Create a temporary container\r\n    const container = document.createElement('div');\r\n    container.style.position = 'absolute';\r\n    container.style.left = '-9999px';\r\n    container.style.top = '-9999px';\r\n    container.style.width = '300px'; // Base width for 50mm label\r\n    container.style.padding = '15px';\r\n    container.style.backgroundColor = 'white';\r\n    container.style.fontFamily = 'Arial, sans-serif';\r\n    document.body.appendChild(container);\r\n\r\n    try {\r\n        // Create the barcode container with styling\r\n        const barcodeContainer = document.createElement('div');\r\n        barcodeContainer.style.display = 'flex';\r\n        barcodeContainer.style.flexDirection = 'column';\r\n        barcodeContainer.style.alignItems = 'center';\r\n        barcodeContainer.style.gap = '8px';\r\n\r\n        // Product name\r\n        const nameElement = document.createElement('div');\r\n        nameElement.textContent = productName.length > 30 ? productName.substring(0, 27) + '...' : productName;\r\n        nameElement.style.fontSize = '14px';\r\n        nameElement.style.fontWeight = 'bold';\r\n        nameElement.style.textAlign = 'center';\r\n        nameElement.style.maxWidth = '100%';\r\n        nameElement.style.wordWrap = 'break-word';\r\n        barcodeContainer.appendChild(nameElement);\r\n\r\n        // Barcode SVG container\r\n        const svgContainer = document.createElement('div');\r\n        svgContainer.id = 'barcode-svg-container';\r\n        barcodeContainer.appendChild(svgContainer);\r\n\r\n        // Price (if applicable)\r\n        if (showPrice && price !== undefined) {\r\n            const priceElement = document.createElement('div');\r\n            priceElement.textContent = `${currency} ${price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;\r\n            priceElement.style.fontSize = '14px';\r\n            priceElement.style.fontWeight = 'bold';\r\n            priceElement.style.textAlign = 'center';\r\n            barcodeContainer.appendChild(priceElement);\r\n        }\r\n\r\n        container.appendChild(barcodeContainer);\r\n\r\n        // Render the barcode using React\r\n        const root = createRoot(svgContainer);\r\n        await new Promise<void>((resolve) => {\r\n            const BarcodeComponent = Barcode as any;\r\n            root.render(\r\n                React.createElement(BarcodeComponent, {\r\n                    value: barcodeValue,\r\n                    width: 1.5,\r\n                    height: 60,\r\n                    fontSize: 12\r\n                })\r\n            );\r\n            // Give React time to render\r\n            setTimeout(() => resolve(), 100);\r\n        });\r\n\r\n        // Convert to canvas\r\n        const canvas = await html2canvas(container, {\r\n            backgroundColor: '#ffffff',\r\n            scale: 2,\r\n        });\r\n\r\n        // Get image data URL\r\n        const imageDataUrl = canvas.toDataURL('image/jpeg', 0.95);\r\n\r\n        // Cleanup\r\n        root.unmount();\r\n        document.body.removeChild(container);\r\n\r\n        return imageDataUrl;\r\n    } catch (error) {\r\n        document.body.removeChild(container);\r\n        throw error;\r\n    }\r\n};\r\n\r\n/**\r\n * Export a single barcode as a PDF file\r\n */\r\nexport const exportSingleBarcodeToPDF = async (options: BarcodeExportOptions): Promise<void> => {\r\n    try {\r\n        const imageDataUrl = await renderBarcodeToImage(options);\r\n\r\n        // Create PDF\r\n        const pdf = new jsPDF({\r\n            orientation: 'portrait',\r\n            unit: 'mm',\r\n            format: 'a4',\r\n        });\r\n\r\n        // Add title\r\n        pdf.setFontSize(16);\r\n        pdf.text('Product Barcode', 105, 20, { align: 'center' });\r\n\r\n        // Add barcode image centered - Fixed 45x30mm\r\n        const imgWidth = 45;\r\n        const imgHeight = 30;\r\n        const x = (210 - imgWidth) / 2; // Center on A4 width (210mm)\r\n        const y = 40;\r\n\r\n        pdf.addImage(imageDataUrl, 'JPEG', x, y, imgWidth, imgHeight);\r\n\r\n        // Save PDF\r\n        const sanitizedName = options.productName.replace(/[^a-z0-9]/gi, '_').toLowerCase();\r\n        pdf.save(`barcode_${sanitizedName}_${Date.now()}.pdf`);\r\n    } catch (error) {\r\n        console.error('Error exporting barcode to PDF:', error);\r\n        throw error;\r\n    }\r\n};\r\n\r\n/**\r\n * Export multiple barcodes to a single PDF file\r\n */\r\nexport const exportBulkBarcodesToPDF = async (\r\n    products: Product[],\r\n    options: { showPrice?: boolean; currency?: string } = {}\r\n): Promise<void> => {\r\n    const { showPrice = true, currency = 'KES' } = options;\r\n\r\n    try {\r\n        // Filter products with barcodes\r\n        const productsWithBarcodes = products.filter(p => p.barcode);\r\n\r\n        if (productsWithBarcodes.length === 0) {\r\n            throw new Error('No products with barcodes to export');\r\n        }\r\n\r\n        const pdf = new jsPDF({\r\n            orientation: 'portrait',\r\n            unit: 'mm',\r\n            format: 'a4',\r\n        });\r\n\r\n        // Layout configuration - Standardized 45x30mm labels\r\n        const labelWidth = 45;\r\n        const labelHeight = 30;\r\n        const spacing = 2; // Reduced spacing for better fit\r\n        const pageWidth = 210; // A4 width in mm\r\n        const pageHeight = 297; // A4 height in mm\r\n        const margin = 10;\r\n\r\n        // Calculate how many labels fit across (columns)\r\n        const cols = Math.floor((pageWidth - (2 * margin) + spacing) / (labelWidth + spacing));\r\n        // Calculate how many labels fit down (rows)\r\n        const rows = Math.floor((pageHeight - (2 * margin) + spacing) / (labelHeight + spacing));\r\n\r\n        const itemsPerPage = cols * rows;\r\n\r\n        // Calculate centered margins based on calculated grid\r\n        const totalGridWidth = (cols * labelWidth) + ((cols - 1) * spacing);\r\n        const totalGridHeight = (rows * labelHeight) + ((rows - 1) * spacing);\r\n\r\n        const marginX = (pageWidth - totalGridWidth) / 2;\r\n        const marginY = (pageHeight - totalGridHeight) / 2;\r\n\r\n        let itemCount = 0;\r\n\r\n        for (const product of productsWithBarcodes) {\r\n            if (itemCount > 0 && itemCount % itemsPerPage === 0) {\r\n                pdf.addPage();\r\n            }\r\n\r\n            const pageIndex = itemCount % itemsPerPage;\r\n            const row = Math.floor(pageIndex / cols);\r\n            const col = pageIndex % cols;\r\n\r\n            const x = marginX + (col * (labelWidth + spacing));\r\n            const y = marginY + (row * (labelHeight + spacing));\r\n\r\n            // Render barcode to image\r\n            const imageDataUrl = await renderBarcodeToImage({\r\n                productName: product.name,\r\n                barcodeValue: product.barcode!,\r\n                price: product.sellingPrice,\r\n                currency,\r\n                showPrice,\r\n            });\r\n\r\n            // Add border for visual separation (optional)\r\n            pdf.setDrawColor(200, 200, 200);\r\n            pdf.rect(x, y, labelWidth, labelHeight);\r\n\r\n            // Add barcode image\r\n            const imgWidth = labelWidth - 4;\r\n            const imgHeight = labelHeight - 4;\r\n            pdf.addImage(imageDataUrl, 'JPEG', x + 2, y + 2, imgWidth, imgHeight);\r\n\r\n            itemCount++;\r\n        }\r\n\r\n        // Add summary on first page\r\n        pdf.setPage(1);\r\n        pdf.setFontSize(10);\r\n        pdf.setTextColor(100, 100, 100);\r\n        pdf.text(`Total barcodes: ${productsWithBarcodes.length}`, 105, 5, { align: 'center' });\r\n\r\n        // Save PDF\r\n        const timestamp = new Date().toISOString().split('T')[0];\r\n        pdf.save(`barcodes_bulk_${timestamp}_${productsWithBarcodes.length}_items.pdf`);\r\n    } catch (error) {\r\n        console.error('Error exporting bulk barcodes to PDF:', error);\r\n        throw error;\r\n    }\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1417, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useFinancialVisibility.ts"],"sourcesContent":["import { useProfiles } from '@/contexts/ProfileContext';\r\n\r\n/**\r\n * Hook to handle financial data visibility based on permissions\r\n */\r\nexport const useFinancialVisibility = () => {\r\n    const { hasPermission } = useProfiles();\r\n\r\n    const canViewCostPrice = hasPermission('inventory', 'view_cost_price');\r\n    const canViewProfit = hasPermission('inventory', 'view_profit');\r\n    const canViewSellingPrice = hasPermission('inventory', 'view_selling_price');\r\n\r\n    // Dashboard-specific permissions\r\n    const canViewTotalSales = hasPermission('dashboard', 'view_total_sales');\r\n    const canViewTotalGrossProfit = hasPermission('dashboard', 'view_gross_profit');\r\n    const canViewTotalExpenses = hasPermission('dashboard', 'view_total_expenses');\r\n    const canViewInventoryValue = hasPermission('dashboard', 'view_inventory_value');\r\n    const canViewSalesTypes = hasPermission('dashboard', 'view_sales_types');\r\n    const canViewAvgPrice = hasPermission('dashboard', 'view_avg_price');\r\n    const canViewTotalAmount = hasPermission('dashboard', 'view_total_amount');\r\n\r\n    // Finance and Expenses permissions\r\n    const canManageFinanceAccounts = hasPermission('finance', 'manage_accounts');\r\n    const canViewFinance = hasPermission('finance', 'view');\r\n    const canViewExpenses = hasPermission('expenses', 'view');\r\n    const canCreateExpenses = hasPermission('expenses', 'create');\r\n    const canEditExpenses = hasPermission('expenses', 'edit');\r\n    const canDeleteExpenses = hasPermission('expenses', 'delete');\r\n\r\n    /**\r\n     * Format a financial value or return a hidden indicator\r\n     */\r\n    const formatFinancial = (value: number | null | undefined, type: 'cost' | 'selling' | 'profit'): string => {\r\n        const hasAccess =\r\n            (type === 'cost' && canViewCostPrice) ||\r\n            (type === 'selling' && canViewSellingPrice) ||\r\n            (type === 'profit' && canViewProfit);\r\n\r\n        if (!hasAccess) {\r\n            return '';\r\n        }\r\n\r\n        return value?.toLocaleString() || '0';\r\n    };\r\n\r\n    return {\r\n        canViewCostPrice,\r\n        canViewProfit,\r\n        canViewSellingPrice,\r\n        canViewTotalSales,\r\n        canViewTotalGrossProfit,\r\n        canViewTotalExpenses,\r\n        canViewInventoryValue,\r\n        canViewSalesTypes,\r\n        canViewAvgPrice,\r\n        canViewTotalAmount,\r\n        canManageFinanceAccounts,\r\n        canViewFinance,\r\n        canViewExpenses,\r\n        canCreateExpenses,\r\n        canEditExpenses,\r\n        canDeleteExpenses,\r\n        formatFinancial,\r\n    };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;;;AAKO,MAAM,yBAAyB;;IAClC,MAAM,EAAE,aAAa,EAAE,GAAG,IAAA,oJAAW;IAErC,MAAM,mBAAmB,cAAc,aAAa;IACpD,MAAM,gBAAgB,cAAc,aAAa;IACjD,MAAM,sBAAsB,cAAc,aAAa;IAEvD,iCAAiC;IACjC,MAAM,oBAAoB,cAAc,aAAa;IACrD,MAAM,0BAA0B,cAAc,aAAa;IAC3D,MAAM,uBAAuB,cAAc,aAAa;IACxD,MAAM,wBAAwB,cAAc,aAAa;IACzD,MAAM,oBAAoB,cAAc,aAAa;IACrD,MAAM,kBAAkB,cAAc,aAAa;IACnD,MAAM,qBAAqB,cAAc,aAAa;IAEtD,mCAAmC;IACnC,MAAM,2BAA2B,cAAc,WAAW;IAC1D,MAAM,iBAAiB,cAAc,WAAW;IAChD,MAAM,kBAAkB,cAAc,YAAY;IAClD,MAAM,oBAAoB,cAAc,YAAY;IACpD,MAAM,kBAAkB,cAAc,YAAY;IAClD,MAAM,oBAAoB,cAAc,YAAY;IAEpD;;KAEC,GACD,MAAM,kBAAkB,CAAC,OAAkC;QACvD,MAAM,YACF,AAAC,SAAS,UAAU,oBACnB,SAAS,aAAa,uBACtB,SAAS,YAAY;QAE1B,IAAI,CAAC,WAAW;YACZ,OAAO;QACX;QAEA,OAAO,OAAO,oBAAoB;IACtC;IAEA,OAAO;QACH;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACJ;AACJ;GA3Da;;QACiB,oJAAW"}},
    {"offset": {"line": 1486, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/alert-dialog.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\nimport { buttonVariants } from \"@/components/ui/button\"\r\n\r\nconst AlertDialog = AlertDialogPrimitive.Root\r\n\r\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\r\n\r\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\r\n\r\nconst AlertDialogOverlay = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Overlay\r\n    className={cn(\r\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\r\n      className\r\n    )}\r\n    {...props}\r\n    ref={ref}\r\n  />\r\n))\r\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\r\n\r\nconst AlertDialogContent = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPortal>\r\n    <AlertDialogOverlay />\r\n    <AlertDialogPrimitive.Content\r\n      ref={ref}\r\n      className={cn(\r\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\r\n        className\r\n      )}\r\n      {...props}\r\n    />\r\n  </AlertDialogPortal>\r\n))\r\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\r\n\r\nconst AlertDialogHeader = ({\r\n  className,\r\n  ...props\r\n}: React.HTMLAttributes<HTMLDivElement>) => (\r\n  <div\r\n    className={cn(\r\n      \"flex flex-col space-y-2 text-center sm:text-left\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n)\r\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\r\n\r\nconst AlertDialogFooter = ({\r\n  className,\r\n  ...props\r\n}: React.HTMLAttributes<HTMLDivElement>) => (\r\n  <div\r\n    className={cn(\r\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n)\r\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\r\n\r\nconst AlertDialogTitle = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Title\r\n    ref={ref}\r\n    className={cn(\"text-lg font-semibold\", className)}\r\n    {...props}\r\n  />\r\n))\r\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\r\n\r\nconst AlertDialogDescription = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Description\r\n    ref={ref}\r\n    className={cn(\"text-sm text-muted-foreground\", className)}\r\n    {...props}\r\n  />\r\n))\r\nAlertDialogDescription.displayName =\r\n  AlertDialogPrimitive.Description.displayName\r\n\r\nconst AlertDialogAction = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Action\r\n    ref={ref}\r\n    className={cn(buttonVariants(), className)}\r\n    {...props}\r\n  />\r\n))\r\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\r\n\r\nconst AlertDialogCancel = React.forwardRef<\r\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\r\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\r\n>(({ className, ...props }, ref) => (\r\n  <AlertDialogPrimitive.Cancel\r\n    ref={ref}\r\n    className={cn(\r\n      buttonVariants({ variant: \"outline\" }),\r\n      \"mt-2 sm:mt-0\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\r\n\r\nexport {\r\n  AlertDialog,\r\n  AlertDialogPortal,\r\n  AlertDialogOverlay,\r\n  AlertDialogTrigger,\r\n  AlertDialogContent,\r\n  AlertDialogHeader,\r\n  AlertDialogFooter,\r\n  AlertDialogTitle,\r\n  AlertDialogDescription,\r\n  AlertDialogAction,\r\n  AlertDialogCancel,\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;;;;;;AAEA,MAAM,cAAc,sLAAyB;AAE7C,MAAM,qBAAqB,yLAA4B;AAEvD,MAAM,oBAAoB,wLAA2B;AAErD,MAAM,mCAAqB,2KAAgB,CAGzC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,yLAA4B;QAC3B,WAAW,IAAA,4HAAE,EACX,2JACA;QAED,GAAG,KAAK;QACT,KAAK;;;;;;KAVH;AAaN,mBAAmB,WAAW,GAAG,yLAA4B,CAAC,WAAW;AAEzE,MAAM,mCAAqB,2KAAgB,OAGzC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;;0BACC,6LAAC;;;;;0BACD,6LAAC,yLAA4B;gBAC3B,KAAK;gBACL,WAAW,IAAA,4HAAE,EACX,+fACA;gBAED,GAAG,KAAK;;;;;;;;;;;;;AAIf,mBAAmB,WAAW,GAAG,yLAA4B,CAAC,WAAW;AAEzE,MAAM,oBAAoB,CAAC,EACzB,SAAS,EACT,GAAG,OACkC,iBACrC,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,oDACA;QAED,GAAG,KAAK;;;;;;MATP;AAYN,kBAAkB,WAAW,GAAG;AAEhC,MAAM,oBAAoB,CAAC,EACzB,SAAS,EACT,GAAG,OACkC,iBACrC,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,iEACA;QAED,GAAG,KAAK;;;;;;MATP;AAYN,kBAAkB,WAAW,GAAG;AAEhC,MAAM,iCAAmB,2KAAgB,OAGvC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,uLAA0B;QACzB,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,yBAAyB;QACtC,GAAG,KAAK;;;;;;;AAGb,iBAAiB,WAAW,GAAG,uLAA0B,CAAC,WAAW;AAErE,MAAM,uCAAyB,2KAAgB,OAG7C,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,6LAAgC;QAC/B,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;;AAGb,uBAAuB,WAAW,GAChC,6LAAgC,CAAC,WAAW;AAE9C,MAAM,kCAAoB,2KAAgB,OAGxC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,wLAA2B;QAC1B,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,IAAA,uJAAc,KAAI;QAC/B,GAAG,KAAK;;;;;;;AAGb,kBAAkB,WAAW,GAAG,wLAA2B,CAAC,WAAW;AAEvE,MAAM,kCAAoB,2KAAgB,QAGxC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,wLAA2B;QAC1B,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,IAAA,uJAAc,EAAC;YAAE,SAAS;QAAU,IACpC,gBACA;QAED,GAAG,KAAK;;;;;;;AAGb,kBAAkB,WAAW,GAAG,wLAA2B,CAAC,WAAW"}},
    {"offset": {"line": 1646, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/inventory/DeleteProductDialog.tsx"],"sourcesContent":["\r\nimport React from 'react';\r\nimport {\r\n  AlertDialog,\r\n  AlertDialogAction,\r\n  AlertDialogCancel,\r\n  AlertDialogContent,\r\n  AlertDialogDescription,\r\n  AlertDialogFooter,\r\n  AlertDialogHeader,\r\n  AlertDialogTitle,\r\n} from \"@/components/ui/alert-dialog\";\r\nimport { Product } from '@/types';\r\n\r\ninterface DeleteProductDialogProps {\r\n  open: boolean;\r\n  onOpenChange: (open: boolean) => void;\r\n  product: Product | null;\r\n  onConfirm: () => void;\r\n}\r\n\r\nconst DeleteProductDialog: React.FC<DeleteProductDialogProps> = ({\r\n  open,\r\n  onOpenChange,\r\n  product,\r\n  onConfirm,\r\n}) => {\r\n  const handleConfirm = () => {\r\n    onConfirm();\r\n    onOpenChange(false);\r\n  };\r\n\r\n  return (\r\n    <AlertDialog open={open} onOpenChange={onOpenChange}>\r\n      <AlertDialogContent>\r\n        <AlertDialogHeader>\r\n          <AlertDialogTitle>Are you sure?</AlertDialogTitle>\r\n          <AlertDialogDescription>\r\n            This will delete the product \"{product?.name}\" and all its associated data.\r\n            This action cannot be undone.\r\n          </AlertDialogDescription>\r\n        </AlertDialogHeader>\r\n        <AlertDialogFooter>\r\n          <AlertDialogCancel>Cancel</AlertDialogCancel>\r\n          <AlertDialogAction onClick={handleConfirm} className=\"bg-red-600 hover:bg-red-700\">\r\n            Delete\r\n          </AlertDialogAction>\r\n        </AlertDialogFooter>\r\n      </AlertDialogContent>\r\n    </AlertDialog>\r\n  );\r\n};\r\n\r\nexport default DeleteProductDialog;\r\n"],"names":[],"mappings":";;;;;AAEA;;;AAmBA,MAAM,sBAA0D,CAAC,EAC/D,IAAI,EACJ,YAAY,EACZ,OAAO,EACP,SAAS,EACV;IACC,MAAM,gBAAgB;QACpB;QACA,aAAa;IACf;IAEA,qBACE,6LAAC,6JAAW;QAAC,MAAM;QAAM,cAAc;kBACrC,cAAA,6LAAC,oKAAkB;;8BACjB,6LAAC,mKAAiB;;sCAChB,6LAAC,kKAAgB;sCAAC;;;;;;sCAClB,6LAAC,wKAAsB;;gCAAC;gCACS,SAAS;gCAAK;;;;;;;;;;;;;8BAIjD,6LAAC,mKAAiB;;sCAChB,6LAAC,mKAAiB;sCAAC;;;;;;sCACnB,6LAAC,mKAAiB;4BAAC,SAAS;4BAAe,WAAU;sCAA8B;;;;;;;;;;;;;;;;;;;;;;;AAO7F;KA9BM;uCAgCS"}},
    {"offset": {"line": 1737, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/switch.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Switch = React.forwardRef<\r\n  React.ElementRef<typeof SwitchPrimitives.Root>,\r\n  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>\r\n>(({ className, ...props }, ref) => (\r\n  <SwitchPrimitives.Root\r\n    className={cn(\r\n      \"peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\r\n      className\r\n    )}\r\n    {...props}\r\n    ref={ref}\r\n  >\r\n    <SwitchPrimitives.Thumb\r\n      className={cn(\r\n        \"pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0\"\r\n      )}\r\n    />\r\n  </SwitchPrimitives.Root>\r\n))\r\nSwitch.displayName = SwitchPrimitives.Root.displayName\r\n\r\nexport { Switch }\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,uBAAS,2KAAgB,MAG7B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,6KAAqB;QACpB,WAAW,IAAA,4HAAE,EACX,sXACA;QAED,GAAG,KAAK;QACT,KAAK;kBAEL,cAAA,6LAAC,8KAAsB;YACrB,WAAW,IAAA,4HAAE,EACX;;;;;;;;;;;;AAKR,OAAO,WAAW,GAAG,6KAAqB,CAAC,WAAW"}},
    {"offset": {"line": 1778, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/inventory/ProductDetails.tsx"],"sourcesContent":["import React, { useState } from 'react';\r\n// @ts-ignore - react-barcode may not have types installed\r\nimport Barcode from 'react-barcode';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Product, StockHistoryEntry } from '@/types';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { useBusinessSettings } from '@/hooks/useBusinessSettings';\r\nimport { formatNumber } from '@/lib/utils';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Edit, Package, AlertCircle, ArrowLeft, Trash2, Copy, RefreshCw, Printer, Download, FileImage, Plus, Minus } from 'lucide-react';\r\nimport { exportBarcodeToJPEG } from '@/utils/exportBarcodeToJPEG';\r\nimport { exportSingleBarcodeToPDF } from '@/utils/exportBarcodeToPDF';\r\nimport { useFinancialVisibility } from '@/hooks/useFinancialVisibility';\r\nimport { format } from 'date-fns';\r\nimport DeleteProductDialog from './DeleteProductDialog';\r\nimport { useProducts } from '@/hooks/useProducts';\r\nimport { useStockHistory } from '@/hooks/useStockHistory';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { toast } from 'sonner';\r\nimport { Input } from '@/components/ui/input';\r\nimport { useProfiles } from '@/contexts/ProfileContext';\r\nimport { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogHeader,\r\n  DialogTitle,\r\n  DialogTrigger,\r\n} from \"@/components/ui/dialog\";\r\nimport { Switch } from \"@/components/ui/switch\";\r\nimport { Label } from '@/components/ui/label';\r\n\r\ninterface ProductDetailsProps {\r\n  product: Product;\r\n  stockHistory: StockHistoryEntry[];\r\n  isLoadingHistory: boolean;\r\n  onStockUpdate?: () => void;\r\n}\r\n\r\nconst ProductDetails: React.FC<ProductDetailsProps> = ({\r\n  product,\r\n  stockHistory,\r\n  isLoadingHistory,\r\n  onStockUpdate\r\n}) => {\r\n  const navigate = useNavigate();\r\n  const { user } = useAuth();\r\n  const { currentBusiness } = useBusiness();\r\n  const { settings } = useBusinessSettings();\r\n  const { updateProduct, deleteProduct } = useProducts(user?.id);\r\n  const { createStockHistoryEntry, stockHistory: allStockHistory } = useStockHistory(user?.id, product.id);\r\n  const { hasPermission } = useProfiles();\r\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\r\n  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);\r\n  const [adjustmentType, setAdjustmentType] = useState<'Stock In' | 'Stock Out'>('Stock In');\r\n  const [adjustmentQuantity, setAdjustmentQuantity] = useState<number>(0);\r\n  const [adjustmentReason, setAdjustmentReason] = useState<string>('');\r\n  const [adjustmentDate, setAdjustmentDate] = useState<string>(new Date().toISOString().split('T')[0]);\r\n  const [adjustmentTime, setAdjustmentTime] = useState<string>(new Date().toTimeString().split(' ')[0]);\r\n  const [isApplying, setIsApplying] = useState(false);\r\n  const [barcodeDialogOpen, setBarcodeDialogOpen] = useState(false);\r\n  const [showPriceOnBarcode, setShowPriceOnBarcode] = useState(true);\r\n  const [printQuantity, setPrintQuantity] = useState(1);\r\n  const [isExporting, setIsExporting] = useState(false);\r\n  const { formatFinancial, canViewCostPrice, canViewProfit, canViewSellingPrice } = useFinancialVisibility();\r\n\r\n  const handleDeleteProduct = async () => {\r\n    const result = await deleteProduct(product.id);\r\n    if (result) {\r\n      toast.success(\"Product deleted successfully\");\r\n      navigate('/inventory');\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  const handleDuplicateProduct = () => {\r\n    toast.success(\"Duplicating product...\");\r\n    // Navigate to new product page with product data for duplication\r\n    navigate('/inventory/new', {\r\n      state: {\r\n        duplicateData: {\r\n          name: `${product.name} (Copy)`,\r\n          description: product.description,\r\n          category: product.category,\r\n          supplier: product.supplier,\r\n          costPrice: product.costPrice,\r\n          sellingPrice: product.sellingPrice,\r\n          imageUrl: product.imageUrl,\r\n          createdAt: product.createdAt,\r\n          minimumStock: product.minimumStock\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  const getStockStatusBadge = () => {\r\n    if (product.quantity === 0) {\r\n      return <Badge variant=\"destructive\" className=\"text-sm\">Out of stock</Badge>;\r\n    }\r\n\r\n    if (product.quantity <= product.minimumStock) {\r\n      return <Badge variant=\"warning\" className=\"bg-amber-500 text-sm\">Low stock</Badge>;\r\n    }\r\n\r\n    return <Badge variant=\"success\" className=\"bg-green-600 text-sm\">In stock</Badge>;\r\n  };\r\n\r\n  // Get the initial stock date (chronologically first entry)\r\n  const getInitialStockDate = (): Date | null => {\r\n    const historyToCheck = stockHistory.length > 0 ? stockHistory : allStockHistory;\r\n    if (historyToCheck.length === 0) return null;\r\n    const sortedHistory = [...historyToCheck].sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\r\n    return sortedHistory[0]?.createdAt || null;\r\n  };\r\n\r\n  const validateAdjustmentDateTime = (dateStr: string, timeStr: string): string => {\r\n    if (!dateStr) return '';\r\n\r\n    const initialStockDate = getInitialStockDate();\r\n    if (!initialStockDate) return '';\r\n\r\n    // Create the proposed datetime with selected date and time\r\n    const [year, month, day] = dateStr.split('-').map(Number);\r\n    const timeParts = timeStr.split(':').map(Number);\r\n    const [hours, minutes, seconds = 0] = timeParts;\r\n    const proposedDateTime = new Date(year, month - 1, day, hours, minutes, seconds);\r\n\r\n    if (proposedDateTime < initialStockDate) {\r\n      return `Date and time cannot be before the initial stock date and time (${format(initialStockDate, 'PPP p')})`;\r\n    }\r\n\r\n    return '';\r\n  };\r\n\r\n  const handleStockAdjustment = async () => {\r\n    if (!adjustmentQuantity || adjustmentQuantity <= 0) {\r\n      toast.error(\"Please enter a valid quantity greater than zero\");\r\n      return;\r\n    }\r\n\r\n    // Validate adjustment date and time\r\n    const dateTimeError = validateAdjustmentDateTime(adjustmentDate, adjustmentTime);\r\n    if (dateTimeError) {\r\n      toast.error(dateTimeError);\r\n      return;\r\n    }\r\n\r\n    setIsApplying(true);\r\n\r\n    try {\r\n      const previousQuantity = product.quantity;\r\n      let newQuantity = previousQuantity;\r\n      // Use standardized reason format\r\n      let changeReason = adjustmentReason.trim()\r\n        ? `${adjustmentType}: ${adjustmentReason}`\r\n        : adjustmentType;\r\n\r\n      if (adjustmentType === 'Stock In') {\r\n        newQuantity = previousQuantity + adjustmentQuantity;\r\n      } else if (adjustmentType === 'Stock Out') {\r\n        newQuantity = Math.max(0, previousQuantity - adjustmentQuantity);\r\n        if (newQuantity === 0 && previousQuantity < adjustmentQuantity) {\r\n          toast.warning(`Attempted to remove ${adjustmentQuantity} items but only ${previousQuantity} were available. Stock is now 0.`);\r\n        }\r\n      }\r\n\r\n      // Create proper datetime for the adjustment using selected date and time\r\n      const [year, month, day] = adjustmentDate.split('-').map(Number);\r\n      const timeParts = adjustmentTime.split(':').map(Number);\r\n      const [hours, minutes, seconds = 0] = timeParts;\r\n      const adjustmentDateTime = new Date(year, month - 1, day, hours, minutes, seconds);\r\n\r\n      // Create the stock history entry which will automatically recalculate the stock chain\r\n      const success = await createStockHistoryEntry(\r\n        product.id,\r\n        previousQuantity,\r\n        newQuantity,\r\n        changeReason,\r\n        undefined,\r\n        adjustmentDateTime,\r\n        undefined,\r\n        product.name\r\n      );\r\n\r\n      if (success) {\r\n        // IMPORTANT: Also update the product record directly to ensure consistency\r\n        const updated = await updateProduct(\r\n          product.id,\r\n          { quantity: newQuantity },\r\n          undefined,\r\n          false,\r\n          'skip-history'\r\n        );\r\n\r\n        if (updated) {\r\n          toast.success(\"Stock updated successfully\");\r\n          if (onStockUpdate) {\r\n            onStockUpdate();\r\n          }\r\n          setAdjustmentQuantity(0);\r\n          setAdjustmentReason('');\r\n          setAdjustmentDate(new Date().toISOString().split('T')[0]);\r\n          setAdjustmentTime(new Date().toTimeString().split(' ')[0]);\r\n        } else {\r\n          toast.error(\"History logged, but failed to update product quantity.\");\r\n        }\r\n      } else {\r\n        toast.error(\"Failed to update stock history\");\r\n      }\r\n    } catch (error) {\r\n      console.error('Error applying stock adjustment:', error);\r\n      toast.error(\"Failed to apply stock adjustment. Please try again.\");\r\n    } finally {\r\n      setIsApplying(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      {/* Header with Navigation and Actions */}\r\n      <div className=\"bg-white border border-gray-200 rounded-lg p-3 md:p-4 shadow-sm\">\r\n        <div className=\"flex flex-col space-y-3 lg:flex-row lg:justify-between lg:items-center lg:space-y-0 lg:gap-4\">\r\n          {/* Navigation and Refresh - Same Line */}\r\n          <div className=\"flex items-center gap-2\">\r\n            <Button\r\n              variant=\"outline\"\r\n              size=\"sm\"\r\n              onClick={() => navigate('/products')}\r\n              className=\"flex items-center gap-2 hover:bg-gray-50 text-sm\"\r\n            >\r\n              <ArrowLeft className=\"h-4 w-4\" />\r\n              Back to Products\r\n            </Button>\r\n\r\n            <Button\r\n              variant=\"outline\"\r\n              size=\"sm\"\r\n              onClick={onStockUpdate}\r\n              className=\"flex items-center gap-1 text-sm\"\r\n            >\r\n              <RefreshCw className=\"h-4 w-4\" />\r\n              Refresh Data\r\n            </Button>\r\n          </div>\r\n\r\n          {/* Action Buttons */}\r\n          <div className=\"flex flex-col space-y-2 lg:flex-row lg:items-center lg:space-y-0 lg:gap-2\">\r\n            {/* Duplicate Button */}\r\n            {hasPermission('inventory', 'create') && (\r\n              <Button\r\n                variant=\"outline\"\r\n                size=\"sm\"\r\n                onClick={handleDuplicateProduct}\r\n                className=\"flex items-center justify-center gap-2 w-full lg:w-auto hover:bg-blue-50 hover:border-blue-300 text-sm\"\r\n              >\r\n                <Copy className=\"h-4 w-4\" />\r\n                Duplicate\r\n              </Button>\r\n            )}\r\n\r\n            {/* Primary Action - Edit Button with Secondary Color */}\r\n            {hasPermission('inventory', 'edit') && (\r\n              <Button\r\n                onClick={() => navigate(`/inventory/edit/${product.id}`)}\r\n                className=\"flex items-center justify-center gap-2 w-full lg:w-auto bg-secondary hover:bg-secondary/90 text-sm\"\r\n                size=\"sm\"\r\n              >\r\n                <Edit className=\"h-4 w-4\" />\r\n                Edit Product\r\n              </Button>\r\n            )}\r\n\r\n            {/* Barcode Label Dialog Button */}\r\n            <Dialog open={barcodeDialogOpen} onOpenChange={setBarcodeDialogOpen}>\r\n              <DialogTrigger asChild>\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  className=\"flex items-center justify-center gap-2 w-full lg:w-auto hover:bg-green-50 hover:border-green-300 text-sm\"\r\n                >\r\n                  <Printer className=\"h-4 w-4\" />\r\n                  Barcode Label\r\n                </Button>\r\n              </DialogTrigger>\r\n              <DialogContent className=\"sm:max-w-md\">\r\n                <DialogHeader>\r\n                  <DialogTitle>Barcode Label Preview</DialogTitle>\r\n                </DialogHeader>\r\n\r\n                <div className=\"flex flex-col items-center justify-center py-6 bg-gray-50 rounded-lg border border-dashed\">\r\n                  {product.barcode ? (\r\n                    <div className=\"bg-white p-6 shadow-sm rounded-md flex flex-col items-center\">\r\n                      <span className=\"text-lg font-bold mb-2 truncate max-w-[280px]\">{product.name}</span>\r\n                      <Barcode\r\n                        value={product.barcode}\r\n                        width={2}\r\n                        height={80}\r\n                        fontSize={16}\r\n                      />\r\n                      {showPriceOnBarcode && (\r\n                        <span className=\"text-lg font-bold mt-2\">\r\n                          {settings.currency} {formatNumber(product.sellingPrice)}\r\n                        </span>\r\n                      )}\r\n                    </div>\r\n                  ) : (\r\n                    <div className=\"text-center p-6 text-muted-foreground\">\r\n                      <AlertCircle className=\"h-10 w-10 mx-auto mb-2 opacity-50\" />\r\n                      <p>No barcode available for this selection.</p>\r\n                    </div>\r\n                  )}\r\n                </div>\r\n\r\n                <div className=\"space-y-4 pt-4 border-t\">\r\n                  <div className=\"flex items-center justify-between\">\r\n                    <div className=\"space-y-0.5\">\r\n                      <Label className=\"text-sm font-medium\">Show Price</Label>\r\n                      <p className=\"text-xs text-muted-foreground\">Include price on the printed label</p>\r\n                    </div>\r\n                    <Switch\r\n                      checked={showPriceOnBarcode}\r\n                      onCheckedChange={setShowPriceOnBarcode}\r\n                    />\r\n                  </div>\r\n\r\n                  <div className=\"flex items-center justify-between\">\r\n                    <div className=\"space-y-0.5\">\r\n                      <Label className=\"text-sm font-medium\">Quantity to Print</Label>\r\n                      <p className=\"text-xs text-muted-foreground\">Number of labels to print</p>\r\n                    </div>\r\n                    <Input\r\n                      type=\"number\"\r\n                      min=\"1\"\r\n                      className=\"w-20\"\r\n                      value={printQuantity}\r\n                      onChange={(e) => setPrintQuantity(parseInt(e.target.value) || 1)}\r\n                    />\r\n                  </div>\r\n\r\n                  <div className=\"flex flex-col gap-2\">\r\n                    {/* Print Button */}\r\n                    <Button\r\n                      className=\"w-full gap-2\"\r\n                      disabled={!product.barcode}\r\n                      onClick={() => {\r\n                        const priceText = showPriceOnBarcode\r\n                          ? `TEXT 15,180,\"3\",0,1,1,\"${settings.currency} ${formatNumber(product.sellingPrice)}\"\\n`\r\n                          : '';\r\n\r\n                        fetch('http://localhost:5000/print/label', {\r\n                          method: 'POST',\r\n                          headers: { 'Content-Type': 'application/json' },\r\n                          mode: 'cors',\r\n                          body: JSON.stringify({\r\n                            PrinterName: settings.defaultPrinterName || 'Label Printer',\r\n                            Content: `SIZE 50 mm, 30 mm\\nGAP 3 mm, 0 mm\\nCLS\\nTEXT 15,20,\"3\",0,1,1,\"${product.name}\"\\nBARCODE 15,70,\"128\",60,1,0,2,2,\"${product.barcode}\"\\n${priceText}PRINT ${printQuantity}\\n`\r\n                          })\r\n                        }).then(() => {\r\n                          toast.success(`${printQuantity} label${printQuantity > 1 ? 's' : ''} sent to printer`);\r\n                        }).catch(err => {\r\n                          console.error('Failed to print label:', err);\r\n                          toast.error('Printing failed. Make sure Printer Bridge is running.');\r\n                        });\r\n                      }}\r\n                    >\r\n                      <Printer className=\"h-4 w-4\" />\r\n                      Print {printQuantity} Label{printQuantity > 1 ? 's' : ''}\r\n                    </Button>\r\n\r\n                    {/* Divider */}\r\n                    <div className=\"relative\">\r\n                      <div className=\"absolute inset-0 flex items-center\">\r\n                        <span className=\"w-full border-t\" />\r\n                      </div>\r\n                      <div className=\"relative flex justify-center text-xs uppercase\">\r\n                        <span className=\"bg-background px-2 text-muted-foreground\">Or Download</span>\r\n                      </div>\r\n                    </div>\r\n\r\n                    {/* Export Buttons */}\r\n                    <div className=\"grid grid-cols-2 gap-2\">\r\n                      <Button\r\n                        variant=\"outline\"\r\n                        className=\"gap-2\"\r\n                        disabled={!product.barcode || isExporting}\r\n                        onClick={async () => {\r\n                          setIsExporting(true);\r\n                          try {\r\n                            await exportBarcodeToJPEG({\r\n                              productName: product.name,\r\n                              barcodeValue: product.barcode,\r\n                              price: product.sellingPrice,\r\n                              currency: settings.currency,\r\n                              showPrice: showPriceOnBarcode,\r\n                            });\r\n                            toast.success('Barcode exported as JPEG');\r\n                          } catch (error) {\r\n                            console.error('Export failed:', error);\r\n                            toast.error('Failed to export barcode');\r\n                          } finally {\r\n                            setIsExporting(false);\r\n                          }\r\n                        }}\r\n                      >\r\n                        <FileImage className=\"h-4 w-4\" />\r\n                        JPEG\r\n                      </Button>\r\n                      <Button\r\n                        variant=\"outline\"\r\n                        className=\"gap-2\"\r\n                        disabled={!product.barcode || isExporting}\r\n                        onClick={async () => {\r\n                          setIsExporting(true);\r\n                          try {\r\n                            await exportSingleBarcodeToPDF({\r\n                              productName: product.name,\r\n                              barcodeValue: product.barcode,\r\n                              price: product.sellingPrice,\r\n                              currency: settings.currency,\r\n                              showPrice: showPriceOnBarcode,\r\n                            });\r\n                            toast.success('Barcode exported as PDF');\r\n                          } catch (error) {\r\n                            console.error('Export failed:', error);\r\n                            toast.error('Failed to export barcode');\r\n                          } finally {\r\n                            setIsExporting(false);\r\n                          }\r\n                        }}\r\n                      >\r\n                        <Download className=\"h-4 w-4\" />\r\n                        PDF\r\n                      </Button>\r\n                    </div>\r\n\r\n                    <Button variant=\"outline\" className=\"w-full\" onClick={() => setBarcodeDialogOpen(false)}>\r\n                      Close\r\n                    </Button>\r\n                  </div>\r\n                </div>\r\n              </DialogContent>\r\n            </Dialog>\r\n\r\n            {/* Delete Button - Below Edit */}\r\n            {hasPermission('inventory', 'delete') && (\r\n              <Button\r\n                variant=\"outline\"\r\n                size=\"sm\"\r\n                onClick={() => setDeleteDialogOpen(true)}\r\n                className=\"flex items-center justify-center gap-2 w-full lg:w-auto text-red-600 hover:text-red-700 border-red-200 hover:border-red-300 hover:bg-red-50 text-sm\"\r\n              >\r\n                <Trash2 className=\"h-4 w-4\" />\r\n                Delete\r\n              </Button>\r\n            )}\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"grid md:grid-cols-3 gap-6\">\r\n        <Card className=\"md:col-span-2\">\r\n          <CardHeader>\r\n            <CardTitle className=\"flex justify-between items-center\">\r\n              <span>Product Details</span>\r\n              {getStockStatusBadge()}\r\n            </CardTitle>\r\n          </CardHeader>\r\n          <CardContent className=\"space-y-6\">\r\n            <div className=\"flex flex-col md:flex-row gap-6\">\r\n              {product.imageUrl && (\r\n                <div className=\"md:w-1/3\">\r\n                  <img\r\n                    src={product.imageUrl}\r\n                    alt={product.name}\r\n                    className=\"w-full h-auto object-contain border rounded-md\"\r\n                  />\r\n                </div>\r\n              )}\r\n\r\n              <div className={product.imageUrl ? 'md:w-2/3' : 'w-full'}>\r\n                <h2 className=\"text-2xl font-bold mb-2\">{product.name}</h2>\r\n\r\n                <div className=\"mb-4 flex flex-wrap gap-2\">\r\n                  <Badge variant=\"outline\">{product.category}</Badge>\r\n                  <Badge variant=\"secondary\">#{product.itemNumber}</Badge>\r\n                </div>\r\n\r\n                {product.description && (\r\n                  <p className=\"text-gray-700 mb-4\">{product.description}</p>\r\n                )}\r\n\r\n                <dl className=\"grid grid-cols-2 gap-x-4 gap-y-2\">\r\n                  <dt className=\"text-gray-500\">Item Number:</dt>\r\n                  <dd className=\"font-semibold\">#{product.itemNumber}</dd>\r\n\r\n                  {product.manufacturerBarcode && (\r\n                    <>\r\n                      <dt className=\"text-gray-500\">Manufacturer Barcode:</dt>\r\n                      <dd className=\"font-semibold\">{product.manufacturerBarcode}</dd>\r\n                    </>\r\n                  )}\r\n\r\n                  <dt className=\"text-gray-500\">Quantity in Stock:</dt>\r\n                  <dd className=\"font-semibold\">{product.quantity % 1 === 0 ? product.quantity : product.quantity.toFixed(2)}</dd>\r\n\r\n                  <dt className=\"text-gray-500\">Minimum Stock Level:</dt>\r\n                  <dd>{product.minimumStock}</dd>\r\n\r\n                  <dt className=\"text-gray-500\">Cost Price:</dt>\r\n                  <dd>{canViewCostPrice ? `${settings.currency} ${formatFinancial(product.costPrice, 'cost')}` : ''}</dd>\r\n\r\n                  <dt className=\"text-gray-500\">Selling Price:</dt>\r\n                  <dd>{canViewSellingPrice ? `${settings.currency} ${formatFinancial(product.sellingPrice, 'selling')}` : ''}</dd>\r\n\r\n                  <dt className=\"text-gray-500\">Total Cost:</dt>\r\n                  <dd className=\"font-semibold\">{canViewCostPrice ? `${settings.currency} ${formatNumber(product.quantity * product.costPrice)}` : ''}</dd>\r\n\r\n                  <dt className=\"text-gray-500\">Profit Margin:</dt>\r\n                  <dd>\r\n                    {canViewProfit ?\r\n                      `${((product.sellingPrice - product.costPrice) / product.sellingPrice * 100).toFixed(2)}%`\r\n                      : ''}\r\n                  </dd>\r\n\r\n                  {product.supplier && (\r\n                    <>\r\n                      <dt className=\"text-gray-500\">Supplier:</dt>\r\n                      <dd>{product.supplier}</dd>\r\n                    </>\r\n                  )}\r\n\r\n                  <dt className=\"text-gray-500\">Created:</dt>\r\n                  <dd>{format(product.createdAt, 'MMM d, yyyy')}</dd>\r\n\r\n                  <dt className=\"text-gray-500\">Last Updated:</dt>\r\n                  <dd>{format(product.updatedAt, 'MMM d, yyyy')}</dd>\r\n                </dl>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"flex flex-wrap gap-4\">\r\n              {product.quantity <= product.minimumStock && (\r\n                <div className=\"bg-amber-50 border border-amber-200 rounded-md p-4 w-full flex items-center gap-3\">\r\n                  <AlertCircle className=\"text-amber-600 h-6 w-6 flex-shrink-0\" />\r\n                  <div>\r\n                    <h4 className=\"font-medium text-amber-800\">Low Stock Alert</h4>\r\n                    <p className=\"text-sm text-amber-700\">\r\n                      Current stock ({product.quantity}) is below or equal to the minimum threshold ({product.minimumStock}).\r\n                    </p>\r\n                  </div>\r\n                </div>\r\n              )}\r\n            </div>\r\n          </CardContent>\r\n        </Card>\r\n\r\n        <div className=\"space-y-6\">\r\n          <Card>\r\n            <CardHeader className=\"pb-2\">\r\n              <CardTitle className=\"text-lg\">Stock Management</CardTitle>\r\n            </CardHeader>\r\n            <CardContent>\r\n              {hasPermission('inventory', 'stock_adjustment') ? (\r\n                <div className=\"space-y-4\">\r\n                  <div>\r\n                    <label className=\"block text-sm font-medium mb-1\">Adjustment Type</label>\r\n                    <div className=\"grid grid-cols-2 gap-4 mb-2\">\r\n                      <Button\r\n                        type=\"button\"\r\n                        variant={adjustmentType === 'Stock In' ? 'default' : 'outline'}\r\n                        onClick={() => setAdjustmentType('Stock In')}\r\n                        className={`w-full ${adjustmentType === 'Stock In' ? 'bg-orange-600 hover:bg-orange-700' : ''}`}\r\n                      >\r\n                        <Plus className=\"mr-2 h-4 w-4\" />\r\n                        Stock In\r\n                      </Button>\r\n                      <Button\r\n                        type=\"button\"\r\n                        variant={adjustmentType === 'Stock Out' ? 'default' : 'outline'}\r\n                        onClick={() => setAdjustmentType('Stock Out')}\r\n                        className={`w-full ${adjustmentType === 'Stock Out' ? 'bg-orange-600 hover:bg-orange-700' : ''}`}\r\n                      >\r\n                        <Minus className=\"mr-2 h-4 w-4\" />\r\n                        Stock Out\r\n                      </Button>\r\n                    </div>\r\n                  </div>\r\n\r\n                  <div>\r\n                    <label className=\"block text-sm font-medium mb-1\">Quantity</label>\r\n                    <Input\r\n                      type=\"number\"\r\n                      min=\"0.01\"\r\n                      step=\"0.01\"\r\n                      value={adjustmentQuantity || ''}\r\n                      onChange={(e) => setAdjustmentQuantity(parseFloat(e.target.value) || 0)}\r\n                      placeholder=\"Enter quantity\"\r\n                    />\r\n                  </div>\r\n\r\n                  <div>\r\n                    <label className=\"block text-sm font-medium mb-1\">Reason (Optional)</label>\r\n                    <Input\r\n                      type=\"text\"\r\n                      value={adjustmentReason}\r\n                      onChange={(e) => setAdjustmentReason(e.target.value)}\r\n                      placeholder=\"e.g., Weekly restock, Damaged goods\"\r\n                      maxLength={100}\r\n                    />\r\n                  </div>\r\n\r\n                  <div className=\"grid grid-cols-2 gap-2\">\r\n                    <div>\r\n                      <label className=\"block text-sm font-medium mb-1\">Date</label>\r\n                      <Input\r\n                        type=\"date\"\r\n                        value={adjustmentDate}\r\n                        onChange={(e) => setAdjustmentDate(e.target.value)}\r\n                        min={product.createdAt ? new Date(product.createdAt).toISOString().split('T')[0] : undefined}\r\n                        max={new Date().toISOString().split('T')[0]}\r\n                        className={validateAdjustmentDateTime(adjustmentDate, adjustmentTime) ? 'border-destructive border-2 bg-destructive/5' : ''}\r\n                      />\r\n                    </div>\r\n                    <div>\r\n                      <label className=\"block text-sm font-medium mb-1\">Time</label>\r\n                      <Input\r\n                        type=\"time\"\r\n                        step=\"1\"\r\n                        value={adjustmentTime}\r\n                        onChange={(e) => setAdjustmentTime(e.target.value)}\r\n                        className={validateAdjustmentDateTime(adjustmentDate, adjustmentTime) ? 'border-destructive border-2 bg-destructive/5' : ''}\r\n                      />\r\n                    </div>\r\n                  </div>\r\n                  {validateAdjustmentDateTime(adjustmentDate, adjustmentTime) && (\r\n                    <p className=\"text-sm text-destructive mt-1\">{validateAdjustmentDateTime(adjustmentDate, adjustmentTime)}</p>\r\n                  )}\r\n\r\n                  <Button\r\n                    onClick={handleStockAdjustment}\r\n                    disabled={isApplying || adjustmentQuantity <= 0 || !!validateAdjustmentDateTime(adjustmentDate, adjustmentTime)}\r\n                    className=\"w-full bg-orange-600 hover:bg-orange-700\"\r\n                  >\r\n                    <Package className=\"mr-2 h-4 w-4\" />\r\n                    {isApplying ? 'Applying...' : `Apply ${adjustmentType}`}\r\n                  </Button>\r\n                </div>\r\n              ) : (\r\n                <div className=\"py-4 text-center space-y-2\">\r\n                  <AlertCircle className=\"h-8 w-8 text-muted-foreground mx-auto opacity-50\" />\r\n                  <p className=\"text-sm text-muted-foreground\">\r\n                    You do not have permission to perform stock adjustments.\r\n                  </p>\r\n                </div>\r\n              )}\r\n            </CardContent>\r\n          </Card>\r\n        </div>\r\n      </div>\r\n\r\n      <DeleteProductDialog\r\n        open={deleteDialogOpen}\r\n        onOpenChange={setDeleteDialogOpen}\r\n        product={product}\r\n        onConfirm={handleDeleteProduct}\r\n      />\r\n    </div >\r\n  );\r\n};\r\n\r\nexport default ProductDetails;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3237, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/inventory/EditStockHistoryDialog.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogHeader,\r\n  DialogTitle,\r\n} from '@/components/ui/dialog';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Label } from '@/components/ui/label';\r\nimport { StockHistoryEntry } from '@/types';\r\nimport { format } from 'date-fns';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useProfiles } from '@/contexts/ProfileContext';\r\n\r\ninterface EditStockHistoryDialogProps {\r\n  open: boolean;\r\n  onOpenChange: (open: boolean) => void;\r\n  entry: StockHistoryEntry | null;\r\n  onConfirm: (entryId: string, newQuantity: number, newReason: string, newDate?: Date) => Promise<boolean>;\r\n  isInitialStock?: boolean;\r\n  stockHistory?: StockHistoryEntry[];\r\n  productCreatedAt?: Date;\r\n}\r\n\r\nconst EditStockHistoryDialog: React.FC<EditStockHistoryDialogProps> = ({\r\n  open,\r\n  onOpenChange,\r\n  entry,\r\n  onConfirm,\r\n  isInitialStock = false,\r\n  stockHistory = [],\r\n  productCreatedAt,\r\n}) => {\r\n  const [quantityChange, setQuantityChange] = useState<number | ''>(0);\r\n  const [newReason, setNewReason] = useState<string>('');\r\n  const [isSubmitting, setIsSubmitting] = useState(false);\r\n  const [validationError, setValidationError] = useState<string>('');\r\n  const { toast } = useToast();\r\n  const { hasPermission } = useProfiles();\r\n\r\n  // Get the initial stock date (chronologically first entry)\r\n  const getInitialStockDate = (): Date | null => {\r\n    if (stockHistory.length === 0) return null;\r\n    const sortedHistory = [...stockHistory].sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\r\n    return sortedHistory[0]?.createdAt || null;\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (entry) {\r\n      setQuantityChange(entry.newQuantity - entry.oldQuantity);\r\n      setNewReason(entry.changeReason);\r\n      setValidationError(''); // Clear validation error when entry changes\r\n    }\r\n  }, [entry]);\r\n\r\n  const validateQuantityChange = (newChange: number, currentChange: number): string => {\r\n    // If current change is negative, don't allow changing to positive\r\n    if (currentChange < 0 && newChange > 0) {\r\n      return 'Cannot change from negative to positive value.';\r\n    }\r\n    // If current change is positive, don't allow changing to negative\r\n    if (currentChange > 0 && newChange < 0) {\r\n      return 'Cannot change from positive to negative value.';\r\n    }\r\n    return '';\r\n  };\r\n\r\n  const handleQuantityChange = (value: string) => {\r\n    // Always allow empty string so users can clear the field\r\n    if (value === '') {\r\n      setQuantityChange('');\r\n      setValidationError('');\r\n      return;\r\n    }\r\n\r\n    const numericValue = parseInt(value) || 0;\r\n    const currentChange = quantityChange === '' ? 0 : quantityChange;\r\n\r\n    const error = validateQuantityChange(numericValue, currentChange);\r\n\r\n    // Only update the input if validation passes\r\n    if (!error) {\r\n      setQuantityChange(numericValue);\r\n      setValidationError('');\r\n    } else {\r\n      // Show validation error but don't update the input\r\n      setValidationError(error);\r\n    }\r\n  };\r\n\r\n  const handleReasonChange = (value: string) => {\r\n    setNewReason(value);\r\n  };\r\n\r\n  const handleSubmit = async (skipDateUpdate = false) => {\r\n    if (!entry) return;\r\n\r\n    const changeAmount = quantityChange === '' ? 0 : quantityChange;\r\n\r\n    // Validate quantity change before submitting\r\n    const originalChange = entry.newQuantity - entry.oldQuantity;\r\n    const error = validateQuantityChange(changeAmount, originalChange);\r\n    if (error) {\r\n      toast({\r\n        title: \"Invalid quantity change\",\r\n        description: error,\r\n        variant: \"destructive\"\r\n      });\r\n      return;\r\n    }\r\n\r\n    const newQuantity = entry.oldQuantity + changeAmount;\r\n\r\n    if (!newReason.trim()) {\r\n      toast({\r\n        title: \"Invalid reason\",\r\n        description: \"Please provide a reason for this stock change\",\r\n        variant: \"destructive\"\r\n      });\r\n      return;\r\n    }\r\n\r\n    setIsSubmitting(true);\r\n\r\n    try {\r\n      const success = await onConfirm(\r\n        entry.id,\r\n        newQuantity,\r\n        newReason.trim()\r\n      );\r\n\r\n      if (success) {\r\n        toast({\r\n          title: \"Stock history updated\",\r\n          description: \"The stock history entry has been updated successfully.\"\r\n        });\r\n        onOpenChange(false);\r\n      } else {\r\n        toast({\r\n          title: \"Update failed\",\r\n          description: \"Failed to update stock history entry. Please try again.\",\r\n          variant: \"destructive\"\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error('Error updating stock history:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"An error occurred while updating the stock history.\",\r\n        variant: \"destructive\"\r\n      });\r\n    } finally {\r\n      setIsSubmitting(false);\r\n    }\r\n  };\r\n\r\n  const handleCancel = () => {\r\n    onOpenChange(false);\r\n  };\r\n\r\n  if (!entry) return null;\r\n\r\n  // Check if this entry was created by a sale operation\r\n  const isSaleRelatedEntry = (entry: StockHistoryEntry): boolean => {\r\n    const saleReasons = ['Sale', 'Delete sale', 'Deleted Sale', 'Sale qty edit'];\r\n    return saleReasons.some(reason => entry.changeReason.toLowerCase().includes(reason.toLowerCase()));\r\n  };\r\n\r\n  const formatChangeReason = (reason: string): string => {\r\n    return reason\r\n      .replace('Deleted sale', 'Deleted Sale');\r\n  };\r\n\r\n  // If this is initial stock, show form with date editing enabled but with validation\r\n  if (isInitialStock) {\r\n    return (\r\n      <Dialog open={open} onOpenChange={onOpenChange}>\r\n        <DialogContent className=\"sm:max-w-md\">\r\n          <DialogHeader>\r\n            <DialogTitle>Edit Initial Stock Entry</DialogTitle>\r\n            <DialogDescription>\r\n              This is the initial stock entry. You can modify quantity, reason, and date, but the date must be earlier than all other stock transactions.\r\n            </DialogDescription>\r\n          </DialogHeader>\r\n\r\n          <div className=\"space-y-4\">\r\n            <div className=\"space-y-2\">\r\n              <Label htmlFor=\"quantity\">Quantity Change</Label>\r\n              <Input\r\n                id=\"quantity\"\r\n                type=\"number\"\r\n                value={quantityChange}\r\n                onChange={(e) => handleQuantityChange(e.target.value)}\r\n                className={validationError ? 'border-destructive border-2 bg-destructive/5 focus:border-destructive focus:ring-destructive' : ''}\r\n              />\r\n              {validationError && (\r\n                <p className=\"text-sm text-destructive\">{validationError}</p>\r\n              )}\r\n            </div>\r\n\r\n            <div className=\"space-y-2\">\r\n              <Label htmlFor=\"reason\">Change Reason</Label>\r\n              <Input\r\n                id=\"reason\"\r\n                value={newReason}\r\n                onChange={(e) => setNewReason(e.target.value)}\r\n                placeholder=\"Enter reason for stock change\"\r\n              />\r\n            </div>\r\n\r\n          </div>\r\n\r\n          <div className=\"flex justify-end gap-2 mt-6\">\r\n            <Button variant=\"outline\" onClick={handleCancel} disabled={isSubmitting}>\r\n              Cancel\r\n            </Button>\r\n            <Button\r\n              onClick={() => handleSubmit()}\r\n              disabled={isSubmitting || !hasPermission('inventory', 'stock_adjustment')}\r\n            >\r\n              {isSubmitting ? 'Updating...' : 'Update Entry'}\r\n            </Button>\r\n          </div>\r\n        </DialogContent>\r\n      </Dialog>\r\n    );\r\n  }\r\n\r\n  // If this is a sale-related entry, show a restricted message\r\n  if (isSaleRelatedEntry(entry)) {\r\n    return (\r\n      <Dialog open={open} onOpenChange={onOpenChange}>\r\n        <DialogContent className=\"sm:max-w-md\">\r\n          <DialogHeader>\r\n            <DialogTitle>Cannot Edit Sale-Related Entry</DialogTitle>\r\n            <DialogDescription>\r\n              This stock history entry was created by a sales operation and can only be modified through the Edit Sale form.\r\n            </DialogDescription>\r\n          </DialogHeader>\r\n\r\n          <div className=\"space-y-4\">\r\n            <div className=\"bg-muted p-3 rounded-lg space-y-2\">\r\n              <div className=\"font-medium\">Entry Details:</div>\r\n              <div className=\"text-sm space-y-1\">\r\n                <div><strong>Date:</strong> {format(entry.createdAt, 'PPP p')}</div>\r\n                <div><strong>Change:</strong> {entry.oldQuantity}  {entry.newQuantity}</div>\r\n                <div><strong>Reason:</strong> {formatChangeReason(entry.changeReason)}</div>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"bg-blue-50 border border-blue-200 p-3 rounded-lg\">\r\n              <div className=\"text-blue-800 text-sm\">\r\n                <strong>Note:</strong> To modify this entry, please use the Edit Sale form in the Sales section.\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          <div className=\"flex justify-end gap-2 mt-6\">\r\n            <Button variant=\"outline\" onClick={() => onOpenChange(false)}>\r\n              Close\r\n            </Button>\r\n          </div>\r\n        </DialogContent>\r\n      </Dialog>\r\n    );\r\n  }\r\n\r\n  const originalChange = entry.newQuantity - entry.oldQuantity;\r\n  const changeAmount = quantityChange === '' ? 0 : quantityChange;\r\n  const newQuantity = entry.oldQuantity + changeAmount;\r\n  const newChange = changeAmount;\r\n\r\n  return (\r\n    <Dialog open={open} onOpenChange={onOpenChange}>\r\n      <DialogContent className=\"sm:max-w-md\">\r\n        <DialogHeader>\r\n          <DialogTitle>Edit Stock History Entry</DialogTitle>\r\n          <DialogDescription>\r\n            Modify the details of this stock history entry. The product's current stock will be recalculated after saving.\r\n          </DialogDescription>\r\n        </DialogHeader>\r\n\r\n        <div className=\"space-y-4\">\r\n          <div className=\"grid grid-cols-2 gap-4 text-sm\">\r\n            <div>\r\n              <Label className=\"text-muted-foreground\">Original</Label>\r\n              <div className=\"font-medium\">\r\n                {entry.oldQuantity}  {entry.newQuantity}\r\n              </div>\r\n              <div className={`text-xs ${originalChange >= 0 ? 'text-green-600' : 'text-red-600'}`}>\r\n                {originalChange >= 0 ? '+' : ''}{originalChange}\r\n              </div>\r\n            </div>\r\n            <div>\r\n              <Label className=\"text-muted-foreground\">New</Label>\r\n              <div className=\"font-medium\">\r\n                {entry.oldQuantity}  {newQuantity}\r\n              </div>\r\n              <div className={`text-xs ${newChange >= 0 ? 'text-green-600' : 'text-red-600'}`}>\r\n                {newChange >= 0 ? '+' : ''}{newChange}\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"quantity\">Quantity Change</Label>\r\n            <Input\r\n              id=\"quantity\"\r\n              type=\"number\"\r\n              value={quantityChange}\r\n              onChange={(e) => handleQuantityChange(e.target.value)}\r\n              className={validationError ? 'border-destructive border-2 bg-destructive/5 focus:border-destructive focus:ring-destructive' : ''}\r\n            />\r\n            {entry && (\r\n              <p className=\"text-xs text-muted-foreground\">\r\n                 {(quantityChange === '' ? 0 : quantityChange) < 0\r\n                  ? \"Current change is negative - you cannot change to positive values\"\r\n                  : \"Current change is positive - you cannot change to negative values\"\r\n                }\r\n              </p>\r\n            )}\r\n            {validationError && (\r\n              <p className=\"text-sm text-destructive\">{validationError}</p>\r\n            )}\r\n          </div>\r\n\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"reason\">Change Reason</Label>\r\n            <Input\r\n              id=\"reason\"\r\n              value={newReason}\r\n              onChange={(e) => setNewReason(e.target.value)}\r\n              placeholder=\"Enter reason for stock change\"\r\n            />\r\n          </div>\r\n\r\n        </div>\r\n\r\n        <div className=\"flex justify-end gap-2 mt-6\">\r\n          <Button variant=\"outline\" onClick={handleCancel} disabled={isSubmitting}>\r\n            Cancel\r\n          </Button>\r\n          <Button\r\n            onClick={() => handleSubmit()}\r\n            disabled={isSubmitting || !hasPermission('inventory', 'stock_adjustment')}\r\n          >\r\n            {isSubmitting ? 'Updating...' : 'Update Entry'}\r\n          </Button>\r\n        </div>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n};\r\n\r\nexport default EditStockHistoryDialog;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3958, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/inventory/DeleteStockHistoryDialog.tsx"],"sourcesContent":["import React, { useState } from 'react';\r\nimport {\r\n  AlertDialog,\r\n  AlertDialogAction,\r\n  AlertDialogCancel,\r\n  AlertDialogContent,\r\n  AlertDialogDescription,\r\n  AlertDialogFooter,\r\n  AlertDialogHeader,\r\n  AlertDialogTitle,\r\n} from '@/components/ui/alert-dialog';\r\nimport { StockHistoryEntry } from '@/types';\r\nimport { format } from 'date-fns';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { AlertTriangle } from 'lucide-react';\r\n\r\ninterface DeleteStockHistoryDialogProps {\r\n  open: boolean;\r\n  onOpenChange: (open: boolean) => void;\r\n  entry: StockHistoryEntry | null;\r\n  onConfirm: (entryId: string) => Promise<boolean>;\r\n}\r\n\r\nconst DeleteStockHistoryDialog: React.FC<DeleteStockHistoryDialogProps> = ({\r\n  open,\r\n  onOpenChange,\r\n  entry,\r\n  onConfirm,\r\n}) => {\r\n  const [isDeleting, setIsDeleting] = useState(false);\r\n  const { toast } = useToast();\r\n\r\n  const handleDelete = async () => {\r\n    if (!entry) return;\r\n\r\n    setIsDeleting(true);\r\n\r\n    try {\r\n      const success = await onConfirm(entry.id);\r\n\r\n      if (success) {\r\n        toast({\r\n          title: \"Stock history deleted\",\r\n          description: \"The stock history entry has been deleted and stock recalculated.\"\r\n        });\r\n        onOpenChange(false);\r\n      } else {\r\n        toast({\r\n          title: \"Delete failed\",\r\n          description: \"Failed to delete stock history entry. Please try again.\",\r\n          variant: \"destructive\"\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error('Error deleting stock history:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"An error occurred while deleting the stock history.\",\r\n        variant: \"destructive\"\r\n      });\r\n    } finally {\r\n      setIsDeleting(false);\r\n    }\r\n  };\r\n\r\n  if (!entry) return null;\r\n\r\n  // Check if this entry was created by a sale operation\r\n  const isSaleRelatedEntry = (entry: StockHistoryEntry): boolean => {\r\n    const saleReasons = ['Sale', 'Delete sale', 'Deleted Sale', 'Sale qty edit'];\r\n    return saleReasons.some(reason => entry.changeReason.toLowerCase().includes(reason.toLowerCase()));\r\n  };\r\n\r\n  const formatChangeReason = (reason: string): string => {\r\n    return reason\r\n      .replace('Deleted sale', 'Deleted Sale');\r\n  };\r\n\r\n  // If this is a sale-related entry, show a restricted message\r\n  if (isSaleRelatedEntry(entry)) {\r\n    return (\r\n      <AlertDialog open={open} onOpenChange={onOpenChange}>\r\n        <AlertDialogContent>\r\n          <AlertDialogHeader>\r\n            <AlertDialogTitle className=\"flex items-center gap-2\">\r\n              <AlertTriangle className=\"h-5 w-5 text-blue-600\" />\r\n              Cannot Delete Sale-Related Entry\r\n            </AlertDialogTitle>\r\n            <AlertDialogDescription className=\"space-y-3\">\r\n              <p>\r\n                This stock history entry was created by a sales operation and cannot be deleted directly.\r\n              </p>\r\n\r\n              <div className=\"bg-muted p-3 rounded-lg space-y-2\">\r\n                <div className=\"font-medium\">Entry Details:</div>\r\n                <div className=\"text-sm space-y-1\">\r\n                  <div><strong>Date:</strong> {format(entry.createdAt, 'PPP p')}</div>\r\n                  <div><strong>Change:</strong> {entry.oldQuantity}  {entry.newQuantity}</div>\r\n                  <div><strong>Reason:</strong> {formatChangeReason(entry.changeReason)}</div>\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"bg-blue-50 border border-blue-200 p-3 rounded-lg\">\r\n                <div className=\"text-blue-800 text-sm\">\r\n                  <strong>Note:</strong> To remove this entry, please edit or delete the corresponding sale in the Sales section.\r\n                </div>\r\n              </div>\r\n            </AlertDialogDescription>\r\n          </AlertDialogHeader>\r\n          <AlertDialogFooter>\r\n            <AlertDialogCancel>Close</AlertDialogCancel>\r\n          </AlertDialogFooter>\r\n        </AlertDialogContent>\r\n      </AlertDialog>\r\n    );\r\n  }\r\n\r\n  const stockChange = entry.newQuantity - entry.oldQuantity;\r\n\r\n  return (\r\n    <AlertDialog open={open} onOpenChange={onOpenChange}>\r\n      <AlertDialogContent>\r\n        <AlertDialogHeader>\r\n          <AlertDialogTitle className=\"flex items-center gap-2\">\r\n            <AlertTriangle className=\"h-5 w-5 text-destructive\" />\r\n            Delete Stock History Entry\r\n          </AlertDialogTitle>\r\n          <AlertDialogDescription className=\"space-y-3\">\r\n            <p>\r\n              Are you sure you want to delete this stock history entry? This action cannot be undone.\r\n            </p>\r\n\r\n            <div className=\"bg-muted p-3 rounded-lg space-y-2\">\r\n              <div className=\"font-medium\">Entry Details:</div>\r\n              <div className=\"text-sm space-y-1\">\r\n                <div><strong>Date:</strong> {format(entry.createdAt, 'PPP p')}</div>\r\n                <div><strong>Change:</strong> {entry.oldQuantity}  {entry.newQuantity}</div>\r\n                <div className={`${stockChange >= 0 ? 'text-green-600' : 'text-red-600'}`}>\r\n                  <strong>Impact:</strong> {stockChange >= 0 ? '+' : ''}{stockChange} units\r\n                </div>\r\n                <div><strong>Reason:</strong> {formatChangeReason(entry.changeReason)}</div>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"bg-amber-50 border border-amber-200 p-3 rounded-lg\">\r\n              <div className=\"text-amber-800 text-sm\">\r\n                <strong>Warning:</strong> After deletion, the product's current stock will be automatically recalculated based on the remaining stock history entries.\r\n              </div>\r\n            </div>\r\n          </AlertDialogDescription>\r\n        </AlertDialogHeader>\r\n        <AlertDialogFooter>\r\n          <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>\r\n          <AlertDialogAction\r\n            onClick={handleDelete}\r\n            disabled={isDeleting}\r\n            className=\"bg-destructive text-destructive-foreground hover:bg-destructive/90\"\r\n          >\r\n            {isDeleting ? 'Deleting...' : 'Delete Entry'}\r\n          </AlertDialogAction>\r\n        </AlertDialogFooter>\r\n      </AlertDialogContent>\r\n    </AlertDialog>\r\n  );\r\n};\r\n\r\nexport default DeleteStockHistoryDialog;"],"names":[],"mappings":";;;;;AAAA;AACA;AAWA;AACA;AACA;;;;;;;;AASA,MAAM,2BAAoE,CAAC,EACzE,IAAI,EACJ,YAAY,EACZ,KAAK,EACL,SAAS,EACV;;IACC,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,yKAAQ,EAAC;IAC7C,MAAM,EAAE,KAAK,EAAE,GAAG,IAAA,2IAAQ;IAE1B,MAAM,eAAe;QACnB,IAAI,CAAC,OAAO;QAEZ,cAAc;QAEd,IAAI;YACF,MAAM,UAAU,MAAM,UAAU,MAAM,EAAE;YAExC,IAAI,SAAS;gBACX,MAAM;oBACJ,OAAO;oBACP,aAAa;gBACf;gBACA,aAAa;YACf,OAAO;gBACL,MAAM;oBACJ,OAAO;oBACP,aAAa;oBACb,SAAS;gBACX;YACF;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,iCAAiC;YAC/C,MAAM;gBACJ,OAAO;gBACP,aAAa;gBACb,SAAS;YACX;QACF,SAAU;YACR,cAAc;QAChB;IACF;IAEA,IAAI,CAAC,OAAO,OAAO;IAEnB,sDAAsD;IACtD,MAAM,qBAAqB,CAAC;QAC1B,MAAM,cAAc;YAAC;YAAQ;YAAe;YAAgB;SAAgB;QAC5E,OAAO,YAAY,IAAI,CAAC,CAAA,SAAU,MAAM,YAAY,CAAC,WAAW,GAAG,QAAQ,CAAC,OAAO,WAAW;IAChG;IAEA,MAAM,qBAAqB,CAAC;QAC1B,OAAO,OACJ,OAAO,CAAC,gBAAgB;IAC7B;IAEA,6DAA6D;IAC7D,IAAI,mBAAmB,QAAQ;QAC7B,qBACE,6LAAC,6JAAW;YAAC,MAAM;YAAM,cAAc;sBACrC,cAAA,6LAAC,oKAAkB;;kCACjB,6LAAC,mKAAiB;;0CAChB,6LAAC,kKAAgB;gCAAC,WAAU;;kDAC1B,6LAAC,4OAAa;wCAAC,WAAU;;;;;;oCAA0B;;;;;;;0CAGrD,6LAAC,wKAAsB;gCAAC,WAAU;;kDAChC,6LAAC;kDAAE;;;;;;kDAIH,6LAAC;wCAAI,WAAU;;0DACb,6LAAC;gDAAI,WAAU;0DAAc;;;;;;0DAC7B,6LAAC;gDAAI,WAAU;;kEACb,6LAAC;;0EAAI,6LAAC;0EAAO;;;;;;4DAAc;4DAAE,IAAA,kKAAM,EAAC,MAAM,SAAS,EAAE;;;;;;;kEACrD,6LAAC;;0EAAI,6LAAC;0EAAO;;;;;;4DAAgB;4DAAE,MAAM,WAAW;4DAAC;4DAAI,MAAM,WAAW;;;;;;;kEACtE,6LAAC;;0EAAI,6LAAC;0EAAO;;;;;;4DAAgB;4DAAE,mBAAmB,MAAM,YAAY;;;;;;;;;;;;;;;;;;;kDAIxE,6LAAC;wCAAI,WAAU;kDACb,cAAA,6LAAC;4CAAI,WAAU;;8DACb,6LAAC;8DAAO;;;;;;gDAAc;;;;;;;;;;;;;;;;;;;;;;;;kCAK9B,6LAAC,mKAAiB;kCAChB,cAAA,6LAAC,mKAAiB;sCAAC;;;;;;;;;;;;;;;;;;;;;;IAK7B;IAEA,MAAM,cAAc,MAAM,WAAW,GAAG,MAAM,WAAW;IAEzD,qBACE,6LAAC,6JAAW;QAAC,MAAM;QAAM,cAAc;kBACrC,cAAA,6LAAC,oKAAkB;;8BACjB,6LAAC,mKAAiB;;sCAChB,6LAAC,kKAAgB;4BAAC,WAAU;;8CAC1B,6LAAC,4OAAa;oCAAC,WAAU;;;;;;gCAA6B;;;;;;;sCAGxD,6LAAC,wKAAsB;4BAAC,WAAU;;8CAChC,6LAAC;8CAAE;;;;;;8CAIH,6LAAC;oCAAI,WAAU;;sDACb,6LAAC;4CAAI,WAAU;sDAAc;;;;;;sDAC7B,6LAAC;4CAAI,WAAU;;8DACb,6LAAC;;sEAAI,6LAAC;sEAAO;;;;;;wDAAc;wDAAE,IAAA,kKAAM,EAAC,MAAM,SAAS,EAAE;;;;;;;8DACrD,6LAAC;;sEAAI,6LAAC;sEAAO;;;;;;wDAAgB;wDAAE,MAAM,WAAW;wDAAC;wDAAI,MAAM,WAAW;;;;;;;8DACtE,6LAAC;oDAAI,WAAW,GAAG,eAAe,IAAI,mBAAmB,gBAAgB;;sEACvE,6LAAC;sEAAO;;;;;;wDAAgB;wDAAE,eAAe,IAAI,MAAM;wDAAI;wDAAY;;;;;;;8DAErE,6LAAC;;sEAAI,6LAAC;sEAAO;;;;;;wDAAgB;wDAAE,mBAAmB,MAAM,YAAY;;;;;;;;;;;;;;;;;;;8CAIxE,6LAAC;oCAAI,WAAU;8CACb,cAAA,6LAAC;wCAAI,WAAU;;0DACb,6LAAC;0DAAO;;;;;;4CAAiB;;;;;;;;;;;;;;;;;;;;;;;;8BAKjC,6LAAC,mKAAiB;;sCAChB,6LAAC,mKAAiB;4BAAC,UAAU;sCAAY;;;;;;sCACzC,6LAAC,mKAAiB;4BAChB,SAAS;4BACT,UAAU;4BACV,WAAU;sCAET,aAAa,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;AAM1C;GA7IM;;QAOc,2IAAQ;;;KAPtB;uCA+IS"}},
    {"offset": {"line": 4422, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/inventory/ProductStockHistory.tsx"],"sourcesContent":["import React, { useState, useMemo } from 'react';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Button } from '@/components/ui/button';\r\nimport { StockHistoryEntry } from '@/types';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Edit, Clock, Trash2, History } from 'lucide-react';\r\nimport {\r\n  DropdownMenu,\r\n  DropdownMenuTrigger,\r\n  DropdownMenuContent,\r\n  DropdownMenuItem,\r\n  DropdownMenuLabel,\r\n  DropdownMenuSeparator\r\n} from '@/components/ui/dropdown-menu';\r\nimport { useProfiles } from '@/contexts/ProfileContext';\r\nimport { format } from 'date-fns';\r\nimport EditStockHistoryDialog from './EditStockHistoryDialog';\r\nimport DeleteStockHistoryDialog from './DeleteStockHistoryDialog';\r\n\r\ninterface ProductStockHistoryProps {\r\n  stockHistory: StockHistoryEntry[];\r\n  isLoadingHistory: boolean;\r\n  onEditStockHistory: (entryId: string, newQuantity: number, newReason: string, newDate?: Date) => Promise<boolean>;\r\n  onDeleteStockHistory: (entryId: string) => Promise<boolean>;\r\n  products: any[];\r\n}\r\n\r\nconst ProductStockHistory: React.FC<ProductStockHistoryProps> = ({\r\n  stockHistory,\r\n  isLoadingHistory,\r\n  onEditStockHistory,\r\n  onDeleteStockHistory,\r\n  products\r\n}) => {\r\n  const { hasPermission } = useProfiles();\r\n  const [editHistoryDialog, setEditHistoryDialog] = useState<{ open: boolean; entry: StockHistoryEntry | null }>({ open: false, entry: null });\r\n  const [deleteHistoryDialog, setDeleteHistoryDialog] = useState<{ open: boolean; entry: StockHistoryEntry | null }>({ open: false, entry: null });\r\n  const [expandedSale, setExpandedSale] = useState<string | null>(null);\r\n  const [expandedManual, setExpandedManual] = useState<string | null>(null);\r\n\r\n  // Check if a stock history entry was created by a sale operation\r\n  const isSaleRelatedEntry = (entry: StockHistoryEntry): boolean => {\r\n    const saleReasons = ['Sale', 'Delete sale', 'Deleted Sale', 'Sale qty edit'];\r\n    return saleReasons.some(reason => entry.changeReason.toLowerCase().includes(reason.toLowerCase()));\r\n  };\r\n\r\n  const formatChangeReason = (reason: string): string => {\r\n    return reason\r\n      .replace('Deleted sale', 'Deleted Sale');\r\n  };\r\n\r\n  // Check if a stock history entry is initial stock (first entry chronologically)\r\n  const isInitialStockEntry = (entry: StockHistoryEntry): boolean => {\r\n    if (stockHistory.length === 0) return false;\r\n\r\n    // Sort by creation date to find the chronologically first entry\r\n    const sortedHistory = [...stockHistory].sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\r\n    return sortedHistory[0]?.id === entry.id;\r\n  };\r\n\r\n  // Prepare unified display items\r\n  const displayItems = useMemo(() => {\r\n    const saleGroups: Record<string, StockHistoryEntry[]> = {};\r\n    const singles: StockHistoryEntry[] = [];\r\n\r\n    // 1. Organize entries\r\n    stockHistory.forEach(entry => {\r\n      if (isSaleRelatedEntry(entry)) {\r\n        const key = entry.receiptNumber || entry.referenceId || entry.id;\r\n        if (!saleGroups[key]) saleGroups[key] = [];\r\n        saleGroups[key].push(entry);\r\n      } else {\r\n        singles.push(entry);\r\n      }\r\n    });\r\n\r\n    // 2. Create standardized items\r\n    const items = [\r\n      // Add sale groups\r\n      ...Object.values(saleGroups).map(group => {\r\n        // Sort inside group by date (Oldest -> Newest for correct timeline in details)\r\n        // If you want details to be Newest on top, swap a and b.\r\n        // User asked for \"Progressive order\", so let's stick to Oldest -> Newest for details too to be consistent.\r\n        // BUT current UI logic for \"main\" uses sorted[0] as display. Let's see.\r\n        // If I strictly follow chronological, details should be Oldest -> Newest.\r\n        // The previous code had `new Date(b.createdAt) - new Date(a.createdAt)` (Newest first).\r\n\r\n        // Let's sort Newest First for the \"main\" display (so we show the latest state),\r\n        // but for the sorting of the *Card* itself, we use the LATEST date (what is displayed) to avoid visual confusion.\r\n        const sortedForMain = [...group].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\r\n        // const sortedForTimeline = [...group].sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\r\n\r\n        return {\r\n          type: 'sale' as const,\r\n          main: sortedForMain[0], // Display the latest state\r\n          all: sortedForMain, // Details table (Newest first is clearer for \"Recent actions\")\r\n          // Sort Key: Use the *displayed* date (Latest) to place it chronologically in the timeline relative to other events\r\n          sortDate: sortedForMain[0].createdAt\r\n        };\r\n      }),\r\n      // Add single entries\r\n      ...singles.map(entry => ({\r\n        type: 'single' as const,\r\n        entry,\r\n        sortDate: entry.createdAt\r\n      }))\r\n    ];\r\n\r\n    // 3. Sort main list Descending (Newest at Top, Oldest at Bottom)\r\n    // Ensure progressive order from bottom to top\r\n    return items.sort((a, b) => {\r\n      const dateA = new Date(a.sortDate).getTime();\r\n      const dateB = new Date(b.sortDate).getTime();\r\n      // console.log('Sort comparison:', { dateA, dateB, diff: dateB - dateA });\r\n      return dateB - dateA;\r\n    });\r\n  }, [stockHistory]);\r\n\r\n  const stockHistoryList = isLoadingHistory ? (\r\n    <div className=\"animate-pulse text-center py-8\">\r\n      <div className=\"w-16 h-16 bg-gray-200 rounded-full mx-auto mb-4\"></div>\r\n      <p className=\"text-gray-500\">Loading stock history...</p>\r\n    </div>\r\n  ) : stockHistory.length === 0 ? (\r\n    <div className=\"text-center py-8 text-gray-500\">\r\n      <History size={48} className=\"mx-auto mb-4 opacity-50\" />\r\n      <p>No stock history available for this product</p>\r\n      <p className=\"text-sm mt-2\">Stock changes will appear here once you make adjustments</p>\r\n    </div>\r\n  ) : (\r\n    <div className=\"space-y-3\">\r\n      {displayItems.map((item) => {\r\n        // SALE ITEM RENDER\r\n        if (item.type === 'sale') {\r\n          const { main, all } = item;\r\n          const saleKey = main.receiptNumber || main.referenceId || main.id;\r\n          const isExpanded = expandedSale === saleKey;\r\n\r\n          // Per-sale summary data (all is sorted Newest -> Oldest)\r\n          const currentRef = all[0];\r\n          const originalRef = all[all.length - 1];\r\n          const hasHistory = all.length > 1;\r\n\r\n          return (\r\n            <div key={main.id} className={`border rounded-lg p-4 transition-colors ${main.newQuantity > main.oldQuantity\r\n              ? 'bg-green-50 border-green-200 hover:bg-green-100'\r\n              : main.newQuantity < main.oldQuantity\r\n                ? 'bg-red-50 border-red-200 hover:bg-red-100'\r\n                : 'border-gray-200 hover:bg-gray-50'\r\n              }`}>\r\n              <div className=\"flex justify-between items-start\">\r\n                <div className=\"flex-1\">\r\n                  <div className=\"flex items-center gap-2 mb-2\">\r\n                    <Badge variant=\"outline\" className=\"text-xs\">\r\n                      Sale - {main.receiptNumber || main.referenceId || main.id}\r\n                    </Badge>\r\n                    {hasHistory && (\r\n                      <Badge variant=\"secondary\" className=\"text-[10px] h-5\">\r\n                        Edited\r\n                      </Badge>\r\n                    )}\r\n                  </div>\r\n\r\n                  <div className=\"flex items-center gap-2 mt-1\">\r\n                    {hasHistory ? (\r\n                      <>\r\n                        <Badge variant=\"outline\" className=\"text-xs bg-muted/50 font-normal\">\r\n                          Original: {originalRef.oldQuantity}  {originalRef.newQuantity} ({originalRef.newQuantity - originalRef.oldQuantity > 0 ? '+' : ''}{originalRef.newQuantity - originalRef.oldQuantity})\r\n                        </Badge>\r\n                        <span className=\"text-muted-foreground\"></span>\r\n                        <Badge variant=\"secondary\" className=\"text-xs font-normal\">\r\n                          Current: {currentRef.oldQuantity}  {currentRef.newQuantity} ({currentRef.newQuantity - currentRef.oldQuantity > 0 ? '+' : ''}{currentRef.newQuantity - currentRef.oldQuantity})\r\n                        </Badge>\r\n                      </>\r\n                    ) : (\r\n                      <Badge variant=\"outline\" className=\"text-xs bg-muted/50 font-normal\">\r\n                        Qty: {main.oldQuantity}  {main.newQuantity} ({main.newQuantity - main.oldQuantity > 0 ? '+' : ''}{main.newQuantity - main.oldQuantity})\r\n                      </Badge>\r\n                    )}\r\n                    {!hasHistory && (\r\n                      <div className=\"text-sm text-gray-500 flex items-center gap-1 ml-2\">\r\n                        <Clock className=\"inline-block w-3 h-3\" />\r\n                        {format(main.createdAt, 'MMM d, yyyy h:mm a')}\r\n                      </div>\r\n                    )}\r\n                    {hasHistory && (\r\n                      <div className=\"text-sm text-gray-500 flex items-center gap-1 ml-2\">\r\n                        <Clock className=\"inline-block w-3 h-3\" />\r\n                        {/* Show Last Edit Time */}\r\n                        {format(currentRef.createdAt, 'MMM d, yyyy h:mm a')}\r\n                      </div>\r\n                    )}\r\n                  </div>\r\n                </div>\r\n                <div className=\"flex items-center gap-3\">\r\n                  <Button\r\n                    variant=\"ghost\"\r\n                    size=\"sm\"\r\n                    className=\"h-8 px-2 text-xs\"\r\n                    onClick={() => setExpandedSale(isExpanded ? null : saleKey)}\r\n                  >\r\n                    {isExpanded ? 'Hide Details' : 'View Details'}\r\n                  </Button>\r\n                </div>\r\n              </div>\r\n              {isExpanded && (\r\n                <div className=\"mt-4 border-t pt-3\">\r\n                  <div className=\"font-semibold mb-2 text-sm text-muted-foreground\">Sale Actions</div>\r\n                  <div className=\"overflow-x-auto\">\r\n                    <table className=\"min-w-full text-xs border\">\r\n                      <thead>\r\n                        <tr className=\"bg-muted/50\">\r\n                          <th className=\"px-2 py-1 text-left\">Action</th>\r\n                          <th className=\"px-2 py-1 text-left\">Date</th>\r\n                          <th className=\"px-2 py-1 text-left\">Qty Change</th>\r\n                        </tr>\r\n                      </thead>\r\n                      <tbody>\r\n                        {all.map((entry) => (\r\n                          <tr key={entry.id} className=\"border-b last:border-b-0\">\r\n                            <td className=\"px-2 py-1 font-medium\">{formatChangeReason(entry.changeReason)}</td>\r\n                            <td className=\"px-2 py-1 text-muted-foreground\">{format(entry.createdAt, 'MMM d, yyyy h:mm a')}</td>\r\n                            <td className=\"px-2 py-1\">{entry.oldQuantity}  {entry.newQuantity} ({entry.newQuantity - entry.oldQuantity > 0 ? '+' : ''}{entry.newQuantity - entry.oldQuantity})</td>\r\n                          </tr>\r\n                        ))}\r\n                      </tbody>\r\n                    </table>\r\n                  </div>\r\n                </div>\r\n              )}\r\n            </div>\r\n          );\r\n        } else {\r\n          // SINGLE ENTRY RENDER\r\n          const { entry } = item;\r\n          const isExpanded = expandedManual === entry.id;\r\n          return (\r\n            <div key={entry.id} className={`border rounded-lg p-4 transition-colors ${entry.newQuantity > entry.oldQuantity\r\n              ? 'bg-green-50 border-green-200 hover:bg-green-100'\r\n              : entry.newQuantity < entry.oldQuantity\r\n                ? 'bg-red-50 border-red-200 hover:bg-red-100'\r\n                : 'border-gray-200 hover:bg-gray-50'\r\n              }`}>\r\n              <div className=\"flex justify-between items-start\">\r\n                <div className=\"flex-1\">\r\n                  <div className=\"flex items-center gap-2 mb-2\">\r\n                    <Badge variant=\"outline\" className=\"text-xs\">\r\n                      {formatChangeReason(entry.changeReason)}\r\n                      {entry.receiptNumber && ` - #${entry.receiptNumber}`}\r\n                    </Badge>\r\n                  </div>\r\n                  <div className=\"flex items-center gap-2 mt-1\">\r\n                    <Badge variant=\"outline\" className=\"text-xs bg-muted/50 font-normal\">\r\n                      Qty: {entry.oldQuantity}  {entry.newQuantity} ({entry.newQuantity - entry.oldQuantity > 0 ? '+' : ''}{entry.newQuantity - entry.oldQuantity})\r\n                    </Badge>\r\n                    <div className=\"text-sm text-gray-500 flex items-center gap-1 ml-2\">\r\n                      <Clock className=\"inline-block w-3 h-3\" />\r\n                      {format(entry.createdAt, 'MMM d, yyyy h:mm a')}\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n                <div className=\"flex items-center gap-3\">\r\n                  <Button\r\n                    variant=\"ghost\"\r\n                    size=\"sm\"\r\n                    className=\"h-8 px-2 text-xs\"\r\n                    onClick={() => setExpandedManual(isExpanded ? null : entry.id)}\r\n                  >\r\n                    {isExpanded ? 'Hide Details' : 'View Details'}\r\n                  </Button>\r\n                  {isInitialStockEntry(entry) ? (\r\n                    <>\r\n                      {hasPermission('inventory', 'edit') && (\r\n                        <Button\r\n                          variant=\"outline\"\r\n                          size=\"sm\"\r\n                          onClick={() => setEditHistoryDialog({ open: true, entry })}\r\n                          className=\"h-8 px-2\"\r\n                        >\r\n                          <Edit className=\"h-3 w-3\" />\r\n                        </Button>\r\n                      )}\r\n                      <div className=\"text-xs text-muted-foreground px-2 py-1 bg-blue-100 text-blue-800 rounded\">\r\n                        Initial Stock\r\n                      </div>\r\n                    </>\r\n                  ) : (\r\n                    <>\r\n                      {hasPermission('inventory', 'edit') && (\r\n                        <Button\r\n                          variant=\"outline\"\r\n                          size=\"sm\"\r\n                          onClick={() => setEditHistoryDialog({ open: true, entry })}\r\n                          className=\"h-8 px-2\"\r\n                        >\r\n                          <Edit className=\"h-3 w-3\" />\r\n                        </Button>\r\n                      )}\r\n                      {hasPermission('inventory', 'delete') && (\r\n                        <Button\r\n                          variant=\"outline\"\r\n                          size=\"sm\"\r\n                          onClick={() => setDeleteHistoryDialog({ open: true, entry })}\r\n                          className=\"h-8 px-2 text-destructive hover:text-destructive\"\r\n                        >\r\n                          <Trash2 className=\"h-3 w-3\" />\r\n                        </Button>\r\n                      )}\r\n                    </>\r\n                  )}\r\n                </div>\r\n              </div>\r\n              {isExpanded && (\r\n                <div className=\"mt-4 border-t pt-3\">\r\n                  <div className=\"font-semibold mb-2 text-sm text-muted-foreground\">Details</div>\r\n                  <div className=\"overflow-x-auto\">\r\n                    <table className=\"min-w-full text-xs border\">\r\n                      <thead>\r\n                        <tr className=\"bg-muted/50\">\r\n                          <th className=\"px-2 py-1 text-left\">Reason</th>\r\n                          <th className=\"px-2 py-1 text-left\">Date</th>\r\n                          <th className=\"px-2 py-1 text-left\">Qty Change</th>\r\n                        </tr>\r\n                      </thead>\r\n                      <tbody>\r\n                        <tr className=\"border-b last:border-b-0\">\r\n                          <td className=\"px-2 py-1 font-medium\">{formatChangeReason(entry.changeReason)}</td>\r\n                          <td className=\"px-2 py-1 text-muted-foreground\">{format(entry.createdAt, 'MMM d, yyyy h:mm a')}</td>\r\n                          <td className=\"px-2 py-1\">{entry.oldQuantity}  {entry.newQuantity} ({entry.newQuantity - entry.oldQuantity > 0 ? '+' : ''}{entry.newQuantity - entry.oldQuantity})</td>\r\n                        </tr>\r\n                      </tbody>\r\n                    </table>\r\n                  </div>\r\n                </div>\r\n              )}\r\n            </div>\r\n          );\r\n        }\r\n      })}\r\n    </div>\r\n  );\r\n\r\n  return (\r\n    <>\r\n      <Card>\r\n        <CardHeader>\r\n          <div className=\"flex items-center justify-between\">\r\n            <CardTitle className=\"flex items-center gap-2\">\r\n              <History className=\"h-5 w-5\" />\r\n              Stock History\r\n              {stockHistory.length > 0 && (\r\n                <Badge variant=\"secondary\" className=\"ml-2\">\r\n                  {stockHistory.length} entries\r\n                </Badge>\r\n              )}\r\n            </CardTitle>\r\n          </div>\r\n        </CardHeader>\r\n        <CardContent>\r\n          {stockHistoryList}\r\n        </CardContent>\r\n      </Card>\r\n\r\n      <EditStockHistoryDialog\r\n        open={editHistoryDialog.open}\r\n        onOpenChange={(open) => setEditHistoryDialog({ open, entry: null })}\r\n        entry={editHistoryDialog.entry}\r\n        onConfirm={onEditStockHistory}\r\n        isInitialStock={editHistoryDialog.entry ? isInitialStockEntry(editHistoryDialog.entry) : false}\r\n        stockHistory={stockHistory}\r\n        productCreatedAt={editHistoryDialog.entry ? (() => {\r\n          const product = products.find(p => p.id === editHistoryDialog.entry?.productId);\r\n          return product ? new Date(product.createdAt) : undefined;\r\n        })() : undefined}\r\n      />\r\n\r\n      <DeleteStockHistoryDialog\r\n        open={deleteHistoryDialog.open}\r\n        onOpenChange={(open) => setDeleteHistoryDialog({ open, entry: null })}\r\n        entry={deleteHistoryDialog.entry}\r\n        onConfirm={onDeleteStockHistory}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\nexport default ProductStockHistory;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5346, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/pages/ProductDetail.tsx"],"sourcesContent":["\r\nimport React, { useEffect, useState } from 'react';\r\nimport { useParams, useNavigate } from 'react-router-dom';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useProducts } from '@/hooks/useProducts';\r\nimport { useStockHistory } from '@/hooks/useStockHistory';\r\nimport { useStockSummaryData } from '@/hooks/useStockSummaryData';\r\nimport { Product } from '@/types';\r\nimport { toast } from 'sonner';\r\nimport ProductDetails from '@/components/inventory/ProductDetails';\r\nimport ProductStockHistory from '@/components/inventory/ProductStockHistory';\r\n\r\nconst ProductDetail = () => {\r\n  const { id } = useParams<{ id: string }>();\r\n  const navigate = useNavigate();\r\n  const { user } = useAuth();\r\n  const { products, isLoading, loadProducts, refetch } = useProducts(user?.id, 10000); // Load all products\r\n  const [product, setProduct] = useState<Product | null>(null);\r\n  const { stockHistory, isLoading: isLoadingHistory, loadStockHistory, updateStockHistoryEntry, deleteStockHistoryEntry, recalculateProductStock } = useStockHistory(user?.id, id);\r\n  const { clearAllLocationCaches } = useStockSummaryData({ from: undefined, to: undefined });\r\n  const [isRefreshing, setIsRefreshing] = useState(false);\r\n  const [refreshKey, setRefreshKey] = useState(0);\r\n\r\n  const loadProductData = async () => {\r\n    if (id) {\r\n      setIsRefreshing(true);\r\n      const { data: refetchedData } = await refetch();\r\n      const fetchedProducts = refetchedData?.products || [];\r\n\r\n      const foundProduct = fetchedProducts.find(p => p.id === id);\r\n      if (foundProduct) {\r\n        setProduct(foundProduct);\r\n      } else {\r\n        toast.error('Product not found');\r\n        navigate('/inventory');\r\n      }\r\n\r\n      setIsRefreshing(false);\r\n    }\r\n  };\r\n\r\n  // Handle stock update callback - refresh both product and stock history\r\n  const handleStockUpdate = async () => {\r\n    await loadProductData();\r\n    if (id && loadStockHistory) {\r\n      await loadStockHistory();\r\n    }\r\n    setRefreshKey(prev => prev + 1);\r\n  };\r\n\r\n  // Stock history handlers\r\n  const handleEditStockHistory = async (entryId: string, newQuantity: number, newReason: string, newDate?: Date) => {\r\n    const success = await updateStockHistoryEntry(entryId, newQuantity, newReason, newDate);\r\n    if (success) {\r\n      // Clear stock summary cache to ensure data consistency\r\n      clearAllLocationCaches();\r\n      // updateStockHistoryEntry already recalculates the entire stock chain\r\n      // Just refresh the UI data\r\n      await Promise.all([\r\n        loadStockHistory(),\r\n        loadProductData()\r\n      ]);\r\n    }\r\n    return success;\r\n  };\r\n\r\n  const handleDeleteStockHistory = async (entryId: string) => {\r\n    const success = await deleteStockHistoryEntry(entryId);\r\n    if (success) {\r\n      // Clear stock summary cache to ensure data consistency\r\n      clearAllLocationCaches();\r\n      await Promise.all([\r\n        recalculateProductStock(product!.id),\r\n        loadStockHistory(),\r\n        loadProductData()\r\n      ]);\r\n    }\r\n    return success;\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (!isLoading && products.length > 0 && id) {\r\n      const foundProduct = products.find(p => p.id === id);\r\n\r\n      if (foundProduct) {\r\n        setProduct(foundProduct);\r\n      } else {\r\n        toast.error('Product not found');\r\n        navigate('/inventory');\r\n      }\r\n    }\r\n  }, [id, products, isLoading, navigate]);\r\n\r\n  // Listen for stock updates from other components\r\n  useEffect(() => {\r\n    const handleStockUpdateEvent = () => {\r\n      console.log('Stock updated, refreshing product data');\r\n      handleStockUpdate();\r\n    };\r\n\r\n    window.addEventListener('stock-updated', handleStockUpdateEvent);\r\n\r\n    return () => {\r\n      window.removeEventListener('stock-updated', handleStockUpdateEvent);\r\n    };\r\n  }, [handleStockUpdate]);\r\n\r\n  if (isLoading || isRefreshing || !product) {\r\n    return (\r\n      <div className=\"flex flex-col items-center justify-center min-h-[60vh] space-y-4\">\r\n        <img\r\n          src=\"/lovable-uploads/7f7549a3-e9df-4762-b8b9-8e041e34f55d.png\"\r\n          alt=\"Loading\"\r\n          className=\"w-16 h-16 animate-spin\"\r\n        />\r\n        <p className=\"text-muted-foreground\">Loading product data...</p>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      {/* Product Details Section */}\r\n      <ProductDetails\r\n        key={`details-${refreshKey}`}\r\n        product={product}\r\n        stockHistory={stockHistory}\r\n        isLoadingHistory={isLoadingHistory}\r\n        onStockUpdate={handleStockUpdate}\r\n      />\r\n\r\n      {/* Stock History Section */}\r\n      <ProductStockHistory\r\n        key={`history-${refreshKey}`}\r\n        stockHistory={stockHistory}\r\n        isLoadingHistory={isLoadingHistory}\r\n        onEditStockHistory={handleEditStockHistory}\r\n        onDeleteStockHistory={handleDeleteStockHistory}\r\n        products={products}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ProductDetail;\r\n"],"names":[],"mappings":"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"}}]
}