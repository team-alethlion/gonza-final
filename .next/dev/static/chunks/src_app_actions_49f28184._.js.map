{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgCsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            locationId: updates.businessId,\r\n            productId: updated.id,\r\n            previousQuantity: current.stock,\r\n            newQuantity: updates.quantity,\r\n            changeReason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qDAAA"}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            locationId: updates.businessId,\r\n            productId: updated.id,\r\n            previousQuantity: current.stock,\r\n            newQuantity: updates.quantity,\r\n            changeReason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgJsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            locationId: updates.businessId,\r\n            productId: updated.id,\r\n            previousQuantity: current.stock,\r\n            newQuantity: updates.quantity,\r\n            changeReason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA+NsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            locationId: updates.businessId,\r\n            productId: updated.id,\r\n            previousQuantity: current.stock,\r\n            newQuantity: updates.quantity,\r\n            changeReason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA8RsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            locationId: updates.businessId,\r\n            productId: updated.id,\r\n            previousQuantity: current.stock,\r\n            newQuantity: updates.quantity,\r\n            changeReason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA2SsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 123, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            locationId: data.businessId,\r\n            productId: product.id,\r\n            previousQuantity: 0,\r\n            newQuantity: data.quantity,\r\n            changeReason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            locationId: updates.businessId,\r\n            productId: updated.id,\r\n            previousQuantity: current.stock,\r\n            newQuantity: updates.quantity,\r\n            changeReason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0GsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,0DAAA"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/sales.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getSalesAction(businessId: string, sortOrder: 'asc' | 'desc' = 'desc', pageSize?: number) {\r\n    try {\r\n        const queryOptions: any = {\r\n            where: {\r\n                branchId: businessId,\r\n            },\r\n            orderBy: {\r\n                createdAt: sortOrder,\r\n            },\r\n            include: {\r\n                cashTransaction: true,\r\n            }\r\n        };\r\n\r\n        if (pageSize && pageSize > 0) {\r\n            queryOptions.take = pageSize;\r\n        }\r\n\r\n        const sales = await db.sale.findMany(queryOptions);\r\n\r\n        // Provide default mappings to existing React components\r\n        return sales.map((item: any) => ({\r\n            id: item.id,\r\n            user_id: item.userId,\r\n            location_id: item.branchId,\r\n            receipt_number: item.receiptNumber,\r\n            customer_name: item.customerName,\r\n            customer_address: item.customerAddress,\r\n            customer_contact: item.customerContact,\r\n            customer_id: item.customerId,\r\n            items: item.items as any, // jsonb type\r\n            payment_status: item.paymentStatus,\r\n            profit: item.profit,\r\n            date: item.date.toISOString(),\r\n            tax_rate: item.taxRate ? Number(item.taxRate) : 0,\r\n            created_at: item.createdAt.toISOString(),\r\n            updated_at: item.updatedAt.toISOString(),\r\n            cash_transaction_id: item.cashTransactionId,\r\n            amount_paid: item.amountPaid,\r\n            amount_due: item.amountDue,\r\n            category_id: item.categoryId,\r\n            notes: item.notes\r\n        }));\r\n    } catch (error) {\r\n        console.error('Error fetching sales:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function deleteSaleAction(id: string, businessId: string) {\r\n    try {\r\n        const sale = await db.sale.findUnique({\r\n            where: { id },\r\n            include: { cashTransaction: true, installments: true }\r\n        });\r\n\r\n        if (!sale || sale.branchId !== businessId) {\r\n            return { success: false, error: 'Sale not found or unauthorized' };\r\n        }\r\n\r\n        // Delete installments\r\n        if (sale.installments && sale.installments.length > 0) {\r\n            await db.installmentPayment.deleteMany({\r\n                where: { saleId: id }\r\n            });\r\n        }\r\n\r\n        // Delete associated cash transaction\r\n        if (sale.cashTransactionId) {\r\n            await db.cashTransaction.delete({\r\n                where: { id: sale.cashTransactionId }\r\n            });\r\n        }\r\n\r\n        // Delete the sale itself\r\n        await db.sale.delete({\r\n            where: { id }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            sale: {\r\n                receiptNumber: sale.receiptNumber,\r\n                customerName: sale.customerName,\r\n                customerAddress: sale.customerAddress,\r\n                customerContact: sale.customerContact,\r\n                paymentStatus: sale.paymentStatus,\r\n                cashTransactionId: sale.cashTransactionId,\r\n                items: sale.items as any,\r\n                amountPaid: sale.amountPaid,\r\n                amountDue: sale.amountDue,\r\n                profit: sale.profit,\r\n                taxRate: sale.taxRate,\r\n                notes: sale.notes\r\n            }\r\n        };\r\n    } catch (error) {\r\n        console.error('Error deleting sale:', error);\r\n        return { success: false, error: 'Failed to delete sale' };\r\n    }\r\n}\r\n\r\nexport async function upsertSaleAction(saleDbData: any, isUpdate: boolean, updateId?: string) {\r\n    try {\r\n        const prismaData = {\r\n            userId: saleDbData.user_id,\r\n            branchId: saleDbData.location_id,\r\n            receiptNumber: saleDbData.receipt_number,\r\n            customerName: saleDbData.customer_name,\r\n            customerAddress: saleDbData.customer_address,\r\n            customerContact: saleDbData.customer_contact,\r\n            customerId: saleDbData.customer_id,\r\n            items: saleDbData.items,\r\n            paymentStatus: saleDbData.payment_status,\r\n            profit: saleDbData.profit,\r\n            date: new Date(saleDbData.date),\r\n            taxRate: saleDbData.tax_rate,\r\n            cashTransactionId: saleDbData.cash_transaction_id,\r\n            amountPaid: saleDbData.amount_paid,\r\n            amountDue: saleDbData.amount_due,\r\n            categoryId: saleDbData.category_id,\r\n            notes: saleDbData.notes\r\n        };\r\n\r\n        if (isUpdate && updateId) {\r\n            const updated = await db.sale.update({\r\n                where: { id: updateId },\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: updated };\r\n        } else {\r\n            const created = await db.sale.create({\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: created };\r\n        }\r\n    } catch (error: any) {\r\n        console.error('Error upserting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to preserve sale' };\r\n    }\r\n}\r\n\r\nexport async function createReceiptAction(saleData: any, businessId: string, userId: string) {\r\n    try {\r\n        const created = await db.sale.create({\r\n            data: {\r\n                userId: userId,\r\n                branchId: businessId,\r\n                receiptNumber: saleData.receiptNumber,\r\n                customerName: saleData.customerName,\r\n                customerId: saleData.customerId,\r\n                date: new Date(saleData.date),\r\n                items: saleData.items,\r\n                paymentStatus: saleData.paymentStatus,\r\n                profit: saleData.profit,\r\n                amountPaid: saleData.amountPaid,\r\n                amountDue: saleData.amountDue,\r\n                cashAccountId: saleData.cashAccountId,\r\n                notes: saleData.notes\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        revalidatePath('/customers');\r\n\r\n        return { success: true, data: created };\r\n    } catch (error: any) {\r\n        console.error('Error creating receipt:', error);\r\n        return { success: false, error: error.message || 'Failed to create receipt' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,kDAAA"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/sales.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getSalesAction(businessId: string, sortOrder: 'asc' | 'desc' = 'desc', pageSize?: number) {\r\n    try {\r\n        const queryOptions: any = {\r\n            where: {\r\n                branchId: businessId,\r\n            },\r\n            orderBy: {\r\n                createdAt: sortOrder,\r\n            },\r\n            include: {\r\n                cashTransaction: true,\r\n            }\r\n        };\r\n\r\n        if (pageSize && pageSize > 0) {\r\n            queryOptions.take = pageSize;\r\n        }\r\n\r\n        const sales = await db.sale.findMany(queryOptions);\r\n\r\n        // Provide default mappings to existing React components\r\n        return sales.map((item: any) => ({\r\n            id: item.id,\r\n            user_id: item.userId,\r\n            location_id: item.branchId,\r\n            receipt_number: item.receiptNumber,\r\n            customer_name: item.customerName,\r\n            customer_address: item.customerAddress,\r\n            customer_contact: item.customerContact,\r\n            customer_id: item.customerId,\r\n            items: item.items as any, // jsonb type\r\n            payment_status: item.paymentStatus,\r\n            profit: item.profit,\r\n            date: item.date.toISOString(),\r\n            tax_rate: item.taxRate ? Number(item.taxRate) : 0,\r\n            created_at: item.createdAt.toISOString(),\r\n            updated_at: item.updatedAt.toISOString(),\r\n            cash_transaction_id: item.cashTransactionId,\r\n            amount_paid: item.amountPaid,\r\n            amount_due: item.amountDue,\r\n            category_id: item.categoryId,\r\n            notes: item.notes\r\n        }));\r\n    } catch (error) {\r\n        console.error('Error fetching sales:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function deleteSaleAction(id: string, businessId: string) {\r\n    try {\r\n        const sale = await db.sale.findUnique({\r\n            where: { id },\r\n            include: { cashTransaction: true, installments: true }\r\n        });\r\n\r\n        if (!sale || sale.branchId !== businessId) {\r\n            return { success: false, error: 'Sale not found or unauthorized' };\r\n        }\r\n\r\n        // Delete installments\r\n        if (sale.installments && sale.installments.length > 0) {\r\n            await db.installmentPayment.deleteMany({\r\n                where: { saleId: id }\r\n            });\r\n        }\r\n\r\n        // Delete associated cash transaction\r\n        if (sale.cashTransactionId) {\r\n            await db.cashTransaction.delete({\r\n                where: { id: sale.cashTransactionId }\r\n            });\r\n        }\r\n\r\n        // Delete the sale itself\r\n        await db.sale.delete({\r\n            where: { id }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            sale: {\r\n                receiptNumber: sale.receiptNumber,\r\n                customerName: sale.customerName,\r\n                customerAddress: sale.customerAddress,\r\n                customerContact: sale.customerContact,\r\n                paymentStatus: sale.paymentStatus,\r\n                cashTransactionId: sale.cashTransactionId,\r\n                items: sale.items as any,\r\n                amountPaid: sale.amountPaid,\r\n                amountDue: sale.amountDue,\r\n                profit: sale.profit,\r\n                taxRate: sale.taxRate,\r\n                notes: sale.notes\r\n            }\r\n        };\r\n    } catch (error) {\r\n        console.error('Error deleting sale:', error);\r\n        return { success: false, error: 'Failed to delete sale' };\r\n    }\r\n}\r\n\r\nexport async function upsertSaleAction(saleDbData: any, isUpdate: boolean, updateId?: string) {\r\n    try {\r\n        const prismaData = {\r\n            userId: saleDbData.user_id,\r\n            branchId: saleDbData.location_id,\r\n            receiptNumber: saleDbData.receipt_number,\r\n            customerName: saleDbData.customer_name,\r\n            customerAddress: saleDbData.customer_address,\r\n            customerContact: saleDbData.customer_contact,\r\n            customerId: saleDbData.customer_id,\r\n            items: saleDbData.items,\r\n            paymentStatus: saleDbData.payment_status,\r\n            profit: saleDbData.profit,\r\n            date: new Date(saleDbData.date),\r\n            taxRate: saleDbData.tax_rate,\r\n            cashTransactionId: saleDbData.cash_transaction_id,\r\n            amountPaid: saleDbData.amount_paid,\r\n            amountDue: saleDbData.amount_due,\r\n            categoryId: saleDbData.category_id,\r\n            notes: saleDbData.notes\r\n        };\r\n\r\n        if (isUpdate && updateId) {\r\n            const updated = await db.sale.update({\r\n                where: { id: updateId },\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: updated };\r\n        } else {\r\n            const created = await db.sale.create({\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: created };\r\n        }\r\n    } catch (error: any) {\r\n        console.error('Error upserting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to preserve sale' };\r\n    }\r\n}\r\n\r\nexport async function createReceiptAction(saleData: any, businessId: string, userId: string) {\r\n    try {\r\n        const created = await db.sale.create({\r\n            data: {\r\n                userId: userId,\r\n                branchId: businessId,\r\n                receiptNumber: saleData.receiptNumber,\r\n                customerName: saleData.customerName,\r\n                customerId: saleData.customerId,\r\n                date: new Date(saleData.date),\r\n                items: saleData.items,\r\n                paymentStatus: saleData.paymentStatus,\r\n                profit: saleData.profit,\r\n                amountPaid: saleData.amountPaid,\r\n                amountDue: saleData.amountDue,\r\n                cashAccountId: saleData.cashAccountId,\r\n                notes: saleData.notes\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        revalidatePath('/customers');\r\n\r\n        return { success: true, data: created };\r\n    } catch (error: any) {\r\n        console.error('Error creating receipt:', error);\r\n        return { success: false, error: error.message || 'Failed to create receipt' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsDsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,oDAAA"}},
    {"offset": {"line": 174, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAOsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,yDAAA"}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoDsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 208, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsFsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}},
    {"offset": {"line": 225, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsIsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,8EAAA"}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/analytics.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\n\r\nexport interface InventoryStats {\r\n    totalCostValue: number;\r\n    totalStockValue: number;\r\n    lowStockCount: number;\r\n    outOfStockCount: number;\r\n}\r\n\r\nexport async function getGlobalInventoryStatsAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: {\r\n                branchId: businessId,\r\n                deletedAt: null\r\n            },\r\n            select: {\r\n                stockLevel: true,\r\n                minStockLevel: true,\r\n                costPrice: true,\r\n                sellingPrice: true\r\n            }\r\n        });\r\n\r\n        const stats: InventoryStats = products.reduce((acc: InventoryStats, p: any) => {\r\n            const stock = p.stockLevel || 0;\r\n            const cost = p.costPrice || 0;\r\n            const price = p.sellingPrice || 0;\r\n            const minStock = p.minStockLevel || 0;\r\n\r\n            acc.totalCostValue += stock * cost;\r\n            acc.totalStockValue += stock * price;\r\n\r\n            if (stock <= 0) {\r\n                acc.outOfStockCount += 1;\r\n            } else if (stock <= minStock) {\r\n                acc.lowStockCount += 1;\r\n            }\r\n\r\n            return acc;\r\n        }, {\r\n            totalCostValue: 0,\r\n            totalStockValue: 0,\r\n            lowStockCount: 0,\r\n            outOfStockCount: 0\r\n        });\r\n\r\n        return { success: true, data: stats };\r\n    } catch (error: any) {\r\n        console.error('Error fetching global inventory stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getTotalExpensesAction(businessId: string, startDate?: string, endDate?: string) {\r\n    try {\r\n        const where: any = {\r\n            locationId: businessId\r\n        };\r\n\r\n        if (startDate || endDate) {\r\n            where.date = {};\r\n            if (startDate) {\r\n                where.date.gte = new Date(startDate);\r\n            }\r\n            if (endDate) {\r\n                where.date.lte = new Date(endDate);\r\n            }\r\n        }\r\n\r\n        const expenses = await db.expense.findMany({\r\n            where,\r\n            select: {\r\n                amount: true\r\n            }\r\n        });\r\n\r\n        const total = expenses.reduce((sum: number, e: any) => sum + Number(e.amount), 0);\r\n\r\n        return { success: true, data: total };\r\n    } catch (error: any) {\r\n        console.error('Error fetching total expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAWsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,iEAAA"}}]
}