{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/table.tsx"],"sourcesContent":["import * as React from \"react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Table = React.forwardRef<\r\n  HTMLTableElement,\r\n  React.HTMLAttributes<HTMLTableElement>\r\n>(({ className, ...props }, ref) => (\r\n  <div className=\"relative w-full overflow-auto\">\r\n    <table\r\n      ref={ref}\r\n      className={cn(\"w-full caption-bottom text-sm\", className)}\r\n      {...props}\r\n    />\r\n  </div>\r\n))\r\nTable.displayName = \"Table\"\r\n\r\nconst TableHeader = React.forwardRef<\r\n  HTMLTableSectionElement,\r\n  React.HTMLAttributes<HTMLTableSectionElement>\r\n>(({ className, ...props }, ref) => (\r\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\r\n))\r\nTableHeader.displayName = \"TableHeader\"\r\n\r\nconst TableBody = React.forwardRef<\r\n  HTMLTableSectionElement,\r\n  React.HTMLAttributes<HTMLTableSectionElement>\r\n>(({ className, ...props }, ref) => (\r\n  <tbody\r\n    ref={ref}\r\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\r\n    {...props}\r\n  />\r\n))\r\nTableBody.displayName = \"TableBody\"\r\n\r\nconst TableFooter = React.forwardRef<\r\n  HTMLTableSectionElement,\r\n  React.HTMLAttributes<HTMLTableSectionElement>\r\n>(({ className, ...props }, ref) => (\r\n  <tfoot\r\n    ref={ref}\r\n    className={cn(\r\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTableFooter.displayName = \"TableFooter\"\r\n\r\nconst TableRow = React.forwardRef<\r\n  HTMLTableRowElement,\r\n  React.HTMLAttributes<HTMLTableRowElement>\r\n>(({ className, ...props }, ref) => (\r\n  <tr\r\n    ref={ref}\r\n    className={cn(\r\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTableRow.displayName = \"TableRow\"\r\n\r\nconst TableHead = React.forwardRef<\r\n  HTMLTableCellElement,\r\n  React.ThHTMLAttributes<HTMLTableCellElement>\r\n>(({ className, ...props }, ref) => (\r\n  <th\r\n    ref={ref}\r\n    className={cn(\r\n      \"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTableHead.displayName = \"TableHead\"\r\n\r\nconst TableCell = React.forwardRef<\r\n  HTMLTableCellElement,\r\n  React.TdHTMLAttributes<HTMLTableCellElement>\r\n>(({ className, ...props }, ref) => (\r\n  <td\r\n    ref={ref}\r\n    className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", className)}\r\n    {...props}\r\n  />\r\n))\r\nTableCell.displayName = \"TableCell\"\r\n\r\nconst TableCaption = React.forwardRef<\r\n  HTMLTableCaptionElement,\r\n  React.HTMLAttributes<HTMLTableCaptionElement>\r\n>(({ className, ...props }, ref) => (\r\n  <caption\r\n    ref={ref}\r\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\r\n    {...props}\r\n  />\r\n))\r\nTableCaption.displayName = \"TableCaption\"\r\n\r\nexport {\r\n  Table,\r\n  TableHeader,\r\n  TableBody,\r\n  TableFooter,\r\n  TableHead,\r\n  TableRow,\r\n  TableCell,\r\n  TableCaption,\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,sBAAQ,2KAAgB,MAG5B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QAAI,WAAU;kBACb,cAAA,6LAAC;YACC,KAAK;YACL,WAAW,IAAA,4HAAE,EAAC,iCAAiC;YAC9C,GAAG,KAAK;;;;;;;;;;;;AAIf,MAAM,WAAW,GAAG;AAEpB,MAAM,4BAAc,2KAAgB,OAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QAAM,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,mBAAmB;QAAa,GAAG,KAAK;;;;;;;AAEzE,YAAY,WAAW,GAAG;AAE1B,MAAM,0BAAY,2KAAgB,OAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,8BAA8B;QAC3C,GAAG,KAAK;;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,4BAAc,2KAAgB,OAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,2DACA;QAED,GAAG,KAAK;;;;;;;AAGb,YAAY,WAAW,GAAG;AAE1B,MAAM,yBAAW,2KAAgB,OAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,+EACA;QAED,GAAG,KAAK;;;;;;;AAGb,SAAS,WAAW,GAAG;AAEvB,MAAM,0BAAY,2KAAgB,QAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,oGACA;QAED,GAAG,KAAK;;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,0BAAY,2KAAgB,QAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,kDAAkD;QAC/D,GAAG,KAAK;;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,6BAAe,2KAAgB,QAGnC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,sCAAsC;QACnD,GAAG,KAAK;;;;;;;AAGb,aAAa,WAAW,GAAG"}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/badge.tsx"],"sourcesContent":["\r\nimport * as React from \"react\"\r\nimport { cva, type VariantProps } from \"class-variance-authority\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst badgeVariants = cva(\r\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default:\r\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\r\n        secondary:\r\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        destructive:\r\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\r\n        outline: \"text-foreground\",\r\n        warning:\r\n          \"border-transparent bg-amber-500 text-white hover:bg-amber-600\",\r\n        success:\r\n          \"border-transparent bg-green-600 text-white hover:bg-green-700\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n    },\r\n  }\r\n)\r\n\r\nexport interface BadgeProps\r\n  extends React.HTMLAttributes<HTMLDivElement>,\r\n    VariantProps<typeof badgeVariants> {}\r\n\r\nfunction Badge({ className, variant, ...props }: BadgeProps) {\r\n  return (\r\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\r\n  )\r\n}\r\n\r\nexport { Badge, badgeVariants }\r\n"],"names":[],"mappings":";;;;;;;AAEA;AAEA;;;;AAEA,MAAM,gBAAgB,IAAA,0KAAG,EACvB,0KACA;IACE,UAAU;QACR,SAAS;YACP,SACE;YACF,WACE;YACF,aACE;YACF,SAAS;YACT,SACE;YACF,SACE;QACJ;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAOF,SAAS,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAmB;IACzD,qBACE,6LAAC;QAAI,WAAW,IAAA,4HAAE,EAAC,cAAc;YAAE;QAAQ,IAAI;QAAa,GAAG,KAAK;;;;;;AAExE;KAJS"}},
    {"offset": {"line": 198, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n\r\nexport async function getAccountStatusAction(userId: string) {\r\n    try {\r\n        const user = await db.user.findUnique({\r\n            where: { id: userId },\r\n            select: {\r\n                isFrozen: true,\r\n                createdAt: true,\r\n                subscriptions: {\r\n                    where: { status: 'active' },\r\n                    orderBy: { endDate: 'desc' },\r\n                    take: 1\r\n                },\r\n                branches: {\r\n                    select: { id: true }\r\n                }\r\n            }\r\n        });\r\n\r\n        if (!user) return null;\r\n\r\n        const activeSub = user.subscriptions[0];\r\n        const now = new Date();\r\n        const daysRemaining = activeSub ? Math.ceil((activeSub.endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)) : 0;\r\n\r\n        return {\r\n            is_frozen: user.isFrozen,\r\n            location_limit: 1, // Traditional limit or from subscription\r\n            billing_amount: activeSub ? Number(activeSub.amount) : 50000,\r\n            billing_duration: 'Monthly',\r\n            days_remaining: Math.max(0, daysRemaining),\r\n            next_billing_date: activeSub?.endDate.toISOString() || ''\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching account status:', error);\r\n        return { is_frozen: false, location_limit: 1, billing_amount: 50000, billing_duration: 'Monthly', days_remaining: 30, next_billing_date: '' };\r\n    }\r\n}\r\n\r\nexport async function getOnboardingStatusAction(locationId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId: locationId }\r\n        });\r\n\r\n        if (!settings) return null;\r\n\r\n        return {\r\n            id: settings.id,\r\n            location_id: settings.branchId,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            completed: !!settings.businessName && !!settings.phone, // Simplified completion check\r\n            is_frozen: false // Should come from branch or user status\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching onboarding status:', error);\r\n        return null;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useBusinessSettings.ts"],"sourcesContent":["\r\nimport { useState, useEffect } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { getBusinessSettingsAction, upsertBusinessSettingsAction } from '@/app/actions/business-settings';\r\n\r\nexport interface BusinessSettings {\r\n  id?: string;\r\n  businessName: string;\r\n  businessAddress: string;\r\n  businessPhone: string;\r\n  businessEmail: string;\r\n  businessLogo?: string;\r\n  currency: string;\r\n  signature?: string;\r\n  paymentInfo?: string;\r\n  defaultPrintFormat?: 'standard' | 'thermal';\r\n  defaultPrinterName?: string;\r\n  defaultPrinterType?: 'USB' | 'Bluetooth';\r\n  printerPaperSize?: '58mm' | '80mm';\r\n}\r\n\r\n// Utility function to parse payment info text into structured format\r\nexport const parsePaymentInfo = (paymentInfo: string): { method: string, accountNumber: string, accountName: string }[] => {\r\n  if (!paymentInfo || paymentInfo.trim() === '') {\r\n    return [];\r\n  }\r\n\r\n  const lines = paymentInfo.split('\\n').filter(line => line.trim() !== '');\r\n  const methods: { method: string, accountNumber: string, accountName: string }[] = [];\r\n\r\n  for (let i = 0; i < lines.length; i += 3) {\r\n    if (i + 2 < lines.length) {\r\n      methods.push({\r\n        method: lines[i].trim(),\r\n        accountNumber: lines[i + 1].trim(),\r\n        accountName: lines[i + 2].trim()\r\n      });\r\n    }\r\n  }\r\n\r\n  return methods;\r\n};\r\n\r\n// Utility function to convert payment methods array back to string format\r\nexport const convertPaymentMethodsToString = (paymentMethods: { method: string, accountNumber: string, accountName: string }[]): string => {\r\n  return paymentMethods\r\n    .filter(pm => pm.method.trim() !== '' || pm.accountNumber.trim() !== '' || pm.accountName.trim() !== '')\r\n    .map(pm => `${pm.method}\\n${pm.accountNumber}\\n${pm.accountName}`)\r\n    .join('\\n');\r\n};\r\n\r\n// Default settings for new businesses\r\nconst getDefaultSettings = (): BusinessSettings => ({\r\n  businessName: '',\r\n  businessAddress: '',\r\n  businessPhone: '',\r\n  businessEmail: '',\r\n  currency: 'UGX',\r\n  paymentInfo: '',\r\n  defaultPrintFormat: 'standard'\r\n});\r\n\r\nexport const useBusinessSettings = () => {\r\n  const [settings, setSettings] = useState<BusinessSettings>(getDefaultSettings());\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const loadSettings = async (): Promise<BusinessSettings> => {\r\n    if (!currentBusiness) {\r\n      return getDefaultSettings();\r\n    }\r\n\r\n    try {\r\n      const data = await getBusinessSettingsAction(currentBusiness.id);\r\n\r\n      if (data) {\r\n        // Extract payment info from metadata\r\n        const paymentInfo = data.metadata && typeof data.metadata === 'object' ?\r\n          (data.metadata as Record<string, unknown>).payment_info as string || '' : '';\r\n\r\n        return {\r\n          id: data.id,\r\n          businessName: data.business_name || '',\r\n          businessAddress: data.business_address || '',\r\n          businessPhone: data.business_phone || '',\r\n          businessEmail: data.business_email || '',\r\n          businessLogo: data.business_logo || undefined,\r\n          currency: data.currency || 'UGX',\r\n          signature: data.signature || undefined,\r\n          paymentInfo: paymentInfo,\r\n          defaultPrintFormat: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_print_format as 'standard' | 'thermal' || 'standard' : 'standard',\r\n          defaultPrinterName: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_name as string || '' : '',\r\n          defaultPrinterType: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_type as 'USB' | 'Bluetooth' || 'USB' : 'USB',\r\n          printerPaperSize: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).printer_paper_size as '58mm' | '80mm' || '58mm' : '58mm'\r\n        };\r\n      } else {\r\n        return getDefaultSettings();\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return getDefaultSettings();\r\n    }\r\n  };\r\n\r\n  const updateSettings = async (newSettings: Partial<BusinessSettings>) => {\r\n    if (!currentBusiness) {\r\n      console.error('No business selected for updating settings');\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"No business selected\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const userData = { user: { id: '00000000-0000-0000-0000-000000000000' } }; // Mocked user id for now\r\n\r\n      // Prepare the metadata object with payment info\r\n      const metadata = {\r\n        payment_info: newSettings.hasOwnProperty('paymentInfo') ? newSettings.paymentInfo : settings.paymentInfo || '',\r\n        default_print_format: newSettings.hasOwnProperty('defaultPrintFormat') ? newSettings.defaultPrintFormat : settings.defaultPrintFormat || 'standard',\r\n        default_printer_name: newSettings.hasOwnProperty('defaultPrinterName') ? newSettings.defaultPrinterName : settings.defaultPrinterName || '',\r\n        default_printer_type: newSettings.hasOwnProperty('defaultPrinterType') ? newSettings.defaultPrinterType : settings.defaultPrinterType || 'USB',\r\n        printer_paper_size: newSettings.hasOwnProperty('printerPaperSize') ? newSettings.printerPaperSize : settings.printerPaperSize || '58mm'\r\n      };\r\n\r\n      const updateData = {\r\n        business_name: newSettings.hasOwnProperty('businessName') ? newSettings.businessName : settings.businessName,\r\n        business_address: newSettings.hasOwnProperty('businessAddress') ? newSettings.businessAddress : settings.businessAddress,\r\n        business_phone: newSettings.hasOwnProperty('businessPhone') ? newSettings.businessPhone : settings.businessPhone,\r\n        business_email: newSettings.hasOwnProperty('businessEmail') ? newSettings.businessEmail : settings.businessEmail,\r\n        business_logo: newSettings.hasOwnProperty('businessLogo') ? newSettings.businessLogo : settings.businessLogo,\r\n        currency: newSettings.hasOwnProperty('currency') ? newSettings.currency : settings.currency,\r\n        signature: newSettings.hasOwnProperty('signature') ? newSettings.signature : settings.signature,\r\n        metadata: metadata\r\n      };\r\n\r\n      const response = await upsertBusinessSettingsAction(currentBusiness.id, userData.user.id, updateData);\r\n\r\n      if (!response.success) {\r\n        console.error('Supabase error updating business settings:', response.error);\r\n        throw new Error(response.error);\r\n      }\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Business settings updated successfully\"\r\n      });\r\n\r\n      // Refetch settings after update\r\n      refetch();\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // React Query for settings loading with proper caching\r\n  const { data: queriedData, isLoading: isQueryLoading, isFetching, refetch } = useQuery({\r\n    queryKey: ['businessSettings', currentBusiness?.id],\r\n    queryFn: loadSettings,\r\n    enabled: !!currentBusiness?.id,\r\n    staleTime: 5 * 60_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: false,\r\n    refetchOnReconnect: false,\r\n  });\r\n\r\n  // Sync React Query data with local state\r\n  useEffect(() => {\r\n    if (queriedData) {\r\n      setSettings(queriedData);\r\n    } else if (!currentBusiness) {\r\n      setSettings(getDefaultSettings());\r\n    }\r\n  }, [queriedData, currentBusiness]);\r\n\r\n  // Sync loading state from React Query\r\n  useEffect(() => {\r\n    setIsLoading(isQueryLoading || isFetching);\r\n  }, [isQueryLoading, isFetching]);\r\n\r\n  return {\r\n    settings,\r\n    isLoading,\r\n    updateSettings,\r\n    loadSettings\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 420, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useFinancialVisibility.ts"],"sourcesContent":["import { useProfiles } from '@/contexts/ProfileContext';\r\n\r\n/**\r\n * Hook to handle financial data visibility based on permissions\r\n */\r\nexport const useFinancialVisibility = () => {\r\n    const { hasPermission } = useProfiles();\r\n\r\n    const canViewCostPrice = hasPermission('inventory', 'view_cost_price');\r\n    const canViewProfit = hasPermission('inventory', 'view_profit');\r\n    const canViewSellingPrice = hasPermission('inventory', 'view_selling_price');\r\n\r\n    // Dashboard-specific permissions\r\n    const canViewTotalSales = hasPermission('dashboard', 'view_total_sales');\r\n    const canViewTotalGrossProfit = hasPermission('dashboard', 'view_gross_profit');\r\n    const canViewTotalExpenses = hasPermission('dashboard', 'view_total_expenses');\r\n    const canViewInventoryValue = hasPermission('dashboard', 'view_inventory_value');\r\n    const canViewSalesTypes = hasPermission('dashboard', 'view_sales_types');\r\n    const canViewAvgPrice = hasPermission('dashboard', 'view_avg_price');\r\n    const canViewTotalAmount = hasPermission('dashboard', 'view_total_amount');\r\n\r\n    // Finance and Expenses permissions\r\n    const canManageFinanceAccounts = hasPermission('finance', 'manage_accounts');\r\n    const canViewFinance = hasPermission('finance', 'view');\r\n    const canViewExpenses = hasPermission('expenses', 'view');\r\n    const canCreateExpenses = hasPermission('expenses', 'create');\r\n    const canEditExpenses = hasPermission('expenses', 'edit');\r\n    const canDeleteExpenses = hasPermission('expenses', 'delete');\r\n\r\n    /**\r\n     * Format a financial value or return a hidden indicator\r\n     */\r\n    const formatFinancial = (value: number | null | undefined, type: 'cost' | 'selling' | 'profit'): string => {\r\n        const hasAccess =\r\n            (type === 'cost' && canViewCostPrice) ||\r\n            (type === 'selling' && canViewSellingPrice) ||\r\n            (type === 'profit' && canViewProfit);\r\n\r\n        if (!hasAccess) {\r\n            return '•••';\r\n        }\r\n\r\n        return value?.toLocaleString() || '0';\r\n    };\r\n\r\n    return {\r\n        canViewCostPrice,\r\n        canViewProfit,\r\n        canViewSellingPrice,\r\n        canViewTotalSales,\r\n        canViewTotalGrossProfit,\r\n        canViewTotalExpenses,\r\n        canViewInventoryValue,\r\n        canViewSalesTypes,\r\n        canViewAvgPrice,\r\n        canViewTotalAmount,\r\n        canManageFinanceAccounts,\r\n        canViewFinance,\r\n        canViewExpenses,\r\n        canCreateExpenses,\r\n        canEditExpenses,\r\n        canDeleteExpenses,\r\n        formatFinancial,\r\n    };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;;;AAKO,MAAM,yBAAyB;;IAClC,MAAM,EAAE,aAAa,EAAE,GAAG,IAAA,oJAAW;IAErC,MAAM,mBAAmB,cAAc,aAAa;IACpD,MAAM,gBAAgB,cAAc,aAAa;IACjD,MAAM,sBAAsB,cAAc,aAAa;IAEvD,iCAAiC;IACjC,MAAM,oBAAoB,cAAc,aAAa;IACrD,MAAM,0BAA0B,cAAc,aAAa;IAC3D,MAAM,uBAAuB,cAAc,aAAa;IACxD,MAAM,wBAAwB,cAAc,aAAa;IACzD,MAAM,oBAAoB,cAAc,aAAa;IACrD,MAAM,kBAAkB,cAAc,aAAa;IACnD,MAAM,qBAAqB,cAAc,aAAa;IAEtD,mCAAmC;IACnC,MAAM,2BAA2B,cAAc,WAAW;IAC1D,MAAM,iBAAiB,cAAc,WAAW;IAChD,MAAM,kBAAkB,cAAc,YAAY;IAClD,MAAM,oBAAoB,cAAc,YAAY;IACpD,MAAM,kBAAkB,cAAc,YAAY;IAClD,MAAM,oBAAoB,cAAc,YAAY;IAEpD;;KAEC,GACD,MAAM,kBAAkB,CAAC,OAAkC;QACvD,MAAM,YACF,AAAC,SAAS,UAAU,oBACnB,SAAS,aAAa,uBACtB,SAAS,YAAY;QAE1B,IAAI,CAAC,WAAW;YACZ,OAAO;QACX;QAEA,OAAO,OAAO,oBAAoB;IACtC;IAEA,OAAO;QACH;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACJ;AACJ;GA3Da;;QACiB,oJAAW"}},
    {"offset": {"line": 489, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/carriage/CarriageInwardsTable.tsx"],"sourcesContent":["\r\nimport React from 'react';\r\nimport { format } from 'date-fns';\r\nimport { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Edit, Trash2, Eye } from 'lucide-react';\r\nimport { CarriageInward } from '@/hooks/useCarriageInwards';\r\nimport { formatCashCurrency } from '@/lib/utils';\r\nimport { useBusinessSettings } from '@/hooks/useBusinessSettings';\r\n\r\nimport { useFinancialVisibility } from '@/hooks/useFinancialVisibility';\r\n\r\ninterface CarriageInwardsTableProps {\r\n  carriageInwards: CarriageInward[];\r\n  onEdit: (record: CarriageInward) => void;\r\n  onDelete: (id: string) => void;\r\n  onView: (record: CarriageInward) => void;\r\n  isLoading: boolean;\r\n}\r\n\r\nconst CarriageInwardsTable: React.FC<CarriageInwardsTableProps> = ({\r\n  carriageInwards,\r\n  onEdit,\r\n  onDelete,\r\n  onView,\r\n  isLoading\r\n}) => {\r\n  const { settings } = useBusinessSettings();\r\n  const { canViewCostPrice } = useFinancialVisibility();\r\n  const currency = settings.currency || 'USD';\r\n\r\n  const totalAmount = carriageInwards.reduce((sum, record) => sum + record.amount, 0);\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <Card>\r\n        <CardContent className=\"p-6\">\r\n          <div className=\"flex justify-center items-center h-32\">\r\n            <div className=\"animate-pulse\">Loading carriage inwards records...</div>\r\n          </div>\r\n        </CardContent>\r\n      </Card>\r\n    );\r\n  }\r\n\r\n  if (carriageInwards.length === 0) {\r\n    return (\r\n      <Card>\r\n        <CardContent className=\"p-6\">\r\n          <div className=\"text-center text-muted-foreground\">\r\n            <p className=\"text-lg font-medium\">No carriage inwards records found</p>\r\n            <p className=\"text-sm\">Add your first transport cost record to get started.</p>\r\n          </div>\r\n        </CardContent>\r\n      </Card>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <Card>\r\n      <CardHeader>\r\n        <div className=\"flex justify-between items-center\">\r\n          <CardTitle>Carriage Inwards Records</CardTitle>\r\n          {canViewCostPrice && (\r\n            <div className=\"text-right\">\r\n              <p className=\"text-sm text-muted-foreground\">Total Amount</p>\r\n              <p className=\"text-lg font-bold\">{formatCashCurrency(totalAmount, currency)}</p>\r\n            </div>\r\n          )}\r\n        </div>\r\n      </CardHeader>\r\n      <CardContent>\r\n        <div className=\"overflow-x-auto\">\r\n          <Table>\r\n            <TableHeader>\r\n              <TableRow>\r\n                <TableHead>Date</TableHead>\r\n                <TableHead>Supplier Name</TableHead>\r\n                <TableHead>Details</TableHead>\r\n                {canViewCostPrice && <TableHead className=\"text-right\">Amount</TableHead>}\r\n                <TableHead>Payment</TableHead>\r\n                <TableHead className=\"text-center\">Actions</TableHead>\r\n              </TableRow>\r\n            </TableHeader>\r\n            <TableBody>\r\n              {carriageInwards.map((record) => (\r\n                <TableRow key={record.id}>\r\n                  <TableCell>\r\n                    {format(record.date, 'MMM dd, yyyy')}\r\n                  </TableCell>\r\n                  <TableCell className=\"font-medium\">\r\n                    {record.supplierName}\r\n                  </TableCell>\r\n                  <TableCell>\r\n                    <div className=\"max-w-xs truncate\" title={record.details}>\r\n                      {record.details}\r\n                    </div>\r\n                  </TableCell>\r\n                  {canViewCostPrice && (\r\n                    <TableCell className=\"text-right font-medium\">\r\n                      {formatCashCurrency(record.amount, currency)}\r\n                    </TableCell>\r\n                  )}\r\n                  <TableCell>\r\n                    {record.cashAccountId ? (\r\n                      <Badge variant=\"secondary\">Paid</Badge>\r\n                    ) : (\r\n                      <Badge variant=\"outline\">Not Linked</Badge>\r\n                    )}\r\n                  </TableCell>\r\n                  <TableCell>\r\n                    <div className=\"flex justify-center gap-1\">\r\n                      <Button\r\n                        variant=\"ghost\"\r\n                        size=\"sm\"\r\n                        onClick={() => onView(record)}\r\n                        title=\"View details\"\r\n                      >\r\n                        <Eye className=\"h-4 w-4\" />\r\n                      </Button>\r\n                      <Button\r\n                        variant=\"ghost\"\r\n                        size=\"sm\"\r\n                        onClick={() => onEdit(record)}\r\n                        title=\"Edit record\"\r\n                      >\r\n                        <Edit className=\"h-4 w-4\" />\r\n                      </Button>\r\n                      <Button\r\n                        variant=\"ghost\"\r\n                        size=\"sm\"\r\n                        onClick={() => onDelete(record.id)}\r\n                        title=\"Delete record\"\r\n                      >\r\n                        <Trash2 className=\"h-4 w-4 text-red-500\" />\r\n                      </Button>\r\n                    </div>\r\n                  </TableCell>\r\n                </TableRow>\r\n              ))}\r\n            </TableBody>\r\n          </Table>\r\n        </div>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n};\r\n\r\nexport default CarriageInwardsTable;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 883, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/textarea.tsx"],"sourcesContent":["import * as React from \"react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nexport interface TextareaProps\r\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\r\n\r\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\r\n  ({ className, ...props }, ref) => {\r\n    return (\r\n      <textarea\r\n        className={cn(\r\n          \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\r\n          className\r\n        )}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    )\r\n  }\r\n)\r\nTextarea.displayName = \"Textarea\"\r\n\r\nexport { Textarea }\r\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAKA,MAAM,yBAAW,2KAAgB,MAC/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE;IACxB,qBACE,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,wSACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;;AAEF,SAAS,WAAW,GAAG"}},
    {"offset": {"line": 917, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/calendar.tsx"],"sourcesContent":["\r\nimport * as React from \"react\";\r\nimport { ChevronLeft, ChevronRight } from \"lucide-react\";\r\nimport { DayPicker } from \"react-day-picker\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\nimport { buttonVariants } from \"@/components/ui/button\";\r\n\r\nexport type CalendarProps = React.ComponentProps<typeof DayPicker>;\r\n\r\nfunction Calendar({\r\n  className,\r\n  classNames,\r\n  showOutsideDays = true,\r\n  ...props\r\n}: CalendarProps) {\r\n  return (\r\n    <DayPicker\r\n      showOutsideDays={showOutsideDays}\r\n      className={cn(\"p-3 pointer-events-auto\", className)}\r\n      classNames={{\r\n        months: \"flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0\",\r\n        month: \"space-y-4\",\r\n        caption: \"flex justify-center pt-1 relative items-center\",\r\n        caption_label: \"text-sm font-medium\",\r\n        caption_dropdowns: \"flex justify-center gap-1\",\r\n        nav: \"space-x-1 flex items-center\",\r\n        nav_button: cn(\r\n          buttonVariants({ variant: \"outline\" }),\r\n          \"h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100\"\r\n        ),\r\n        nav_button_previous: \"absolute left-1\",\r\n        nav_button_next: \"absolute right-1\",\r\n        table: \"w-full border-collapse space-y-1\",\r\n        head_row: \"flex\",\r\n        head_cell:\r\n          \"text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]\",\r\n        row: \"flex w-full mt-2\",\r\n        cell: \"h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20\",\r\n        day: cn(\r\n          buttonVariants({ variant: \"ghost\" }),\r\n          \"h-9 w-9 p-0 font-normal aria-selected:opacity-100\"\r\n        ),\r\n        day_range_end: \"day-range-end\",\r\n        day_selected:\r\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground\",\r\n        day_today: \"bg-accent text-accent-foreground\",\r\n        day_outside:\r\n          \"day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30\",\r\n        day_disabled: \"text-muted-foreground opacity-50\",\r\n        day_range_middle:\r\n          \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\r\n        day_hidden: \"invisible\",\r\n        dropdown: \"bg-background rounded-md border p-1 shadow-md\",\r\n        dropdown_month: \"w-[var(--rdp-caption-dropdown-month-width)]\",\r\n        dropdown_year: \"w-[var(--rdp-caption-dropdown-year-width)]\",\r\n        dropdown_icon: \"w-4 h-4\",\r\n        button_reset: \"appearance-none bg-transparent border-none p-0 m-0\",\r\n        vhidden: \"sr-only\",\r\n        ...classNames,\r\n      }}\r\n      components={{\r\n        IconLeft: ({ ..._props }) => <ChevronLeft className=\"h-4 w-4\" />,\r\n        IconRight: ({ ..._props }) => <ChevronRight className=\"h-4 w-4\" />,\r\n      }}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\nCalendar.displayName = \"Calendar\";\r\n\r\nexport { Calendar };\r\n"],"names":[],"mappings":";;;;;AAEA;AAAA;AACA;AAEA;AACA;;;;;;AAIA,SAAS,SAAS,EAChB,SAAS,EACT,UAAU,EACV,kBAAkB,IAAI,EACtB,GAAG,OACW;IACd,qBACE,6LAAC,8KAAS;QACR,iBAAiB;QACjB,WAAW,IAAA,4HAAE,EAAC,2BAA2B;QACzC,YAAY;YACV,QAAQ;YACR,OAAO;YACP,SAAS;YACT,eAAe;YACf,mBAAmB;YACnB,KAAK;YACL,YAAY,IAAA,4HAAE,EACZ,IAAA,uJAAc,EAAC;gBAAE,SAAS;YAAU,IACpC;YAEF,qBAAqB;YACrB,iBAAiB;YACjB,OAAO;YACP,UAAU;YACV,WACE;YACF,KAAK;YACL,MAAM;YACN,KAAK,IAAA,4HAAE,EACL,IAAA,uJAAc,EAAC;gBAAE,SAAS;YAAQ,IAClC;YAEF,eAAe;YACf,cACE;YACF,WAAW;YACX,aACE;YACF,cAAc;YACd,kBACE;YACF,YAAY;YACZ,UAAU;YACV,gBAAgB;YAChB,eAAe;YACf,eAAe;YACf,cAAc;YACd,SAAS;YACT,GAAG,UAAU;QACf;QACA,YAAY;YACV,UAAU,CAAC,EAAE,GAAG,QAAQ,iBAAK,6LAAC,sOAAW;oBAAC,WAAU;;;;;;YACpD,WAAW,CAAC,EAAE,GAAG,QAAQ,iBAAK,6LAAC,yOAAY;oBAAC,WAAU;;;;;;QACxD;QACC,GAAG,KAAK;;;;;;AAGf;KA1DS;AA2DT,SAAS,WAAW,GAAG"}},
    {"offset": {"line": 1006, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/popover.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Popover = PopoverPrimitive.Root\r\n\r\nconst PopoverTrigger = PopoverPrimitive.Trigger\r\n\r\nconst PopoverContent = React.forwardRef<\r\n  React.ElementRef<typeof PopoverPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\r\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\r\n  <PopoverPrimitive.Portal>\r\n    <PopoverPrimitive.Content\r\n      ref={ref}\r\n      align={align}\r\n      sideOffset={sideOffset}\r\n      className={cn(\r\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\r\n        className\r\n      )}\r\n      {...props}\r\n    />\r\n  </PopoverPrimitive.Portal>\r\n))\r\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\r\n\r\nexport { Popover, PopoverTrigger, PopoverContent }\r\n"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,UAAU,8KAAqB;AAErC,MAAM,iBAAiB,iLAAwB;AAE/C,MAAM,+BAAiB,2KAAgB,MAGrC,CAAC,EAAE,SAAS,EAAE,QAAQ,QAAQ,EAAE,aAAa,CAAC,EAAE,GAAG,OAAO,EAAE,oBAC5D,6LAAC,gLAAuB;kBACtB,cAAA,6LAAC,iLAAwB;YACvB,KAAK;YACL,OAAO;YACP,YAAY;YACZ,WAAW,IAAA,4HAAE,EACX,8aACA;YAED,GAAG,KAAK;;;;;;;;;;;;AAIf,eAAe,WAAW,GAAG,iLAAwB,CAAC,WAAW"}},
    {"offset": {"line": 1054, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA4fsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,0DAAA"}},
    {"offset": {"line": 1071, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqhBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 1088, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0iBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 1105, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA8jBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 1122, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgmBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4EAAA"}},
    {"offset": {"line": 1139, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    branchId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        branchId: currentExpense.branchId || currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- INSTALLMENT PAYMENTS ---\r\n\r\nexport async function getInstallmentPaymentsAction(saleId: string) {\r\n    try {\r\n        const payments = await db.installmentPayment.findMany({\r\n            where: { saleId },\r\n            orderBy: { paymentDate: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: payments.map((p: any) => ({\r\n                id: p.id,\r\n                saleId: p.saleId,\r\n                userId: p.userId,\r\n                amount: Number(p.amount),\r\n                paymentDate: p.paymentDate.toISOString(),\r\n                notes: p.notes,\r\n                cashTransactionId: p.cashTransactionId,\r\n                createdAt: p.createdAt.toISOString(),\r\n                updatedAt: p.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching installment payments:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createInstallmentPaymentAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            let cashTxId = data.cashTransactionId;\r\n\r\n            if (data.accountId && data.locationId && !cashTxId) {\r\n                const sale = await tx.sale.findUnique({\r\n                    where: { id: data.saleId },\r\n                    select: { customerName: true, receiptNumber: true }\r\n                });\r\n\r\n                const description = sale\r\n                    ? `Installment payment for ${sale.customerName} - Receipt #${sale.receiptNumber}`\r\n                    : `Installment payment for sale`;\r\n\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_in',\r\n                        category: 'Installment payment',\r\n                        description: description,\r\n                        date: data.paymentDate ? new Date(data.paymentDate) : new Date(),\r\n                    }\r\n                });\r\n                cashTxId = cashTx.id;\r\n            }\r\n\r\n            const payment = await tx.installmentPayment.create({\r\n                data: {\r\n                    saleId: data.saleId,\r\n                    userId: data.userId,\r\n                    amount: data.amount,\r\n                    notes: data.notes,\r\n                    cashTransactionId: cashTxId,\r\n                    paymentDate: data.paymentDate ? new Date(data.paymentDate) : new Date()\r\n                }\r\n            });\r\n\r\n            return payment;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateInstallmentPaymentAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const current = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!current) throw new Error(\"Payment not found\");\r\n\r\n            const updated = await tx.installmentPayment.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    notes: updates.notes,\r\n                    paymentDate: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                }\r\n            });\r\n\r\n            if (current.cashTransactionId) {\r\n                await tx.cashTransaction.update({\r\n                    where: { id: current.cashTransactionId },\r\n                    data: {\r\n                        amount: updates.amount,\r\n                        date: updates.paymentDate ? new Date(updates.paymentDate) : undefined\r\n                    }\r\n                });\r\n            }\r\n\r\n            return updated;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteInstallmentPaymentAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (payment?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: payment.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.installmentPayment.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting installment payment:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function linkInstallmentToCashAction(paymentId: string, accountId: string, locationId: string, userId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                include: { sale: true }\r\n            });\r\n\r\n            if (!payment) throw new Error(\"Payment not found\");\r\n            if (payment.cashTransactionId) throw new Error(\"Payment already linked\");\r\n\r\n            const description = payment.sale\r\n                ? `Installment payment for ${payment.sale.customerName} - Receipt #${payment.sale.receiptNumber}`\r\n                : `Installment payment #${paymentId.substring(0, 8)}`;\r\n\r\n            const cashTx = await tx.cashTransaction.create({\r\n                data: {\r\n                    userId,\r\n                    branchId: locationId,\r\n                    accountId,\r\n                    amount: payment.amount,\r\n                    transactionType: 'cash_in',\r\n                    category: 'Installment payment',\r\n                    description,\r\n                    date: payment.paymentDate,\r\n                }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: cashTx.id }\r\n            });\r\n\r\n            return cashTx;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error linking installment to cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function unlinkInstallmentFromCashAction(paymentId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const payment = await tx.installmentPayment.findUnique({\r\n                where: { id: paymentId },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (!payment?.cashTransactionId) throw new Error(\"Payment not linked\");\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id: payment.cashTransactionId }\r\n            });\r\n\r\n            await tx.installmentPayment.update({\r\n                where: { id: paymentId },\r\n                data: { cashTransactionId: null }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error unlinking installment from cash:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- EXPENSE CATEGORIES ---\r\n\r\nexport async function getExpenseCategoriesAction(locationId: string) {\r\n    try {\r\n        const categories = await db.expenseCategory.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map((c: any) => ({\r\n                id: c.id,\r\n                name: c.name,\r\n                isDefault: c.isDefault,\r\n                createdAt: c.createdAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expense categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createExpenseCategoryAction(data: any) {\r\n    try {\r\n        const result = await db.expenseCategory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseCategoryAction(id: string) {\r\n    try {\r\n        await db.expenseCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultExpenseCategoriesAction(userId: string, locationId: string, categoryNames: string[]) {\r\n    try {\r\n        const data = categoryNames.map(name => ({\r\n            userId,\r\n            branchId: locationId,\r\n            name,\r\n            isDefault: true\r\n        }));\r\n\r\n        await db.expenseCategory.createMany({\r\n            data,\r\n            skipDuplicates: true\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { branchId: locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.initialBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                initialBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                initialBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, branchId: locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, branchId: locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, branchId: locationId }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, branchId: locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, branchId: locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, branchId: locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.initialBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { branchId: locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        branchId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        personInCharge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date ? new Date(data.date) : new Date(),\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashTransactionAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashTransaction.update({\r\n            where: { id },\r\n            data: {\r\n                accountId: updates.accountId,\r\n                amount: updates.amount,\r\n                transactionType: updates.transactionType,\r\n                category: updates.category,\r\n                description: updates.description,\r\n                personInCharge: updates.personInCharge,\r\n                tags: updates.tags,\r\n                date: updates.date ? new Date(updates.date) : undefined,\r\n                paymentMethod: updates.paymentMethod,\r\n                receiptImage: updates.receiptImage\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function findCashTransactionAction(id: string) {\r\n    try {\r\n        const transaction = await db.cashTransaction.findUnique({\r\n            where: { id },\r\n            select: { accountId: true }\r\n        });\r\n\r\n        return { success: true, data: transaction };\r\n    } catch (error: any) {\r\n        console.error('Error finding cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, branchId: locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, branchId: locationId },\r\n            select: { initialBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.initialBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            branchId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            personInCharge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date ? new Date(data.date) : new Date(),\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAmoBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 1156, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useCashAccounts.ts"],"sourcesContent":["import { useState, useEffect, useMemo, useCallback } from 'react';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { CashAccount } from '@/types/cash';\r\nimport {\r\n  getCashAccountsAction,\r\n  createCashAccountAction,\r\n  updateCashAccountAction,\r\n  deleteCashAccountAction,\r\n  deleteCashAccountWithTransactionsAction,\r\n  getCashAccountBalanceAction\r\n} from '@/app/actions/finance';\r\n\r\nexport const useCashAccounts = () => {\r\n  const [accounts, setAccounts] = useState<CashAccount[]>([]);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n  const { user } = useAuth();\r\n  const queryClient = useQueryClient();\r\n\r\n  const loadAccounts = useCallback(async (): Promise<CashAccount[]> => {\r\n    if (!currentBusiness?.id) return [];\r\n\r\n    try {\r\n      const result = await getCashAccountsAction(currentBusiness.id);\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error || 'Failed to fetch accounts');\r\n      }\r\n\r\n      return result.data.map((account: any) => ({\r\n        ...account,\r\n        createdAt: new Date(account.createdAt),\r\n        updatedAt: new Date(account.updatedAt)\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error loading cash accounts:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load cash accounts\",\r\n        variant: \"destructive\"\r\n      });\r\n      return [];\r\n    }\r\n  }, [currentBusiness?.id, toast]);\r\n\r\n  const queryKey = ['cash_accounts', currentBusiness?.id];\r\n  const { data: queriedAccounts, isLoading: isQueryLoading } = useQuery({\r\n    queryKey,\r\n    queryFn: loadAccounts,\r\n    enabled: !!currentBusiness?.id,\r\n    staleTime: 30_000,\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (queriedAccounts) {\r\n      setAccounts(queriedAccounts);\r\n    }\r\n  }, [queriedAccounts]);\r\n\r\n  const isLoading = isQueryLoading && !queriedAccounts;\r\n\r\n  const refreshAccounts = useCallback(() => {\r\n    queryClient.invalidateQueries({ queryKey });\r\n  }, [queryClient, queryKey]);\r\n\r\n  const createAccount = useCallback(async (accountData: {\r\n    name: string;\r\n    description?: string;\r\n    openingBalance: number;\r\n    isDefault?: boolean;\r\n  }) => {\r\n    if (!currentBusiness?.id || !user?.id) return null;\r\n\r\n    try {\r\n      const result = await createCashAccountAction({\r\n        ...accountData,\r\n        userId: user.id,\r\n        locationId: currentBusiness.id\r\n      });\r\n\r\n      if (!result.success || !result.data) throw new Error(result.error);\r\n\r\n      queryClient.invalidateQueries({ queryKey });\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Cash account created successfully\"\r\n      });\r\n\r\n      return result.data;\r\n    } catch (error) {\r\n      console.error('Error creating cash account:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to create cash account\",\r\n        variant: \"destructive\"\r\n      });\r\n      return null;\r\n    }\r\n  }, [currentBusiness?.id, user?.id, queryClient, queryKey, toast]);\r\n\r\n  const updateAccount = async (id: string, updates: Partial<CashAccount>) => {\r\n    if (!currentBusiness?.id) return false;\r\n\r\n    try {\r\n      const result = await updateCashAccountAction(id, {\r\n        ...updates,\r\n        locationId: currentBusiness.id\r\n      });\r\n\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      queryClient.invalidateQueries({ queryKey });\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Cash account updated successfully\"\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating cash account:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update cash account\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteAccount = async (id: string, onDeleted?: () => void) => {\r\n    if (!currentBusiness?.id) return { success: false, hasTransactions: false };\r\n\r\n    try {\r\n      const result = await deleteCashAccountAction(id, currentBusiness.id);\r\n\r\n      if (result.success) {\r\n        queryClient.invalidateQueries({ queryKey });\r\n        toast({\r\n          title: \"Success\",\r\n          description: \"Cash account deleted successfully\"\r\n        });\r\n        if (onDeleted) onDeleted();\r\n      }\r\n\r\n      return result as any;\r\n    } catch (error) {\r\n      console.error('Error deleting cash account:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete cash account\",\r\n        variant: \"destructive\"\r\n      });\r\n      return { success: false, hasTransactions: false };\r\n    }\r\n  };\r\n\r\n  const deleteAccountWithTransactions = async (id: string, deleteTransactions: boolean = false, onDeleted?: () => void) => {\r\n    if (!currentBusiness?.id) return false;\r\n\r\n    try {\r\n      const result = await deleteCashAccountWithTransactionsAction(id, currentBusiness.id, deleteTransactions);\r\n\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      queryClient.invalidateQueries({ queryKey });\r\n      toast({\r\n        title: \"Success\",\r\n        description: deleteTransactions\r\n          ? \"Account and transactions deleted\"\r\n          : \"Account deleted (records unlinked)\"\r\n      });\r\n      if (onDeleted) onDeleted();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting cash account:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete cash account\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const getAccountBalance = useCallback(async (accountId: string): Promise<number> => {\r\n    if (!currentBusiness?.id) return 0;\r\n    try {\r\n      const result = await getCashAccountBalanceAction(accountId, currentBusiness.id);\r\n      if (result.success) return result.data as number;\r\n      return 0;\r\n    } catch (error) {\r\n      console.error('Error getting balance:', error);\r\n      return 0;\r\n    }\r\n  }, [currentBusiness?.id]);\r\n\r\n  return useMemo(() => ({\r\n    accounts,\r\n    isLoading,\r\n    createAccount,\r\n    updateAccount,\r\n    deleteAccount,\r\n    deleteAccountWithTransactions,\r\n    getAccountBalance,\r\n    loadAccounts,\r\n    refreshAccounts\r\n  }), [accounts, isLoading, createAccount, updateAccount, deleteAccount, deleteAccountWithTransactions, getAccountBalance, loadAccounts, refreshAccounts]);\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1416, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/carriage/CarriageInwardsForm.tsx"],"sourcesContent":["\r\nimport React, { useState } from 'react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Label } from '@/components/ui/label';\r\nimport { Textarea } from '@/components/ui/textarea';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Calendar } from '@/components/ui/calendar';\r\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\r\nimport { CalendarIcon } from 'lucide-react';\r\nimport { format } from 'date-fns';\r\nimport { cn } from '@/lib/utils';\r\nimport { CarriageInwardFormData } from '@/hooks/useCarriageInwards';\r\nimport { useCashAccounts } from '@/hooks/useCashAccounts';\r\n\r\ninterface CarriageInwardsFormProps {\r\n  onSubmit: (data: CarriageInwardFormData) => Promise<void>;\r\n  onCancel: () => void;\r\n  initialData?: Partial<CarriageInwardFormData>;\r\n  isEditing?: boolean;\r\n}\r\n\r\nconst CarriageInwardsForm: React.FC<CarriageInwardsFormProps> = ({\r\n  onSubmit,\r\n  onCancel,\r\n  initialData,\r\n  isEditing = false\r\n}) => {\r\n  const [formData, setFormData] = useState<CarriageInwardFormData>({\r\n    supplierName: initialData?.supplierName || '',\r\n    details: initialData?.details || '',\r\n    amount: initialData?.amount || 0,\r\n    date: initialData?.date || new Date(),\r\n    cashAccountId: initialData?.cashAccountId || undefined\r\n  });\r\n  \r\n  const [isSubmitting, setIsSubmitting] = useState(false);\r\n  const { accounts } = useCashAccounts();\r\n\r\n  const handleSubmit = async (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n    \r\n    if (!formData.supplierName.trim() || !formData.details.trim() || formData.amount <= 0) {\r\n      return;\r\n    }\r\n\r\n    setIsSubmitting(true);\r\n    try {\r\n      await onSubmit(formData);\r\n    } finally {\r\n      setIsSubmitting(false);\r\n    }\r\n  };\r\n\r\n  // Get the current select value, ensuring it's never undefined for the Select component\r\n  const selectValue = formData.cashAccountId || 'none';\r\n\r\n  return (\r\n    <Card className=\"w-full max-w-2xl mx-auto\">\r\n      <CardHeader>\r\n        <CardTitle>\r\n          {isEditing ? 'Edit Carriage Inwards' : 'Add New Carriage Inwards'}\r\n        </CardTitle>\r\n      </CardHeader>\r\n      <CardContent>\r\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"supplierName\">Supplier Name *</Label>\r\n            <Input\r\n              id=\"supplierName\"\r\n              value={formData.supplierName}\r\n              onChange={(e) => setFormData({ ...formData, supplierName: e.target.value })}\r\n              onKeyDown={(e) => {\r\n                if (e.key === 'Enter') {\r\n                  e.preventDefault();\r\n                  document.getElementById('details')?.focus();\r\n                }\r\n              }}\r\n              placeholder=\"Enter supplier name\"\r\n              required\r\n            />\r\n          </div>\r\n\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"details\">Details *</Label>\r\n            <Textarea\r\n              id=\"details\"\r\n              value={formData.details}\r\n              onChange={(e) => setFormData({ ...formData, details: e.target.value })}\r\n              onKeyDown={(e) => {\r\n                if (e.key === 'Enter' && !e.shiftKey) {\r\n                  e.preventDefault();\r\n                  document.getElementById('amount')?.focus();\r\n                }\r\n              }}\r\n              placeholder=\"Enter transport details\"\r\n              rows={3}\r\n              required\r\n            />\r\n          </div>\r\n\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"amount\">Amount *</Label>\r\n            <Input\r\n              id=\"amount\"\r\n              type=\"number\"\r\n              step=\"0.01\"\r\n              min=\"0\"\r\n              value={formData.amount}\r\n              onChange={(e) => setFormData({ ...formData, amount: parseFloat(e.target.value) || 0 })}\r\n              onKeyDown={(e) => {\r\n                if (e.key === 'Enter') {\r\n                  e.preventDefault();\r\n                  const dateButton = document.querySelector('[role=\"combobox\"]') as HTMLElement;\r\n                  if (dateButton) {\r\n                    dateButton.focus();\r\n                  }\r\n                }\r\n              }}\r\n              placeholder=\"0.00\"\r\n              required\r\n            />\r\n          </div>\r\n\r\n          <div className=\"space-y-2\">\r\n            <Label>Date *</Label>\r\n            <Popover>\r\n              <PopoverTrigger asChild>\r\n                <Button\r\n                  variant=\"outline\"\r\n                  className={cn(\r\n                    \"w-full justify-start text-left font-normal\",\r\n                    !formData.date && \"text-muted-foreground\"\r\n                  )}\r\n                  onKeyDown={(e) => {\r\n                    if (e.key === 'Enter') {\r\n                      e.preventDefault();\r\n                      const cashAccountSelect = document.querySelector('button[role=\"combobox\"]:last-of-type') as HTMLElement;\r\n                      if (cashAccountSelect) {\r\n                        cashAccountSelect.focus();\r\n                      }\r\n                    }\r\n                  }}\r\n                >\r\n                  <CalendarIcon className=\"mr-2 h-4 w-4\" />\r\n                  {formData.date ? format(formData.date, \"PPP\") : <span>Pick a date</span>}\r\n                </Button>\r\n              </PopoverTrigger>\r\n              <PopoverContent className=\"w-auto p-0\" align=\"start\">\r\n                <Calendar\r\n                  mode=\"single\"\r\n                  selected={formData.date}\r\n                  onSelect={(date) => date && setFormData({ ...formData, date })}\r\n                  disabled={(date) => date > new Date()}\r\n                  initialFocus\r\n                  className=\"p-3 pointer-events-auto\"\r\n                />\r\n              </PopoverContent>\r\n            </Popover>\r\n          </div>\r\n\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"cashAccount\">Cash Account (Optional)</Label>\r\n            <Select\r\n              value={selectValue}\r\n              onValueChange={(value) => {\r\n                setFormData({ \r\n                  ...formData, \r\n                  cashAccountId: value === 'none' ? undefined : value \r\n                });\r\n                // Focus submit button after selection\r\n                setTimeout(() => {\r\n                  const submitButton = document.querySelector('button[type=\"submit\"]') as HTMLElement;\r\n                  submitButton?.focus();\r\n                }, 100);\r\n              }}\r\n            >\r\n              <SelectTrigger\r\n                onKeyDown={(e) => {\r\n                  if (e.key === 'Enter') {\r\n                    e.preventDefault();\r\n                    setTimeout(() => {\r\n                      const submitButton = document.querySelector('button[type=\"submit\"]') as HTMLElement;\r\n                      submitButton?.focus();\r\n                    }, 100);\r\n                  }\r\n                }}\r\n              >\r\n                <SelectValue placeholder=\"Select a cash account\" />\r\n              </SelectTrigger>\r\n              <SelectContent>\r\n                <SelectItem value=\"none\">No cash account</SelectItem>\r\n                {accounts.map((account) => (\r\n                  <SelectItem key={account.id} value={account.id}>\r\n                    {account.name}\r\n                  </SelectItem>\r\n                ))}\r\n              </SelectContent>\r\n            </Select>\r\n          </div>\r\n\r\n          <div className=\"flex gap-2 pt-4\">\r\n            <Button\r\n              type=\"submit\"\r\n              disabled={isSubmitting || !formData.supplierName.trim() || !formData.details.trim() || formData.amount <= 0}\r\n              className=\"flex-1\"\r\n            >\r\n              {isSubmitting ? 'Saving...' : (isEditing ? 'Update' : 'Add')}\r\n            </Button>\r\n            <Button\r\n              type=\"button\"\r\n              variant=\"outline\"\r\n              onClick={onCancel}\r\n              disabled={isSubmitting}\r\n              className=\"flex-1\"\r\n            >\r\n              Cancel\r\n            </Button>\r\n          </div>\r\n        </form>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n};\r\n\r\nexport default CarriageInwardsForm;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1848, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useCarriageInwards.ts"],"sourcesContent":["\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useToast } from '@/hooks/use-toast';\r\n\r\nexport interface CarriageInward {\r\n  id: string;\r\n  userId: string;\r\n  locationId: string;\r\n  supplierName: string;\r\n  details: string;\r\n  amount: number;\r\n  date: Date;\r\n  cashAccountId?: string;\r\n  cashTransactionId?: string;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface CarriageInwardFormData {\r\n  supplierName: string;\r\n  details: string;\r\n  amount: number;\r\n  date: Date;\r\n  cashAccountId?: string;\r\n}\r\n\r\nexport const useCarriageInwards = () => {\r\n  const [carriageInwards, setCarriageInwards] = useState<CarriageInward[]>([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const { user } = useAuth();\r\n  const { currentBusiness } = useBusiness();\r\n  const { toast } = useToast();\r\n\r\n  const loadCarriageInwards = useCallback(async () => {\r\n    try {\r\n      if (!user || !currentBusiness) {\r\n        setCarriageInwards([]);\r\n        setIsLoading(false);\r\n        return;\r\n      }\r\n\r\n      setIsLoading(true);\r\n      \r\n      const { data, error } = await supabase\r\n        .from('carriage_inwards')\r\n        .select('*')\r\n        .eq('location_id', currentBusiness.id)\r\n        .order('date', { ascending: false })\r\n        .order('created_at', { ascending: false });\r\n\r\n      if (error) throw error;\r\n\r\n      const formattedData: CarriageInward[] = data?.map(item => ({\r\n        id: item.id,\r\n        userId: item.user_id,\r\n        locationId: item.location_id,\r\n        supplierName: item.supplier_name,\r\n        details: item.details,\r\n        amount: Number(item.amount),\r\n        date: new Date(item.date),\r\n        cashAccountId: item.cash_account_id,\r\n        cashTransactionId: item.cash_transaction_id,\r\n        createdAt: new Date(item.created_at),\r\n        updatedAt: new Date(item.updated_at)\r\n      })) || [];\r\n\r\n      setCarriageInwards(formattedData);\r\n    } catch (error) {\r\n      console.error('Error loading carriage inwards:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load carriage inwards records. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [user, currentBusiness?.id, toast]);\r\n\r\n  const createCarriageInward = async (data: CarriageInwardFormData) => {\r\n    try {\r\n      if (!user || !currentBusiness) throw new Error('User not authenticated or no business selected');\r\n\r\n      let cashTransactionId = null;\r\n\r\n      // Create cash transaction if cash account is selected\r\n      if (data.cashAccountId) {\r\n        const { data: cashTransaction, error: cashError } = await supabase\r\n          .from('cash_transactions')\r\n          .insert({\r\n            user_id: user.id,\r\n            location_id: currentBusiness.id,\r\n            account_id: data.cashAccountId,\r\n            amount: data.amount,\r\n            transaction_type: 'cash_out',\r\n            category: 'Transport',\r\n            description: `Carriage inwards - ${data.supplierName}: ${data.details}`,\r\n            date: data.date.toISOString().split('T')[0]\r\n          })\r\n          .select()\r\n          .single();\r\n\r\n        if (cashError) throw cashError;\r\n        cashTransactionId = cashTransaction.id;\r\n      }\r\n\r\n      const { data: carriageData, error } = await supabase\r\n        .from('carriage_inwards')\r\n        .insert({\r\n          user_id: user.id,\r\n          location_id: currentBusiness.id,\r\n          supplier_name: data.supplierName,\r\n          details: data.details,\r\n          amount: data.amount,\r\n          date: data.date.toISOString().split('T')[0],\r\n          cash_account_id: data.cashAccountId || null,\r\n          cash_transaction_id: cashTransactionId\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) throw error;\r\n\r\n      await loadCarriageInwards();\r\n      \r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Carriage inwards record created successfully\"\r\n      });\r\n\r\n      return carriageData;\r\n    } catch (error) {\r\n      console.error('Error creating carriage inwards:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to create carriage inwards record. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const updateCarriageInward = async (id: string, updates: Partial<CarriageInwardFormData>) => {\r\n    try {\r\n      if (!currentBusiness) throw new Error('No business selected');\r\n\r\n      const updateData: any = {};\r\n      \r\n      if (updates.supplierName !== undefined) updateData.supplier_name = updates.supplierName;\r\n      if (updates.details !== undefined) updateData.details = updates.details;\r\n      if (updates.amount !== undefined) updateData.amount = updates.amount;\r\n      if (updates.date !== undefined) updateData.date = updates.date.toISOString().split('T')[0];\r\n\r\n      const { error } = await supabase\r\n        .from('carriage_inwards')\r\n        .update(updateData)\r\n        .eq('id', id)\r\n        .eq('location_id', currentBusiness.id);\r\n\r\n      if (error) throw error;\r\n\r\n      await loadCarriageInwards();\r\n      \r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Carriage inwards record updated successfully\"\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating carriage inwards:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update carriage inwards record. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteCarriageInward = async (id: string) => {\r\n    try {\r\n      if (!currentBusiness) throw new Error('No business selected');\r\n\r\n      // Get the record to check if it has an associated cash transaction\r\n      const { data: record, error: fetchError } = await supabase\r\n        .from('carriage_inwards')\r\n        .select('cash_transaction_id')\r\n        .eq('id', id)\r\n        .eq('location_id', currentBusiness.id)\r\n        .single();\r\n\r\n      if (fetchError) throw fetchError;\r\n\r\n      // Delete associated cash transaction if exists\r\n      if (record.cash_transaction_id) {\r\n        const { error: cashError } = await supabase\r\n          .from('cash_transactions')\r\n          .delete()\r\n          .eq('id', record.cash_transaction_id)\r\n          .eq('location_id', currentBusiness.id);\r\n\r\n        if (cashError) throw cashError;\r\n      }\r\n\r\n      // Delete the carriage inwards record\r\n      const { error } = await supabase\r\n        .from('carriage_inwards')\r\n        .delete()\r\n        .eq('id', id)\r\n        .eq('location_id', currentBusiness.id);\r\n\r\n      if (error) throw error;\r\n\r\n      await loadCarriageInwards();\r\n      \r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Carriage inwards record deleted successfully\"\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting carriage inwards:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete carriage inwards record. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    loadCarriageInwards();\r\n  }, [loadCarriageInwards]);\r\n\r\n  return {\r\n    carriageInwards,\r\n    isLoading,\r\n    createCarriageInward,\r\n    updateCarriageInward,\r\n    deleteCarriageInward,\r\n    refreshCarriageInwards: loadCarriageInwards\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2053, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/pages/CarriageInwards.tsx"],"sourcesContent":["\r\nimport React, { useState } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Plus, RefreshCw, ArrowLeft } from 'lucide-react';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport CarriageInwardsTable from '@/components/carriage/CarriageInwardsTable';\r\nimport CarriageInwardsForm from '@/components/carriage/CarriageInwardsForm';\r\nimport { useCarriageInwards } from '@/hooks/useCarriageInwards';\r\nimport { useBusinessSettings } from '@/hooks/useBusinessSettings';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useIsMobile } from '@/hooks/use-mobile';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport LoadingSpinner from '@/components/LoadingSpinner';\r\nimport { useProfiles } from '@/contexts/ProfileContext';\r\n\r\nconst CarriageInwards = () => {\r\n  const navigate = useNavigate();\r\n  const { user } = useAuth();\r\n  const { currentBusiness, isLoading: businessLoading } = useBusiness();\r\n  const { toast } = useToast();\r\n  const isMobile = useIsMobile();\r\n  const { settings } = useBusinessSettings();\r\n  const { hasPermission } = useProfiles();\r\n\r\n  const canCreate = hasPermission('inventory', 'create');\r\n  const canEdit = hasPermission('inventory', 'edit');\r\n  const canDelete = hasPermission('inventory', 'delete');\r\n\r\n  const {\r\n    carriageInwards,\r\n    isLoading,\r\n    createCarriageInward,\r\n    updateCarriageInward,\r\n    deleteCarriageInward\r\n  } = useCarriageInwards();\r\n\r\n  const [showForm, setShowForm] = useState(false);\r\n\r\n  // Calculate summary statistics\r\n  const totalAmount = carriageInwards.reduce((sum, item) => sum + Number(item.amount), 0);\r\n  const totalEntries = carriageInwards.length;\r\n  const uniqueSuppliers = [...new Set(carriageInwards.map(item => item.supplierName))].length;\r\n  const thisMonthEntries = carriageInwards.filter(item => {\r\n    const itemDate = new Date(item.date);\r\n    const now = new Date();\r\n    return itemDate.getMonth() === now.getMonth() && itemDate.getFullYear() === now.getFullYear();\r\n  }).length;\r\n\r\n  const handleRefresh = () => {\r\n    // The hook already handles loading, so we just show a toast\r\n    toast({\r\n      title: \"Data refreshed\",\r\n      description: \"Carriage inwards data has been updated.\",\r\n    });\r\n  };\r\n\r\n  const handleEdit = (record: any) => {\r\n    // TODO: Implement edit functionality\r\n    console.log('Edit record:', record);\r\n  };\r\n\r\n  const handleView = (record: any) => {\r\n    // TODO: Implement view functionality\r\n    console.log('View record:', record);\r\n  };\r\n\r\n  if (businessLoading || !currentBusiness || isLoading) {\r\n    return (\r\n      <div className=\"flex flex-col items-center justify-center min-h-[60vh] space-y-4\">\r\n        <LoadingSpinner />\r\n        <p className=\"text-muted-foreground\">Loading carriage inwards data...</p>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"p-3 md:p-6 space-y-4 md:space-y-6\">\r\n      {/* Header Section - Improved Mobile Layout */}\r\n      <div className=\"space-y-3 md:space-y-4\">\r\n        <div className=\"flex flex-col gap-3 md:flex-row md:items-center md:justify-between\">\r\n          <div className=\"flex items-center gap-3\">\r\n            <Button\r\n              variant=\"ghost\"\r\n              size=\"icon\"\r\n              onClick={() => navigate('/inventory')}\r\n              className=\"shrink-0 h-8 w-8\"\r\n              title=\"Back to inventory\"\r\n            >\r\n              <ArrowLeft className=\"h-4 w-4\" />\r\n            </Button>\r\n            <div className=\"space-y-1\">\r\n              <h1 className=\"text-lg md:text-2xl lg:text-3xl font-bold text-sales-dark\">Carriage Inwards</h1>\r\n              <p className=\"text-xs md:text-base text-muted-foreground\">\r\n                Track transportation and delivery costs for your inventory\r\n              </p>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Mobile Action Buttons - Improved Layout */}\r\n          {isMobile ? (\r\n            <div className=\"space-y-2\">\r\n              <div className=\"flex gap-2\">\r\n                {canCreate && (\r\n                  <Button\r\n                    onClick={() => setShowForm(!showForm)}\r\n                    className=\"flex-1 gap-2 h-9\"\r\n                    variant={showForm ? \"outline\" : \"default\"}\r\n                  >\r\n                    <Plus size={16} /> {showForm ? 'Cancel' : 'Add Entry'}\r\n                  </Button>\r\n                )}\r\n                <Button\r\n                  onClick={handleRefresh}\r\n                  variant=\"outline\"\r\n                  size=\"icon\"\r\n                  disabled={isLoading}\r\n                  className=\"shrink-0 h-9 w-9\"\r\n                >\r\n                  <RefreshCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} />\r\n                </Button>\r\n              </div>\r\n            </div>\r\n          ) : (\r\n            // Desktop Action Buttons\r\n            <div className=\"flex items-center gap-2\">\r\n              <Button\r\n                onClick={handleRefresh}\r\n                variant=\"outline\"\r\n                size=\"icon\"\r\n                disabled={isLoading}\r\n                title=\"Refresh data\"\r\n              >\r\n                <RefreshCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} />\r\n              </Button>\r\n              {canCreate && (\r\n                <Button onClick={() => setShowForm(!showForm)} className=\"gap-2\">\r\n                  <Plus size={16} /> {showForm ? 'Cancel' : 'Add Entry'}\r\n                </Button>\r\n              )}\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Summary Cards - Improved Mobile Layout */}\r\n      <div className=\"grid grid-cols-2 md:grid-cols-4 gap-3 md:gap-4\">\r\n        <Card className=\"overflow-hidden\">\r\n          <CardContent className=\"p-3 md:p-4\">\r\n            <div className=\"space-y-1\">\r\n              <p className=\"text-xs text-muted-foreground\">Total Amount</p>\r\n              <p className=\"text-lg md:text-xl font-bold\">{settings.currency || 'USD'} {totalAmount.toFixed(2)}</p>\r\n            </div>\r\n          </CardContent>\r\n        </Card>\r\n\r\n        <Card className=\"overflow-hidden\">\r\n          <CardContent className=\"p-3 md:p-4\">\r\n            <div className=\"space-y-1\">\r\n              <p className=\"text-xs text-muted-foreground\">Total Entries</p>\r\n              <p className=\"text-lg md:text-xl font-bold\">{totalEntries}</p>\r\n            </div>\r\n          </CardContent>\r\n        </Card>\r\n\r\n        <Card className=\"overflow-hidden\">\r\n          <CardContent className=\"p-3 md:p-4\">\r\n            <div className=\"space-y-1\">\r\n              <p className=\"text-xs text-muted-foreground\">Suppliers</p>\r\n              <p className=\"text-lg md:text-xl font-bold\">{uniqueSuppliers}</p>\r\n            </div>\r\n          </CardContent>\r\n        </Card>\r\n\r\n        <Card className=\"overflow-hidden\">\r\n          <CardContent className=\"p-3 md:p-4\">\r\n            <div className=\"space-y-1\">\r\n              <p className=\"text-xs text-muted-foreground\">This Month</p>\r\n              <p className=\"text-lg md:text-xl font-bold\">{thisMonthEntries}</p>\r\n            </div>\r\n          </CardContent>\r\n        </Card>\r\n      </div>\r\n\r\n      {/* Form Section */}\r\n      {showForm && (\r\n        <Card className=\"shadow-sm\">\r\n          <CardHeader className=\"pb-2 md:pb-6\">\r\n            <CardTitle className=\"text-sm md:text-lg\">Add New Carriage Entry</CardTitle>\r\n          </CardHeader>\r\n          <CardContent>\r\n            <CarriageInwardsForm\r\n              onSubmit={async (data) => {\r\n                try {\r\n                  await createCarriageInward(data);\r\n                  setShowForm(false);\r\n                  toast({\r\n                    title: \"Entry created\",\r\n                    description: \"Carriage inwards entry has been successfully created.\",\r\n                  });\r\n                } catch (error) {\r\n                  toast({\r\n                    title: \"Error\",\r\n                    description: \"Failed to create carriage inwards entry.\",\r\n                    variant: \"destructive\",\r\n                  });\r\n                }\r\n              }}\r\n              onCancel={() => setShowForm(false)}\r\n            />\r\n          </CardContent>\r\n        </Card>\r\n      )}\r\n\r\n      {/* Table Section */}\r\n      <Card className=\"shadow-sm\">\r\n        <CardHeader className=\"pb-2 md:pb-6\">\r\n          <CardTitle className=\"text-sm md:text-lg\">Carriage Inwards Entries</CardTitle>\r\n        </CardHeader>\r\n        <CardContent className=\"p-0\">\r\n          <CarriageInwardsTable\r\n            carriageInwards={carriageInwards}\r\n            isLoading={isLoading}\r\n            onEdit={canEdit ? handleEdit : undefined}\r\n            onDelete={canDelete ? deleteCarriageInward : undefined}\r\n            onView={handleView}\r\n          />\r\n        </CardContent>\r\n      </Card>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CarriageInwards;\r\n"],"names":[],"mappings":"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"}}]
}