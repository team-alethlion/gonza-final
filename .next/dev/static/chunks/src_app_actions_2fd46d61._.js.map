{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA2EsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qDAAA"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoBsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqGsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoLsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgCsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAiNsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,yDAAA"}},
    {"offset": {"line": 123, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0OsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,2DAAA"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA+PsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,2DAAA"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAmRsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,2DAAA"}},
    {"offset": {"line": 174, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsTsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,2EAAA"}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/finance.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, PaymentStatus, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- EXPENSES ---\r\n\r\nexport interface ExpenseInput {\r\n    amount: number;\r\n    description: string;\r\n    category?: string;\r\n    date: Date;\r\n    paymentMethod?: string;\r\n    personInCharge?: string;\r\n    receiptImage?: string;\r\n    cashAccountId?: string;\r\n    userId: string;\r\n    locationId: string;\r\n}\r\n\r\nexport async function createExpenseAction(data: ExpenseInput, linkToCash: boolean) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // 1. Create the expense\r\n            const expense = await tx.expense.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    amount: data.amount,\r\n                    description: data.description,\r\n                    category: data.category || null,\r\n                    date: data.date,\r\n                    paymentMethod: data.paymentMethod || null,\r\n                    personInCharge: data.personInCharge || null,\r\n                    receiptImage: data.receiptImage || null,\r\n                    cashAccountId: linkToCash && data.cashAccountId ? data.cashAccountId : null\r\n                }\r\n            });\r\n\r\n            // 2. If linking to cash, create a cash transaction\r\n            if (linkToCash && data.cashAccountId) {\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.cashAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: data.category || 'Expense',\r\n                        description: `Expense: ${data.description}`,\r\n                        personInCharge: data.personInCharge || null,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod || null,\r\n                        receiptImage: data.receiptImage || null\r\n                    }\r\n                });\r\n\r\n                // Update expense with transaction reference\r\n                await tx.expense.update({\r\n                    where: { id: expense.id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            }\r\n\r\n            return expense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getExpensesAction(locationId: string) {\r\n    try {\r\n        const expenses = await db.expense.findMany({\r\n            where: { locationId },\r\n            orderBy: { date: 'desc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: expenses.map((e: any) => ({\r\n                ...e,\r\n                created_at: e.createdAt.toISOString(),\r\n                updated_at: e.updatedAt.toISOString(),\r\n                payment_method: e.paymentMethod,\r\n                person_in_charge: e.personInCharge,\r\n                receipt_image: e.receiptImage,\r\n                cash_account_id: e.cashAccountId,\r\n                cash_transaction_id: e.cashTransactionId\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching expenses:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateExpenseAction(id: string, updates: any, currentExpense: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Update expense\r\n            const updatedExpense = await tx.expense.update({\r\n                where: { id },\r\n                data: {\r\n                    amount: updates.amount,\r\n                    description: updates.description,\r\n                    category: updates.category,\r\n                    date: updates.date,\r\n                    paymentMethod: updates.paymentMethod,\r\n                    personInCharge: updates.personInCharge,\r\n                    receiptImage: updates.receiptImage,\r\n                    cashAccountId: updates.cashAccountId || null\r\n                }\r\n            });\r\n\r\n            const shouldLinkToCash = !!updates.cashAccountId;\r\n            const wasLinkedToCash = !!currentExpense.cashTransactionId;\r\n\r\n            if (shouldLinkToCash && !wasLinkedToCash) {\r\n                // Create new cash transaction\r\n                const cashTx = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: currentExpense.userId,\r\n                        locationId: currentExpense.locationId,\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        transactionType: 'cash_out',\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: cashTx.id }\r\n                });\r\n            } else if (shouldLinkToCash && wasLinkedToCash) {\r\n                // Update existing cash transaction\r\n                await tx.cashTransaction.update({\r\n                    where: { id: currentExpense.cashTransactionId },\r\n                    data: {\r\n                        accountId: updates.cashAccountId,\r\n                        amount: updates.amount || currentExpense.amount,\r\n                        category: updates.category || currentExpense.category || 'Expense',\r\n                        description: `Expense: ${updates.description || currentExpense.description}`,\r\n                        personInCharge: updates.personInCharge || currentExpense.personInCharge || null,\r\n                        date: updates.date || currentExpense.date,\r\n                        paymentMethod: updates.paymentMethod || currentExpense.paymentMethod || null,\r\n                        receiptImage: updates.receiptImage || currentExpense.receiptImage || null\r\n                    }\r\n                });\r\n            } else if (!shouldLinkToCash && wasLinkedToCash) {\r\n                // Delete existing cash transaction\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: currentExpense.cashTransactionId }\r\n                });\r\n                await tx.expense.update({\r\n                    where: { id },\r\n                    data: { cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            return updatedExpense;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteExpenseAction(id: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            const expense = await tx.expense.findUnique({\r\n                where: { id },\r\n                select: { cashTransactionId: true }\r\n            });\r\n\r\n            if (expense?.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: expense.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            await tx.expense.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting expense:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH ACCOUNTS ---\r\n\r\nexport async function getCashAccountsAction(locationId: string) {\r\n    try {\r\n        const accounts = await db.cashAccount.findMany({\r\n            where: { locationId },\r\n            orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: accounts.map((a: any) => ({\r\n                id: a.id,\r\n                name: a.name,\r\n                description: a.description,\r\n                openingBalance: Number(a.openingBalance),\r\n                isDefault: a.isDefault,\r\n                createdAt: a.createdAt.toISOString(),\r\n                updatedAt: a.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash accounts:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashAccountAction(data: any) {\r\n    try {\r\n        const result = await db.cashAccount.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                name: data.name,\r\n                description: data.description || null,\r\n                openingBalance: data.openingBalance || 0,\r\n                isDefault: data.isDefault || false\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCashAccountAction(id: string, updates: any) {\r\n    try {\r\n        const result = await db.cashAccount.update({\r\n            where: { id },\r\n            data: {\r\n                name: updates.name,\r\n                description: updates.description,\r\n                openingBalance: updates.openingBalance,\r\n                isDefault: updates.isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountAction(id: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            // Check for transactions\r\n            const txCount = await tx.cashTransaction.count({\r\n                where: { accountId: id, locationId }\r\n            });\r\n\r\n            const expCount = await tx.expense.count({\r\n                where: { cashAccountId: id, locationId }\r\n            });\r\n\r\n            if (txCount > 0 || expCount > 0) {\r\n                return {\r\n                    success: false,\r\n                    hasTransactions: true,\r\n                    details: `Account has ${txCount} transactions and ${expCount} expenses.`\r\n                };\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n\r\n            return { success: true, hasTransactions: false };\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return result;\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashAccountWithTransactionsAction(id: string, locationId: string, deleteTransactions: boolean) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            if (deleteTransactions) {\r\n                // Delete everything\r\n                await tx.cashTransaction.deleteMany({\r\n                    where: { accountId: id, locationId }\r\n                });\r\n                // Expenses are linked, better to just null them out or delete? \r\n                // In original it unlinked expenses.\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            } else {\r\n                // Unlink everything\r\n                await tx.cashTransaction.updateMany({\r\n                    where: { accountId: id, locationId },\r\n                    data: { accountId: null }\r\n                });\r\n                await tx.expense.updateMany({\r\n                    where: { cashAccountId: id, locationId },\r\n                    data: { cashAccountId: null, cashTransactionId: null }\r\n                });\r\n            }\r\n\r\n            await tx.cashAccount.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash account with transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCashAccountBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findUnique({\r\n            where: { id: accountId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        if (!account) return { success: false, error: 'Account not found' };\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where: { accountId, locationId },\r\n            select: { amount: true, transactionType: true }\r\n        });\r\n\r\n        let balance = Number(account.openingBalance);\r\n        for (const tx of transactions) {\r\n            const amount = Number(tx.amount);\r\n            if (tx.transactionType === 'cash_in' || tx.transactionType === 'transfer_in') {\r\n                balance += amount;\r\n            } else if (tx.transactionType === 'cash_out' || tx.transactionType === 'transfer_out') {\r\n                balance -= amount;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: balance };\r\n    } catch (error: any) {\r\n        console.error('Error calculating account balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CASH TRANSACTIONS ---\r\n\r\nexport async function getCashTransactionsAction(locationId: string, accountId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (accountId) where.accountId = accountId;\r\n\r\n        const transactions = await db.cashTransaction.findMany({\r\n            where,\r\n            orderBy: [{ date: 'desc' }, { createdAt: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: transactions.map((t: any) => ({\r\n                ...t,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                user_id: t.userId,\r\n                account_id: t.accountId,\r\n                location_id: t.locationId,\r\n                transaction_type: t.transactionType,\r\n                person_in_charge: t.personInCharge,\r\n                payment_method: t.paymentMethod,\r\n                receipt_image: t.receiptImage\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching cash transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCashTransactionAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                // Create two transactions for a transfer\r\n                const txOut = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_out',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                const txIn = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.toAccountId,\r\n                        amount: data.amount,\r\n                        transactionType: 'transfer_in',\r\n                        description: data.description,\r\n                        date: data.date,\r\n                        category: data.category || 'Transfer'\r\n                    }\r\n                });\r\n\r\n                return [txOut, txIn];\r\n            } else {\r\n                const transaction = await tx.cashTransaction.create({\r\n                    data: {\r\n                        userId: data.userId,\r\n                        locationId: data.locationId,\r\n                        accountId: data.accountId,\r\n                        amount: data.amount,\r\n                        transactionType: data.transactionType,\r\n                        category: data.category,\r\n                        description: data.description,\r\n                        person_in_charge: data.personInCharge,\r\n                        tags: data.tags,\r\n                        date: data.date,\r\n                        paymentMethod: data.paymentMethod,\r\n                        receiptImage: data.receiptImage\r\n                    }\r\n                });\r\n                return transaction;\r\n            }\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCashTransactionAction(id: string, locationId: string) {\r\n    try {\r\n        await db.$transaction(async (tx: any) => {\r\n            // Check for installment payments linked to this transaction\r\n            await tx.installmentPayment.updateMany({\r\n                where: { cashTransactionId: id },\r\n                data: { cashTransactionId: null }\r\n            });\r\n\r\n            await tx.cashTransaction.delete({\r\n                where: { id, locationId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting cash transaction:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getAccountOpeningBalanceAction(accountId: string, locationId: string) {\r\n    try {\r\n        const account = await db.cashAccount.findFirst({\r\n            where: { id: accountId, locationId },\r\n            select: { openingBalance: true }\r\n        });\r\n\r\n        return { success: true, data: Number(account?.openingBalance || 0) };\r\n    } catch (error: any) {\r\n        console.error('Error fetching opening balance:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createBulkCashTransactionsAction(transactions: any[]) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const created = [];\r\n            for (const data of transactions) {\r\n                if (data.transactionType === 'transfer' && data.toAccountId) {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_out',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.toAccountId,\r\n                            amount: data.amount,\r\n                            transactionType: 'transfer_in',\r\n                            description: data.description,\r\n                            date: data.date,\r\n                            category: data.category || 'Transfer'\r\n                        }\r\n                    }));\r\n                } else {\r\n                    created.push(await tx.cashTransaction.create({\r\n                        data: {\r\n                            userId: data.userId,\r\n                            locationId: data.locationId,\r\n                            accountId: data.accountId,\r\n                            amount: data.amount,\r\n                            transactionType: data.transactionType,\r\n                            category: data.category,\r\n                            description: data.description,\r\n                            person_in_charge: data.personInCharge,\r\n                            tags: data.tags,\r\n                            date: data.date,\r\n                            paymentMethod: data.paymentMethod,\r\n                            receiptImage: data.receiptImage\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            return created;\r\n        });\r\n\r\n        revalidatePath('/finance');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating bulk transactions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA6VsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+DAAA"}}]
}