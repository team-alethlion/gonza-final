{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useBusinessSettings.ts"],"sourcesContent":["\r\nimport { useState, useEffect } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { getBusinessSettingsAction, upsertBusinessSettingsAction } from '@/app/actions/business-settings';\r\n\r\nexport interface BusinessSettings {\r\n  id?: string;\r\n  businessName: string;\r\n  businessAddress: string;\r\n  businessPhone: string;\r\n  businessEmail: string;\r\n  businessLogo?: string;\r\n  currency: string;\r\n  signature?: string;\r\n  paymentInfo?: string;\r\n  defaultPrintFormat?: 'standard' | 'thermal';\r\n  defaultPrinterName?: string;\r\n  defaultPrinterType?: 'USB' | 'Bluetooth';\r\n  printerPaperSize?: '58mm' | '80mm';\r\n}\r\n\r\n// Utility function to parse payment info text into structured format\r\nexport const parsePaymentInfo = (paymentInfo: string): { method: string, accountNumber: string, accountName: string }[] => {\r\n  if (!paymentInfo || paymentInfo.trim() === '') {\r\n    return [];\r\n  }\r\n\r\n  const lines = paymentInfo.split('\\n').filter(line => line.trim() !== '');\r\n  const methods: { method: string, accountNumber: string, accountName: string }[] = [];\r\n\r\n  for (let i = 0; i < lines.length; i += 3) {\r\n    if (i + 2 < lines.length) {\r\n      methods.push({\r\n        method: lines[i].trim(),\r\n        accountNumber: lines[i + 1].trim(),\r\n        accountName: lines[i + 2].trim()\r\n      });\r\n    }\r\n  }\r\n\r\n  return methods;\r\n};\r\n\r\n// Utility function to convert payment methods array back to string format\r\nexport const convertPaymentMethodsToString = (paymentMethods: { method: string, accountNumber: string, accountName: string }[]): string => {\r\n  return paymentMethods\r\n    .filter(pm => pm.method.trim() !== '' || pm.accountNumber.trim() !== '' || pm.accountName.trim() !== '')\r\n    .map(pm => `${pm.method}\\n${pm.accountNumber}\\n${pm.accountName}`)\r\n    .join('\\n');\r\n};\r\n\r\n// Default settings for new businesses\r\nconst getDefaultSettings = (): BusinessSettings => ({\r\n  businessName: '',\r\n  businessAddress: '',\r\n  businessPhone: '',\r\n  businessEmail: '',\r\n  currency: 'UGX',\r\n  paymentInfo: '',\r\n  defaultPrintFormat: 'standard'\r\n});\r\n\r\nexport const useBusinessSettings = () => {\r\n  const [settings, setSettings] = useState<BusinessSettings>(getDefaultSettings());\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const loadSettings = async (): Promise<BusinessSettings> => {\r\n    if (!currentBusiness) {\r\n      return getDefaultSettings();\r\n    }\r\n\r\n    try {\r\n      const data = await getBusinessSettingsAction(currentBusiness.id);\r\n\r\n      if (data) {\r\n        // Extract payment info from metadata\r\n        const paymentInfo = data.metadata && typeof data.metadata === 'object' ?\r\n          (data.metadata as Record<string, unknown>).payment_info as string || '' : '';\r\n\r\n        return {\r\n          id: data.id,\r\n          businessName: data.business_name,\r\n          businessAddress: data.business_address,\r\n          businessPhone: data.business_phone,\r\n          businessEmail: data.business_email,\r\n          businessLogo: data.business_logo,\r\n          currency: data.currency,\r\n          signature: data.signature,\r\n          paymentInfo: paymentInfo,\r\n          defaultPrintFormat: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_print_format as 'standard' | 'thermal' || 'standard' : 'standard',\r\n          defaultPrinterName: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_name as string || '' : '',\r\n          defaultPrinterType: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_type as 'USB' | 'Bluetooth' || 'USB' : 'USB',\r\n          printerPaperSize: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).printer_paper_size as '58mm' | '80mm' || '58mm' : '58mm'\r\n        };\r\n      } else {\r\n        return getDefaultSettings();\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return getDefaultSettings();\r\n    }\r\n  };\r\n\r\n  const updateSettings = async (newSettings: Partial<BusinessSettings>) => {\r\n    if (!currentBusiness) {\r\n      console.error('No business selected for updating settings');\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"No business selected\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const userData = { user: { id: '00000000-0000-0000-0000-000000000000' } }; // Mocked user id for now\r\n\r\n      // Prepare the metadata object with payment info\r\n      const metadata = {\r\n        payment_info: newSettings.hasOwnProperty('paymentInfo') ? newSettings.paymentInfo : settings.paymentInfo || '',\r\n        default_print_format: newSettings.hasOwnProperty('defaultPrintFormat') ? newSettings.defaultPrintFormat : settings.defaultPrintFormat || 'standard',\r\n        default_printer_name: newSettings.hasOwnProperty('defaultPrinterName') ? newSettings.defaultPrinterName : settings.defaultPrinterName || '',\r\n        default_printer_type: newSettings.hasOwnProperty('defaultPrinterType') ? newSettings.defaultPrinterType : settings.defaultPrinterType || 'USB',\r\n        printer_paper_size: newSettings.hasOwnProperty('printerPaperSize') ? newSettings.printerPaperSize : settings.printerPaperSize || '58mm'\r\n      };\r\n\r\n      const updateData = {\r\n        business_name: newSettings.hasOwnProperty('businessName') ? newSettings.businessName : settings.businessName,\r\n        business_address: newSettings.hasOwnProperty('businessAddress') ? newSettings.businessAddress : settings.businessAddress,\r\n        business_phone: newSettings.hasOwnProperty('businessPhone') ? newSettings.businessPhone : settings.businessPhone,\r\n        business_email: newSettings.hasOwnProperty('businessEmail') ? newSettings.businessEmail : settings.businessEmail,\r\n        business_logo: newSettings.hasOwnProperty('businessLogo') ? newSettings.businessLogo : settings.businessLogo,\r\n        currency: newSettings.hasOwnProperty('currency') ? newSettings.currency : settings.currency,\r\n        signature: newSettings.hasOwnProperty('signature') ? newSettings.signature : settings.signature,\r\n        metadata: metadata\r\n      };\r\n\r\n      const response = await upsertBusinessSettingsAction(currentBusiness.id, userData.user.id, updateData);\r\n\r\n      if (!response.success) {\r\n        console.error('Supabase error updating business settings:', response.error);\r\n        throw new Error(response.error);\r\n      }\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Business settings updated successfully\"\r\n      });\r\n\r\n      // Refetch settings after update\r\n      refetch();\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // React Query for settings loading with proper caching\r\n  const { data: queriedData, isLoading: isQueryLoading, isFetching, refetch } = useQuery({\r\n    queryKey: ['businessSettings', currentBusiness?.id],\r\n    queryFn: loadSettings,\r\n    enabled: !!currentBusiness?.id,\r\n    staleTime: 5 * 60_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: false,\r\n    refetchOnReconnect: false,\r\n  });\r\n\r\n  // Sync React Query data with local state\r\n  useEffect(() => {\r\n    if (queriedData) {\r\n      setSettings(queriedData);\r\n    } else if (!currentBusiness) {\r\n      setSettings(getDefaultSettings());\r\n    }\r\n  }, [queriedData, currentBusiness]);\r\n\r\n  // Sync loading state from React Query\r\n  useEffect(() => {\r\n    setIsLoading(isQueryLoading || isFetching);\r\n  }, [isQueryLoading, isFetching]);\r\n\r\n  return {\r\n    settings,\r\n    isLoading,\r\n    updateSettings,\r\n    loadSettings\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useStockHistory.ts"],"sourcesContent":["\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { StockHistoryEntry } from '@/types';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\n\r\nexport interface ChainRepairBreakEntry {\r\n  entryId: string;\r\n  createdAt: string;\r\n  changeReason: string;\r\n  currentPrevQty: number;\r\n  currentNewQty: number;\r\n  fixedPrevQty: number;\r\n  fixedNewQty: number;\r\n}\r\n\r\nexport interface ChainRepairPreview {\r\n  productId: string;\r\n  productName: string;\r\n  totalEntries: number;\r\n  brokenEntries: ChainRepairBreakEntry[];\r\n  finalFixedQty: number;\r\n  currentProductQty: number;\r\n}\r\n\r\nexport const useStockHistory = (userId: string | undefined, productId?: string) => {\r\n  const [stockHistory, setStockHistory] = useState<StockHistoryEntry[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  // Memoize the load function to prevent infinite re-renders\r\n  const loadStockHistory = useCallback(async () => {\r\n    if (!userId || !currentBusiness) {\r\n      setStockHistory([]);\r\n      setIsLoading(false);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setIsLoading(true);\r\n      // Fetch all stock history without any limits\r\n      // We'll implement a recursive fetch to get all records\r\n      let allData: any[] = [];\r\n      let hasMore = true;\r\n      let offset = 0;\r\n      const batchSize = 1000; // Fetch in smaller, more manageable batches\r\n\r\n      while (hasMore) {\r\n        let query = supabase\r\n          .from('stock_history')\r\n          .select('*, products(name, cost_price, selling_price, item_number)')\r\n          .eq('location_id', currentBusiness.id)\r\n          .order('created_at', { ascending: true })\r\n          .order('id', { ascending: true })\r\n          .range(offset, offset + batchSize - 1);\r\n\r\n        // If productId is provided, filter by it\r\n        if (productId) {\r\n          query = query.eq('product_id', productId);\r\n        }\r\n\r\n        const { data: batchData, error: batchError } = await query;\r\n\r\n        if (batchError) {\r\n          throw batchError;\r\n        }\r\n\r\n        if (batchData && batchData.length > 0) {\r\n          allData = [...allData, ...batchData];\r\n\r\n          // If we got less than the batch size, we've reached the end\r\n          if (batchData.length < batchSize) {\r\n            hasMore = false;\r\n          } else {\r\n            offset += batchSize;\r\n          }\r\n        } else {\r\n          hasMore = false;\r\n        }\r\n      }\r\n\r\n      const data = allData;\r\n\r\n      // Remove the individual query as it's now handled in the batch loop above\r\n      const error = null; // No error if we reached this point\r\n\r\n      if (error) {\r\n        throw error;\r\n      }\r\n\r\n      if (data) {\r\n        const formattedHistory: StockHistoryEntry[] = data.map(entry => {\r\n          const productData = entry.products;\r\n          return {\r\n            id: entry.id,\r\n            productId: entry.product_id,\r\n            oldQuantity: entry.previous_quantity,\r\n            newQuantity: entry.new_quantity,\r\n            changeReason: entry.change_reason,\r\n            createdAt: new Date(entry.created_at),\r\n            referenceId: entry.reference_id,\r\n            receiptNumber: entry.receipt_number,\r\n            product: productData ? {\r\n              name: productData.name,\r\n              costPrice: productData.cost_price,\r\n              sellingPrice: productData.selling_price,\r\n              itemNumber: productData.item_number\r\n            } : undefined\r\n          };\r\n        });\r\n        // Reverse for display (newest first for UI)\r\n        setStockHistory(formattedHistory.reverse());\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading stock history:', error);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [userId, currentBusiness, productId]);\r\n\r\n  useEffect(() => {\r\n    loadStockHistory();\r\n  }, [loadStockHistory]);\r\n\r\n  // Create stock history entry with standardized reasons and recalculate stock chain\r\n  const createStockHistoryEntry = async (\r\n    productId: string,\r\n    previousQuantity: number,\r\n    newQuantity: number,\r\n    reason: string,\r\n    referenceId?: string,\r\n    entryDate?: Date,\r\n    receiptNumber?: string,\r\n    productName?: string\r\n  ) => {\r\n    console.log('ðŸ“ createStockHistoryEntry CALLED', {\r\n      productId,\r\n      productName,\r\n      prevQty: previousQuantity,\r\n      newQty: newQuantity,\r\n      reason,\r\n      refId: referenceId,\r\n      receipt: receiptNumber,\r\n      entryDate: entryDate?.toISOString(),\r\n      stack: new Error().stack\r\n    });\r\n\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      // Prefix reason with product name for future retrieval if product is deleted\r\n      const snapshottedReason = productName\r\n        ? `[${productName}] | ${reason}`\r\n        : reason;\r\n\r\n      const insertData: any = {\r\n        user_id: userId,\r\n        product_id: productId,\r\n        previous_quantity: previousQuantity,\r\n        new_quantity: newQuantity,\r\n        change_reason: snapshottedReason,\r\n        reference_id: referenceId,\r\n        receipt_number: receiptNumber,\r\n        location_id: currentBusiness.id\r\n      };\r\n\r\n      // ONLY use explicit date if provided AND it includes a real time component\r\n      // Otherwise let database use now() to avoid midnight UTC issues (which show as 3:00 AM in EAT)\r\n      if (entryDate) {\r\n        const hours = entryDate.getHours();\r\n        const minutes = entryDate.getMinutes();\r\n        const seconds = entryDate.getSeconds();\r\n\r\n        // Skip midnight (00:00:00) - this is from date pickers, let DB use now() instead\r\n        // Also skip noon (12:00:00) from our date picker fix - let DB use now()\r\n        const isMidnight = hours === 0 && minutes === 0 && seconds === 0;\r\n        const isNoon = hours === 12 && minutes === 0 && seconds === 0;\r\n\r\n        if (!isMidnight && !isNoon) {\r\n          insertData.created_at = entryDate.toISOString();\r\n        }\r\n        // If it's midnight or noon, don't set created_at - let DB use now() for accurate timestamp\r\n      }\r\n\r\n      const { error } = await supabase\r\n        .from('stock_history')\r\n        .insert(insertData);\r\n\r\n      if (error) {\r\n        console.error('Error creating stock history entry:', error);\r\n        return false;\r\n      }\r\n\r\n      // Chain recalculation disabled to prevent cascading errors\r\n      // Use the Reconciliation tool to fix stock discrepancies instead\r\n      // const recalcSuccess = await recalculateStockChain(productId);\r\n\r\n      // Refresh stock history after creating new entry\r\n      await loadStockHistory();\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error creating stock history:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Update stock history entry and recalculate all subsequent entries\r\n  const updateStockHistoryEntry = async (\r\n    entryId: string,\r\n    newQuantity: number,\r\n    newChangeReason: string,\r\n    newDate?: Date\r\n  ) => {\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      // First, get the current entry to understand the change\r\n      const { data: currentEntry, error: fetchError } = await supabase\r\n        .from('stock_history')\r\n        .select('*')\r\n        .eq('id', entryId)\r\n        .single();\r\n\r\n      if (fetchError || !currentEntry) {\r\n        console.error('Error fetching current entry:', fetchError);\r\n        return false;\r\n      }\r\n\r\n      // Check if this is the initial stock entry by getting all stock history for this product\r\n      const { data: allStockHistory, error: stockHistoryError } = await supabase\r\n        .from('stock_history')\r\n        .select('*')\r\n        .eq('product_id', currentEntry.product_id)\r\n        .eq('location_id', currentBusiness.id)\r\n        .order('created_at', { ascending: true })\r\n        .order('id', { ascending: true });\r\n\r\n      if (stockHistoryError || !allStockHistory) {\r\n        console.error('Error fetching stock history:', stockHistoryError);\r\n        return false;\r\n      }\r\n\r\n      const isInitialStock = allStockHistory.length > 0 && allStockHistory[0].id === entryId;\r\n\r\n      // Update the current entry\r\n      const updateData: any = {\r\n        new_quantity: newQuantity,\r\n        change_reason: newChangeReason,\r\n      };\r\n\r\n      if (newDate) {\r\n        // Use toISOString() to preserve the exact local time without timezone conversion\r\n        updateData.created_at = newDate.toISOString();\r\n      }\r\n\r\n      const { error: updateError } = await supabase\r\n        .from('stock_history')\r\n        .update(updateData)\r\n        .eq('id', entryId);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating stock history entry:', updateError);\r\n        return false;\r\n      }\r\n\r\n      // If this is initial stock and date is being updated, also update product creation date\r\n      if (isInitialStock && newDate) {\r\n        const { error: productDateUpdateError } = await supabase\r\n          .from('products')\r\n          .update({ created_at: newDate.toISOString() })\r\n          .eq('id', currentEntry.product_id);\r\n\r\n        if (productDateUpdateError) {\r\n          console.error('Error updating product creation date:', productDateUpdateError);\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Use the already fetched stock history to avoid duplicate queries\r\n      const allHistory = allStockHistory;\r\n\r\n      // Find the index of the updated entry\r\n      const updatedEntryIndex = allHistory.findIndex(entry => entry.id === entryId);\r\n      if (updatedEntryIndex === -1) return false;\r\n\r\n      // Calculate the user's intended change amount for the edited entry\r\n      const userChangeAmount = newQuantity - currentEntry.previous_quantity;\r\n\r\n      // Recalculate the entire chain from the beginning\r\n      const updatesToMake = [];\r\n      let runningQuantity = 0; // Start from initial stock of 0\r\n\r\n      for (let i = 0; i < allHistory.length; i++) {\r\n        const entry = allHistory[i];\r\n\r\n        if (i === updatedEntryIndex) {\r\n          // For the updated entry, preserve the user's intended change amount\r\n          const newPreviousQuantity = runningQuantity;\r\n          const newNewQuantity = newPreviousQuantity + userChangeAmount;\r\n\r\n          // Update both previous and new quantities to preserve user's change amount\r\n          if (entry.previous_quantity !== newPreviousQuantity || entry.new_quantity !== newNewQuantity) {\r\n            updatesToMake.push({\r\n              id: entry.id,\r\n              previous_quantity: newPreviousQuantity,\r\n              new_quantity: newNewQuantity\r\n            });\r\n          }\r\n\r\n          runningQuantity = newNewQuantity;\r\n        } else {\r\n          // For all other entries, recalculate based on their original change amount\r\n          const originalChange = entry.new_quantity - entry.previous_quantity;\r\n          const newPreviousQuantity = runningQuantity;\r\n          const newNewQuantity = newPreviousQuantity + originalChange;\r\n\r\n          // Only update if values have changed\r\n          if (entry.previous_quantity !== newPreviousQuantity || entry.new_quantity !== newNewQuantity) {\r\n            updatesToMake.push({\r\n              id: entry.id,\r\n              previous_quantity: newPreviousQuantity,\r\n              new_quantity: newNewQuantity\r\n            });\r\n          }\r\n\r\n          runningQuantity = newNewQuantity;\r\n        }\r\n      }\r\n\r\n      // Perform batch updates for all subsequent entries\r\n      if (updatesToMake.length > 0) {\r\n        for (const update of updatesToMake) {\r\n          const { error: batchUpdateError } = await supabase\r\n            .from('stock_history')\r\n            .update({\r\n              previous_quantity: update.previous_quantity,\r\n              new_quantity: update.new_quantity\r\n            })\r\n            .eq('id', update.id);\r\n\r\n          if (batchUpdateError) {\r\n            console.error('Error updating subsequent entry:', batchUpdateError);\r\n            // Continue with other updates even if one fails\r\n          }\r\n        }\r\n      }\r\n\r\n      // Update the final product quantity\r\n      const finalQuantity = runningQuantity;\r\n\r\n      const { error: productUpdateError } = await supabase\r\n        .from('products')\r\n        .update({ quantity: finalQuantity })\r\n        .eq('id', currentEntry.product_id);\r\n\r\n      if (productUpdateError) {\r\n        console.error('Error updating product quantity:', productUpdateError);\r\n        return false;\r\n      }\r\n\r\n      // Refresh stock history to show updated chain\r\n      await loadStockHistory();\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating stock history:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Delete multiple stock history entries (for bulk operations like deleting entire invoice)\r\n  const deleteMultipleStockHistoryEntries = async (entryIds: string[]) => {\r\n    try {\r\n      if (!userId || !currentBusiness || entryIds.length === 0) return false;\r\n\r\n      // Get all entries to be deleted\r\n      const { data: entriesToDelete, error: fetchError } = await supabase\r\n        .from('stock_history')\r\n        .select('*')\r\n        .in('id', entryIds);\r\n\r\n      if (fetchError || !entriesToDelete) {\r\n        console.error('Error fetching entries to delete:', fetchError);\r\n        return false;\r\n      }\r\n\r\n      // Group entries by product_id to handle recalculation properly\r\n      const entriesByProduct = entriesToDelete.reduce((acc, entry) => {\r\n        if (!acc[entry.product_id]) {\r\n          acc[entry.product_id] = [];\r\n        }\r\n        acc[entry.product_id].push(entry);\r\n        return acc;\r\n      }, {} as Record<string, typeof entriesToDelete>);\r\n\r\n      // Delete all entries in a single batch\r\n      const { error: deleteError } = await supabase\r\n        .from('stock_history')\r\n        .delete()\r\n        .in('id', entryIds);\r\n\r\n      if (deleteError) {\r\n        console.error('Error deleting stock history entries:', deleteError);\r\n        return false;\r\n      }\r\n\r\n      // Re-enable chain recalculation for affected products only.\r\n      // We only recalculate the specific product IDs that were deleted â€” not all products.\r\n      for (const productId of Object.keys(entriesByProduct)) {\r\n        await recalculateStockChain(productId);\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting multiple stock history entries:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Delete stock history entry and recalculate all subsequent entries\r\n  const deleteStockHistoryEntry = async (entryId: string) => {\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      // First, get the entry to be deleted\r\n      const { data: entryToDelete, error: fetchError } = await supabase\r\n        .from('stock_history')\r\n        .select('*')\r\n        .eq('id', entryId)\r\n        .single();\r\n\r\n      if (fetchError || !entryToDelete) {\r\n        console.error('Error fetching entry to delete:', fetchError);\r\n        return false;\r\n      }\r\n\r\n      // Get all stock history for this product in chronological order\r\n      const { data: allHistory, error: historyError } = await supabase\r\n        .from('stock_history')\r\n        .select('*')\r\n        .eq('product_id', entryToDelete.product_id)\r\n        .eq('location_id', currentBusiness.id)\r\n        .order('created_at', { ascending: true })\r\n        .order('id', { ascending: true });\r\n\r\n      if (historyError || !allHistory) {\r\n        console.error('Error fetching stock history:', historyError);\r\n        return false;\r\n      }\r\n\r\n      // Find the index of the entry to delete\r\n      const deleteIndex = allHistory.findIndex(entry => entry.id === entryId);\r\n      if (deleteIndex === -1) return false;\r\n\r\n      // Delete the entry\r\n      const { error: deleteError } = await supabase\r\n        .from('stock_history')\r\n        .delete()\r\n        .eq('id', entryId);\r\n\r\n      if (deleteError) {\r\n        console.error('Error deleting stock history entry:', deleteError);\r\n        return false;\r\n      }\r\n\r\n      // Recalculate all subsequent entries\r\n      const updatesToMake = [];\r\n\r\n      // If this was the first entry, the next entry's previous_quantity should be 0\r\n      // If this was a middle entry, the next entry's previous_quantity should be the previous entry's new_quantity\r\n      let newPreviousQuantity = 0;\r\n      if (deleteIndex > 0) {\r\n        newPreviousQuantity = allHistory[deleteIndex - 1].new_quantity;\r\n      }\r\n\r\n      // Recalculate all entries after the deleted one\r\n      for (let i = deleteIndex + 1; i < allHistory.length; i++) {\r\n        const entry = allHistory[i];\r\n        const originalChange = entry.new_quantity - entry.previous_quantity;\r\n        const newNewQuantity = newPreviousQuantity + originalChange;\r\n\r\n        updatesToMake.push({\r\n          id: entry.id,\r\n          previous_quantity: newPreviousQuantity,\r\n          new_quantity: newNewQuantity\r\n        });\r\n\r\n        newPreviousQuantity = newNewQuantity;\r\n      }\r\n\r\n      // Perform batch updates for all subsequent entries\r\n      if (updatesToMake.length > 0) {\r\n        for (const update of updatesToMake) {\r\n          const { error: batchUpdateError } = await supabase\r\n            .from('stock_history')\r\n            .update({\r\n              previous_quantity: update.previous_quantity,\r\n              new_quantity: update.new_quantity\r\n            })\r\n            .eq('id', update.id);\r\n\r\n          if (batchUpdateError) {\r\n            console.error('Error updating subsequent entry:', batchUpdateError);\r\n            // Continue with other updates even if one fails\r\n          }\r\n        }\r\n      }\r\n\r\n      // Update the final product quantity\r\n      const finalQuantity = updatesToMake.length > 0\r\n        ? updatesToMake[updatesToMake.length - 1].new_quantity\r\n        : (deleteIndex > 0 ? allHistory[deleteIndex - 1].new_quantity : 0);\r\n\r\n      const { error: productUpdateError } = await supabase\r\n        .from('products')\r\n        .update({ quantity: finalQuantity })\r\n        .eq('id', entryToDelete.product_id);\r\n\r\n      if (productUpdateError) {\r\n        console.error('Error updating product quantity:', productUpdateError);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting stock history:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Recalculate the entire stock chain for a product to maintain proper flow\r\n  const recalculateStockChain = async (productId: string) => {\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      // Get all stock history for this product in chronological order\r\n      const { data: allHistory, error: historyError } = await supabase\r\n        .from('stock_history')\r\n        .select('*')\r\n        .eq('product_id', productId)\r\n        .eq('location_id', currentBusiness.id)\r\n        .order('created_at', { ascending: true })\r\n        .order('id', { ascending: true });\r\n\r\n      if (historyError || !allHistory) {\r\n        console.error('Error fetching stock history for recalculation:', historyError);\r\n        return false;\r\n      }\r\n\r\n      if (allHistory.length === 0) return true;\r\n\r\n      // Recalculate the entire chain from the beginning\r\n      const updatesToMake = [];\r\n      let runningQuantity = 0; // Start from initial stock of 0\r\n\r\n      for (let i = 0; i < allHistory.length; i++) {\r\n        const entry = allHistory[i];\r\n\r\n        // Calculate the original change amount for this entry\r\n        const originalChange = entry.new_quantity - entry.previous_quantity;\r\n\r\n        // Set the correct previous quantity and recalculated new quantity\r\n        const newPreviousQuantity = runningQuantity;\r\n        const newNewQuantity = newPreviousQuantity + originalChange;\r\n\r\n        // Only update if values have changed\r\n        if (entry.previous_quantity !== newPreviousQuantity || entry.new_quantity !== newNewQuantity) {\r\n          updatesToMake.push({\r\n            id: entry.id,\r\n            previous_quantity: newPreviousQuantity,\r\n            new_quantity: newNewQuantity\r\n          });\r\n        }\r\n\r\n        runningQuantity = newNewQuantity;\r\n      }\r\n\r\n      // Perform batch updates for all entries that need updating\r\n      if (updatesToMake.length > 0) {\r\n        for (const update of updatesToMake) {\r\n          const { error: batchUpdateError } = await supabase\r\n            .from('stock_history')\r\n            .update({\r\n              previous_quantity: update.previous_quantity,\r\n              new_quantity: update.new_quantity\r\n            })\r\n            .eq('id', update.id);\r\n\r\n          if (batchUpdateError) {\r\n            console.error('Error updating entry during chain recalculation:', batchUpdateError);\r\n            // Continue with other updates even if one fails\r\n          }\r\n        }\r\n      }\r\n\r\n      // Update the final product quantity\r\n      const finalQuantity = runningQuantity;\r\n\r\n      const { error: productUpdateError } = await supabase\r\n        .from('products')\r\n        .update({ quantity: finalQuantity })\r\n        .eq('id', productId);\r\n\r\n      if (productUpdateError) {\r\n        console.error('Error updating product quantity during chain recalculation:', productUpdateError);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error recalculating stock chain:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Recalculate product stock based on remaining history\r\n  // Update stock history dates for a specific sale\r\n  const updateStockHistoryDatesBySaleId = async (saleId: string, newDate: Date) => {\r\n    try {\r\n      if (!userId || !currentBusiness) {\r\n        console.log('Missing userId or currentBusiness for stock history update');\r\n        return false;\r\n      }\r\n\r\n      console.log('Updating stock history dates for sale:', saleId, 'to date:', newDate);\r\n\r\n      // Find all stock history entries with this sale as reference_id\r\n      const { data: stockEntries, error: fetchError } = await supabase\r\n        .from('stock_history')\r\n        .select('*')\r\n        .eq('reference_id', saleId)\r\n        .eq('location_id', currentBusiness.id);\r\n\r\n      if (fetchError) {\r\n        console.error('Error fetching stock history entries for sale:', fetchError);\r\n        return false;\r\n      }\r\n\r\n      console.log('Found stock history entries for sale:', stockEntries?.length || 0);\r\n\r\n      if (!stockEntries || stockEntries.length === 0) {\r\n        console.log('No stock entries found for sale:', saleId);\r\n        return true; // No stock entries to update\r\n      }\r\n\r\n      // Group entries by product_id to handle recalculation properly\r\n      const entriesByProduct = stockEntries.reduce((acc, entry) => {\r\n        if (!acc[entry.product_id]) {\r\n          acc[entry.product_id] = [];\r\n        }\r\n        acc[entry.product_id].push(entry);\r\n        return acc;\r\n      }, {} as Record<string, typeof stockEntries>);\r\n\r\n      // Update each stock history entry's date\r\n      for (const entry of stockEntries) {\r\n        console.log('Updating stock history entry:', entry.id, 'from date:', entry.created_at, 'to:', newDate.toISOString());\r\n\r\n        const { error: updateError } = await supabase\r\n          .from('stock_history')\r\n          .update({ created_at: newDate.toISOString() })\r\n          .eq('id', entry.id);\r\n\r\n        if (updateError) {\r\n          console.error('Error updating stock history date:', updateError);\r\n          return false;\r\n        }\r\n      }\r\n\r\n      console.log('Successfully updated', stockEntries.length, 'stock history entries');\r\n\r\n      // Re-run chain recalculation for each affected product after date reorder.\r\n      // Date changes can reorder entries in the chain so recalculation is mandatory.\r\n      for (const productId of Object.keys(entriesByProduct)) {\r\n        const recalcSuccess = await recalculateStockChain(productId);\r\n        if (!recalcSuccess) {\r\n          console.error('Failed to recalculate stock chain for product:', productId);\r\n        }\r\n      }\r\n\r\n      // Refresh stock history to reflect the updated dates\r\n      await loadStockHistory();\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating stock history dates by sale ID:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const recalculateProductStock = async (productId: string) => {\r\n    try {\r\n      if (!userId || !currentBusiness) return null;\r\n\r\n      // Get all stock history for this product in chronological order\r\n      const { data, error } = await supabase\r\n        .from('stock_history')\r\n        .select('*')\r\n        .eq('product_id', productId)\r\n        .eq('location_id', currentBusiness.id)\r\n        .order('created_at', { ascending: true })\r\n        .order('id', { ascending: true });\r\n\r\n      if (error) {\r\n        console.error('Error fetching stock history for recalculation:', error);\r\n        return null;\r\n      }\r\n\r\n      // Calculate final stock quantity from history\r\n      let currentStock = 0;\r\n      if (data && data.length > 0) {\r\n        // Start with the first entry's new quantity\r\n        currentStock = data[0].new_quantity;\r\n\r\n        // Process remaining entries sequentially\r\n        for (let i = 1; i < data.length; i++) {\r\n          const entry = data[i];\r\n          const previousEntry = data[i - 1];\r\n\r\n          // Calculate the change based on the difference\r\n          const change = entry.new_quantity - entry.previous_quantity;\r\n          currentStock = previousEntry.new_quantity + change;\r\n        }\r\n\r\n        // The final stock is the new_quantity of the last entry\r\n        if (data.length > 0) {\r\n          currentStock = data[data.length - 1].new_quantity;\r\n        }\r\n      }\r\n\r\n      // Update the product's quantity\r\n      const { error: updateError } = await supabase\r\n        .from('products')\r\n        .update({ quantity: currentStock })\r\n        .eq('id', productId);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating product quantity:', updateError);\r\n        return null;\r\n      }\r\n\r\n      return currentStock;\r\n    } catch (error) {\r\n      console.error('Error recalculating product stock:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Dry-run preview: walks every product's stock chain and returns the list of\r\n   * products that have broken chains, with per-product detail.\r\n   * Does NOT write anything to the database.\r\n   */\r\n  const previewStockChainRepairs = async (\r\n    onProgress?: (current: number, total: number) => void\r\n  ): Promise<ChainRepairPreview[]> => {\r\n    if (!userId || !currentBusiness) return [];\r\n\r\n    // Collect all distinct product IDs in this business's stock history\r\n    let allProductIds: string[] = [];\r\n    let offset = 0;\r\n    const batch = 1000;\r\n    let hasMore = true;\r\n\r\n    while (hasMore) {\r\n      const { data, error } = await supabase\r\n        .from('stock_history')\r\n        .select('product_id')\r\n        .eq('location_id', currentBusiness.id)\r\n        .range(offset, offset + batch - 1);\r\n\r\n      if (error) {\r\n        console.error('previewStockChainRepairs: error fetching product IDs', error);\r\n        break;\r\n      }\r\n\r\n      if (data && data.length > 0) {\r\n        allProductIds.push(...data.map((r: any) => r.product_id));\r\n        offset += batch;\r\n        hasMore = data.length === batch;\r\n      } else {\r\n        hasMore = false;\r\n      }\r\n    }\r\n\r\n    const uniqueProductIds = [...new Set(allProductIds)];\r\n    const total = uniqueProductIds.length;\r\n    const broken: ChainRepairPreview[] = [];\r\n\r\n    for (let i = 0; i < uniqueProductIds.length; i++) {\r\n      const productId = uniqueProductIds[i];\r\n\r\n      const { data: allHistory, error: historyError } = await supabase\r\n        .from('stock_history')\r\n        .select('*')\r\n        .eq('product_id', productId)\r\n        .eq('location_id', currentBusiness.id)\r\n        .order('created_at', { ascending: true })\r\n        .order('id', { ascending: true });\r\n\r\n      if (historyError || !allHistory || allHistory.length === 0) {\r\n        onProgress?.(i + 1, total);\r\n        continue;\r\n      }\r\n\r\n      // Fetch product name separately to avoid TS join-resolution issues\r\n      let productName = productId;\r\n      const { data: productRow } = await supabase\r\n        .from('products')\r\n        .select('name')\r\n        .eq('id', productId)\r\n        .maybeSingle();\r\n      if (productRow?.name) productName = productRow.name;\r\n      const brokenEntries: ChainRepairPreview['brokenEntries'] = [];\r\n      let runningQuantity = 0;\r\n\r\n      for (const entry of allHistory) {\r\n        const originalChange = entry.new_quantity - entry.previous_quantity;\r\n        const expectedPrev = runningQuantity;\r\n        const expectedNew = runningQuantity + originalChange;\r\n\r\n        if (entry.previous_quantity !== expectedPrev || entry.new_quantity !== expectedNew) {\r\n          brokenEntries.push({\r\n            entryId: entry.id,\r\n            createdAt: entry.created_at,\r\n            changeReason: entry.change_reason ?? '',\r\n            currentPrevQty: entry.previous_quantity,\r\n            currentNewQty: entry.new_quantity,\r\n            fixedPrevQty: expectedPrev,\r\n            fixedNewQty: expectedNew,\r\n          });\r\n        }\r\n\r\n        runningQuantity = expectedNew;\r\n      }\r\n\r\n      if (brokenEntries.length > 0) {\r\n        broken.push({\r\n          productId,\r\n          productName,\r\n          totalEntries: allHistory.length,\r\n          brokenEntries,\r\n          finalFixedQty: runningQuantity,\r\n          currentProductQty: allHistory[allHistory.length - 1].new_quantity,\r\n        });\r\n      }\r\n\r\n      onProgress?.(i + 1, total);\r\n    }\r\n\r\n    return broken;\r\n  };\r\n\r\n  /**\r\n   * Repairs all broken stock chains for the current business by iterating\r\n   * every product and re-running recalculateStockChain.\r\n   * Use this to fix historical data corruption caused by past disabled recalculations.\r\n   * Returns { repaired, failed } counts.\r\n   */\r\n  const repairAllStockChains = async (\r\n    onProgress?: (current: number, total: number) => void\r\n  ): Promise<{ repaired: number; failed: number }> => {\r\n    if (!userId || !currentBusiness) return { repaired: 0, failed: 0 };\r\n\r\n    // Fetch all distinct product IDs that have stock history for this business\r\n    let allProductIds: string[] = [];\r\n    let offset = 0;\r\n    const batch = 1000;\r\n    let hasMore = true;\r\n\r\n    while (hasMore) {\r\n      const { data, error } = await supabase\r\n        .from('stock_history')\r\n        .select('product_id')\r\n        .eq('location_id', currentBusiness.id)\r\n        .range(offset, offset + batch - 1);\r\n\r\n      if (error) {\r\n        console.error('repairAllStockChains: error fetching product IDs', error);\r\n        break;\r\n      }\r\n\r\n      if (data && data.length > 0) {\r\n        allProductIds.push(...data.map((r: any) => r.product_id));\r\n        offset += batch;\r\n        hasMore = data.length === batch;\r\n      } else {\r\n        hasMore = false;\r\n      }\r\n    }\r\n\r\n    // Deduplicate\r\n    const uniqueProductIds = [...new Set(allProductIds)];\r\n    const total = uniqueProductIds.length;\r\n    let repaired = 0;\r\n    let failed = 0;\r\n\r\n    for (let i = 0; i < uniqueProductIds.length; i++) {\r\n      const productId = uniqueProductIds[i];\r\n      const success = await recalculateStockChain(productId);\r\n      if (success) {\r\n        repaired++;\r\n      } else {\r\n        failed++;\r\n        console.warn('repairAllStockChains: failed for product', productId);\r\n      }\r\n      onProgress?.(i + 1, total);\r\n    }\r\n\r\n    // Refresh UI after full repair\r\n    await loadStockHistory();\r\n\r\n    return { repaired, failed };\r\n  };\r\n\r\n  return {\r\n    stockHistory,\r\n    isLoading,\r\n    createStockHistoryEntry,\r\n    updateStockHistoryEntry,\r\n    deleteStockHistoryEntry,\r\n    deleteMultipleStockHistoryEntries,\r\n    recalculateStockChain,\r\n    repairAllStockChains,\r\n    previewStockChainRepairs,\r\n    updateStockHistoryDatesBySaleId,\r\n    recalculateProductStock,\r\n    loadStockHistory\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 928, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useProductFilters.ts"],"sourcesContent":["import { useState, useMemo, useEffect, useCallback } from 'react';\r\nimport { Product, ProductFilters } from '@/types';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { matchProductSearch } from '@/utils/searchUtils';\r\n\r\n/**\r\n * Hook for filtering products based on search, category, and stock status\r\n */\r\nexport const useProductFilters = (products: Product[]) => {\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const FILTER_STORAGE_KEY = useMemo(() =>\r\n    currentBusiness?.id ? `productFilters_${currentBusiness.id}` : 'productFilters'\r\n    , [currentBusiness?.id]);\r\n\r\n  // Load initial filters from localStorage or use defaults\r\n  const loadFiltersFromStorage = useCallback((): ProductFilters => {\r\n    try {\r\n      const stored = localStorage.getItem(FILTER_STORAGE_KEY);\r\n      if (stored) {\r\n        const parsed = JSON.parse(stored);\r\n        return {\r\n          search: parsed.search || '',\r\n          category: parsed.category || '',\r\n          stockStatus: parsed.stockStatus || 'all'\r\n        };\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to load filters from localStorage:', error);\r\n    }\r\n\r\n    return {\r\n      search: '',\r\n      category: '',\r\n      stockStatus: 'all'\r\n    };\r\n  }, [FILTER_STORAGE_KEY]);\r\n\r\n  const [filters, setFiltersState] = useState<ProductFilters>(loadFiltersFromStorage);\r\n\r\n  // Reload filters when business changes\r\n  useEffect(() => {\r\n    if (currentBusiness?.id) {\r\n      setFiltersState(loadFiltersFromStorage());\r\n    }\r\n  }, [currentBusiness?.id, loadFiltersFromStorage]);\r\n\r\n  // Save filters to localStorage whenever they change\r\n  useEffect(() => {\r\n    try {\r\n      localStorage.setItem(FILTER_STORAGE_KEY, JSON.stringify(filters));\r\n    } catch (error) {\r\n      console.error('Failed to save filters to localStorage:', error);\r\n    }\r\n  }, [filters, FILTER_STORAGE_KEY]);\r\n\r\n  // Wrapper function to update filters\r\n  const setFilters = (newFilters: ProductFilters) => {\r\n    setFiltersState(newFilters);\r\n  };\r\n\r\n  const applyFilters = (products: Product[], filters: ProductFilters): Product[] => {\r\n    return products.filter(product => {\r\n      // Search filter - now uses multi-word matching\r\n      if (filters.search) {\r\n        if (!matchProductSearch(product, filters.search)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Category filter\r\n      if (filters.category && filters.category !== product.category) {\r\n        return false;\r\n      }\r\n\r\n      // Stock status filter\r\n      if (filters.stockStatus !== 'all') {\r\n        if (filters.stockStatus === 'inStock' && product.quantity <= product.minimumStock) {\r\n          return false;\r\n        }\r\n        if (filters.stockStatus === 'lowStock' && (product.quantity === 0 || product.quantity > product.minimumStock)) {\r\n          return false;\r\n        }\r\n        if (filters.stockStatus === 'outOfStock' && product.quantity > 0) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    });\r\n  };\r\n\r\n  const filteredProducts = useMemo(() => {\r\n    return applyFilters(products, filters);\r\n  }, [products, filters]);\r\n\r\n  return {\r\n    filters,\r\n    setFilters,\r\n    filteredProducts,\r\n    applyFilters\r\n  };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;AAEA;AACA;;;;;AAKO,MAAM,oBAAoB,CAAC;;IAChC,MAAM,EAAE,eAAe,EAAE,GAAG,IAAA,qJAAW;IAEvC,MAAM,qBAAqB,IAAA,wKAAO;yDAAC,IACjC,iBAAiB,KAAK,CAAC,eAAe,EAAE,gBAAgB,EAAE,EAAE,GAAG;wDAC7D;QAAC,iBAAiB;KAAG;IAEzB,yDAAyD;IACzD,MAAM,yBAAyB,IAAA,4KAAW;iEAAC;YACzC,IAAI;gBACF,MAAM,SAAS,aAAa,OAAO,CAAC;gBACpC,IAAI,QAAQ;oBACV,MAAM,SAAS,KAAK,KAAK,CAAC;oBAC1B,OAAO;wBACL,QAAQ,OAAO,MAAM,IAAI;wBACzB,UAAU,OAAO,QAAQ,IAAI;wBAC7B,aAAa,OAAO,WAAW,IAAI;oBACrC;gBACF;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,6CAA6C;YAC7D;YAEA,OAAO;gBACL,QAAQ;gBACR,UAAU;gBACV,aAAa;YACf;QACF;gEAAG;QAAC;KAAmB;IAEvB,MAAM,CAAC,SAAS,gBAAgB,GAAG,IAAA,yKAAQ,EAAiB;IAE5D,uCAAuC;IACvC,IAAA,0KAAS;uCAAC;YACR,IAAI,iBAAiB,IAAI;gBACvB,gBAAgB;YAClB;QACF;sCAAG;QAAC,iBAAiB;QAAI;KAAuB;IAEhD,oDAAoD;IACpD,IAAA,0KAAS;uCAAC;YACR,IAAI;gBACF,aAAa,OAAO,CAAC,oBAAoB,KAAK,SAAS,CAAC;YAC1D,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,2CAA2C;YAC3D;QACF;sCAAG;QAAC;QAAS;KAAmB;IAEhC,qCAAqC;IACrC,MAAM,aAAa,CAAC;QAClB,gBAAgB;IAClB;IAEA,MAAM,eAAe,CAAC,UAAqB;QACzC,OAAO,SAAS,MAAM,CAAC,CAAA;YACrB,+CAA+C;YAC/C,IAAI,QAAQ,MAAM,EAAE;gBAClB,IAAI,CAAC,IAAA,oJAAkB,EAAC,SAAS,QAAQ,MAAM,GAAG;oBAChD,OAAO;gBACT;YACF;YAEA,kBAAkB;YAClB,IAAI,QAAQ,QAAQ,IAAI,QAAQ,QAAQ,KAAK,QAAQ,QAAQ,EAAE;gBAC7D,OAAO;YACT;YAEA,sBAAsB;YACtB,IAAI,QAAQ,WAAW,KAAK,OAAO;gBACjC,IAAI,QAAQ,WAAW,KAAK,aAAa,QAAQ,QAAQ,IAAI,QAAQ,YAAY,EAAE;oBACjF,OAAO;gBACT;gBACA,IAAI,QAAQ,WAAW,KAAK,cAAc,CAAC,QAAQ,QAAQ,KAAK,KAAK,QAAQ,QAAQ,GAAG,QAAQ,YAAY,GAAG;oBAC7G,OAAO;gBACT;gBACA,IAAI,QAAQ,WAAW,KAAK,gBAAgB,QAAQ,QAAQ,GAAG,GAAG;oBAChE,OAAO;gBACT;YACF;YAEA,OAAO;QACT;IACF;IAEA,MAAM,mBAAmB,IAAA,wKAAO;uDAAC;YAC/B,OAAO,aAAa,UAAU;QAChC;sDAAG;QAAC;QAAU;KAAQ;IAEtB,OAAO;QACL;QACA;QACA;QACA;IACF;AACF;GA9Fa;;QACiB,qJAAW"}},
    {"offset": {"line": 1055, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useProducts.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useMemo } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct, ProductFilters } from '@/types';\r\nimport { useBusinessSettings } from './useBusinessSettings';\r\nimport { useStockHistory } from './useStockHistory';\r\nimport { useProductFilters } from './useProductFilters';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { clearInventoryCaches } from '@/utils/inventoryCacheUtils';\r\n\r\n// Import our new Server Actions\r\nimport { getProductsAction, createProductAction, updateProductAction, deleteProductAction, updateProductsBulkAction } from '@/app/actions/products';\r\n\r\nexport const useProducts = (userId: string | undefined, initialPageSize: number = 50) => {\r\n  const [products, setProducts] = useState<Product[]>([]);\r\n  const [page, setPage] = useState(1);\r\n  const [pageSize, setPageSize] = useState(initialPageSize);\r\n  const [totalCount, setTotalCount] = useState(0);\r\n  const [isTyping, setIsTyping] = useState(false);\r\n  const { settings } = useBusinessSettings();\r\n  const { createStockHistoryEntry } = useStockHistory(userId);\r\n  const { currentBusiness } = useBusiness();\r\n  const queryClient = useQueryClient();\r\n\r\n  const { filters, setFilters, filteredProducts } = useProductFilters(products);\r\n  const [typingTimer, setTypingTimer] = useState<NodeJS.Timeout | null>(null);\r\n\r\n  const setFiltersWithTypingState = useCallback((newFilters: ProductFilters) => {\r\n    if (newFilters.search !== filters.search) {\r\n      setIsTyping(true);\r\n      if (typingTimer) clearTimeout(typingTimer);\r\n      const timer = setTimeout(() => {\r\n        setIsTyping(false);\r\n      }, 600);\r\n      setTypingTimer(timer);\r\n    }\r\n    setFilters(newFilters);\r\n  }, [filters.search, typingTimer, setFilters]);\r\n\r\n  // Use Server Action instead of Supabase\r\n  const loadProducts = useCallback(async (): Promise<{ products: Product[], count: number }> => {\r\n    if (!userId || !currentBusiness) {\r\n      return { products: [], count: 0 };\r\n    }\r\n\r\n    try {\r\n      // Server Action call\r\n      const result = await getProductsAction({\r\n        userId,\r\n        businessId: currentBusiness.id,\r\n        page,\r\n        pageSize,\r\n        search: filters.search,\r\n        category: filters.category,\r\n        stockStatus: filters.stockStatus,\r\n      });\r\n      return result;\r\n    } catch (error) {\r\n      console.error('Error loading products from server action:', error);\r\n      return { products: [], count: 0 };\r\n    }\r\n  }, [userId, currentBusiness?.id, page, pageSize, filters.search, filters.category, filters.stockStatus]);\r\n\r\n  const baseQueryKey = useMemo(() => ['products', userId, currentBusiness?.id], [userId, currentBusiness?.id]);\r\n  const queryKey = useMemo(() => [...baseQueryKey, page, pageSize, filters.search, filters.category, filters.stockStatus], [baseQueryKey, page, pageSize, filters.search, filters.category, filters.stockStatus]);\r\n\r\n  const { data: queriedData, isLoading: isQueryLoading, isFetching, refetch } = useQuery({\r\n    queryKey,\r\n    queryFn: loadProducts,\r\n    enabled: !!userId && !!currentBusiness?.id,\r\n    staleTime: 30_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: true,\r\n    refetchOnReconnect: true,\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (queriedData) {\r\n      setProducts(queriedData.products);\r\n      setTotalCount(queriedData.count);\r\n    }\r\n  }, [queriedData]);\r\n\r\n  const isLoading = (isQueryLoading && !queriedData) && !isTyping;\r\n\r\n  // Supabase Storage remains untouched since Prisma doesn't do file storage\r\n  const uploadProductImage = async (imageFile: File): Promise<string | null> => {\r\n    try {\r\n      if (!userId) return null;\r\n      const fileExt = imageFile.name.split('.').pop();\r\n      const fileName = `${Date.now()}.${fileExt}`;\r\n      const filePath = `${userId}/${fileName}`;\r\n\r\n      const { error: uploadError } = await supabase.storage\r\n        .from('product-images')\r\n        .upload(filePath, imageFile, { upsert: true });\r\n\r\n      if (uploadError) {\r\n        console.error('Error uploading image:', uploadError);\r\n        return null;\r\n      }\r\n\r\n      const { data: { publicUrl } } = supabase.storage\r\n        .from('product-images')\r\n        .getPublicUrl(filePath);\r\n\r\n      return publicUrl;\r\n    } catch (error) {\r\n      console.error('Error in uploadProductImage:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const createProduct = async (productData: ProductFormData): Promise<Product | null> => {\r\n    try {\r\n      if (!userId || !currentBusiness) return null;\r\n\r\n      // Assuming createProductAction exists and is fully implemented:\r\n      const newProduct = await createProductAction({\r\n        ...productData,\r\n        userId,\r\n        businessId: currentBusiness.id\r\n      });\r\n\r\n      if (!newProduct) return null;\r\n\r\n      if (newProduct.quantity > 0) {\r\n        await createStockHistoryEntry(\r\n          newProduct.id,\r\n          0,\r\n          newProduct.quantity,\r\n          'Initial stock',\r\n          undefined,\r\n          productData.createdAt,\r\n          undefined,\r\n          newProduct.name\r\n        );\r\n      }\r\n\r\n      setProducts(prev => [newProduct, ...prev]);\r\n      setTotalCount(c => c + 1);\r\n\r\n      queryClient.setQueryData(queryKey, (oldData: any) => {\r\n        if (!oldData) return { products: [newProduct], count: 1 };\r\n        return {\r\n          products: [newProduct, ...oldData.products],\r\n          count: (oldData.count || 0) + 1\r\n        };\r\n      });\r\n\r\n      clearInventoryCaches(queryClient);\r\n\r\n      return newProduct;\r\n    } catch (error) {\r\n      console.error('Error creating product:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updateProduct = async (\r\n    id: string,\r\n    updates: Partial<Product>,\r\n    imageFile?: File | null,\r\n    isFromSale = false,\r\n    customChangeReason?: string,\r\n    adjustmentDate?: Date,\r\n    referenceId?: string,\r\n    receiptNumber?: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      if (!userId) return false;\r\n\r\n      let currentProduct = products.find(p => p.id === id);\r\n      if (!currentProduct) return false;\r\n\r\n      let imageUrl = updates.imageUrl;\r\n      if (imageFile) {\r\n        imageUrl = await uploadProductImage(imageFile);\r\n      }\r\n\r\n      const updatedData = { ...updates, imageUrl, barcode: updates.barcode !== undefined ? updates.barcode : currentProduct.barcode };\r\n\r\n      // We will create the update updateProductAction next\r\n      await updateProductAction(id, { ...updatedData, userId, businessId: currentBusiness?.id });\r\n\r\n      setProducts(prev => prev.map(p => p.id === id ? { ...p, ...updatedData } : p));\r\n      queryClient.setQueryData(queryKey, (oldData: any) => {\r\n        if (!oldData) return oldData;\r\n        return {\r\n          ...oldData,\r\n          products: oldData.products.map((p: Product) =>\r\n            p.id === id ? { ...p, ...updatedData } : p\r\n          )\r\n        };\r\n      });\r\n\r\n      if (updates.quantity !== undefined && updates.quantity !== currentProduct.quantity && customChangeReason !== 'skip-history') {\r\n        let changeReason = customChangeReason || (isFromSale ? 'Sale' : (updates.quantity > currentProduct.quantity ? 'Manual stock addition' : 'Manual stock reduction'));\r\n        await createStockHistoryEntry(\r\n          id,\r\n          currentProduct.quantity,\r\n          updates.quantity,\r\n          changeReason,\r\n          referenceId,\r\n          adjustmentDate,\r\n          receiptNumber,\r\n          currentProduct.name\r\n        );\r\n      }\r\n\r\n      queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n      clearInventoryCaches(queryClient);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating product:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteProduct = async (id: string): Promise<boolean> => {\r\n    try {\r\n      if (!userId) return false;\r\n\r\n      await deleteProductAction(id);\r\n\r\n      setProducts(prev => prev.filter(p => p.id !== id));\r\n      queryClient.setQueryData(queryKey, (old: any) => {\r\n        if (!old) return old;\r\n        const { products: oldProducts, count } = old;\r\n        const newProducts = (oldProducts as Product[]).filter(p => p.id !== id);\r\n        return { products: newProducts, count: Math.max(0, (count || 0) - 1) };\r\n      });\r\n\r\n      queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n      clearInventoryCaches(queryClient);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting product:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    // In Prisma, we either use WebSockets, polling, or React Query's built-in focus/refetch handlers\r\n    // Disabled Supabase Realtime Channels since we moved off the raw Supabase client for data fetches\r\n  }, [userId, currentBusiness?.id, baseQueryKey]);\r\n\r\n  const updateProductsBulk = async (\r\n    updates: Array<{ id: string; updated: Partial<Product>; imageFile?: File | null }>,\r\n    userIdForHistory?: string,\r\n    changeReason?: string,\r\n    referenceId?: string,\r\n    adjustmentDate?: Date,\r\n    receiptNumber?: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      // Basic implementation without handling independent image uploads for bulk right now\r\n      const success = await updateProductsBulkAction(\r\n        updates.map(u => ({ id: u.id, updated: u.updated })),\r\n        currentBusiness.id\r\n      );\r\n\r\n      if (success) {\r\n        // Optimistically update UI\r\n        setProducts(prev => {\r\n          const updatedMap = new Map(updates.map(u => [u.id, u.updated]));\r\n          return prev.map(p => {\r\n            const updatedItem = updatedMap.get(p.id);\r\n            return updatedItem ? { ...p, ...updatedItem } as Product : p;\r\n          });\r\n        });\r\n\r\n        // Add history for quantity changes\r\n        for (const update of updates) {\r\n          const currentProduct = products.find(p => p.id === update.id);\r\n          if (currentProduct && update.updated.quantity !== undefined && update.updated.quantity !== currentProduct.quantity) {\r\n            await createStockHistoryEntry(\r\n              update.id,\r\n              currentProduct.quantity,\r\n              update.updated.quantity,\r\n              changeReason || 'Bulk update',\r\n              referenceId,\r\n              adjustmentDate,\r\n              receiptNumber,\r\n              currentProduct.name\r\n            );\r\n          }\r\n        }\r\n\r\n        queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n        clearInventoryCaches(queryClient);\r\n      }\r\n\r\n      return success;\r\n    } catch (error) {\r\n      console.error('Error in bulk update:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  return {\r\n    products,\r\n    isLoading,\r\n    loadProducts,\r\n    page,\r\n    setPage,\r\n    pageSize,\r\n    setPageSize,\r\n    totalCount,\r\n    createProduct,\r\n    updateProduct,\r\n    updateProductsBulk,\r\n    deleteProduct,\r\n    uploadProductImage,\r\n    refetch,\r\n    isFetching,\r\n    filters,\r\n    setFilters: setFiltersWithTypingState,\r\n    filteredProducts\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1423, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useFinancialVisibility.ts"],"sourcesContent":["import { useProfiles } from '@/contexts/ProfileContext';\r\n\r\n/**\r\n * Hook to handle financial data visibility based on permissions\r\n */\r\nexport const useFinancialVisibility = () => {\r\n    const { hasPermission } = useProfiles();\r\n\r\n    const canViewCostPrice = hasPermission('inventory', 'view_cost_price');\r\n    const canViewProfit = hasPermission('inventory', 'view_profit');\r\n    const canViewSellingPrice = hasPermission('inventory', 'view_selling_price');\r\n\r\n    // Dashboard-specific permissions\r\n    const canViewTotalSales = hasPermission('dashboard', 'view_total_sales');\r\n    const canViewTotalGrossProfit = hasPermission('dashboard', 'view_gross_profit');\r\n    const canViewTotalExpenses = hasPermission('dashboard', 'view_total_expenses');\r\n    const canViewInventoryValue = hasPermission('dashboard', 'view_inventory_value');\r\n    const canViewSalesTypes = hasPermission('dashboard', 'view_sales_types');\r\n    const canViewAvgPrice = hasPermission('dashboard', 'view_avg_price');\r\n    const canViewTotalAmount = hasPermission('dashboard', 'view_total_amount');\r\n\r\n    // Finance and Expenses permissions\r\n    const canManageFinanceAccounts = hasPermission('finance', 'manage_accounts');\r\n    const canViewFinance = hasPermission('finance', 'view');\r\n    const canViewExpenses = hasPermission('expenses', 'view');\r\n    const canCreateExpenses = hasPermission('expenses', 'create');\r\n    const canEditExpenses = hasPermission('expenses', 'edit');\r\n    const canDeleteExpenses = hasPermission('expenses', 'delete');\r\n\r\n    /**\r\n     * Format a financial value or return a hidden indicator\r\n     */\r\n    const formatFinancial = (value: number | null | undefined, type: 'cost' | 'selling' | 'profit'): string => {\r\n        const hasAccess =\r\n            (type === 'cost' && canViewCostPrice) ||\r\n            (type === 'selling' && canViewSellingPrice) ||\r\n            (type === 'profit' && canViewProfit);\r\n\r\n        if (!hasAccess) {\r\n            return 'â€¢â€¢â€¢';\r\n        }\r\n\r\n        return value?.toLocaleString() || '0';\r\n    };\r\n\r\n    return {\r\n        canViewCostPrice,\r\n        canViewProfit,\r\n        canViewSellingPrice,\r\n        canViewTotalSales,\r\n        canViewTotalGrossProfit,\r\n        canViewTotalExpenses,\r\n        canViewInventoryValue,\r\n        canViewSalesTypes,\r\n        canViewAvgPrice,\r\n        canViewTotalAmount,\r\n        canManageFinanceAccounts,\r\n        canViewFinance,\r\n        canViewExpenses,\r\n        canCreateExpenses,\r\n        canEditExpenses,\r\n        canDeleteExpenses,\r\n        formatFinancial,\r\n    };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;;;AAKO,MAAM,yBAAyB;;IAClC,MAAM,EAAE,aAAa,EAAE,GAAG,IAAA,oJAAW;IAErC,MAAM,mBAAmB,cAAc,aAAa;IACpD,MAAM,gBAAgB,cAAc,aAAa;IACjD,MAAM,sBAAsB,cAAc,aAAa;IAEvD,iCAAiC;IACjC,MAAM,oBAAoB,cAAc,aAAa;IACrD,MAAM,0BAA0B,cAAc,aAAa;IAC3D,MAAM,uBAAuB,cAAc,aAAa;IACxD,MAAM,wBAAwB,cAAc,aAAa;IACzD,MAAM,oBAAoB,cAAc,aAAa;IACrD,MAAM,kBAAkB,cAAc,aAAa;IACnD,MAAM,qBAAqB,cAAc,aAAa;IAEtD,mCAAmC;IACnC,MAAM,2BAA2B,cAAc,WAAW;IAC1D,MAAM,iBAAiB,cAAc,WAAW;IAChD,MAAM,kBAAkB,cAAc,YAAY;IAClD,MAAM,oBAAoB,cAAc,YAAY;IACpD,MAAM,kBAAkB,cAAc,YAAY;IAClD,MAAM,oBAAoB,cAAc,YAAY;IAEpD;;KAEC,GACD,MAAM,kBAAkB,CAAC,OAAkC;QACvD,MAAM,YACF,AAAC,SAAS,UAAU,oBACnB,SAAS,aAAa,uBACtB,SAAS,YAAY;QAE1B,IAAI,CAAC,WAAW;YACZ,OAAO;QACX;QAEA,OAAO,OAAO,oBAAoB;IACtC;IAEA,OAAO;QACH;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACJ;AACJ;GA3Da;;QACiB,oJAAW"}},
    {"offset": {"line": 1492, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useProductSuggestions.ts"],"sourcesContent":["\r\nimport { useState, useEffect, useMemo } from 'react';\r\nimport { Product } from '@/types';\r\nimport { matchProductSearch } from '@/utils/searchUtils';\r\n\r\nexport const useProductSuggestions = (products: Product[], searchTerm: string) => {\r\n  const [isOpen, setIsOpen] = useState(false);\r\n\r\n  // Get filtered suggestions based on search term\r\n  const suggestions = useMemo(() => {\r\n    if (!searchTerm || searchTerm.length < 1) {\r\n      return [];\r\n    }\r\n\r\n    // Use unified search utility for consistency\r\n    const filtered = products.filter(product => matchProductSearch(product, searchTerm));\r\n\r\n    // Sort by relevance (exact matches first, then starts with, then contains)\r\n    const searchLower = searchTerm.toLowerCase();\r\n    return filtered\r\n      .sort((a, b) => {\r\n        const aNameLower = String(a.name || '').toLowerCase();\r\n        const bNameLower = String(b.name || '').toLowerCase();\r\n        const aItemLower = String(a.itemNumber || '').toLowerCase();\r\n        const bItemLower = String(b.itemNumber || '').toLowerCase();\r\n\r\n        // Exact match on item number (highest priority)\r\n        if (aItemLower === searchLower) return -1;\r\n        if (bItemLower === searchLower) return 1;\r\n\r\n        // Exact match on name\r\n        if (aNameLower === searchLower) return -1;\r\n        if (bNameLower === searchLower) return 1;\r\n\r\n        // Starts with on item number\r\n        if (aItemLower.startsWith(searchLower) && !bItemLower.startsWith(searchLower)) return -1;\r\n        if (bItemLower.startsWith(searchLower) && !aItemLower.startsWith(searchLower)) return 1;\r\n\r\n        // Starts with on name\r\n        if (aNameLower.startsWith(searchLower) && !bNameLower.startsWith(searchLower)) return -1;\r\n        if (bNameLower.startsWith(searchLower) && !aNameLower.startsWith(searchLower)) return 1;\r\n\r\n        // Alphabetical by name\r\n        return aNameLower.localeCompare(bNameLower);\r\n      })\r\n      .slice(0, 100); // Increased to 100 suggestions for better user experience\r\n  }, [products, searchTerm]);\r\n\r\n  // Open panel when there are suggestions and search term is present\r\n  useEffect(() => {\r\n    if (searchTerm.length >= 1 && suggestions.length > 0) {\r\n      setIsOpen(true);\r\n    } else if (searchTerm.length === 0) {\r\n      setIsOpen(false);\r\n    }\r\n  }, [searchTerm, suggestions.length]);\r\n\r\n  const openPanel = () => {\r\n    setIsOpen(true);\r\n  };\r\n\r\n  const closePanel = () => {\r\n    setIsOpen(false);\r\n  };\r\n\r\n  return {\r\n    suggestions,\r\n    isOpen,\r\n    openPanel,\r\n    closePanel\r\n  };\r\n};\r\n"],"names":[],"mappings":";;;;AACA;AAEA;;;;AAEO,MAAM,wBAAwB,CAAC,UAAqB;;IACzD,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,yKAAQ,EAAC;IAErC,gDAAgD;IAChD,MAAM,cAAc,IAAA,wKAAO;sDAAC;YAC1B,IAAI,CAAC,cAAc,WAAW,MAAM,GAAG,GAAG;gBACxC,OAAO,EAAE;YACX;YAEA,6CAA6C;YAC7C,MAAM,WAAW,SAAS,MAAM;uEAAC,CAAA,UAAW,IAAA,oJAAkB,EAAC,SAAS;;YAExE,2EAA2E;YAC3E,MAAM,cAAc,WAAW,WAAW;YAC1C,OAAO,SACJ,IAAI;8DAAC,CAAC,GAAG;oBACR,MAAM,aAAa,OAAO,EAAE,IAAI,IAAI,IAAI,WAAW;oBACnD,MAAM,aAAa,OAAO,EAAE,IAAI,IAAI,IAAI,WAAW;oBACnD,MAAM,aAAa,OAAO,EAAE,UAAU,IAAI,IAAI,WAAW;oBACzD,MAAM,aAAa,OAAO,EAAE,UAAU,IAAI,IAAI,WAAW;oBAEzD,gDAAgD;oBAChD,IAAI,eAAe,aAAa,OAAO,CAAC;oBACxC,IAAI,eAAe,aAAa,OAAO;oBAEvC,sBAAsB;oBACtB,IAAI,eAAe,aAAa,OAAO,CAAC;oBACxC,IAAI,eAAe,aAAa,OAAO;oBAEvC,6BAA6B;oBAC7B,IAAI,WAAW,UAAU,CAAC,gBAAgB,CAAC,WAAW,UAAU,CAAC,cAAc,OAAO,CAAC;oBACvF,IAAI,WAAW,UAAU,CAAC,gBAAgB,CAAC,WAAW,UAAU,CAAC,cAAc,OAAO;oBAEtF,sBAAsB;oBACtB,IAAI,WAAW,UAAU,CAAC,gBAAgB,CAAC,WAAW,UAAU,CAAC,cAAc,OAAO,CAAC;oBACvF,IAAI,WAAW,UAAU,CAAC,gBAAgB,CAAC,WAAW,UAAU,CAAC,cAAc,OAAO;oBAEtF,uBAAuB;oBACvB,OAAO,WAAW,aAAa,CAAC;gBAClC;6DACC,KAAK,CAAC,GAAG,MAAM,0DAA0D;QAC9E;qDAAG;QAAC;QAAU;KAAW;IAEzB,mEAAmE;IACnE,IAAA,0KAAS;2CAAC;YACR,IAAI,WAAW,MAAM,IAAI,KAAK,YAAY,MAAM,GAAG,GAAG;gBACpD,UAAU;YACZ,OAAO,IAAI,WAAW,MAAM,KAAK,GAAG;gBAClC,UAAU;YACZ;QACF;0CAAG;QAAC;QAAY,YAAY,MAAM;KAAC;IAEnC,MAAM,YAAY;QAChB,UAAU;IACZ;IAEA,MAAM,aAAa;QACjB,UAAU;IACZ;IAEA,OAAO;QACL;QACA;QACA;QACA;IACF;AACF;GAlEa"}},
    {"offset": {"line": 1577, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useCurrentUser.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\n\r\nexport const useCurrentUser = () => {\r\n  const [userId, setUserId] = useState<string | undefined>(undefined);\r\n  \r\n  // Get current user with faster initial check\r\n  useEffect(() => {\r\n    const getCurrentUser = async () => {\r\n      try {\r\n        // Try to get user from session first (faster)\r\n        const { data: sessionData } = await supabase.auth.getSession();\r\n        if (sessionData.session?.user) {\r\n          setUserId(sessionData.session.user.id);\r\n          return;\r\n        }\r\n        \r\n        // Fallback to getUser if no session\r\n        const { data: userData } = await supabase.auth.getUser();\r\n        setUserId(userData.user?.id);\r\n      } catch (error) {\r\n        console.error('Error getting user:', error);\r\n        setUserId(undefined);\r\n      }\r\n    };\r\n    getCurrentUser();\r\n  }, []);\r\n\r\n  return { userId };\r\n};"],"names":[],"mappings":";;;;AAAA;AACA;;;;AAEO,MAAM,iBAAiB;;IAC5B,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,yKAAQ,EAAqB;IAEzD,6CAA6C;IAC7C,IAAA,0KAAS;oCAAC;YACR,MAAM;2DAAiB;oBACrB,IAAI;wBACF,8CAA8C;wBAC9C,MAAM,EAAE,MAAM,WAAW,EAAE,GAAG,MAAM,wJAAQ,CAAC,IAAI,CAAC,UAAU;wBAC5D,IAAI,YAAY,OAAO,EAAE,MAAM;4BAC7B,UAAU,YAAY,OAAO,CAAC,IAAI,CAAC,EAAE;4BACrC;wBACF;wBAEA,oCAAoC;wBACpC,MAAM,EAAE,MAAM,QAAQ,EAAE,GAAG,MAAM,wJAAQ,CAAC,IAAI,CAAC,OAAO;wBACtD,UAAU,SAAS,IAAI,EAAE;oBAC3B,EAAE,OAAO,OAAO;wBACd,QAAQ,KAAK,CAAC,uBAAuB;wBACrC,UAAU;oBACZ;gBACF;;YACA;QACF;mCAAG,EAAE;IAEL,OAAO;QAAE;IAAO;AAClB;GA1Ba"}},
    {"offset": {"line": 1625, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useActivityLogger.ts"],"sourcesContent":["import { supabase } from '@/integrations/supabase/client';\r\nimport { useCurrentUser } from './useCurrentUser';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useProfiles } from '@/contexts/ProfileContext';\r\n\r\nexport type ActivityType = 'CREATE' | 'UPDATE' | 'DELETE';\r\nexport type ModuleType = 'SALES' | 'INVENTORY' | 'EXPENSES' | 'FINANCE' | 'CUSTOMERS' | 'TASKS';\r\n\r\nexport interface ActivityLogData {\r\n  activityType: ActivityType;\r\n  module: ModuleType;\r\n  entityType: string;\r\n  entityId?: string;\r\n  entityName: string;\r\n  description: string;\r\n  metadata?: any;\r\n}\r\n\r\nexport const useActivityLogger = () => {\r\n  const { userId } = useCurrentUser();\r\n  const { currentBusiness } = useBusiness();\r\n  \r\n  // Safely get current profile, handle case where ProfileProvider isn't available\r\n  let currentProfile = null;\r\n  try {\r\n    const { currentProfile: profile } = useProfiles();\r\n    currentProfile = profile;\r\n  } catch {\r\n    // ProfileProvider not available, continue without profile\r\n    currentProfile = null;\r\n  }\r\n\r\n  const logActivity = async (data: ActivityLogData) => {\r\n    if (!userId || !currentBusiness?.id) {\r\n      console.warn('Cannot log activity: missing user or business context');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const { error } = await supabase\r\n        .from('activity_history')\r\n        .insert({\r\n          user_id: userId,\r\n          location_id: currentBusiness.id,\r\n          activity_type: data.activityType,\r\n          module: data.module,\r\n          entity_type: data.entityType,\r\n          entity_id: data.entityId || null,\r\n          entity_name: data.entityName,\r\n          description: data.description,\r\n          metadata: data.metadata || null,\r\n          profile_id: currentProfile?.id || null,\r\n          profile_name: currentProfile?.profile_name || null\r\n        });\r\n\r\n      if (error) {\r\n        console.error('Error logging activity:', error);\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to log activity:', error);\r\n    }\r\n  };\r\n\r\n  return { logActivity };\r\n};"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;;AAeO,MAAM,oBAAoB;;IAC/B,MAAM,EAAE,MAAM,EAAE,GAAG,IAAA,mJAAc;IACjC,MAAM,EAAE,eAAe,EAAE,GAAG,IAAA,qJAAW;IAEvC,gFAAgF;IAChF,IAAI,iBAAiB;IACrB,IAAI;QACF,MAAM,EAAE,gBAAgB,OAAO,EAAE,GAAG,IAAA,oJAAW;QAC/C,iBAAiB;IACnB,EAAE,OAAM;QACN,0DAA0D;QAC1D,iBAAiB;IACnB;IAEA,MAAM,cAAc,OAAO;QACzB,IAAI,CAAC,UAAU,CAAC,iBAAiB,IAAI;YACnC,QAAQ,IAAI,CAAC;YACb;QACF;QAEA,IAAI;YACF,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,wJAAQ,CAC7B,IAAI,CAAC,oBACL,MAAM,CAAC;gBACN,SAAS;gBACT,aAAa,gBAAgB,EAAE;gBAC/B,eAAe,KAAK,YAAY;gBAChC,QAAQ,KAAK,MAAM;gBACnB,aAAa,KAAK,UAAU;gBAC5B,WAAW,KAAK,QAAQ,IAAI;gBAC5B,aAAa,KAAK,UAAU;gBAC5B,aAAa,KAAK,WAAW;gBAC7B,UAAU,KAAK,QAAQ,IAAI;gBAC3B,YAAY,gBAAgB,MAAM;gBAClC,cAAc,gBAAgB,gBAAgB;YAChD;YAEF,IAAI,OAAO;gBACT,QAAQ,KAAK,CAAC,2BAA2B;YAC3C;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2BAA2B;QAC3C;IACF;IAEA,OAAO;QAAE;IAAY;AACvB;GA9Ca;;QACQ,mJAAc;QACL,qJAAW"}},
    {"offset": {"line": 1694, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useInventoryActions.ts"],"sourcesContent":["import { useProducts } from './useProducts';\r\nimport { SaleItem, Product, mapDbProductToProduct } from '@/types';\r\nimport { toast } from 'sonner';\r\nimport { supabase } from '@/integrations/supabase/client';\r\n\r\nexport const useInventoryActions = (userId: string | undefined) => {\r\n    const { updateProductsBulk, products } = useProducts(userId);\r\n\r\n    /**\r\n     * Helper to fetch fresh product data from DB to avoid race conditions/stale data\r\n     */\r\n    const fetchFreshProducts = async (productIds: string[], locationId?: string) => {\r\n        if (!productIds.length) return [];\r\n\r\n        let query = supabase\r\n            .from('products')\r\n            .select('*')\r\n            .in('id', productIds);\r\n\r\n        if (locationId) {\r\n            query = query.eq('location_id', locationId);\r\n        }\r\n\r\n        const { data: dbProducts, error } = await query;\r\n\r\n        if (error) {\r\n            console.error('Error fetching fresh products:', error);\r\n            throw error;\r\n        }\r\n\r\n        return (dbProducts || []).map(mapDbProductToProduct);\r\n    };\r\n\r\n    /**\r\n     * Deduct stock for a new sale\r\n     */\r\n    const deductStockForSale = async (\r\n        items: SaleItem[],\r\n        saleId?: string,\r\n        saleDate?: Date,\r\n        receiptNumber?: string,\r\n        locationId?: string\r\n    ): Promise<boolean> => {\r\n        if (!userId) return false;\r\n\r\n        try {\r\n            const itemsWithProductIds = items.filter(item => item.productId);\r\n            if (itemsWithProductIds.length === 0) return true;\r\n\r\n            const uniqueIds = [...new Set(itemsWithProductIds.map(item => item.productId!))];\r\n            const freshProducts = await fetchFreshProducts(uniqueIds, locationId);\r\n\r\n            if (freshProducts.length === 0) return false;\r\n\r\n            // Calculate total quantity to deduct per product\r\n            const quantityChanges = new Map<string, number>();\r\n            for (const item of itemsWithProductIds) {\r\n                const existing = quantityChanges.get(item.productId!) || 0;\r\n                quantityChanges.set(item.productId!, existing + item.quantity);\r\n            }\r\n\r\n            const bulkUpdates = [];\r\n            for (const [productId, quantityToDeduct] of quantityChanges.entries()) {\r\n                const product = freshProducts.find(p => p.id === productId);\r\n                if (!product) continue;\r\n\r\n                const newQuantity = product.quantity - quantityToDeduct;\r\n\r\n                bulkUpdates.push({\r\n                    id: productId,\r\n                    updated: { ...product, quantity: newQuantity }\r\n                });\r\n\r\n                if (newQuantity < 0) {\r\n                    toast.warning(`${product.name} inventory is now negative (${newQuantity}). Please restock soon.`);\r\n                }\r\n            }\r\n\r\n            if (bulkUpdates.length > 0) {\r\n                await updateProductsBulk(bulkUpdates, userId, 'Sale', saleId, saleDate, receiptNumber);\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error deducting stock for sale:', error);\r\n            return false;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Restore stock (e.g. when deleting a sale)\r\n     */\r\n    const restoreStockForSale = async (\r\n        items: SaleItem[],\r\n        saleId?: string, // Reference ID for history\r\n        receiptNumber?: string, // Reference receipt number\r\n        locationId?: string\r\n    ): Promise<boolean> => {\r\n        if (!userId) return false;\r\n\r\n        try {\r\n            const itemsWithProductIds = items.filter(item => item.productId);\r\n            if (itemsWithProductIds.length === 0) return true;\r\n\r\n            const uniqueIds = [...new Set(itemsWithProductIds.map(item => item.productId!))];\r\n            const freshProducts = await fetchFreshProducts(uniqueIds, locationId);\r\n\r\n            // Calculate total quantity to restore\r\n            const quantityChanges = new Map<string, number>();\r\n            for (const item of itemsWithProductIds) {\r\n                const existing = quantityChanges.get(item.productId!) || 0;\r\n                quantityChanges.set(item.productId!, existing + item.quantity);\r\n            }\r\n\r\n            const bulkUpdates = [];\r\n            for (const [productId, quantityToRestore] of quantityChanges.entries()) {\r\n                const product = freshProducts.find(p => p.id === productId);\r\n                if (!product) continue;\r\n\r\n                const newQuantity = product.quantity + quantityToRestore;\r\n\r\n                bulkUpdates.push({\r\n                    id: productId,\r\n                    updated: { ...product, quantity: newQuantity }\r\n                });\r\n            }\r\n\r\n            if (bulkUpdates.length > 0) {\r\n                await updateProductsBulk(bulkUpdates, userId, 'Deleted Sale', saleId, undefined, receiptNumber);\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error restoring stock for sale:', error);\r\n            return false;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Adjust stock for an edited sale (Handle both adding and removing items)\r\n     */\r\n    const adjustStockForEditedSale = async (\r\n        originalItems: SaleItem[],\r\n        newItems: SaleItem[],\r\n        saleId?: string,\r\n        saleDate?: Date,\r\n        receiptNumber?: string,\r\n        locationId?: string\r\n    ): Promise<boolean> => {\r\n        if (!userId) return false;\r\n\r\n        try {\r\n            const allProductIds = [\r\n                ...originalItems.filter(i => i.productId).map(i => i.productId!),\r\n                ...newItems.filter(i => i.productId).map(i => i.productId!)\r\n            ];\r\n            const uniqueIds = [...new Set(allProductIds)];\r\n            if (uniqueIds.length === 0) return true;\r\n\r\n            const freshProducts = await fetchFreshProducts(uniqueIds, locationId);\r\n\r\n            const productNetChanges = new Map<string, number>();\r\n\r\n            // 1. Restore original items (add back to stock)\r\n            for (const item of originalItems.filter(i => i.productId)) {\r\n                const current = productNetChanges.get(item.productId!) || 0;\r\n                productNetChanges.set(item.productId!, current + item.quantity);\r\n            }\r\n\r\n            // 2. Deduct new items (remove from stock)\r\n            for (const item of newItems.filter(i => i.productId)) {\r\n                const current = productNetChanges.get(item.productId!) || 0;\r\n                productNetChanges.set(item.productId!, current - item.quantity);\r\n            }\r\n\r\n            const bulkUpdates = [];\r\n            for (const [productId, netChange] of productNetChanges.entries()) {\r\n                if (netChange === 0) continue;\r\n\r\n                const product = freshProducts.find(p => p.id === productId);\r\n                if (!product) continue;\r\n\r\n                const newQuantity = product.quantity + netChange;\r\n\r\n                bulkUpdates.push({\r\n                    id: productId,\r\n                    updated: { ...product, quantity: newQuantity }\r\n                });\r\n\r\n                if (newQuantity < 0) {\r\n                    toast.warning(`${product.name} inventory is now negative (${newQuantity}). Please restock soon.`);\r\n                }\r\n            }\r\n\r\n            if (bulkUpdates.length > 0) {\r\n                await updateProductsBulk(bulkUpdates, userId, 'Sale Status/Qty Edit', saleId, saleDate, receiptNumber);\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error adjusting stock for edited sale:', error);\r\n            return false;\r\n        }\r\n    };\r\n\r\n    return {\r\n        deductStockForSale,\r\n        restoreStockForSale,\r\n        adjustStockForEditedSale\r\n    };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1876, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useSalesData.ts"],"sourcesContent":["\r\nimport { useState, useEffect, useMemo, useCallback } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { Sale, DbSale, mapDbSaleToSale } from '@/types';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { useActivityLogger } from '@/hooks/useActivityLogger';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useProducts } from '@/hooks/useProducts';\r\nimport { useInventoryActions } from '@/hooks/useInventoryActions';\r\nimport { clearInventoryCaches } from '@/utils/inventoryCacheUtils';\r\nimport { getSalesAction, deleteSaleAction } from '@/app/actions/sales';\r\n\r\nexport interface TopCustomer {\r\n  id?: string;\r\n  name: string;\r\n  totalPurchases: number;\r\n  orderCount: number;\r\n}\r\n\r\nexport const useSalesData = (userId: string | undefined, sortOrder: string = 'desc', pageSize?: number) => {\r\n\r\n  const queryClient = useQueryClient();\r\n  const { toast } = useToast();\r\n  const { logActivity } = useActivityLogger();\r\n  const { currentBusiness } = useBusiness();\r\n  const { updateProduct, loadProducts, updateProductsBulk } = useProducts(userId);\r\n  const { restoreStockForSale } = useInventoryActions(userId);\r\n\r\n  const loadSales = useCallback(async (): Promise<Sale[]> => {\r\n    try {\r\n      if (!userId || !currentBusiness) {\r\n        return [];\r\n      }\r\n\r\n      // If pageSize is specified, load only that many records\r\n      const salesData = await getSalesAction(currentBusiness.id, sortOrder as any, pageSize);\r\n\r\n      const formattedSales: Sale[] = salesData ? salesData.map((item: any) => {\r\n        const dbSale: DbSale = {\r\n          id: item.id,\r\n          user_id: item.user_id,\r\n          location_id: item.location_id,\r\n          receipt_number: item.receipt_number,\r\n          customer_name: item.customer_name,\r\n          customer_address: item.customer_address,\r\n          customer_contact: item.customer_contact,\r\n          customer_id: item.customer_id,\r\n          items: item.items as any,\r\n          payment_status: item.payment_status,\r\n          profit: item.profit ? Number(item.profit) : 0,\r\n          date: item.date,\r\n          tax_rate: item.tax_rate || 0,\r\n          created_at: item.created_at,\r\n          updated_at: item.updated_at,\r\n          cash_transaction_id: item.cash_transaction_id,\r\n          amount_paid: item.amount_paid ? Number(item.amount_paid) : undefined,\r\n          amount_due: item.amount_due ? Number(item.amount_due) : undefined,\r\n          category_id: item.category_id,\r\n          notes: item.notes\r\n        };\r\n        return mapDbSaleToSale(dbSale);\r\n      }) : [];\r\n\r\n      return formattedSales;\r\n\r\n    } catch (error) {\r\n      console.error('Error loading sales:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load sales data. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return [];\r\n    }\r\n  }, [userId, currentBusiness?.id, sortOrder, pageSize, toast]);\r\n\r\n  // React Query caching with persistent storage for improved performance\r\n  const baseQueryKey = useMemo(() => ['sales', currentBusiness?.id, userId], [currentBusiness?.id, userId]);\r\n  const queryKey = useMemo(() => [...baseQueryKey, sortOrder, pageSize], [baseQueryKey, sortOrder, pageSize]);\r\n\r\n  const {\r\n    data: sales = [],\r\n    isLoading: isQueryLoading,\r\n    isFetching,\r\n    refetch\r\n  } = useQuery({\r\n    queryKey,\r\n    queryFn: loadSales,\r\n    enabled: !!userId && !!currentBusiness?.id,\r\n    staleTime: 30_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: true,\r\n    refetchOnReconnect: true,\r\n  });\r\n\r\n  // Derived loading state\r\n  const isLoading = isQueryLoading || (isFetching && sales.length === 0);\r\n\r\n  // Set up real-time subscription with optimized incremental updates\r\n  useEffect(() => {\r\n    if (!userId || !currentBusiness?.id) return;\r\n\r\n    const channel = supabase\r\n      .channel('sales_changes')\r\n      .on(\r\n        'postgres_changes',\r\n        {\r\n          event: '*',\r\n          schema: 'public',\r\n          table: 'sales',\r\n          filter: `location_id=eq.${currentBusiness.id}`,\r\n        },\r\n        (payload) => {\r\n          // Invalidate cache to trigger refetch or handle optimistic updates via setQueryData if needed\r\n          // For now, invalidation is safer to ensure consistency\r\n          queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n          clearSoldItemsCache();\r\n          clearInventoryCaches();\r\n        }\r\n      )\r\n      .subscribe();\r\n\r\n    return () => {\r\n      supabase.removeChannel(channel);\r\n    };\r\n  }, [userId, currentBusiness?.id, baseQueryKey, queryClient]);\r\n\r\n  const getTopCustomers = useMemo((): TopCustomer[] => {\r\n    // Skip quotes since they're not actual purchases\r\n    const nonQuoteSales = sales.filter(sale => sale.paymentStatus !== \"Quote\");\r\n\r\n    // Group sales by customer name\r\n    const customerMap = new Map<string, { total: number, count: number, customerId?: string }>();\r\n\r\n    nonQuoteSales.forEach(sale => {\r\n      const customerName = sale.customerName;\r\n      const saleTotal = sale.items.reduce((sum, item) => sum + (item.price * item.quantity), 0);\r\n\r\n      if (!customerMap.has(customerName)) {\r\n        customerMap.set(customerName, {\r\n          total: saleTotal,\r\n          count: 1,\r\n          customerId: sale.customerId\r\n        });\r\n      } else {\r\n        const current = customerMap.get(customerName)!;\r\n        customerMap.set(customerName, {\r\n          total: current.total + saleTotal,\r\n          count: current.count + 1,\r\n          customerId: current.customerId || sale.customerId\r\n        });\r\n      }\r\n    });\r\n\r\n    // Convert map to array and sort by total purchases\r\n    return Array.from(customerMap.entries())\r\n      .map(([name, data]) => ({\r\n        id: data.customerId,\r\n        name,\r\n        totalPurchases: data.total,\r\n        orderCount: data.count\r\n      }))\r\n      .sort((a, b) => b.totalPurchases - a.totalPurchases);\r\n  }, [sales]);\r\n\r\n  // Memoize customer lifetime purchases function\r\n  const getCustomerLifetimePurchases = useMemo(() => {\r\n    return (customerName: string) => {\r\n      // Filter sales by customer name and exclude quotes\r\n      const customerSales = sales.filter(sale =>\r\n        sale.customerName.toLowerCase() === customerName.toLowerCase() &&\r\n        sale.paymentStatus !== \"Quote\"\r\n      );\r\n\r\n      // Calculate total purchase amount and count\r\n      const total = customerSales.reduce((sum, sale) =>\r\n        sum + sale.items.reduce((itemSum, item) => itemSum + (item.price * item.quantity), 0), 0\r\n      );\r\n\r\n      return {\r\n        total,\r\n        count: customerSales.length\r\n      };\r\n    };\r\n  }, [sales]);\r\n\r\n  const deleteSale = async (id: string) => {\r\n    try {\r\n      // First, find the sale to get its details for logging\r\n      const saleToDelete = sales.find(sale => sale.id === id);\r\n      if (!saleToDelete) {\r\n        throw new Error('Sale not found');\r\n      }\r\n\r\n      console.log('Deleting sale:', id, 'with cash transaction:', saleToDelete.cashTransactionId);\r\n\r\n      // Delete associated installment payments first (they might reference cash transactions)\r\n      const { error: installmentError } = await supabase\r\n        .from('installment_payments' as any)\r\n        .delete()\r\n        .eq('sale_id', id);\r\n\r\n      if (installmentError) {\r\n        console.error('Error deleting installment payments:', installmentError);\r\n        // Continue with sale deletion even if installment deletion fails\r\n      }\r\n\r\n      // If there's an associated cash transaction, delete it\r\n      if (saleToDelete.cashTransactionId) {\r\n        console.log('Deleting associated cash transaction:', saleToDelete.cashTransactionId);\r\n        const { error: cashError } = await (supabase as any)\r\n          .from('cash_transactions')\r\n          .delete()\r\n          .eq('id', saleToDelete.cashTransactionId);\r\n\r\n        if (cashError) {\r\n          console.error('Error deleting cash transaction:', cashError);\r\n          toast({\r\n            title: \"Warning\",\r\n            description: \"Sale deleted but failed to remove associated cash transaction. Please check your cash accounts.\",\r\n            variant: \"destructive\"\r\n          });\r\n        } else {\r\n          console.log('Successfully deleted cash transaction');\r\n        }\r\n      }\r\n\r\n      // Restore product quantities back to inventory (Only if it wasn't a quote which doesn't deduct stock)\r\n      if (saleToDelete.paymentStatus !== 'Quote' && saleToDelete.items.length > 0) {\r\n        console.log('Restoring product quantities via useInventoryActions...');\r\n        const success = await restoreStockForSale(saleToDelete.items, id, saleToDelete.receiptNumber, currentBusiness?.id);\r\n\r\n        if (!success) {\r\n          toast({\r\n            title: \"Inventory Update Warning\",\r\n            description: \"Sale deleted, but inventory restoration might have failed. Please check your stock levels.\",\r\n            variant: \"destructive\"\r\n          });\r\n        }\r\n      } else {\r\n        console.log('Skipping product restoration (Quote or No items)');\r\n      }\r\n\r\n      // If we made it here, proceed to delete the sale via API Action\r\n      if (!currentBusiness?.id) {\r\n        throw new Error('Business context missing for deletion');\r\n      }\r\n\r\n      const result = await deleteSaleAction(id, currentBusiness.id);\r\n\r\n      if (!result.success) {\r\n        throw new Error(result.error);\r\n      }\r\n\r\n      // Update React Query cache\r\n      queryClient.setQueryData(queryKey, (oldData: Sale[] | undefined) => {\r\n        return oldData ? oldData.filter(sale => sale.id !== id) : [];\r\n      });\r\n      queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n\r\n      // Clear sold items cache after deletion\r\n      clearSoldItemsCache();\r\n\r\n      // Log activity for sale deletion\r\n      await logActivity({\r\n        activityType: 'DELETE',\r\n        module: 'SALES',\r\n        entityType: 'sale',\r\n        entityId: id,\r\n        entityName: `Sale #${saleToDelete.receiptNumber}`,\r\n        description: `Deleted sale for ${saleToDelete.customerName} - Total: UGX ${((saleToDelete.amountPaid || 0) + (saleToDelete.amountDue || 0)).toLocaleString()} (Stock restored)`,\r\n        metadata: {\r\n          receiptNumber: saleToDelete.receiptNumber,\r\n          customerName: saleToDelete.customerName,\r\n          customerAddress: saleToDelete.customerAddress,\r\n          customerContact: saleToDelete.customerContact,\r\n          totalAmount: (saleToDelete.amountPaid || 0) + (saleToDelete.amountDue || 0),\r\n          amountPaid: saleToDelete.amountPaid,\r\n          profit: saleToDelete.profit,\r\n          paymentStatus: saleToDelete.paymentStatus,\r\n          taxRate: saleToDelete.taxRate,\r\n          itemCount: saleToDelete.items.length,\r\n          items: saleToDelete.items.map(item => ({\r\n            description: item.description,\r\n            quantity: item.quantity,\r\n            price: item.price,\r\n            cost: item.cost,\r\n            total: item.quantity * item.price,\r\n            discountPercentage: item.discountPercentage,\r\n            discountAmount: item.discountAmount\r\n          })),\r\n          notes: saleToDelete.notes,\r\n          cashTransactionDeleted: !!saleToDelete.cashTransactionId\r\n        }\r\n      });\r\n\r\n      toast({\r\n        title: \"Sale Deleted\",\r\n        description: saleToDelete.cashTransactionId\r\n          ? \"The sale record and associated cash transaction have been successfully deleted.\"\r\n          : \"The sale record has been successfully deleted.\"\r\n      });\r\n\r\n      clearInventoryCaches();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting sale:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete sale. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const clearSoldItemsCache = useCallback(() => {\r\n    if (!currentBusiness?.id) return;\r\n    const key = `soldItemsFilters_${currentBusiness.id}`;\r\n    localStorage.removeItem(key);\r\n\r\n    // Also clear legacy keys for safety\r\n    localStorage.removeItem('soldItemsFilters');\r\n  }, [currentBusiness?.id]);\r\n\r\n  const addSale = useCallback((newSale: Sale) => {\r\n    queryClient.setQueryData(queryKey, (oldData: Sale[] | undefined) => {\r\n      return oldData ? [newSale, ...oldData] : [newSale];\r\n    });\r\n    queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n    clearSoldItemsCache();\r\n    clearInventoryCaches();\r\n  }, [queryClient, queryKey, baseQueryKey, clearSoldItemsCache, clearInventoryCaches]);\r\n\r\n  const updateSale = useCallback((updatedSale: Sale) => {\r\n    queryClient.setQueryData(queryKey, (oldData: Sale[] | undefined) => {\r\n      return oldData ? oldData.map(s => s.id === updatedSale.id ? updatedSale : s) : [updatedSale];\r\n    });\r\n    queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n    clearSoldItemsCache();\r\n    clearInventoryCaches();\r\n  }, [queryClient, queryKey, baseQueryKey, clearSoldItemsCache, clearInventoryCaches]);\r\n\r\n  return {\r\n    sales,\r\n    // Removed setSales to prevent manual manipulation outside of mutations\r\n    isLoading,\r\n    deleteSale,\r\n    addSale,\r\n    updateSale,\r\n    getTopCustomers,\r\n    getCustomerLifetimePurchases,\r\n    clearSoldItemsCache,\r\n    refetch,\r\n    isFetching\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2301, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useSoldItemsData.ts"],"sourcesContent":["import { useState, useEffect, useMemo } from 'react';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useSalesData } from '@/hooks/useSalesData';\r\nimport { useProducts } from '@/hooks/useProducts';\r\nimport { getDateRangeFromFilter } from '@/utils/dateFilters';\r\nimport { isSameDay } from 'date-fns';\r\nimport { calculateItemActualAmount, calculateItemActualPrice } from '@/utils/discountCalculations';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { useQuery } from '@tanstack/react-query';\r\n\r\ninterface SoldItem {\r\n  description: string;\r\n  totalQuantity: number;\r\n  averagePrice: number;\r\n  totalAmount: number;\r\n  totalCost: number;\r\n  totalProfit: number;\r\n  totalDiscount: number;\r\n  averageCost?: number;\r\n  productIds: string[];\r\n}\r\n\r\nexport const useSoldItemsData = (\r\n  dateFilter: string,\r\n  dateRange: { from: Date | undefined; to: Date | undefined },\r\n  specificDate: Date | undefined,\r\n  showOnlyNotInInventory: boolean\r\n) => {\r\n  const { user } = useAuth();\r\n  const { currentBusiness } = useBusiness();\r\n  const { sales, isLoading: salesLoading, clearSoldItemsCache } = useSalesData(user?.id, 'desc');\r\n\r\n  // Fetch product inventory status for checking if items exist in inventory\r\n  const { data: dbInventoryMap, isLoading: inventoryLoading } = useQuery({\r\n    queryKey: ['inventory_check_map', currentBusiness?.id],\r\n    queryFn: async () => {\r\n      if (!currentBusiness?.id) return new Map<string, boolean>();\r\n\r\n      const { data: dbProducts } = await supabase\r\n        .from('products' as any)\r\n        .select('id, name')\r\n        .eq('location_id', currentBusiness.id)\r\n        .limit(10000);\r\n\r\n      const invMap = new Map<string, boolean>();\r\n      (dbProducts || []).forEach((p: any) => {\r\n        if (p.id) invMap.set(p.id, true);\r\n        if (p.name) invMap.set(p.name.trim().toLowerCase(), true);\r\n      });\r\n      return invMap;\r\n    },\r\n    enabled: !!currentBusiness?.id,\r\n    staleTime: 5 * 60 * 1000, // 5 minutes\r\n    gcTime: 30 * 60 * 1000 // 30 minutes\r\n  });\r\n\r\n  // Calculate sold items derived from sales and inventory map\r\n  const soldItems = useMemo(() => {\r\n    if (!sales || sales.length === 0) return [];\r\n\r\n    let from: Date, to: Date;\r\n\r\n    if (dateFilter === 'specific-date' && specificDate) {\r\n      from = new Date(specificDate);\r\n      from.setHours(0, 0, 0, 0);\r\n      to = new Date(specificDate);\r\n      to.setHours(23, 59, 59, 999);\r\n    } else if (dateFilter === 'custom' && dateRange.from && dateRange.to) {\r\n      from = dateRange.from;\r\n      to = dateRange.to;\r\n    } else {\r\n      const range = getDateRangeFromFilter(dateFilter);\r\n      from = range.from;\r\n      to = range.to;\r\n    }\r\n\r\n    const filteredSales = sales.filter(sale => {\r\n      const saleDate = new Date(sale.date);\r\n      if (dateFilter === 'specific-date' && specificDate) {\r\n        return isSameDay(saleDate, specificDate) && sale.paymentStatus !== 'Quote';\r\n      }\r\n      return saleDate >= from && saleDate <= to && sale.paymentStatus !== 'Quote';\r\n    });\r\n\r\n    const itemsMap = new Map<string, { totalQuantity: number; totalAmount: number; totalCost: number; totalProfit: number; totalDiscount: number; prices: number[]; costs: number[]; productIds: string[] }>();\r\n\r\n    filteredSales.forEach(sale => {\r\n      sale.items.forEach(item => {\r\n        const key = item.description;\r\n        const subtotal = item.price * item.quantity;\r\n        const amount = calculateItemActualAmount(item);\r\n        const discount = subtotal - amount;\r\n        const cost = (item.cost || 0) * item.quantity;\r\n        const profit = amount - cost;\r\n        const actualPrice = calculateItemActualPrice(item);\r\n\r\n        if (itemsMap.has(key)) {\r\n          const existing = itemsMap.get(key)!;\r\n          existing.totalQuantity += item.quantity;\r\n          existing.totalAmount += amount;\r\n          existing.totalCost += cost;\r\n          existing.totalProfit += profit;\r\n          existing.totalDiscount += discount;\r\n          existing.prices.push(actualPrice);\r\n          existing.costs.push(item.cost || 0);\r\n          if (item.productId && !existing.productIds.includes(item.productId)) {\r\n            existing.productIds.push(item.productId);\r\n          }\r\n        } else {\r\n          itemsMap.set(key, {\r\n            totalQuantity: item.quantity,\r\n            totalAmount: amount,\r\n            totalCost: cost,\r\n            totalProfit: profit,\r\n            totalDiscount: discount,\r\n            prices: [actualPrice],\r\n            costs: [item.cost || 0],\r\n            productIds: item.productId ? [item.productId] : []\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    const result: SoldItem[] = Array.from(itemsMap.entries()).map(([description, data]) => ({\r\n      description,\r\n      totalQuantity: data.totalQuantity,\r\n      averagePrice: data.prices.reduce((sum, price) => sum + price, 0) / data.prices.length,\r\n      totalAmount: data.totalAmount,\r\n      totalCost: data.totalCost,\r\n      totalProfit: data.totalProfit,\r\n      totalDiscount: data.totalDiscount,\r\n      averageCost: data.costs.reduce((sum, cost) => sum + cost, 0) / data.costs.length,\r\n      productIds: data.productIds\r\n    }));\r\n\r\n    const sortedResult = result.sort((a, b) => b.totalAmount - a.totalAmount);\r\n\r\n    // Apply inventory filter if needed\r\n    if (showOnlyNotInInventory && dbInventoryMap) {\r\n      return sortedResult.filter(item => {\r\n        const existsById = item.productIds.some(id => dbInventoryMap.has(id));\r\n        if (existsById) return false;\r\n\r\n        const trimmedDesc = item.description.trim().toLowerCase();\r\n        return !dbInventoryMap.has(trimmedDesc);\r\n      });\r\n    }\r\n\r\n    return sortedResult;\r\n  }, [sales, dateFilter, dateRange, specificDate, dbInventoryMap, showOnlyNotInInventory]);\r\n\r\n  return {\r\n    soldItems,\r\n    isLoading: salesLoading || inventoryLoading,\r\n    loadSoldItemsData: () => {\r\n      // Force reload by invalidating sales query (since we rely on it)\r\n      clearSoldItemsCache(); // This helper from useSalesData will clear caches, but real reload comes from useSalesData invalidation\r\n    }\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2493, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useMobileOptimization.ts"],"sourcesContent":["\r\nimport { useState, useEffect } from 'react';\r\n\r\nexport interface MobileOptimizationConfig {\r\n  pageSize: number;\r\n  enableVirtualScrolling: boolean;\r\n  reducedAnimations: boolean;\r\n  compactView: boolean;\r\n}\r\n\r\nexport const useMobileOptimization = (): MobileOptimizationConfig => {\r\n  const [config, setConfig] = useState<MobileOptimizationConfig>({\r\n    pageSize: 20, // Increased default page size\r\n    enableVirtualScrolling: false,\r\n    reducedAnimations: false,\r\n    compactView: false\r\n  });\r\n\r\n  useEffect(() => {\r\n    const updateConfig = () => {\r\n      const isMobile = window.innerWidth < 768;\r\n      const isSlowConnection = 'connection' in navigator && \r\n        (navigator as any).connection?.effectiveType === 'slow-2g' || \r\n        (navigator as any).connection?.effectiveType === '2g';\r\n\r\n      setConfig({\r\n        pageSize: isMobile ? 15 : 20, // Increased page sizes but keep them reasonable\r\n        enableVirtualScrolling: isMobile,\r\n        reducedAnimations: isSlowConnection,\r\n        compactView: isMobile\r\n      });\r\n    };\r\n\r\n    updateConfig();\r\n    window.addEventListener('resize', updateConfig);\r\n    \r\n    return () => window.removeEventListener('resize', updateConfig);\r\n  }, []);\r\n\r\n  return config;\r\n};\r\n"],"names":[],"mappings":";;;;AACA;;;AASO,MAAM,wBAAwB;;IACnC,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,yKAAQ,EAA2B;QAC7D,UAAU;QACV,wBAAwB;QACxB,mBAAmB;QACnB,aAAa;IACf;IAEA,IAAA,0KAAS;2CAAC;YACR,MAAM;gEAAe;oBACnB,MAAM,WAAW,OAAO,UAAU,GAAG;oBACrC,MAAM,mBAAmB,gBAAgB,aACvC,AAAC,UAAkB,UAAU,EAAE,kBAAkB,aACjD,AAAC,UAAkB,UAAU,EAAE,kBAAkB;oBAEnD,UAAU;wBACR,UAAU,WAAW,KAAK;wBAC1B,wBAAwB;wBACxB,mBAAmB;wBACnB,aAAa;oBACf;gBACF;;YAEA;YACA,OAAO,gBAAgB,CAAC,UAAU;YAElC;mDAAO,IAAM,OAAO,mBAAmB,CAAC,UAAU;;QACpD;0CAAG,EAAE;IAEL,OAAO;AACT;GA9Ba"}},
    {"offset": {"line": 2539, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useInstallmentPayments.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { useToast } from '@/hooks/use-toast';\r\n\r\nexport interface InstallmentPayment {\r\n  id: string;\r\n  saleId: string;\r\n  userId: string;\r\n  amount: number;\r\n  paymentDate: Date;\r\n  notes?: string;\r\n  cashTransactionId?: string;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport const useInstallmentPayments = (saleId?: string) => {\r\n  const [payments, setPayments] = useState<InstallmentPayment[]>([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const { toast } = useToast();\r\n\r\n  const fetchPayments = async (targetSaleId: string) => {\r\n    try {\r\n      setIsLoading(true);\r\n      const { data, error } = await supabase\r\n        .from('installment_payments')\r\n        .select('*')\r\n        .eq('sale_id', targetSaleId)\r\n        .order('payment_date', { ascending: false });\r\n\r\n      if (error) throw error;\r\n\r\n      const formattedPayments: InstallmentPayment[] = data?.map(payment => ({\r\n        id: payment.id,\r\n        saleId: payment.sale_id,\r\n        userId: payment.user_id,\r\n        amount: Number(payment.amount),\r\n        paymentDate: new Date(payment.payment_date),\r\n        notes: payment.notes || undefined,\r\n        cashTransactionId: payment.cash_transaction_id || undefined,\r\n        createdAt: new Date(payment.created_at),\r\n        updatedAt: new Date(payment.updated_at)\r\n      })) || [];\r\n\r\n      setPayments(formattedPayments);\r\n    } catch (error) {\r\n      console.error('Error fetching installment payments:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load payment history\",\r\n        variant: \"destructive\"\r\n      });\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const createCashTransactionForPayment = async (payment: {\r\n    amount: number;\r\n    description: string;\r\n    date: Date;\r\n    accountId: string;\r\n    locationId: string;\r\n  }) => {\r\n    try {\r\n      const { data: userData } = await supabase.auth.getUser();\r\n      if (!userData.user) throw new Error('User not authenticated');\r\n\r\n      const { data, error } = await supabase\r\n        .from('cash_transactions')\r\n        .insert({\r\n          user_id: userData.user.id,\r\n          account_id: payment.accountId,\r\n          location_id: payment.locationId,\r\n          amount: payment.amount,\r\n          transaction_type: 'cash_in',\r\n          category: 'Installment payment',\r\n          description: payment.description,\r\n          date: payment.date.toISOString().split('T')[0],\r\n          person_in_charge: '',\r\n          tags: [],\r\n          payment_method: '',\r\n          receipt_image: ''\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) throw error;\r\n      return data.id;\r\n    } catch (error) {\r\n      console.error('Error creating cash transaction:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const createPayment = async (payment: {\r\n    saleId: string;\r\n    amount: number;\r\n    notes?: string;\r\n    accountId?: string;\r\n    saleDescription?: string;\r\n    locationId?: string;\r\n    paymentDate?: Date;\r\n  }) => {\r\n    try {\r\n      const { data: userData } = await supabase.auth.getUser();\r\n      if (!userData.user) throw new Error('User not authenticated');\r\n\r\n      // Count existing payments to determine if this is the first payment\r\n      const { data: existingPayments, error: countError } = await supabase\r\n        .from('installment_payments')\r\n        .select('id')\r\n        .eq('sale_id', payment.saleId);\r\n\r\n      if (countError) throw countError;\r\n\r\n      // Determine the note based on payment count\r\n      const isFirstPayment = !existingPayments || existingPayments.length === 0;\r\n      const automaticNote = isFirstPayment ? 'Initial payment' : 'Payment update';\r\n      \r\n      // Use provided notes or automatic note\r\n      const finalNotes = payment.notes || automaticNote;\r\n\r\n      let cashTransactionId = null;\r\n\r\n      // Create cash transaction if account ID and location ID are provided\r\n      if (payment.accountId && payment.locationId) {\r\n        // Get sale details for better description\r\n        const { data: saleData } = await supabase\r\n          .from('sales')\r\n          .select('customer_name, receipt_number')\r\n          .eq('id', payment.saleId)\r\n          .single();\r\n        \r\n        const description = saleData \r\n          ? `Installment payment for ${saleData.customer_name} - Receipt #${saleData.receipt_number}`\r\n          : `Installment payment for sale`;\r\n          \r\n        cashTransactionId = await createCashTransactionForPayment({\r\n          amount: payment.amount,\r\n          description: description,\r\n          date: payment.paymentDate || new Date(),\r\n          accountId: payment.accountId,\r\n          locationId: payment.locationId\r\n        });\r\n      }\r\n\r\n      const { data, error } = await supabase\r\n        .from('installment_payments')\r\n        .insert({\r\n          sale_id: payment.saleId,\r\n          user_id: userData.user.id,\r\n          amount: payment.amount,\r\n          notes: finalNotes,\r\n          cash_transaction_id: cashTransactionId,\r\n          payment_date: payment.paymentDate?.toISOString() || new Date().toISOString()\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) throw error;\r\n\r\n      const newPayment: InstallmentPayment = {\r\n        id: data.id,\r\n        saleId: data.sale_id,\r\n        userId: data.user_id,\r\n        amount: Number(data.amount),\r\n        paymentDate: new Date(data.payment_date),\r\n        notes: data.notes || undefined,\r\n        cashTransactionId: data.cash_transaction_id || undefined,\r\n        createdAt: new Date(data.created_at),\r\n        updatedAt: new Date(data.updated_at)\r\n      };\r\n\r\n      setPayments(prev => [newPayment, ...prev]);\r\n      return newPayment;\r\n    } catch (error) {\r\n      console.error('Error creating payment:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to record payment\",\r\n        variant: \"destructive\"\r\n      });\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updatePayment = async (paymentId: string, updates: {\r\n    amount?: number;\r\n    notes?: string;\r\n    paymentDate?: Date;\r\n  }) => {\r\n    try {\r\n      const payment = payments.find(p => p.id === paymentId);\r\n      if (!payment) throw new Error('Payment not found');\r\n\r\n      // Prepare update data\r\n      const updateData: any = {};\r\n      if (updates.amount !== undefined) updateData.amount = updates.amount;\r\n      if (updates.notes !== undefined) updateData.notes = updates.notes;\r\n      if (updates.paymentDate !== undefined) updateData.payment_date = updates.paymentDate.toISOString();\r\n\r\n      // Update installment payment\r\n      const { data, error } = await supabase\r\n        .from('installment_payments')\r\n        .update(updateData)\r\n        .eq('id', paymentId)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) throw error;\r\n\r\n      // Update associated cash transaction if it exists\r\n      if (payment.cashTransactionId) {\r\n        const cashUpdateData: any = {};\r\n        if (updates.amount !== undefined) cashUpdateData.amount = updates.amount;\r\n        if (updates.paymentDate !== undefined) cashUpdateData.date = updates.paymentDate.toISOString().split('T')[0];\r\n\r\n        if (Object.keys(cashUpdateData).length > 0) {\r\n          const { error: cashError } = await supabase\r\n            .from('cash_transactions')\r\n            .update(cashUpdateData)\r\n            .eq('id', payment.cashTransactionId);\r\n\r\n          if (cashError) {\r\n            console.error('Error updating cash transaction:', cashError);\r\n          }\r\n        }\r\n      }\r\n\r\n      const updatedPayment: InstallmentPayment = {\r\n        id: data.id,\r\n        saleId: data.sale_id,\r\n        userId: data.user_id,\r\n        amount: Number(data.amount),\r\n        paymentDate: new Date(data.payment_date),\r\n        notes: data.notes || undefined,\r\n        cashTransactionId: data.cash_transaction_id || undefined,\r\n        createdAt: new Date(data.created_at),\r\n        updatedAt: new Date(data.updated_at)\r\n      };\r\n\r\n      setPayments(prev => prev.map(p => p.id === paymentId ? updatedPayment : p));\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Payment updated successfully\",\r\n      });\r\n      return updatedPayment;\r\n    } catch (error) {\r\n      console.error('Error updating payment:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update payment\",\r\n        variant: \"destructive\"\r\n      });\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const deletePayment = async (paymentId: string) => {\r\n    try {\r\n      const payment = payments.find(p => p.id === paymentId);\r\n      if (!payment) throw new Error('Payment not found');\r\n\r\n      // Delete associated cash transaction first if it exists\r\n      if (payment.cashTransactionId) {\r\n        const { error: cashError } = await supabase\r\n          .from('cash_transactions')\r\n          .delete()\r\n          .eq('id', payment.cashTransactionId);\r\n\r\n        if (cashError) {\r\n          console.error('Error deleting cash transaction:', cashError);\r\n        }\r\n      }\r\n\r\n      // Delete installment payment\r\n      const { error } = await supabase\r\n        .from('installment_payments')\r\n        .delete()\r\n        .eq('id', paymentId);\r\n\r\n      if (error) throw error;\r\n\r\n      setPayments(prev => prev.filter(p => p.id !== paymentId));\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Payment deleted successfully\",\r\n      });\r\n    } catch (error) {\r\n      console.error('Error deleting payment:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete payment\",\r\n        variant: \"destructive\"\r\n      });\r\n    }\r\n  };\r\n\r\n  const linkPaymentToCashAccount = async (paymentId: string, accountId: string) => {\r\n    try {\r\n      const payment = payments.find(p => p.id === paymentId);\r\n      if (!payment) throw new Error('Payment not found');\r\n      \r\n      if (payment.cashTransactionId) {\r\n        throw new Error('Payment is already linked to a cash account');\r\n      }\r\n\r\n      const { data: userData } = await supabase.auth.getUser();\r\n      if (!userData.user) throw new Error('User not authenticated');\r\n\r\n      // Get account info for location_id\r\n      const { data: accountData, error: accountError } = await supabase\r\n        .from('cash_accounts')\r\n        .select('location_id')\r\n        .eq('id', accountId)\r\n        .single();\r\n\r\n      if (accountError) throw accountError;\r\n\r\n      // Get sale details for better description\r\n      const { data: saleData } = await supabase\r\n        .from('sales')\r\n        .select('customer_name, receipt_number')\r\n        .eq('id', payment.saleId)\r\n        .single();\r\n\r\n      const description = saleData \r\n        ? `Installment payment for ${saleData.customer_name} - Receipt #${saleData.receipt_number}`\r\n        : `Installment payment #${payment.id.substring(0, 8)}`;\r\n\r\n      // Create cash transaction\r\n      const cashTransactionId = await createCashTransactionForPayment({\r\n        amount: payment.amount,\r\n        description: description,\r\n        date: payment.paymentDate,\r\n        accountId,\r\n        locationId: accountData.location_id\r\n      });\r\n\r\n      if (!cashTransactionId) throw new Error('Failed to create cash transaction');\r\n\r\n      // Update payment with cash transaction ID\r\n      const { error: updateError } = await supabase\r\n        .from('installment_payments')\r\n        .update({ cash_transaction_id: cashTransactionId })\r\n        .eq('id', paymentId);\r\n\r\n      if (updateError) throw updateError;\r\n\r\n      // Update local state\r\n      setPayments(prev => prev.map(p => \r\n        p.id === paymentId \r\n          ? { ...p, cashTransactionId }\r\n          : p\r\n      ));\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Payment linked to cash account successfully\",\r\n      });\r\n    } catch (error) {\r\n      console.error('Error linking payment to cash account:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: error instanceof Error ? error.message : \"Failed to link payment to cash account\",\r\n        variant: \"destructive\"\r\n      });\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const unlinkPaymentFromCashAccount = async (paymentId: string) => {\r\n    try {\r\n      const payment = payments.find(p => p.id === paymentId);\r\n      if (!payment) throw new Error('Payment not found');\r\n      \r\n      if (!payment.cashTransactionId) {\r\n        throw new Error('Payment is not linked to a cash account');\r\n      }\r\n\r\n      // Delete cash transaction\r\n      const { error: cashError } = await supabase\r\n        .from('cash_transactions')\r\n        .delete()\r\n        .eq('id', payment.cashTransactionId);\r\n\r\n      if (cashError) throw cashError;\r\n\r\n      // Update payment to remove cash transaction ID\r\n      const { error: updateError } = await supabase\r\n        .from('installment_payments')\r\n        .update({ cash_transaction_id: null })\r\n        .eq('id', paymentId);\r\n\r\n      if (updateError) throw updateError;\r\n\r\n      // Update local state\r\n      setPayments(prev => prev.map(p => \r\n        p.id === paymentId \r\n          ? { ...p, cashTransactionId: undefined }\r\n          : p\r\n      ));\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Payment unlinked from cash account successfully\",\r\n      });\r\n    } catch (error) {\r\n      console.error('Error unlinking payment from cash account:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: error instanceof Error ? error.message : \"Failed to unlink payment from cash account\",\r\n        variant: \"destructive\"\r\n      });\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (saleId) {\r\n      fetchPayments(saleId);\r\n    }\r\n  }, [saleId]);\r\n\r\n  return {\r\n    payments,\r\n    isLoading,\r\n    fetchPayments,\r\n    createPayment,\r\n    updatePayment,\r\n    deletePayment,\r\n    linkPaymentToCashAccount,\r\n    unlinkPaymentFromCashAccount\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2864, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useStockSummaryData.ts"],"sourcesContent":["import { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { supabase } from '@/integrations/supabase/client';\r\n\r\nexport interface StockSummaryData {\r\n  productId: string;\r\n  productName: string;\r\n  itemNumber: string;\r\n  imageUrl?: string | null;\r\n  costPrice: number;\r\n  sellingPrice: number;\r\n  category?: string;\r\n  openingStock: number;\r\n  itemsSold: number;\r\n  stockIn: number;\r\n  transferOut: number;\r\n  returnIn: number;\r\n  returnOut: number;\r\n  returnOut: number;\r\n  adjustmentsIn: number;\r\n  adjustmentsOut: number;\r\n  closingStock: number;\r\n  revaluation: number;\r\n}\r\n\r\nexport const useStockSummaryData = (\r\n  dateRange: { from: Date | undefined; to: Date | undefined }\r\n) => {\r\n  const { user } = useAuth();\r\n  const { currentBusiness } = useBusiness();\r\n  const queryClient = useQueryClient();\r\n\r\n  const fetchStockSummary = async (): Promise<StockSummaryData[]> => {\r\n    if (!user?.id || !currentBusiness?.id || !dateRange?.from || !dateRange?.to) return [];\r\n\r\n    console.log('[StockSummary] Fetching report...', {\r\n      location: currentBusiness.id,\r\n      from: dateRange.from.toISOString(),\r\n      to: dateRange.to.toISOString()\r\n    });\r\n\r\n    // We use \"as any\" to bypass strict type checking during this debug phase\r\n    const { data, error } = await (supabase.rpc as any)('get_stock_summary_report', {\r\n      p_location_id: currentBusiness.id,\r\n      p_start_date: dateRange.from.toISOString(),\r\n      p_end_date: dateRange.to.toISOString()\r\n    });\r\n\r\n    if (error) {\r\n      // LOG AS STRING SO IT IS VISIBLE IN THE USER LOGS\r\n      console.error('[StockSummary] CRITICAL ERROR MESSAGE:', error.message);\r\n      console.error('[StockSummary] FULL ERROR OBJECT:', JSON.stringify(error, null, 2));\r\n      throw error;\r\n    }\r\n\r\n    console.log('[StockSummary] SUCCESS. Rows received:', data?.length || 0);\r\n    return (data || []) as StockSummaryData[];\r\n  };\r\n\r\n  const { data: stockSummaryData = [], isLoading, refetch } = useQuery({\r\n    queryKey: ['stockSummary', currentBusiness?.id, dateRange.from?.toISOString(), dateRange.to?.toISOString()],\r\n    queryFn: fetchStockSummary,\r\n    enabled: !!user?.id && !!currentBusiness?.id && !!dateRange?.from && !!dateRange?.to,\r\n    staleTime: 5 * 60 * 1000,\r\n    gcTime: 30 * 60 * 1000,\r\n  });\r\n\r\n  return {\r\n    stockSummaryData,\r\n    isLoading,\r\n    loadStockSummaryData: refetch,\r\n    clearCache: () => {\r\n      queryClient.invalidateQueries({ queryKey: ['stockSummary'] });\r\n    },\r\n    clearAllLocationCaches: () => {\r\n      queryClient.invalidateQueries({ queryKey: ['stockSummary'] });\r\n    }\r\n  };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AAAA;AACA;;;;;;AAuBO,MAAM,sBAAsB,CACjC;;IAEA,MAAM,EAAE,IAAI,EAAE,GAAG,IAAA,wJAAO;IACxB,MAAM,EAAE,eAAe,EAAE,GAAG,IAAA,qJAAW;IACvC,MAAM,cAAc,IAAA,2MAAc;IAElC,MAAM,oBAAoB;QACxB,IAAI,CAAC,MAAM,MAAM,CAAC,iBAAiB,MAAM,CAAC,WAAW,QAAQ,CAAC,WAAW,IAAI,OAAO,EAAE;QAEtF,QAAQ,GAAG,CAAC,qCAAqC;YAC/C,UAAU,gBAAgB,EAAE;YAC5B,MAAM,UAAU,IAAI,CAAC,WAAW;YAChC,IAAI,UAAU,EAAE,CAAC,WAAW;QAC9B;QAEA,yEAAyE;QACzE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,AAAC,wJAAQ,CAAC,GAAG,CAAS,4BAA4B;YAC9E,eAAe,gBAAgB,EAAE;YACjC,cAAc,UAAU,IAAI,CAAC,WAAW;YACxC,YAAY,UAAU,EAAE,CAAC,WAAW;QACtC;QAEA,IAAI,OAAO;YACT,kDAAkD;YAClD,QAAQ,KAAK,CAAC,0CAA0C,MAAM,OAAO;YACrE,QAAQ,KAAK,CAAC,qCAAqC,KAAK,SAAS,CAAC,OAAO,MAAM;YAC/E,MAAM;QACR;QAEA,QAAQ,GAAG,CAAC,0CAA0C,MAAM,UAAU;QACtE,OAAQ,QAAQ,EAAE;IACpB;IAEA,MAAM,EAAE,MAAM,mBAAmB,EAAE,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,IAAA,0LAAQ,EAAC;QACnE,UAAU;YAAC;YAAgB,iBAAiB;YAAI,UAAU,IAAI,EAAE;YAAe,UAAU,EAAE,EAAE;SAAc;QAC3G,SAAS;QACT,SAAS,CAAC,CAAC,MAAM,MAAM,CAAC,CAAC,iBAAiB,MAAM,CAAC,CAAC,WAAW,QAAQ,CAAC,CAAC,WAAW;QAClF,WAAW,IAAI,KAAK;QACpB,QAAQ,KAAK,KAAK;IACpB;IAEA,OAAO;QACL;QACA;QACA,sBAAsB;QACtB,YAAY;YACV,YAAY,iBAAiB,CAAC;gBAAE,UAAU;oBAAC;iBAAe;YAAC;QAC7D;QACA,wBAAwB;YACtB,YAAY,iBAAiB,CAAC;gBAAE,UAAU;oBAAC;iBAAe;YAAC;QAC7D;IACF;AACF;GArDa;;QAGM,wJAAO;QACI,qJAAW;QACnB,2MAAc;QA6B0B,0LAAQ"}},
    {"offset": {"line": 2952, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useCategories.ts"],"sourcesContent":["\r\nimport { useState, useEffect } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { ProductCategory, DbProductCategory, mapDbProductCategoryToProductCategory } from '@/types';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\n\r\nexport const useCategories = (userId: string | undefined) => {\r\n  const [categories, setCategories] = useState<ProductCategory[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const loadCategories = async () => {\r\n    try {\r\n      if (!userId || !currentBusiness) return;\r\n      \r\n      setIsLoading(true);\r\n      const { data, error } = await supabase\r\n        .from('product_categories')\r\n        .select('*')\r\n        .eq('location_id', currentBusiness.id)\r\n        .order('name');\r\n\r\n      if (error) {\r\n        throw error;\r\n      }\r\n\r\n      const formattedCategories: ProductCategory[] = data ? \r\n        data.map((item: DbProductCategory) => mapDbProductCategoryToProductCategory(item)) : [];\r\n      \r\n      setCategories(formattedCategories);\r\n    } catch (error) {\r\n      console.error('Error loading categories:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load product categories. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    loadCategories();\r\n  }, [userId, currentBusiness?.id]);\r\n\r\n  const createCategory = async (name: string) => {\r\n    try {\r\n      if (!userId || !currentBusiness) return null;\r\n\r\n      // Check if category already exists\r\n      const existingCategory = categories.find(\r\n        cat => cat.name.toLowerCase() === name.toLowerCase()\r\n      );\r\n      \r\n      if (existingCategory) {\r\n        toast({\r\n          title: \"Category exists\",\r\n          description: \"This category already exists.\",\r\n          variant: \"default\"\r\n        });\r\n        return existingCategory;\r\n      }\r\n\r\n      const { data, error } = await supabase\r\n        .from('product_categories')\r\n        .insert({\r\n          user_id: userId,\r\n          location_id: currentBusiness.id,\r\n          name\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) throw error;\r\n\r\n      if (data) {\r\n        const newCategory = mapDbProductCategoryToProductCategory(data as DbProductCategory);\r\n        setCategories([...categories, newCategory]);\r\n        return newCategory;\r\n      }\r\n      \r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error creating category:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to create category. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updateCategory = async (id: string, name: string) => {\r\n    try {\r\n      if (!userId) return false;\r\n\r\n      // Check if category already exists\r\n      const existingCategory = categories.find(\r\n        cat => cat.name.toLowerCase() === name.toLowerCase() && cat.id !== id\r\n      );\r\n      \r\n      if (existingCategory) {\r\n        toast({\r\n          title: \"Category exists\",\r\n          description: \"Another category with this name already exists.\",\r\n          variant: \"default\"\r\n        });\r\n        return false;\r\n      }\r\n\r\n      const { data, error } = await supabase\r\n        .from('product_categories')\r\n        .update({ name })\r\n        .eq('id', id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) throw error;\r\n\r\n      if (data) {\r\n        const updatedCategory = mapDbProductCategoryToProductCategory(data as DbProductCategory);\r\n        setCategories(categories.map(c => c.id === id ? updatedCategory : c));\r\n        return true;\r\n      }\r\n      \r\n      return false;\r\n    } catch (error) {\r\n      console.error('Error updating category:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update category. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteCategory = async (id: string) => {\r\n    try {\r\n      if (!userId) return false;\r\n\r\n      // First check if there are any products using this category\r\n      const { data: products, error: productsError } = await supabase\r\n        .from('products')\r\n        .select('id')\r\n        .eq('category', categories.find(c => c.id === id)?.name || '');\r\n      \r\n      if (productsError) throw productsError;\r\n      \r\n      if (products && products.length > 0) {\r\n        toast({\r\n          title: \"Cannot delete category\",\r\n          description: \"This category is being used by one or more products.\",\r\n          variant: \"destructive\"\r\n        });\r\n        return false;\r\n      }\r\n\r\n      const { error } = await supabase\r\n        .from('product_categories')\r\n        .delete()\r\n        .eq('id', id);\r\n\r\n      if (error) throw error;\r\n\r\n      setCategories(categories.filter(c => c.id !== id));\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting category:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete category. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  return { \r\n    categories, \r\n    isLoading, \r\n    loadCategories,\r\n    createCategory,\r\n    updateCategory,\r\n    deleteCategory\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3123, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useBulkProducts.ts"],"sourcesContent":["\r\nimport { useState } from 'react';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useProducts } from '@/hooks/useProducts';\r\nimport { useCategories } from '@/hooks/useCategories';\r\nimport { ProductFormData } from '@/types';\r\nimport { toast } from 'sonner';\r\n\r\nexport const useBulkProducts = () => {\r\n  const { user } = useAuth();\r\n  const { createProduct } = useProducts(user?.id);\r\n  const { categories, createCategory } = useCategories(user?.id);\r\n  const [isUploading, setIsUploading] = useState(false);\r\n\r\n  const createMissingCategories = async (productCategories: string[]) => {\r\n    const existingCategoryNames = categories.map(cat => cat.name.toLowerCase());\r\n    const uniqueCategories = [...new Set(productCategories.filter(cat => cat.trim() !== ''))];\r\n    const missingCategories = uniqueCategories.filter(\r\n      category => !existingCategoryNames.includes(category.toLowerCase())\r\n    );\r\n\r\n    const createdCategories: string[] = [];\r\n    const failedCategories: string[] = [];\r\n\r\n    for (const categoryName of missingCategories) {\r\n      try {\r\n        const result = await createCategory(categoryName);\r\n        if (result) {\r\n          createdCategories.push(categoryName);\r\n        } else {\r\n          failedCategories.push(categoryName);\r\n        }\r\n      } catch (error) {\r\n        console.error(`Failed to create category ${categoryName}:`, error);\r\n        failedCategories.push(categoryName);\r\n      }\r\n    }\r\n\r\n    return { createdCategories, failedCategories };\r\n  };\r\n\r\n  const bulkCreateProducts = async (\r\n    products: ProductFormData[], \r\n    progressCallback?: (current: number, total: number) => void\r\n  ) => {\r\n    if (!user?.id) {\r\n      throw new Error('User not authenticated');\r\n    }\r\n\r\n    setIsUploading(true);\r\n    let successCount = 0;\r\n    let failureCount = 0;\r\n    const errors: string[] = [];\r\n\r\n    try {\r\n      // Extract all categories from products\r\n      const productCategories = products.map(p => p.category).filter(Boolean);\r\n      \r\n      // Create missing categories first\r\n      if (productCategories.length > 0) {\r\n        const { createdCategories, failedCategories } = await createMissingCategories(productCategories);\r\n        \r\n        if (createdCategories.length > 0) {\r\n          toast.success(`Created ${createdCategories.length} new categories`);\r\n        }\r\n        \r\n        if (failedCategories.length > 0) {\r\n          toast.error(`Failed to create ${failedCategories.length} categories`);\r\n        }\r\n      }\r\n\r\n      // Now create products with progress tracking\r\n      for (let i = 0; i < products.length; i++) {\r\n        const productData = products[i];\r\n        \r\n        try {\r\n          const result = await createProduct(productData);\r\n          if (result) {\r\n            successCount++;\r\n          } else {\r\n            failureCount++;\r\n            errors.push(`Failed to create product: ${productData.name}`);\r\n          }\r\n        } catch (error) {\r\n          failureCount++;\r\n          errors.push(`Error creating ${productData.name}: ${error}`);\r\n          console.error(`Error creating product ${productData.name}:`, error);\r\n        }\r\n        \r\n        // Update progress after each product\r\n        if (progressCallback) {\r\n          progressCallback(successCount + failureCount, products.length);\r\n        }\r\n      }\r\n\r\n      // Show summary toast only if no progress callback (for regular usage)\r\n      if (!progressCallback) {\r\n        if (successCount > 0) {\r\n          toast.success(`Successfully created ${successCount} products`);\r\n        }\r\n        \r\n        if (failureCount > 0) {\r\n          toast.error(`${failureCount} products failed to upload`);\r\n        }\r\n      }\r\n\r\n      return { successCount, failureCount, errors };\r\n    } finally {\r\n      setIsUploading(false);\r\n    }\r\n  };\r\n\r\n  const detectNewCategories = (products: ProductFormData[]) => {\r\n    const existingCategoryNames = categories.map(cat => cat.name.toLowerCase());\r\n    const productCategories = products.map(p => p.category).filter(Boolean);\r\n    const uniqueCategories = [...new Set(productCategories)];\r\n    \r\n    return uniqueCategories.filter(\r\n      category => !existingCategoryNames.includes(category.toLowerCase())\r\n    );\r\n  };\r\n\r\n  return {\r\n    bulkCreateProducts,\r\n    detectNewCategories,\r\n    isUploading\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3258, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useRequisitions.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { useToast } from '@/hooks/use-toast';\r\n\r\nexport interface Requisition {\r\n  id: string;\r\n  userId: string;\r\n  locationId: string;\r\n  requisitionNumber: string;\r\n  title: string;\r\n  items: RequisitionItem[];\r\n  notes: string | null;\r\n  status: 'draft' | 'submitted' | 'approved' | 'completed';\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface RequisitionItem {\r\n  id: string;\r\n  productId: string;\r\n  productName: string;\r\n  quantity: number;\r\n  urgentItem?: boolean;\r\n}\r\n\r\nexport interface DbRequisition {\r\n  id: string;\r\n  user_id: string;\r\n  location_id: string;\r\n  requisition_number: string;\r\n  title: string;\r\n  items: any;\r\n  notes: string | null;\r\n  status: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nconst mapDbRequisitionToRequisition = (dbRequisition: DbRequisition): Requisition => {\r\n  return {\r\n    id: dbRequisition.id,\r\n    userId: dbRequisition.user_id,\r\n    locationId: dbRequisition.location_id,\r\n    requisitionNumber: dbRequisition.requisition_number,\r\n    title: dbRequisition.title,\r\n    items: dbRequisition.items as RequisitionItem[],\r\n    notes: dbRequisition.notes,\r\n    status: dbRequisition.status as 'draft' | 'submitted' | 'approved' | 'completed',\r\n    createdAt: new Date(dbRequisition.created_at),\r\n    updatedAt: new Date(dbRequisition.updated_at)\r\n  };\r\n};\r\n\r\nexport const useRequisitions = (userId: string | undefined, locationId: string | undefined) => {\r\n  const [requisitions, setRequisitions] = useState<Requisition[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const { toast } = useToast();\r\n\r\n  const loadRequisitions = async () => {\r\n    if (!userId || !locationId) {\r\n      setRequisitions([]);\r\n      setIsLoading(false);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setIsLoading(true);\r\n      const { data, error } = await supabase\r\n        .from('requisitions')\r\n        .select('*')\r\n        .eq('user_id', userId)\r\n        .eq('location_id', locationId)\r\n        .order('created_at', { ascending: false });\r\n\r\n      if (error) {\r\n        throw error;\r\n      }\r\n\r\n      const formattedRequisitions = data ? data.map(mapDbRequisitionToRequisition) : [];\r\n      setRequisitions(formattedRequisitions);\r\n    } catch (error) {\r\n      console.error('Error loading requisitions:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load requisitions. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    loadRequisitions();\r\n  }, [userId, locationId]);\r\n\r\n  const createRequisition = async (\r\n    title: string,\r\n    items: RequisitionItem[],\r\n    notes?: string\r\n  ): Promise<Requisition | null> => {\r\n    if (!userId || !locationId) return null;\r\n\r\n    try {\r\n      const requisitionNumber = generateRequisitionNumber();\r\n\r\n      const { data, error } = await supabase\r\n        .from('requisitions')\r\n        .insert({\r\n          user_id: userId,\r\n          location_id: locationId,\r\n          requisition_number: requisitionNumber,\r\n          title: title,\r\n          items: items as any,\r\n          notes: notes || null,\r\n          status: 'draft'\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        throw error;\r\n      }\r\n\r\n      const newRequisition = mapDbRequisitionToRequisition(data);\r\n      setRequisitions(prev => [newRequisition, ...prev]);\r\n      \r\n      toast({\r\n        title: \"Requisition created\",\r\n        description: `Requisition ${requisitionNumber} has been created successfully.`\r\n      });\r\n\r\n      return newRequisition;\r\n    } catch (error) {\r\n      console.error('Error creating requisition:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to create requisition. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updateRequisition = async (\r\n    id: string,\r\n    updates: Partial<{\r\n      title: string;\r\n      items: RequisitionItem[];\r\n      notes: string;\r\n      status: 'draft' | 'submitted' | 'approved' | 'completed';\r\n    }>\r\n  ): Promise<boolean> => {\r\n    if (!userId) return false;\r\n\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('requisitions')\r\n        .update({\r\n          ...updates,\r\n          items: updates.items as any,\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .eq('id', id)\r\n        .eq('user_id', userId)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        throw error;\r\n      }\r\n\r\n      const updatedRequisition = mapDbRequisitionToRequisition(data);\r\n      setRequisitions(prev => prev.map(req => req.id === id ? updatedRequisition : req));\r\n      \r\n      toast({\r\n        title: \"Requisition updated\",\r\n        description: \"Requisition has been updated successfully.\"\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating requisition:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update requisition. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteRequisition = async (id: string): Promise<boolean> => {\r\n    if (!userId) return false;\r\n\r\n    try {\r\n      const { error } = await supabase\r\n        .from('requisitions')\r\n        .delete()\r\n        .eq('id', id)\r\n        .eq('user_id', userId);\r\n\r\n      if (error) {\r\n        throw error;\r\n      }\r\n\r\n      setRequisitions(prev => prev.filter(req => req.id !== id));\r\n      \r\n      toast({\r\n        title: \"Requisition deleted\",\r\n        description: \"Requisition has been deleted successfully.\"\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting requisition:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete requisition. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  return {\r\n    requisitions,\r\n    isLoading,\r\n    loadRequisitions,\r\n    createRequisition,\r\n    updateRequisition,\r\n    deleteRequisition\r\n  };\r\n};\r\n\r\nconst generateRequisitionNumber = () => {\r\n  const date = new Date();\r\n  const year = date.getFullYear().toString().slice(-2);\r\n  const month = (date.getMonth() + 1).toString().padStart(2, '0');\r\n  const day = date.getDate().toString().padStart(2, '0');\r\n  const time = date.getTime().toString().slice(-4);\r\n  return `REQ${year}${month}${day}${time}`;\r\n};"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;AAoCA,MAAM,gCAAgC,CAAC;IACrC,OAAO;QACL,IAAI,cAAc,EAAE;QACpB,QAAQ,cAAc,OAAO;QAC7B,YAAY,cAAc,WAAW;QACrC,mBAAmB,cAAc,kBAAkB;QACnD,OAAO,cAAc,KAAK;QAC1B,OAAO,cAAc,KAAK;QAC1B,OAAO,cAAc,KAAK;QAC1B,QAAQ,cAAc,MAAM;QAC5B,WAAW,IAAI,KAAK,cAAc,UAAU;QAC5C,WAAW,IAAI,KAAK,cAAc,UAAU;IAC9C;AACF;AAEO,MAAM,kBAAkB,CAAC,QAA4B;;IAC1D,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,yKAAQ,EAAgB,EAAE;IAClE,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAC;IAC3C,MAAM,EAAE,KAAK,EAAE,GAAG,IAAA,2IAAQ;IAE1B,MAAM,mBAAmB;QACvB,IAAI,CAAC,UAAU,CAAC,YAAY;YAC1B,gBAAgB,EAAE;YAClB,aAAa;YACb;QACF;QAEA,IAAI;YACF,aAAa;YACb,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,wJAAQ,CACnC,IAAI,CAAC,gBACL,MAAM,CAAC,KACP,EAAE,CAAC,WAAW,QACd,EAAE,CAAC,eAAe,YAClB,KAAK,CAAC,cAAc;gBAAE,WAAW;YAAM;YAE1C,IAAI,OAAO;gBACT,MAAM;YACR;YAEA,MAAM,wBAAwB,OAAO,KAAK,GAAG,CAAC,iCAAiC,EAAE;YACjF,gBAAgB;QAClB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,MAAM;gBACJ,OAAO;gBACP,aAAa;gBACb,SAAS;YACX;QACF,SAAU;YACR,aAAa;QACf;IACF;IAEA,IAAA,0KAAS;qCAAC;YACR;QACF;oCAAG;QAAC;QAAQ;KAAW;IAEvB,MAAM,oBAAoB,OACxB,OACA,OACA;QAEA,IAAI,CAAC,UAAU,CAAC,YAAY,OAAO;QAEnC,IAAI;YACF,MAAM,oBAAoB;YAE1B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,wJAAQ,CACnC,IAAI,CAAC,gBACL,MAAM,CAAC;gBACN,SAAS;gBACT,aAAa;gBACb,oBAAoB;gBACpB,OAAO;gBACP,OAAO;gBACP,OAAO,SAAS;gBAChB,QAAQ;YACV,GACC,MAAM,GACN,MAAM;YAET,IAAI,OAAO;gBACT,MAAM;YACR;YAEA,MAAM,iBAAiB,8BAA8B;YACrD,gBAAgB,CAAA,OAAQ;oBAAC;uBAAmB;iBAAK;YAEjD,MAAM;gBACJ,OAAO;gBACP,aAAa,CAAC,YAAY,EAAE,kBAAkB,+BAA+B,CAAC;YAChF;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,MAAM;gBACJ,OAAO;gBACP,aAAa;gBACb,SAAS;YACX;YACA,OAAO;QACT;IACF;IAEA,MAAM,oBAAoB,OACxB,IACA;QAOA,IAAI,CAAC,QAAQ,OAAO;QAEpB,IAAI;YACF,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,wJAAQ,CACnC,IAAI,CAAC,gBACL,MAAM,CAAC;gBACN,GAAG,OAAO;gBACV,OAAO,QAAQ,KAAK;gBACpB,YAAY,IAAI,OAAO,WAAW;YACpC,GACC,EAAE,CAAC,MAAM,IACT,EAAE,CAAC,WAAW,QACd,MAAM,GACN,MAAM;YAET,IAAI,OAAO;gBACT,MAAM;YACR;YAEA,MAAM,qBAAqB,8BAA8B;YACzD,gBAAgB,CAAA,OAAQ,KAAK,GAAG,CAAC,CAAA,MAAO,IAAI,EAAE,KAAK,KAAK,qBAAqB;YAE7E,MAAM;gBACJ,OAAO;gBACP,aAAa;YACf;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,MAAM;gBACJ,OAAO;gBACP,aAAa;gBACb,SAAS;YACX;YACA,OAAO;QACT;IACF;IAEA,MAAM,oBAAoB,OAAO;QAC/B,IAAI,CAAC,QAAQ,OAAO;QAEpB,IAAI;YACF,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,wJAAQ,CAC7B,IAAI,CAAC,gBACL,MAAM,GACN,EAAE,CAAC,MAAM,IACT,EAAE,CAAC,WAAW;YAEjB,IAAI,OAAO;gBACT,MAAM;YACR;YAEA,gBAAgB,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,MAAO,IAAI,EAAE,KAAK;YAEtD,MAAM;gBACJ,OAAO;gBACP,aAAa;YACf;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,MAAM;gBACJ,OAAO;gBACP,aAAa;gBACb,SAAS;YACX;YACA,OAAO;QACT;IACF;IAEA,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;IACF;AACF;GApLa;;QAGO,2IAAQ;;;AAmL5B,MAAM,4BAA4B;IAChC,MAAM,OAAO,IAAI;IACjB,MAAM,OAAO,KAAK,WAAW,GAAG,QAAQ,GAAG,KAAK,CAAC,CAAC;IAClD,MAAM,QAAQ,CAAC,KAAK,QAAQ,KAAK,CAAC,EAAE,QAAQ,GAAG,QAAQ,CAAC,GAAG;IAC3D,MAAM,MAAM,KAAK,OAAO,GAAG,QAAQ,GAAG,QAAQ,CAAC,GAAG;IAClD,MAAM,OAAO,KAAK,OAAO,GAAG,QAAQ,GAAG,KAAK,CAAC,CAAC;IAC9C,OAAO,CAAC,GAAG,EAAE,OAAO,QAAQ,MAAM,MAAM;AAC1C"}},
    {"offset": {"line": 3439, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/usePagination.ts"],"sourcesContent":["\r\nimport { useState, useMemo } from 'react';\r\n\r\ninterface UsePaginationProps<T> {\r\n  items: T[];\r\n  itemsPerPage?: number;\r\n}\r\n\r\ninterface UsePaginationReturn<T> {\r\n  currentPage: number;\r\n  setCurrentPage: (page: number) => void;\r\n  paginatedItems: T[];\r\n  totalPages: number;\r\n}\r\n\r\nexport function usePagination<T>({ \r\n  items, \r\n  itemsPerPage = 20 // Increased from 10 to 20 for better UX with larger datasets\r\n}: UsePaginationProps<T>): UsePaginationReturn<T> {\r\n  const [currentPage, setCurrentPage] = useState(1);\r\n  \r\n  const totalPages = useMemo(() => {\r\n    return Math.max(1, Math.ceil(items.length / itemsPerPage));\r\n  }, [items, itemsPerPage]);\r\n  \r\n  // Adjust current page if it's out of bounds\r\n  useMemo(() => {\r\n    if (currentPage > totalPages) {\r\n      setCurrentPage(totalPages);\r\n    }\r\n  }, [totalPages, currentPage]);\r\n  \r\n  const paginatedItems = useMemo(() => {\r\n    const startIndex = (currentPage - 1) * itemsPerPage;\r\n    return items.slice(startIndex, startIndex + itemsPerPage);\r\n  }, [items, currentPage, itemsPerPage]);\r\n  \r\n  return {\r\n    currentPage,\r\n    setCurrentPage,\r\n    paginatedItems,\r\n    totalPages\r\n  };\r\n}\r\n"],"names":[],"mappings":";;;;AACA;;;AAcO,SAAS,cAAiB,EAC/B,KAAK,EACL,eAAe,GAAG,6DAA6D;AAA9D,EACK;;IACtB,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,yKAAQ,EAAC;IAE/C,MAAM,aAAa,IAAA,wKAAO;6CAAC;YACzB,OAAO,KAAK,GAAG,CAAC,GAAG,KAAK,IAAI,CAAC,MAAM,MAAM,GAAG;QAC9C;4CAAG;QAAC;QAAO;KAAa;IAExB,4CAA4C;IAC5C,IAAA,wKAAO;iCAAC;YACN,IAAI,cAAc,YAAY;gBAC5B,eAAe;YACjB;QACF;gCAAG;QAAC;QAAY;KAAY;IAE5B,MAAM,iBAAiB,IAAA,wKAAO;iDAAC;YAC7B,MAAM,aAAa,CAAC,cAAc,CAAC,IAAI;YACvC,OAAO,MAAM,KAAK,CAAC,YAAY,aAAa;QAC9C;gDAAG;QAAC;QAAO;QAAa;KAAa;IAErC,OAAO;QACL;QACA;QACA;QACA;IACF;AACF;GA5BgB"}},
    {"offset": {"line": 3494, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useInventoryData.ts"],"sourcesContent":["import { useMemo } from 'react';\r\nimport { Product } from '@/types';\r\nimport { Sale } from '@/types';\r\nimport { format, startOfDay, endOfDay, startOfWeek, endOfWeek, startOfMonth, endOfMonth } from 'date-fns';\r\nimport { calculateItemActualAmount, calculateItemActualPrice } from '@/utils/discountCalculations';\r\n\r\nexport interface TopSellingItem {\r\n  description: string;\r\n  totalQuantity: number;\r\n  averagePrice: number;\r\n  totalAmount: number;\r\n  totalCost: number;\r\n  totalProfit: number;\r\n  totalDiscount: number;\r\n  averageCost?: number;\r\n  productIds: string[];\r\n}\r\n\r\nexport const useInventoryData = (\r\n  filteredProducts: Product[],\r\n  sales: Sale[],\r\n  period: 'today' | 'yesterday' | 'this-week' | 'last-week' | 'this-month' | 'last-month' | 'all-time'\r\n) => {\r\n  // Calculate date range based on selected period\r\n  const dateRange = useMemo(() => {\r\n    const now = new Date();\r\n    switch (period) {\r\n      case 'today':\r\n        return { from: startOfDay(now), to: endOfDay(now) };\r\n      case 'yesterday':\r\n        const yesterday = new Date(now);\r\n        yesterday.setDate(yesterday.getDate() - 1);\r\n        return { from: startOfDay(yesterday), to: endOfDay(yesterday) };\r\n      case 'this-week':\r\n        return { from: startOfWeek(now), to: endOfWeek(now) };\r\n      case 'last-week':\r\n        const lastWeek = new Date(now);\r\n        lastWeek.setDate(lastWeek.getDate() - 7);\r\n        return { from: startOfWeek(lastWeek), to: endOfWeek(lastWeek) };\r\n      case 'this-month':\r\n        return { from: startOfMonth(now), to: endOfMonth(now) };\r\n      case 'last-month':\r\n        const lastMonth = new Date(now);\r\n        lastMonth.setMonth(lastMonth.getMonth() - 1);\r\n        return { from: startOfMonth(lastMonth), to: endOfMonth(lastMonth) };\r\n      case 'all-time':\r\n      default:\r\n        return { from: new Date(0), to: now };\r\n    }\r\n  }, [period]);\r\n\r\n  // Memoize top selling products (aggregated by item description from sales)\r\n  const topSellingProducts = useMemo(() => {\r\n    try {\r\n      // Early return if no data\r\n      if (!sales || sales.length === 0) {\r\n        return [];\r\n      }\r\n\r\n      // Filter sales by date range and payment status with safer date handling\r\n      const filteredSales = sales.filter(sale => {\r\n        try {\r\n          if (!sale || sale.paymentStatus === 'Quote') return false;\r\n          const saleDate = new Date(sale.date);\r\n          // Check for invalid date\r\n          if (isNaN(saleDate.getTime())) return false;\r\n          return saleDate >= dateRange.from && saleDate <= dateRange.to;\r\n        } catch (error) {\r\n          console.warn('Error filtering sale:', error);\r\n          return false;\r\n        }\r\n      });\r\n\r\n      // Aggregate items by description (same logic as useSoldItemsData)\r\n      const itemsMap = new Map<string, {\r\n        totalQuantity: number;\r\n        totalAmount: number;\r\n        totalCost: number;\r\n        totalProfit: number;\r\n        totalDiscount: number;\r\n        prices: number[];\r\n        costs: number[];\r\n        productIds: string[]\r\n      }>();\r\n\r\n      filteredSales.forEach(sale => {\r\n        try {\r\n          if (!sale.items || !Array.isArray(sale.items)) return;\r\n\r\n          sale.items.forEach(item => {\r\n            const key = item.description;\r\n            const subtotal = item.price * item.quantity;\r\n            const amount = calculateItemActualAmount(item);\r\n            const discount = subtotal - amount;\r\n            const cost = (item.cost || 0) * item.quantity;\r\n            const profit = amount - cost;\r\n            const actualPrice = calculateItemActualPrice(item);\r\n\r\n            if (itemsMap.has(key)) {\r\n              const existing = itemsMap.get(key)!;\r\n              existing.totalQuantity += item.quantity;\r\n              existing.totalAmount += amount;\r\n              existing.totalCost += cost;\r\n              existing.totalProfit += profit;\r\n              existing.totalDiscount += discount;\r\n              existing.prices.push(actualPrice);\r\n              existing.costs.push(item.cost || 0);\r\n              if (item.productId && !existing.productIds.includes(item.productId)) {\r\n                existing.productIds.push(item.productId);\r\n              }\r\n            } else {\r\n              itemsMap.set(key, {\r\n                totalQuantity: item.quantity,\r\n                totalAmount: amount,\r\n                totalCost: cost,\r\n                totalProfit: profit,\r\n                totalDiscount: discount,\r\n                prices: [actualPrice],\r\n                costs: [item.cost || 0],\r\n                productIds: item.productId ? [item.productId] : []\r\n              });\r\n            }\r\n          });\r\n        } catch (error) {\r\n          console.warn('Error processing sale items:', error);\r\n        }\r\n      });\r\n\r\n      // Convert to array and sort by total quantity sold\r\n      const result: TopSellingItem[] = Array.from(itemsMap.entries()).map(([description, data]) => ({\r\n        description,\r\n        totalQuantity: data.totalQuantity,\r\n        averagePrice: data.prices.reduce((sum, price) => sum + price, 0) / data.prices.length,\r\n        totalAmount: data.totalAmount,\r\n        totalCost: data.totalCost,\r\n        totalProfit: data.totalProfit,\r\n        totalDiscount: data.totalDiscount,\r\n        averageCost: data.costs.reduce((sum, cost) => sum + cost, 0) / data.costs.length,\r\n        productIds: data.productIds\r\n      }));\r\n\r\n      // Sort by total quantity and return all\r\n      return result\r\n        .sort((a, b) => b.totalQuantity - a.totalQuantity);\r\n    } catch (error) {\r\n      console.error('Error calculating top selling products:', error);\r\n      return [];\r\n    }\r\n  }, [sales, dateRange]);\r\n\r\n  return {\r\n    topSellingProducts,\r\n    dateRange\r\n  };\r\n};"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3683, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useGlobalInventoryStats.ts"],"sourcesContent":["import { useQuery } from '@tanstack/react-query';\r\nimport { supabase } from '@/integrations/supabase/client';\r\n\r\nexport interface GlobalInventoryStats {\r\n    totalCostValue: number;\r\n    totalStockValue: number;\r\n    lowStockCount: number;\r\n    outOfStockCount: number;\r\n}\r\n\r\nexport const useGlobalInventoryStats = (businessId: string | undefined) => {\r\n    return useQuery<GlobalInventoryStats>({\r\n        queryKey: ['inventory_global_stats', businessId],\r\n        queryFn: async (): Promise<GlobalInventoryStats> => {\r\n            if (!businessId) {\r\n                return {\r\n                    totalCostValue: 0,\r\n                    totalStockValue: 0,\r\n                    lowStockCount: 0,\r\n                    outOfStockCount: 0\r\n                };\r\n            }\r\n\r\n            const { data, error } = await (supabase.rpc as any)('get_inventory_stats', {\r\n                p_location_id: businessId\r\n            });\r\n\r\n            if (error) {\r\n                console.error('Error fetching global stats:', error);\r\n                throw error;\r\n            }\r\n\r\n            // Map the snake_case or json keys to our interface\r\n            // The RPC returns a JSON object, so keys will be exactly what we built in json_build_object\r\n            const result = data as any;\r\n\r\n            return {\r\n                totalCostValue: Number(result.totalCostValue) || 0,\r\n                totalStockValue: Number(result.totalStockValue) || 0,\r\n                lowStockCount: Number(result.lowStockCount) || 0,\r\n                outOfStockCount: Number(result.outOfStockCount) || 0\r\n            };\r\n        },\r\n        enabled: !!businessId,\r\n        staleTime: 30 * 1000, // 30 seconds\r\n        gcTime: 5 * 60 * 1000, // Keep cache for 5 mins\r\n    });\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;AASO,MAAM,0BAA0B,CAAC;;IACpC,OAAO,IAAA,0LAAQ,EAAuB;QAClC,UAAU;YAAC;YAA0B;SAAW;QAChD,OAAO;gDAAE;gBACL,IAAI,CAAC,YAAY;oBACb,OAAO;wBACH,gBAAgB;wBAChB,iBAAiB;wBACjB,eAAe;wBACf,iBAAiB;oBACrB;gBACJ;gBAEA,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,AAAC,wJAAQ,CAAC,GAAG,CAAS,uBAAuB;oBACvE,eAAe;gBACnB;gBAEA,IAAI,OAAO;oBACP,QAAQ,KAAK,CAAC,gCAAgC;oBAC9C,MAAM;gBACV;gBAEA,mDAAmD;gBACnD,4FAA4F;gBAC5F,MAAM,SAAS;gBAEf,OAAO;oBACH,gBAAgB,OAAO,OAAO,cAAc,KAAK;oBACjD,iBAAiB,OAAO,OAAO,eAAe,KAAK;oBACnD,eAAe,OAAO,OAAO,aAAa,KAAK;oBAC/C,iBAAiB,OAAO,OAAO,eAAe,KAAK;gBACvD;YACJ;;QACA,SAAS,CAAC,CAAC;QACX,WAAW,KAAK;QAChB,QAAQ,IAAI,KAAK;IACrB;AACJ;GArCa;;QACF,0LAAQ"}}]
}