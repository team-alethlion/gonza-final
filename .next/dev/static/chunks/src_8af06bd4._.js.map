{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useMessages.ts"],"sourcesContent":["// hooks/useMessages.ts\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useProfiles } from '@/contexts/ProfileContext';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\n\r\nexport interface Message {\r\n  id: string;\r\n  userId: string;\r\n  locationId: string;\r\n  profileId?: string;\r\n  customerId?: string;\r\n  phoneNumber: string;\r\n  content: string;\r\n  status: 'pending' | 'sent' | 'delivered' | 'failed';\r\n  smsCreditsUsed: number;\r\n  templateId?: string;\r\n  errorMessage?: string;\r\n  sentAt?: string;\r\n  deliveredAt?: string;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  metadata?: any;\r\n}\r\n\r\nexport interface MessageTemplate {\r\n  id: string;\r\n  userId: string;\r\n  locationId: string;\r\n  name: string;\r\n  content: string;\r\n  category: string | null;\r\n  variables: string[];\r\n  isDefault: boolean;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\nexport interface Purchase {\r\n  id: string;\r\n  userId: string;\r\n  locationId: string;\r\n  profileId?: string;\r\n  creditsAmount: number;\r\n  totalCost: number;\r\n  paymentPhoneNumber: string;\r\n  paymentStatus: string;\r\n  pesapalTrackingId?: string;\r\n  pesapalMerchantReference?: string;\r\n  pesapalRedirectUrl?: string;\r\n  paymentMethod?: string;\r\n  paymentCompletedAt?: string;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\nconst formatPhoneNumber = (phone: string) => {\r\n  let cleaned = phone.replace(/[\\s\\-\\(\\)]/g, '');\r\n  if (cleaned.startsWith('+')) return cleaned;\r\n  if (cleaned.startsWith('256')) return '+' + cleaned;\r\n  if (cleaned.startsWith('0')) return '+256' + cleaned.substring(1);\r\n  if (cleaned.length === 9 && cleaned.match(/^[7]\\d{8}$/)) return '+256' + cleaned;\r\n  return '+256' + cleaned;\r\n};\r\n\r\nexport const useMessages = (userId?: string) => {\r\n  const [messages, setMessages] = useState<Message[]>([]);\r\n  const [templates, setTemplates] = useState<any[]>([]);\r\n  const [purchases, setPurchases] = useState<Purchase[]>([]);\r\n  const [liveCredits, setLiveCredits] = useState<number>(0);\r\n  // Remove manual loading state; derive from React Query for messages\r\n\r\n  const { currentBusiness } = useBusiness();\r\n  const { currentProfile } = useProfiles();\r\n  const queryClient = useQueryClient();\r\n\r\n  // -----------------------------\r\n  // FETCH LIVE CREDITS\r\n  // -----------------------------\r\n  const fetchLiveCredits = async () => {\r\n    if (!currentProfile?.id) return;\r\n    const { data, error } = await supabase\r\n      .from('business_profiles')\r\n      .select('sms_credits')\r\n      .eq('id', currentProfile.id)\r\n      .single();\r\n\r\n    if (!error && data) setLiveCredits(data.sms_credits);\r\n  };\r\n\r\n  // Templates\r\n  const createTemplate = async (templateData: Omit<MessageTemplate, 'id' | 'userId' | 'locationId' | 'createdAt' | 'updatedAt'>) => {\r\n    if (!userId || !currentBusiness?.id) return null;\r\n\r\n    const { data, error } = await supabase\r\n      .from('message_templates')\r\n      .insert({\r\n        user_id: userId,\r\n        location_id: currentBusiness.id,\r\n        name: templateData.name,\r\n        content: templateData.content,\r\n        category: templateData.category,\r\n        variables: templateData.variables,\r\n        is_default: templateData.isDefault\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (!error && data) {\r\n      const newTemplate: MessageTemplate = {\r\n        id: data.id,\r\n        userId: data.user_id,\r\n        locationId: data.location_id,\r\n        name: data.name,\r\n        content: data.content,\r\n        category: data.category,\r\n        variables: data.variables,\r\n        isDefault: data.is_default,\r\n        createdAt: data.created_at,\r\n        updatedAt: data.updated_at\r\n      };\r\n\r\n      setTemplates(prev => [newTemplate, ...prev]);\r\n      return newTemplate;\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  const updateTemplate = async (id: string, updates: Partial<MessageTemplate>) => {\r\n    const { error } = await supabase\r\n      .from('message_templates')\r\n      .update({\r\n        name: updates.name,\r\n        content: updates.content,\r\n        category: updates.category,\r\n        variables: updates.variables,\r\n        is_default: updates.isDefault,\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .eq('id', id);\r\n\r\n    if (!error) {\r\n      await fetchTemplates();\r\n    }\r\n  };\r\n\r\n  const deleteTemplate = async (id: string) => {\r\n    const { error } = await supabase\r\n      .from('message_templates')\r\n      .delete()\r\n      .eq('id', id);\r\n\r\n    if (!error) {\r\n      setTemplates(prev => prev.filter(t => t.id !== id));\r\n    }\r\n  };\r\n\r\n  // -----------------------------\r\n  // FETCH MESSAGES\r\n  // -----------------------------\r\n  const fetchMessages = useCallback(async (): Promise<Message[]> => {\r\n    if (!userId || !currentBusiness?.id) return [];\r\n    const { data, error } = await supabase\r\n      .from('messages')\r\n      .select('*')\r\n      .eq('user_id', userId)\r\n      .eq('location_id', currentBusiness.id)\r\n      .order('created_at', { ascending: false });\r\n\r\n    if (!error && data) {\r\n      const formattedMessages = data.map(msg => ({\r\n        id: msg.id,\r\n        userId: msg.user_id,\r\n        locationId: msg.location_id,\r\n        profileId: msg.profile_id,\r\n        customerId: msg.customer_id,\r\n        phoneNumber: msg.phone_number,\r\n        content: msg.content,\r\n        status: msg.status,\r\n        smsCreditsUsed: msg.sms_credits_used,\r\n        templateId: msg.template_id,\r\n        errorMessage: msg.error_message,\r\n        sentAt: msg.sent_at,\r\n        deliveredAt: msg.delivered_at,\r\n        createdAt: msg.created_at,\r\n        updatedAt: msg.updated_at,\r\n        metadata: msg.metadata\r\n      }));\r\n      return formattedMessages;\r\n    }\r\n    return [];\r\n  }, [userId, currentBusiness?.id]);\r\n\r\n  // React Query caching for messages\r\n  const messagesQueryKey = ['messages', userId, currentBusiness?.id];\r\n  const { data: queriedMessages, isLoading: messagesLoading, isFetching: messagesFetching } = useQuery({\r\n    queryKey: messagesQueryKey,\r\n    queryFn: fetchMessages,\r\n    enabled: !!userId && !!currentBusiness?.id,\r\n    staleTime: 5 * 60_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: false,\r\n    refetchOnReconnect: false,\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (queriedMessages) {\r\n      setMessages(queriedMessages);\r\n    }\r\n  }, [queriedMessages]);\r\n\r\n  // -----------------------------\r\n  // FETCH TEMPLATES\r\n  // -----------------------------\r\n  const fetchTemplates = async () => {\r\n    if (!userId || !currentBusiness?.id) return;\r\n    const { data, error } = await supabase\r\n      .from('message_templates')\r\n      .select('*')\r\n      .eq('user_id', userId)\r\n      .eq('location_id', currentBusiness.id)\r\n      .order('created_at', { ascending: false });\r\n\r\n    if (!error) setTemplates(data || []);\r\n  };\r\n\r\n  // -----------------------------\r\n  // FETCH PURCHASES\r\n  // -----------------------------\r\n  const fetchPurchases = async () => {\r\n    if (!userId || !currentBusiness?.id) return;\r\n    const { data, error } = await supabase\r\n      .from('sms_credit_purchases')\r\n      .select('*')\r\n      .eq('user_id', userId)\r\n      .eq('location_id', currentBusiness.id)\r\n      .order('created_at', { ascending: false })\r\n      .limit(10);\r\n\r\n    if (!error && data) setPurchases(data);\r\n  };\r\n\r\n  // -----------------------------\r\n  // SEND SMS EDGE\r\n  // -----------------------------\r\n  const sendSMSViaEdgeFunction = async (messageId: string) => {\r\n    const { data: { session } } = await supabase.auth.getSession();\r\n    if (!session?.access_token) throw new Error('No active session');\r\n\r\n    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\r\n    const response = await fetch(`${supabaseUrl}/functions/v1/send-sms`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Authorization': `Bearer ${session.access_token}`\r\n      },\r\n      body: JSON.stringify({ messageId })\r\n    });\r\n\r\n    const result = await response.json();\r\n    if (!response.ok || !result.success) throw new Error(JSON.stringify(result));\r\n    return result;\r\n  };\r\n\r\n  // -----------------------------\r\n  // CREATE SINGLE MESSAGE\r\n  // -----------------------------\r\n  const createMessage = async (messageData: { phoneNumber: string; content: string; customerId?: string; templateId?: string; metadata?: any }) => {\r\n    if (!userId || !currentBusiness?.id || !currentProfile) return null;\r\n\r\n    const formattedPhone = formatPhoneNumber(messageData.phoneNumber);\r\n\r\n    let finalContent = messageData.content;\r\n    if (messageData.customerId) {\r\n      const { data: customer } = await supabase\r\n        .from('customers')\r\n        .select('full_name, phone_number, email')\r\n        .eq('id', messageData.customerId)\r\n        .single();\r\n      if (customer) {\r\n        finalContent = finalContent\r\n          .replace(/\\{customer_name\\}/gi, customer.full_name || 'Customer')\r\n          .replace(/\\{customer_phone\\}/gi, customer.phone_number || '')\r\n          .replace(/\\{customer_email\\}/gi, customer.email || '')\r\n          .replace(/\\{first_name\\}/gi, customer.full_name?.split(' ')[0] || 'Customer')\r\n          .replace(/\\{last_name\\}/gi, customer.full_name?.split(' ').slice(1).join(' ') || '');\r\n      }\r\n    }\r\n\r\n    const creditsNeeded = Math.ceil(finalContent.length / 160);\r\n    if (currentProfile.sms_credits < creditsNeeded) throw new Error(`Insufficient credits`);\r\n\r\n    const { data, error } = await supabase\r\n      .from('messages')\r\n      .insert({\r\n        user_id: userId,\r\n        location_id: currentBusiness.id,\r\n        profile_id: currentProfile.id,\r\n        customer_id: messageData.customerId,\r\n        phone_number: formattedPhone,\r\n        content: finalContent,\r\n        template_id: messageData.templateId,\r\n        sms_credits_used: creditsNeeded,\r\n        status: 'pending',\r\n        metadata: messageData.metadata\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (error || !data) throw error;\r\n\r\n    // Note: Credits will be automatically deducted by database trigger when message status becomes 'sent'\r\n    // This prevents charging for failed messages\r\n\r\n    const newMessage: Message = { ...data, userId: data.user_id, locationId: data.location_id };\r\n\r\n    // Update local state immediately\r\n    setMessages(prev => [newMessage, ...prev]);\r\n\r\n    // Update React Query cache immediately\r\n    queryClient.setQueryData(messagesQueryKey, (oldData: Message[] | undefined) => {\r\n      return oldData ? [newMessage, ...oldData] : [newMessage];\r\n    });\r\n\r\n    // Send SMS asynchronously - edge function will update status which triggers credit deduction\r\n    sendSMSViaEdgeFunction(data.id).catch((err) => {\r\n      console.error('Failed to send SMS:', err);\r\n      // Message status will remain 'pending', no credits deducted\r\n    });\r\n\r\n    return newMessage;\r\n  };\r\n\r\n  // -----------------------------\r\n  // CREATE BULK MESSAGES\r\n  // -----------------------------\r\n  const createBulkMessages = async (messageData: { customerIds: string[]; content: string; templateId?: string; metadata?: any }) => {\r\n    if (!userId || !currentBusiness?.id || !currentProfile) return { success: 0, failed: 0, errors: [] as string[] };\r\n\r\n    const { data: customers } = await supabase\r\n      .from('customers')\r\n      .select('id, full_name, phone_number, email')\r\n      .in('id', messageData.customerIds);\r\n\r\n    let totalCreditsNeeded = 0;\r\n    const messagesToInsert: any[] = [];\r\n\r\n    (customers || []).forEach(customer => {\r\n      if (!customer.phone_number) return;\r\n      const content = messageData.content\r\n        .replace(/\\{customer_name\\}/gi, customer.full_name || 'Customer')\r\n        .replace(/\\{customer_phone\\}/gi, customer.phone_number || '')\r\n        .replace(/\\{customer_email\\}/gi, customer.email || '')\r\n        .replace(/\\{first_name\\}/gi, customer.full_name?.split(' ')[0] || 'Customer')\r\n        .replace(/\\{last_name\\}/gi, customer.full_name?.split(' ').slice(1).join(' ') || '');\r\n      const credits = Math.ceil(content.length / 160);\r\n      totalCreditsNeeded += credits;\r\n      messagesToInsert.push({\r\n        user_id: userId,\r\n        location_id: currentBusiness.id,\r\n        profile_id: currentProfile.id,\r\n        customer_id: customer.id,\r\n        phone_number: formatPhoneNumber(customer.phone_number),\r\n        content,\r\n        template_id: messageData.templateId,\r\n        sms_credits_used: credits,\r\n        status: 'pending',\r\n        metadata: { ...messageData.metadata, bulk: true }\r\n      });\r\n    });\r\n\r\n    if (currentProfile.sms_credits < totalCreditsNeeded) throw new Error(`Insufficient credits`);\r\n\r\n    const { data: insertedMessages } = await supabase\r\n      .from('messages')\r\n      .insert(messagesToInsert)\r\n      .select();\r\n\r\n    // Note: Credits will be automatically deducted by database trigger as each message status becomes 'sent'\r\n    // This ensures customers are only charged for messages that successfully send\r\n\r\n    // Send each message asynchronously - edge function will update status which triggers credit deduction\r\n    insertedMessages?.forEach(msg => {\r\n      sendSMSViaEdgeFunction(msg.id).catch((err) => {\r\n        console.error('Failed to send SMS:', msg.id, err);\r\n        // Message status will remain 'pending', no credits deducted\r\n      });\r\n    });\r\n\r\n    queryClient.invalidateQueries({ queryKey: messagesQueryKey });\r\n\r\n    return { success: insertedMessages?.length || 0, failed: messagesToInsert.length - (insertedMessages?.length || 0), errors: [] };\r\n  };\r\n\r\n  // Initialize credit purchase via Edge Function\r\n\r\n  const initiateCreditPurchase = async (creditsAmount: number, phoneNumber: string) => {\r\n    if (!userId || !currentBusiness?.id || !currentProfile) {\r\n      throw new Error('Missing user or business context');\r\n    }\r\n\r\n    try {\r\n      console.log('=== Initiating Credit Purchase ===');\r\n      console.log('Credits:', creditsAmount);\r\n      console.log('Phone:', phoneNumber);\r\n      console.log('User ID:', userId);\r\n      console.log('Business ID:', currentBusiness.id);\r\n      console.log('Profile ID:', currentProfile.id);\r\n\r\n      const creditCost = Number(import.meta.env.VITE_SMS_CREDIT_COST || 100);\r\n      const totalCost = creditsAmount * creditCost;\r\n\r\n      console.log('Credit cost:', creditCost);\r\n      console.log('Total cost:', totalCost);\r\n\r\n      // Create purchase record\r\n      const { data: purchaseData, error: purchaseError } = await supabase\r\n        .from('sms_credit_purchases')\r\n        .insert({\r\n          user_id: userId,\r\n          location_id: currentBusiness.id,\r\n          profile_id: currentProfile.id,\r\n          credits_amount: creditsAmount,\r\n          total_cost: totalCost,\r\n          payment_phone_number: phoneNumber,\r\n          payment_status: 'pending'\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (purchaseError || !purchaseData) {\r\n        console.error('Purchase error:', purchaseError);\r\n        throw new Error('Failed to create purchase record');\r\n      }\r\n\r\n      console.log('Purchase record created:', purchaseData.id);\r\n\r\n      // Get the current session token\r\n      const { data: { session }, error: sessionError } = await supabase.auth.getSession();\r\n\r\n      console.log('Session check:');\r\n      console.log('- Session exists:', !!session);\r\n      console.log('- Session error:', sessionError);\r\n      console.log('- Access token exists:', !!session?.access_token);\r\n      console.log('- Token preview:', session?.access_token?.substring(0, 30) + '...');\r\n\r\n      if (!session || !session.access_token) {\r\n        throw new Error('No active session or access token. Please log in again.');\r\n      }\r\n\r\n      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || 'https://ujgxxcgemmfmfsbngnqo.supabase.co';\r\n      const functionUrl = `${supabaseUrl}/functions/v1/pesapal-payment`;\r\n\r\n      console.log('Calling function URL:', functionUrl);\r\n\r\n      const paymentData = {\r\n        purchaseId: purchaseData.id,\r\n        amount: totalCost,\r\n        phoneNumber: phoneNumber,\r\n        description: `Purchase of ${creditsAmount} SMS credits`\r\n      };\r\n\r\n      console.log('Payment data:', paymentData);\r\n\r\n      // Initiate PesaPal payment with proper headers\r\n      const response = await fetch(functionUrl, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Authorization': `Bearer ${session.access_token}`,\r\n          'apikey': import.meta.env.VITE_SUPABASE_ANON_KEY || '',\r\n        },\r\n        body: JSON.stringify(paymentData)\r\n      });\r\n\r\n      console.log('Response status:', response.status);\r\n      console.log('Response ok:', response.ok);\r\n\r\n      const responseData = await response.json();\r\n      console.log('Response data:', responseData);\r\n\r\n      if (!response.ok) {\r\n        throw new Error(responseData.error || `Payment initiation failed: ${response.status}`);\r\n      }\r\n\r\n      // Update purchase with PesaPal details\r\n      await supabase\r\n        .from('sms_credit_purchases')\r\n        .update({\r\n          pesapal_tracking_id: responseData.order_tracking_id,\r\n          pesapal_merchant_reference: responseData.merchant_reference,\r\n          pesapal_redirect_url: responseData.redirect_url\r\n        })\r\n        .eq('id', purchaseData.id);\r\n\r\n      console.log('Purchase updated with PesaPal details');\r\n\r\n      await fetchPurchases();\r\n\r\n      return {\r\n        purchaseId: purchaseData.id,\r\n        redirectUrl: responseData.redirect_url,\r\n        trackingId: responseData.order_tracking_id\r\n      };\r\n    } catch (error) {\r\n      console.error('=== Credit Purchase Error ===');\r\n      console.error(error);\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  // -----------------------------\r\n  // REALTIME SUBSCRIPTIONS\r\n  // -----------------------------\r\n  useEffect(() => {\r\n    if (!userId || !currentBusiness?.id) return;\r\n\r\n    const messageChannel = supabase\r\n      .channel('messages_changes')\r\n      .on('postgres_changes', {\r\n        event: '*',\r\n        schema: 'public',\r\n        table: 'messages',\r\n        filter: `location_id=eq.${currentBusiness.id}`\r\n      }, () => {\r\n        queryClient.invalidateQueries({ queryKey: messagesQueryKey });\r\n      })\r\n      .subscribe();\r\n\r\n    const templateChannel = supabase\r\n      .channel('templates_changes')\r\n      .on('postgres_changes', {\r\n        event: '*',\r\n        schema: 'public',\r\n        table: 'message_templates',\r\n        filter: `location_id=eq.${currentBusiness.id}`\r\n      }, fetchTemplates)\r\n      .subscribe();\r\n\r\n    const creditsChannel = supabase\r\n      .channel('credits_changes')\r\n      .on('postgres_changes', {\r\n        event: '*',\r\n        schema: 'public',\r\n        table: 'business_profiles',\r\n        filter: `id=eq.${currentProfile?.id}`\r\n      }, fetchLiveCredits)\r\n      .subscribe();\r\n\r\n    return () => {\r\n      supabase.removeChannel(messageChannel);\r\n      supabase.removeChannel(templateChannel);\r\n      supabase.removeChannel(creditsChannel);\r\n    };\r\n  }, [userId, currentBusiness?.id, currentProfile?.id]);\r\n\r\n  // -----------------------------\r\n  // INITIAL LOAD\r\n  // -----------------------------\r\n  useEffect(() => {\r\n    if (userId && currentBusiness?.id) {\r\n      // Background load ancillary data; messages handled by React Query\r\n      fetchTemplates();\r\n      fetchPurchases();\r\n      fetchLiveCredits();\r\n    }\r\n  }, [userId, currentBusiness?.id, currentProfile?.id]);\r\n\r\n  // Derived loading: only true on initial message fetch with no cached data\r\n  const isLoading = messagesLoading && !queriedMessages;\r\n\r\n  const getMessageStats = () => {\r\n    const total = messages.length;\r\n    const sent = messages.filter(m => m.status === 'sent' || m.status === 'delivered').length;\r\n    const failed = messages.filter(m => m.status === 'failed').length;\r\n    const pending = messages.filter(m => m.status === 'pending').length;\r\n    const totalCreditsUsed = messages.reduce((sum, m) => sum + m.smsCreditsUsed, 0);\r\n\r\n    return { total, sent, failed, pending, totalCreditsUsed, creditsRemaining: liveCredits };\r\n  };\r\n\r\n  return {\r\n    messages,\r\n    templates,\r\n    purchases,\r\n    liveCredits,\r\n    isLoading,\r\n    createMessage,\r\n    createBulkMessages,\r\n    createTemplate,\r\n    updateTemplate,\r\n    deleteTemplate,\r\n    getMessageStats,\r\n    initiateCreditPurchase,\r\n    refresh: () => { fetchMessages(); fetchTemplates(); fetchPurchases(); fetchLiveCredits(); }\r\n  };\r\n\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 517, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/activity.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, ActivityType, ActivityModule } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport interface ActivityLogInput {\r\n    userId: string;\r\n    locationId: string;\r\n    activityType: ActivityType;\r\n    module: ActivityModule;\r\n    entityType: string;\r\n    entityId?: string;\r\n    entityName: string;\r\n    description: string;\r\n    metadata?: any;\r\n    profileId?: string;\r\n    profileName?: string;\r\n}\r\n\r\nexport async function logActivityAction(data: ActivityLogInput) {\r\n    try {\r\n        await db.activityHistory.create({\r\n            data: {\r\n                userId: data.userId,\r\n                locationId: data.locationId,\r\n                activityType: data.activityType,\r\n                module: data.module,\r\n                entityType: data.entityType,\r\n                entityId: data.entityId || null,\r\n                entityName: data.entityName,\r\n                description: data.description,\r\n                metadata: data.metadata || null,\r\n                profileId: data.profileId || null,\r\n                profileName: data.profileName || null\r\n            }\r\n        });\r\n\r\n        // revalidatePath('/history'); // Typically history page might need refresh\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error logging activity:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport interface ActivityFilters {\r\n    activityType?: string;\r\n    module?: string;\r\n    search?: string;\r\n    dateFrom?: string;\r\n    dateTo?: string;\r\n}\r\n\r\nexport async function getActivityHistoryAction(\r\n    locationId: string,\r\n    userId: string,\r\n    page: number = 1,\r\n    pageSize: number = 20,\r\n    filters?: ActivityFilters\r\n) {\r\n    try {\r\n        const skip = (page - 1) * pageSize;\r\n\r\n        const where: any = {\r\n            locationId,\r\n            userId\r\n        };\r\n\r\n        if (filters) {\r\n            if (filters.activityType && filters.activityType !== 'ALL') {\r\n                where.activityType = filters.activityType;\r\n            }\r\n            if (filters.module && filters.module !== 'ALL') {\r\n                where.module = filters.module;\r\n            }\r\n            if (filters.search) {\r\n                where.OR = [\r\n                    { entityName: { contains: filters.search, mode: 'insensitive' } },\r\n                    { description: { contains: filters.search, mode: 'insensitive' } }\r\n                ];\r\n            }\r\n            if (filters.dateFrom || filters.dateTo) {\r\n                where.createdAt = {};\r\n                if (filters.dateFrom) {\r\n                    where.createdAt.gte = new Date(filters.dateFrom);\r\n                }\r\n                if (filters.dateTo) {\r\n                    const toDate = new Date(filters.dateTo);\r\n                    toDate.setHours(23, 59, 59, 999);\r\n                    where.createdAt.lte = toDate;\r\n                }\r\n            }\r\n        }\r\n\r\n        const [activities, count] = await Promise.all([\r\n            db.activityHistory.findMany({\r\n                where,\r\n                skip,\r\n                take: pageSize,\r\n                orderBy: {\r\n                    createdAt: 'desc'\r\n                }\r\n            }),\r\n            db.activityHistory.count({ where })\r\n        ]);\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                activities: activities.map((a: any) => ({\r\n                    ...a,\r\n                    created_at: a.createdAt.toISOString(), // Map back to shape expected by hook\r\n                    activity_type: a.activityType,\r\n                    location_id: a.locationId,\r\n                    user_id: a.userId,\r\n                    entity_type: a.entityType,\r\n                    entity_id: a.entityId,\r\n                    entity_name: a.entityName,\r\n                    profile_id: a.profileId,\r\n                    profile_name: a.profileName\r\n                })),\r\n                count\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching activity history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAmBsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qDAAA"}},
    {"offset": {"line": 534, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useCurrentUser.ts"],"sourcesContent":["import { useAuth } from '@/components/auth/AuthProvider';\r\n\r\nexport const useCurrentUser = () => {\r\n  const { user } = useAuth();\r\n  return { userId: user?.id };\r\n};"],"names":[],"mappings":";;;;AAAA;;;AAEO,MAAM,iBAAiB;;IAC5B,MAAM,EAAE,IAAI,EAAE,GAAG,IAAA,wJAAO;IACxB,OAAO;QAAE,QAAQ,MAAM;IAAG;AAC5B;GAHa;;QACM,wJAAO"}},
    {"offset": {"line": 560, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useActivityLogger.ts"],"sourcesContent":["import { logActivityAction, ActivityLogInput } from '@/app/actions/activity';\r\nimport { useCurrentUser } from './useCurrentUser';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useProfiles } from '@/contexts/ProfileContext';\r\n\r\nexport type ActivityType = 'CREATE' | 'UPDATE' | 'DELETE';\r\nexport type ModuleType = 'SALES' | 'INVENTORY' | 'EXPENSES' | 'FINANCE' | 'CUSTOMERS' | 'TASKS';\r\n\r\nexport interface ActivityLogData {\r\n  activityType: ActivityType;\r\n  module: ModuleType;\r\n  entityType: string;\r\n  entityId?: string;\r\n  entityName: string;\r\n  description: string;\r\n  metadata?: any;\r\n}\r\n\r\nexport const useActivityLogger = () => {\r\n  const { userId } = useCurrentUser();\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  // Safely get current profile, handle case where ProfileProvider isn't available\r\n  let currentProfile = null;\r\n  try {\r\n    const { currentProfile: profile } = useProfiles();\r\n    currentProfile = profile;\r\n  } catch {\r\n    // ProfileProvider not available, continue without profile\r\n    currentProfile = null;\r\n  }\r\n\r\n  const logActivity = async (data: ActivityLogData) => {\r\n    if (!userId || !currentBusiness?.id) {\r\n      console.warn('Cannot log activity: missing user or business context');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const result = await logActivityAction({\r\n        userId: userId,\r\n        locationId: currentBusiness.id,\r\n        activityType: data.activityType as any,\r\n        module: data.module as any,\r\n        entityType: data.entityType,\r\n        entityId: data.entityId || undefined,\r\n        entityName: data.entityName,\r\n        description: data.description,\r\n        metadata: data.metadata || undefined,\r\n        profileId: currentProfile?.id || undefined,\r\n        profileName: currentProfile?.profile_name || undefined\r\n      });\r\n\r\n      if (!result.success) {\r\n        console.error('Error logging activity:', result.error);\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to log activity:', error);\r\n    }\r\n  };\r\n\r\n  return { logActivity };\r\n};"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;;AAeO,MAAM,oBAAoB;;IAC/B,MAAM,EAAE,MAAM,EAAE,GAAG,IAAA,mJAAc;IACjC,MAAM,EAAE,eAAe,EAAE,GAAG,IAAA,qJAAW;IAEvC,gFAAgF;IAChF,IAAI,iBAAiB;IACrB,IAAI;QACF,MAAM,EAAE,gBAAgB,OAAO,EAAE,GAAG,IAAA,oJAAW;QAC/C,iBAAiB;IACnB,EAAE,OAAM;QACN,0DAA0D;QAC1D,iBAAiB;IACnB;IAEA,MAAM,cAAc,OAAO;QACzB,IAAI,CAAC,UAAU,CAAC,iBAAiB,IAAI;YACnC,QAAQ,IAAI,CAAC;YACb;QACF;QAEA,IAAI;YACF,MAAM,SAAS,MAAM,IAAA,qLAAiB,EAAC;gBACrC,QAAQ;gBACR,YAAY,gBAAgB,EAAE;gBAC9B,cAAc,KAAK,YAAY;gBAC/B,QAAQ,KAAK,MAAM;gBACnB,YAAY,KAAK,UAAU;gBAC3B,UAAU,KAAK,QAAQ,IAAI;gBAC3B,YAAY,KAAK,UAAU;gBAC3B,aAAa,KAAK,WAAW;gBAC7B,UAAU,KAAK,QAAQ,IAAI;gBAC3B,WAAW,gBAAgB,MAAM;gBACjC,aAAa,gBAAgB,gBAAgB;YAC/C;YAEA,IAAI,CAAC,OAAO,OAAO,EAAE;gBACnB,QAAQ,KAAK,CAAC,2BAA2B,OAAO,KAAK;YACvD;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2BAA2B;QAC3C;IACF;IAEA,OAAO;QAAE;IAAY;AACvB;GA5Ca;;QACQ,mJAAc;QACL,qJAAW"}},
    {"offset": {"line": 629, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/customers.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getCustomerStatsAction(userId: string, branchId: string) {\r\n    try {\r\n        const thisMonth = new Date();\r\n        const startOfMonth = new Date(thisMonth.getFullYear(), thisMonth.getMonth(), 1);\r\n\r\n        // 1. Count customers created this month\r\n        const thisMonthCount = await db.customer.count({\r\n            where: {\r\n                // Assuming we use agencyId for userId if they are an owner, or it's connected somehow\r\n                // For now, focusing on branchId as that's normally the tenant isolation in the schema\r\n                branchId: branchId,\r\n                createdAt: {\r\n                    gte: startOfMonth\r\n                }\r\n            }\r\n        });\r\n\r\n        // 2. Count customers with upcoming backgrounds (for now just count those who have a birthday set)\r\n        const withBirthdays = await db.customer.count({\r\n            where: {\r\n                branchId: branchId,\r\n                birthday: {\r\n                    not: null\r\n                }\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                withBirthdays,\r\n                thisMonth: thisMonthCount\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function mergeCustomersAction(primaryCustomerId: string, duplicateIds: string[]) {\r\n    try {\r\n        if (!primaryCustomerId || duplicateIds.length === 0) {\r\n            return { success: false, error: 'Invalid selection' };\r\n        }\r\n\r\n        // Use a transaction to ensure all operations succeed or fail together\r\n        await db.$transaction(async (tx: any) => {\r\n            // 1. Update sales to point to primary customer\r\n            // In Prisma, assuming relation is through customerId\r\n            await tx.sale.updateMany({\r\n                where: {\r\n                    customerId: {\r\n                        in: duplicateIds\r\n                    }\r\n                },\r\n                data: {\r\n                    customerId: primaryCustomerId\r\n                }\r\n            });\r\n\r\n            // Note: The original code also updated messages. \r\n            // If there's a Message model connected to customers, add it here.\r\n            // await tx.message.updateMany({\r\n            //     where: { customerId: { in: duplicateIds } },\r\n            //     data: { customerId: primaryCustomerId }\r\n            // });\r\n\r\n            // 3. Delete duplicate customers\r\n            await tx.customer.deleteMany({\r\n                where: {\r\n                    id: {\r\n                        in: duplicateIds\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Revalidate customers list\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error merging customers:', error);\r\n        return { success: false, error: error.message || 'Failed to merge customers' };\r\n    }\r\n}\r\n\r\nexport async function getCustomersAction(branchId: string) {\r\n    try {\r\n        const customers = await db.customer.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const count = await db.customer.count({\r\n            where: { branchId }\r\n        });\r\n\r\n        // Map Prisma Customer model to the shape expected by useCustomers hook\r\n        const mappedCustomers = customers.map((c: any) => ({\r\n            id: c.id,\r\n            fullName: c.name,\r\n            phoneNumber: c.phone,\r\n            email: c.email,\r\n            birthday: c.birthday ? c.birthday.toISOString() : null,\r\n            gender: c.gender,\r\n            location: c.address,\r\n            categoryId: c.categoryId,\r\n            notes: c.notes,\r\n            tags: c.tags || [],\r\n            socialMedia: c.socialMedia || null,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: { customers: mappedCustomers, count } };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customers:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerAction(branchId: string, userId: string, data: any) {\r\n    try {\r\n        const newCustomer = await db.customer.create({\r\n            data: {\r\n                branchId: branchId,\r\n                adminId: userId, // Assuming user who created it is the admin/owner\r\n                name: data.fullName,\r\n                phone: data.phoneNumber || null,\r\n                email: data.email || null,\r\n                birthday: data.birthday ? new Date(data.birthday) : null,\r\n                gender: data.gender || null,\r\n                address: data.location || null,\r\n                categoryId: data.categoryId || null,\r\n                notes: data.notes || null,\r\n                tags: data.tags || [],\r\n                socialMedia: data.socialMedia || null\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerAction(customerId: string, data: any) {\r\n    try {\r\n        const updateData: any = {};\r\n        if (data.fullName !== undefined) updateData.name = data.fullName;\r\n        if (data.phoneNumber !== undefined) updateData.phone = data.phoneNumber;\r\n        if (data.email !== undefined) updateData.email = data.email;\r\n        if (data.birthday !== undefined) updateData.birthday = data.birthday ? new Date(data.birthday) : null;\r\n        if (data.gender !== undefined) updateData.gender = data.gender;\r\n        if (data.location !== undefined) updateData.address = data.location;\r\n        if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;\r\n        if (data.notes !== undefined) updateData.notes = data.notes;\r\n        if (data.tags !== undefined) updateData.tags = data.tags;\r\n        if (data.socialMedia !== undefined) updateData.socialMedia = data.socialMedia;\r\n\r\n        const updatedCustomer = await db.customer.update({\r\n            where: { id: customerId },\r\n            data: updateData\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerAction(customerId: string) {\r\n    try {\r\n        await db.customer.delete({\r\n            where: { id: customerId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCustomerCategoriesAction(branchId: string) {\r\n    try {\r\n        const categories = await db.customerCategory.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const formattedCategories = categories.map((c: any) => ({\r\n            id: c.id,\r\n            name: c.name,\r\n            isDefault: c.isDefault,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: formattedCategories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerCategoryAction(branchId: string, userId: string, name: string) {\r\n    try {\r\n        const newCategory = await db.customerCategory.create({\r\n            data: {\r\n                branchId: branchId,\r\n                name: name.trim(),\r\n                isDefault: false,\r\n                userId: userId\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCategory };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerCategoryAction(categoryId: string, name: string) {\r\n    try {\r\n        const updatedCategory = await db.customerCategory.update({\r\n            where: { id: categoryId },\r\n            data: { name: name.trim() }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCategory };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerCategoryAction(categoryId: string) {\r\n    try {\r\n        await db.customerCategory.delete({\r\n            where: { id: categoryId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA4FsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,sDAAA"}},
    {"offset": {"line": 646, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/customers.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getCustomerStatsAction(userId: string, branchId: string) {\r\n    try {\r\n        const thisMonth = new Date();\r\n        const startOfMonth = new Date(thisMonth.getFullYear(), thisMonth.getMonth(), 1);\r\n\r\n        // 1. Count customers created this month\r\n        const thisMonthCount = await db.customer.count({\r\n            where: {\r\n                // Assuming we use agencyId for userId if they are an owner, or it's connected somehow\r\n                // For now, focusing on branchId as that's normally the tenant isolation in the schema\r\n                branchId: branchId,\r\n                createdAt: {\r\n                    gte: startOfMonth\r\n                }\r\n            }\r\n        });\r\n\r\n        // 2. Count customers with upcoming backgrounds (for now just count those who have a birthday set)\r\n        const withBirthdays = await db.customer.count({\r\n            where: {\r\n                branchId: branchId,\r\n                birthday: {\r\n                    not: null\r\n                }\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                withBirthdays,\r\n                thisMonth: thisMonthCount\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function mergeCustomersAction(primaryCustomerId: string, duplicateIds: string[]) {\r\n    try {\r\n        if (!primaryCustomerId || duplicateIds.length === 0) {\r\n            return { success: false, error: 'Invalid selection' };\r\n        }\r\n\r\n        // Use a transaction to ensure all operations succeed or fail together\r\n        await db.$transaction(async (tx: any) => {\r\n            // 1. Update sales to point to primary customer\r\n            // In Prisma, assuming relation is through customerId\r\n            await tx.sale.updateMany({\r\n                where: {\r\n                    customerId: {\r\n                        in: duplicateIds\r\n                    }\r\n                },\r\n                data: {\r\n                    customerId: primaryCustomerId\r\n                }\r\n            });\r\n\r\n            // Note: The original code also updated messages. \r\n            // If there's a Message model connected to customers, add it here.\r\n            // await tx.message.updateMany({\r\n            //     where: { customerId: { in: duplicateIds } },\r\n            //     data: { customerId: primaryCustomerId }\r\n            // });\r\n\r\n            // 3. Delete duplicate customers\r\n            await tx.customer.deleteMany({\r\n                where: {\r\n                    id: {\r\n                        in: duplicateIds\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Revalidate customers list\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error merging customers:', error);\r\n        return { success: false, error: error.message || 'Failed to merge customers' };\r\n    }\r\n}\r\n\r\nexport async function getCustomersAction(branchId: string) {\r\n    try {\r\n        const customers = await db.customer.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const count = await db.customer.count({\r\n            where: { branchId }\r\n        });\r\n\r\n        // Map Prisma Customer model to the shape expected by useCustomers hook\r\n        const mappedCustomers = customers.map((c: any) => ({\r\n            id: c.id,\r\n            fullName: c.name,\r\n            phoneNumber: c.phone,\r\n            email: c.email,\r\n            birthday: c.birthday ? c.birthday.toISOString() : null,\r\n            gender: c.gender,\r\n            location: c.address,\r\n            categoryId: c.categoryId,\r\n            notes: c.notes,\r\n            tags: c.tags || [],\r\n            socialMedia: c.socialMedia || null,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: { customers: mappedCustomers, count } };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customers:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerAction(branchId: string, userId: string, data: any) {\r\n    try {\r\n        const newCustomer = await db.customer.create({\r\n            data: {\r\n                branchId: branchId,\r\n                adminId: userId, // Assuming user who created it is the admin/owner\r\n                name: data.fullName,\r\n                phone: data.phoneNumber || null,\r\n                email: data.email || null,\r\n                birthday: data.birthday ? new Date(data.birthday) : null,\r\n                gender: data.gender || null,\r\n                address: data.location || null,\r\n                categoryId: data.categoryId || null,\r\n                notes: data.notes || null,\r\n                tags: data.tags || [],\r\n                socialMedia: data.socialMedia || null\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerAction(customerId: string, data: any) {\r\n    try {\r\n        const updateData: any = {};\r\n        if (data.fullName !== undefined) updateData.name = data.fullName;\r\n        if (data.phoneNumber !== undefined) updateData.phone = data.phoneNumber;\r\n        if (data.email !== undefined) updateData.email = data.email;\r\n        if (data.birthday !== undefined) updateData.birthday = data.birthday ? new Date(data.birthday) : null;\r\n        if (data.gender !== undefined) updateData.gender = data.gender;\r\n        if (data.location !== undefined) updateData.address = data.location;\r\n        if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;\r\n        if (data.notes !== undefined) updateData.notes = data.notes;\r\n        if (data.tags !== undefined) updateData.tags = data.tags;\r\n        if (data.socialMedia !== undefined) updateData.socialMedia = data.socialMedia;\r\n\r\n        const updatedCustomer = await db.customer.update({\r\n            where: { id: customerId },\r\n            data: updateData\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerAction(customerId: string) {\r\n    try {\r\n        await db.customer.delete({\r\n            where: { id: customerId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCustomerCategoriesAction(branchId: string) {\r\n    try {\r\n        const categories = await db.customerCategory.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const formattedCategories = categories.map((c: any) => ({\r\n            id: c.id,\r\n            name: c.name,\r\n            isDefault: c.isDefault,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: formattedCategories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerCategoryAction(branchId: string, userId: string, name: string) {\r\n    try {\r\n        const newCategory = await db.customerCategory.create({\r\n            data: {\r\n                branchId: branchId,\r\n                name: name.trim(),\r\n                isDefault: false,\r\n                userId: userId\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCategory };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerCategoryAction(categoryId: string, name: string) {\r\n    try {\r\n        const updatedCategory = await db.customerCategory.update({\r\n            where: { id: categoryId },\r\n            data: { name: name.trim() }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCategory };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerCategoryAction(categoryId: string) {\r\n    try {\r\n        await db.customerCategory.delete({\r\n            where: { id: categoryId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA+HsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 663, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/customers.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getCustomerStatsAction(userId: string, branchId: string) {\r\n    try {\r\n        const thisMonth = new Date();\r\n        const startOfMonth = new Date(thisMonth.getFullYear(), thisMonth.getMonth(), 1);\r\n\r\n        // 1. Count customers created this month\r\n        const thisMonthCount = await db.customer.count({\r\n            where: {\r\n                // Assuming we use agencyId for userId if they are an owner, or it's connected somehow\r\n                // For now, focusing on branchId as that's normally the tenant isolation in the schema\r\n                branchId: branchId,\r\n                createdAt: {\r\n                    gte: startOfMonth\r\n                }\r\n            }\r\n        });\r\n\r\n        // 2. Count customers with upcoming backgrounds (for now just count those who have a birthday set)\r\n        const withBirthdays = await db.customer.count({\r\n            where: {\r\n                branchId: branchId,\r\n                birthday: {\r\n                    not: null\r\n                }\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                withBirthdays,\r\n                thisMonth: thisMonthCount\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function mergeCustomersAction(primaryCustomerId: string, duplicateIds: string[]) {\r\n    try {\r\n        if (!primaryCustomerId || duplicateIds.length === 0) {\r\n            return { success: false, error: 'Invalid selection' };\r\n        }\r\n\r\n        // Use a transaction to ensure all operations succeed or fail together\r\n        await db.$transaction(async (tx: any) => {\r\n            // 1. Update sales to point to primary customer\r\n            // In Prisma, assuming relation is through customerId\r\n            await tx.sale.updateMany({\r\n                where: {\r\n                    customerId: {\r\n                        in: duplicateIds\r\n                    }\r\n                },\r\n                data: {\r\n                    customerId: primaryCustomerId\r\n                }\r\n            });\r\n\r\n            // Note: The original code also updated messages. \r\n            // If there's a Message model connected to customers, add it here.\r\n            // await tx.message.updateMany({\r\n            //     where: { customerId: { in: duplicateIds } },\r\n            //     data: { customerId: primaryCustomerId }\r\n            // });\r\n\r\n            // 3. Delete duplicate customers\r\n            await tx.customer.deleteMany({\r\n                where: {\r\n                    id: {\r\n                        in: duplicateIds\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Revalidate customers list\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error merging customers:', error);\r\n        return { success: false, error: error.message || 'Failed to merge customers' };\r\n    }\r\n}\r\n\r\nexport async function getCustomersAction(branchId: string) {\r\n    try {\r\n        const customers = await db.customer.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const count = await db.customer.count({\r\n            where: { branchId }\r\n        });\r\n\r\n        // Map Prisma Customer model to the shape expected by useCustomers hook\r\n        const mappedCustomers = customers.map((c: any) => ({\r\n            id: c.id,\r\n            fullName: c.name,\r\n            phoneNumber: c.phone,\r\n            email: c.email,\r\n            birthday: c.birthday ? c.birthday.toISOString() : null,\r\n            gender: c.gender,\r\n            location: c.address,\r\n            categoryId: c.categoryId,\r\n            notes: c.notes,\r\n            tags: c.tags || [],\r\n            socialMedia: c.socialMedia || null,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: { customers: mappedCustomers, count } };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customers:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerAction(branchId: string, userId: string, data: any) {\r\n    try {\r\n        const newCustomer = await db.customer.create({\r\n            data: {\r\n                branchId: branchId,\r\n                adminId: userId, // Assuming user who created it is the admin/owner\r\n                name: data.fullName,\r\n                phone: data.phoneNumber || null,\r\n                email: data.email || null,\r\n                birthday: data.birthday ? new Date(data.birthday) : null,\r\n                gender: data.gender || null,\r\n                address: data.location || null,\r\n                categoryId: data.categoryId || null,\r\n                notes: data.notes || null,\r\n                tags: data.tags || [],\r\n                socialMedia: data.socialMedia || null\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerAction(customerId: string, data: any) {\r\n    try {\r\n        const updateData: any = {};\r\n        if (data.fullName !== undefined) updateData.name = data.fullName;\r\n        if (data.phoneNumber !== undefined) updateData.phone = data.phoneNumber;\r\n        if (data.email !== undefined) updateData.email = data.email;\r\n        if (data.birthday !== undefined) updateData.birthday = data.birthday ? new Date(data.birthday) : null;\r\n        if (data.gender !== undefined) updateData.gender = data.gender;\r\n        if (data.location !== undefined) updateData.address = data.location;\r\n        if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;\r\n        if (data.notes !== undefined) updateData.notes = data.notes;\r\n        if (data.tags !== undefined) updateData.tags = data.tags;\r\n        if (data.socialMedia !== undefined) updateData.socialMedia = data.socialMedia;\r\n\r\n        const updatedCustomer = await db.customer.update({\r\n            where: { id: customerId },\r\n            data: updateData\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerAction(customerId: string) {\r\n    try {\r\n        await db.customer.delete({\r\n            where: { id: customerId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCustomerCategoriesAction(branchId: string) {\r\n    try {\r\n        const categories = await db.customerCategory.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const formattedCategories = categories.map((c: any) => ({\r\n            id: c.id,\r\n            name: c.name,\r\n            isDefault: c.isDefault,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: formattedCategories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerCategoryAction(branchId: string, userId: string, name: string) {\r\n    try {\r\n        const newCategory = await db.customerCategory.create({\r\n            data: {\r\n                branchId: branchId,\r\n                name: name.trim(),\r\n                isDefault: false,\r\n                userId: userId\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCategory };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerCategoryAction(categoryId: string, name: string) {\r\n    try {\r\n        const updatedCategory = await db.customerCategory.update({\r\n            where: { id: categoryId },\r\n            data: { name: name.trim() }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCategory };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerCategoryAction(categoryId: string) {\r\n    try {\r\n        await db.customerCategory.delete({\r\n            where: { id: categoryId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAyJsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 680, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/customers.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getCustomerStatsAction(userId: string, branchId: string) {\r\n    try {\r\n        const thisMonth = new Date();\r\n        const startOfMonth = new Date(thisMonth.getFullYear(), thisMonth.getMonth(), 1);\r\n\r\n        // 1. Count customers created this month\r\n        const thisMonthCount = await db.customer.count({\r\n            where: {\r\n                // Assuming we use agencyId for userId if they are an owner, or it's connected somehow\r\n                // For now, focusing on branchId as that's normally the tenant isolation in the schema\r\n                branchId: branchId,\r\n                createdAt: {\r\n                    gte: startOfMonth\r\n                }\r\n            }\r\n        });\r\n\r\n        // 2. Count customers with upcoming backgrounds (for now just count those who have a birthday set)\r\n        const withBirthdays = await db.customer.count({\r\n            where: {\r\n                branchId: branchId,\r\n                birthday: {\r\n                    not: null\r\n                }\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                withBirthdays,\r\n                thisMonth: thisMonthCount\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer stats:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function mergeCustomersAction(primaryCustomerId: string, duplicateIds: string[]) {\r\n    try {\r\n        if (!primaryCustomerId || duplicateIds.length === 0) {\r\n            return { success: false, error: 'Invalid selection' };\r\n        }\r\n\r\n        // Use a transaction to ensure all operations succeed or fail together\r\n        await db.$transaction(async (tx: any) => {\r\n            // 1. Update sales to point to primary customer\r\n            // In Prisma, assuming relation is through customerId\r\n            await tx.sale.updateMany({\r\n                where: {\r\n                    customerId: {\r\n                        in: duplicateIds\r\n                    }\r\n                },\r\n                data: {\r\n                    customerId: primaryCustomerId\r\n                }\r\n            });\r\n\r\n            // Note: The original code also updated messages. \r\n            // If there's a Message model connected to customers, add it here.\r\n            // await tx.message.updateMany({\r\n            //     where: { customerId: { in: duplicateIds } },\r\n            //     data: { customerId: primaryCustomerId }\r\n            // });\r\n\r\n            // 3. Delete duplicate customers\r\n            await tx.customer.deleteMany({\r\n                where: {\r\n                    id: {\r\n                        in: duplicateIds\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Revalidate customers list\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error merging customers:', error);\r\n        return { success: false, error: error.message || 'Failed to merge customers' };\r\n    }\r\n}\r\n\r\nexport async function getCustomersAction(branchId: string) {\r\n    try {\r\n        const customers = await db.customer.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const count = await db.customer.count({\r\n            where: { branchId }\r\n        });\r\n\r\n        // Map Prisma Customer model to the shape expected by useCustomers hook\r\n        const mappedCustomers = customers.map((c: any) => ({\r\n            id: c.id,\r\n            fullName: c.name,\r\n            phoneNumber: c.phone,\r\n            email: c.email,\r\n            birthday: c.birthday ? c.birthday.toISOString() : null,\r\n            gender: c.gender,\r\n            location: c.address,\r\n            categoryId: c.categoryId,\r\n            notes: c.notes,\r\n            tags: c.tags || [],\r\n            socialMedia: c.socialMedia || null,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: { customers: mappedCustomers, count } };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customers:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerAction(branchId: string, userId: string, data: any) {\r\n    try {\r\n        const newCustomer = await db.customer.create({\r\n            data: {\r\n                branchId: branchId,\r\n                adminId: userId, // Assuming user who created it is the admin/owner\r\n                name: data.fullName,\r\n                phone: data.phoneNumber || null,\r\n                email: data.email || null,\r\n                birthday: data.birthday ? new Date(data.birthday) : null,\r\n                gender: data.gender || null,\r\n                address: data.location || null,\r\n                categoryId: data.categoryId || null,\r\n                notes: data.notes || null,\r\n                tags: data.tags || [],\r\n                socialMedia: data.socialMedia || null\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerAction(customerId: string, data: any) {\r\n    try {\r\n        const updateData: any = {};\r\n        if (data.fullName !== undefined) updateData.name = data.fullName;\r\n        if (data.phoneNumber !== undefined) updateData.phone = data.phoneNumber;\r\n        if (data.email !== undefined) updateData.email = data.email;\r\n        if (data.birthday !== undefined) updateData.birthday = data.birthday ? new Date(data.birthday) : null;\r\n        if (data.gender !== undefined) updateData.gender = data.gender;\r\n        if (data.location !== undefined) updateData.address = data.location;\r\n        if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;\r\n        if (data.notes !== undefined) updateData.notes = data.notes;\r\n        if (data.tags !== undefined) updateData.tags = data.tags;\r\n        if (data.socialMedia !== undefined) updateData.socialMedia = data.socialMedia;\r\n\r\n        const updatedCustomer = await db.customer.update({\r\n            where: { id: customerId },\r\n            data: updateData\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCustomer };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerAction(customerId: string) {\r\n    try {\r\n        await db.customer.delete({\r\n            where: { id: customerId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getCustomerCategoriesAction(branchId: string) {\r\n    try {\r\n        const categories = await db.customerCategory.findMany({\r\n            where: { branchId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        const formattedCategories = categories.map((c: any) => ({\r\n            id: c.id,\r\n            name: c.name,\r\n            isDefault: c.isDefault,\r\n            createdAt: c.createdAt.toISOString(),\r\n            updatedAt: c.updatedAt.toISOString()\r\n        }));\r\n\r\n        return { success: true, data: formattedCategories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching customer categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createCustomerCategoryAction(branchId: string, userId: string, name: string) {\r\n    try {\r\n        const newCategory = await db.customerCategory.create({\r\n            data: {\r\n                branchId: branchId,\r\n                name: name.trim(),\r\n                isDefault: false,\r\n                userId: userId\r\n            }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: newCategory };\r\n    } catch (error: any) {\r\n        console.error('Error creating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateCustomerCategoryAction(categoryId: string, name: string) {\r\n    try {\r\n        const updatedCategory = await db.customerCategory.update({\r\n            where: { id: categoryId },\r\n            data: { name: name.trim() }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true, data: updatedCategory };\r\n    } catch (error: any) {\r\n        console.error('Error updating customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteCustomerCategoryAction(categoryId: string) {\r\n    try {\r\n        await db.customerCategory.delete({\r\n            where: { id: categoryId }\r\n        });\r\n        revalidatePath('/customers');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting customer category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAmLsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 697, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useCustomers.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useActivityLogger } from '@/hooks/useActivityLogger';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { getCustomersAction, createCustomerAction, updateCustomerAction, deleteCustomerAction } from '@/app/actions/customers';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\n\r\nexport interface Customer {\r\n  id: string;\r\n  fullName: string;\r\n  phoneNumber: string | null;\r\n  email: string | null;\r\n  birthday: Date | null;\r\n  gender: string | null;\r\n  location: string | null;\r\n  categoryId: string | null; // Added category field\r\n  notes: string | null;\r\n  tags: string[] | null;\r\n  socialMedia: {\r\n    instagram?: string;\r\n    facebook?: string;\r\n    twitter?: string;\r\n    linkedin?: string;\r\n  } | null;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport const useCustomers = (initialPageSize: number = 50) => {\r\n  const [customers, setCustomers] = useState<Customer[]>([]);\r\n  const [page, setPage] = useState(1);\r\n  const [pageSize, setPageSize] = useState(initialPageSize);\r\n  const [totalCount, setTotalCount] = useState(0);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n  const { user } = useAuth();\r\n  const { logActivity } = useActivityLogger();\r\n  const queryClient = useQueryClient();\r\n\r\n  const loadCustomers = useCallback(async (): Promise<{ customers: Customer[], count: number }> => {\r\n    if (!currentBusiness) {\r\n      return { customers: [], count: 0 };\r\n    }\r\n\r\n    try {\r\n      const result = await getCustomersAction(currentBusiness.id);\r\n\r\n      if (!result.success) {\r\n        throw new Error(result.error);\r\n      }\r\n\r\n      const formattedCustomers: Customer[] = (result.data?.customers || []).map((customer: any) => ({\r\n        id: customer.id,\r\n        fullName: customer.fullName || customer.name,\r\n        phoneNumber: customer.phoneNumber || customer.phone,\r\n        email: customer.email,\r\n        birthday: customer.birthday ? new Date(customer.birthday) : null,\r\n        gender: customer.gender,\r\n        location: customer.location || customer.address,\r\n        categoryId: customer.categoryId,\r\n        notes: customer.notes,\r\n        tags: customer.tags,\r\n        socialMedia: customer.socialMedia || null,\r\n        createdAt: new Date(customer.createdAt),\r\n        updatedAt: new Date(customer.updatedAt)\r\n      }));\r\n\r\n      return { customers: formattedCustomers, count: result.data?.count || 0 };\r\n    } catch (error) {\r\n      console.error('Error loading customers:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load customers. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return { customers: [], count: 0 };\r\n    }\r\n  }, [currentBusiness?.id, toast]);\r\n\r\n  // React Query caching\r\n  const queryKey = ['customers', currentBusiness?.id];\r\n  const { data: queriedData, isLoading: isQueryLoading, isFetching } = useQuery({\r\n    queryKey,\r\n    queryFn: loadCustomers,\r\n    enabled: !!currentBusiness?.id,\r\n    staleTime: 5 * 60_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: false,\r\n    refetchOnReconnect: false,\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (queriedData) {\r\n      setCustomers(queriedData.customers);\r\n      setTotalCount(queriedData.count);\r\n    }\r\n  }, [queriedData]);\r\n\r\n  // Derived loading state to avoid flash on background refetch\r\n  const isLoading = isQueryLoading && !queriedData;\r\n\r\n  const createCustomer = async (customerData: Omit<Customer, 'id' | 'createdAt' | 'updatedAt'>) => {\r\n    if (!currentBusiness) {\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"No business selected\",\r\n        variant: \"destructive\"\r\n      });\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      if (!user) throw new Error('User not authenticated');\r\n\r\n      const insertData = {\r\n        fullName: customerData.fullName,\r\n        phoneNumber: customerData.phoneNumber || null,\r\n        email: customerData.email || null,\r\n        birthday: customerData.birthday?.toISOString().split('T')[0] || null,\r\n        gender: customerData.gender || null,\r\n        location: customerData.location || null,\r\n        categoryId: customerData.categoryId || null,\r\n        notes: customerData.notes || null,\r\n        tags: customerData.tags || null,\r\n        socialMedia: customerData.socialMedia || null\r\n      };\r\n\r\n      const result = await createCustomerAction(currentBusiness.id, user.id, insertData);\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error || 'Failed to create customer');\r\n      }\r\n\r\n      const data = result.data;\r\n\r\n      // Format the new customer and update cache immediately\r\n      const newCustomer: Customer = {\r\n        id: data.id,\r\n        fullName: data.name || data.fullName,\r\n        phoneNumber: data.phone || data.phoneNumber,\r\n        email: data.email,\r\n        birthday: data.birthday ? new Date(data.birthday) : null,\r\n        gender: data.gender,\r\n        location: data.address || data.location,\r\n        categoryId: data.categoryId,\r\n        notes: data.notes,\r\n        tags: data.tags,\r\n        socialMedia: data.socialMedia,\r\n        createdAt: new Date(data.createdAt),\r\n        updatedAt: new Date(data.updatedAt)\r\n      };\r\n\r\n      // Update local state immediately\r\n      setCustomers(prev => [newCustomer, ...prev]);\r\n      setTotalCount(c => c + 1);\r\n\r\n      // Update React Query cache immediately\r\n      queryClient.setQueryData(queryKey, (oldData: any) => {\r\n        if (!oldData) return { customers: [newCustomer], count: 1 };\r\n        return {\r\n          customers: [newCustomer, ...oldData.customers],\r\n          count: (oldData.count || 0) + 1\r\n        };\r\n      });\r\n\r\n      // Log activity\r\n      await logActivity({\r\n        activityType: 'CREATE',\r\n        module: 'CUSTOMERS',\r\n        entityType: 'customer',\r\n        entityId: data.id,\r\n        entityName: customerData.fullName,\r\n        description: `Created customer \"${customerData.fullName}\"`,\r\n        metadata: {\r\n          phoneNumber: customerData.phoneNumber,\r\n          email: customerData.email,\r\n          location: customerData.location\r\n        }\r\n      });\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Customer created successfully\"\r\n      });\r\n\r\n      return data;\r\n    } catch (error) {\r\n      console.error('Error creating customer:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to create customer. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const addCustomer = createCustomer;\r\n\r\n  const updateCustomer = async (id: string, updates: Partial<Customer>) => {\r\n    try {\r\n      const updateData: any = {};\r\n\r\n      if (updates.fullName !== undefined) updateData.fullName = updates.fullName;\r\n      if (updates.phoneNumber !== undefined) updateData.phoneNumber = updates.phoneNumber;\r\n      if (updates.email !== undefined) updateData.email = updates.email;\r\n      if (updates.birthday !== undefined) updateData.birthday = updates.birthday?.toISOString();\r\n      if (updates.gender !== undefined) updateData.gender = updates.gender;\r\n      if (updates.location !== undefined) updateData.location = updates.location;\r\n      if (updates.categoryId !== undefined) updateData.categoryId = updates.categoryId;\r\n      if (updates.notes !== undefined) updateData.notes = updates.notes;\r\n      if (updates.tags !== undefined) updateData.tags = updates.tags;\r\n      if (updates.socialMedia !== undefined) updateData.socialMedia = updates.socialMedia;\r\n\r\n      const result = await updateCustomerAction(id, updateData);\r\n\r\n      if (!result.success) throw new Error(result.error || 'Failed to update customer');\r\n\r\n      // Update local state immediately\r\n      setCustomers(prev => prev.map(c => c.id === id ? { ...c, ...updates } : c));\r\n\r\n      // Update React Query cache immediately\r\n      queryClient.setQueryData(queryKey, (oldData: any) => {\r\n        if (!oldData) return oldData;\r\n        return {\r\n          ...oldData,\r\n          customers: oldData.customers.map((c: Customer) =>\r\n            c.id === id ? { ...c, ...updates } : c\r\n          )\r\n        };\r\n      });\r\n\r\n      // Log activity\r\n      const customer = customers.find(c => c.id === id);\r\n      if (customer) {\r\n        await logActivity({\r\n          activityType: 'UPDATE',\r\n          module: 'CUSTOMERS',\r\n          entityType: 'customer',\r\n          entityId: id,\r\n          entityName: customer.fullName,\r\n          description: `Updated customer \"${customer.fullName}\"`,\r\n          metadata: { updates }\r\n        });\r\n      }\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Customer updated successfully\"\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating customer:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update customer. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteCustomer = async (id: string) => {\r\n    try {\r\n      // Get customer details before deletion\r\n      const customer = customers.find(c => c.id === id);\r\n\r\n      const result = await deleteCustomerAction(id);\r\n\r\n      if (!result.success) throw new Error(result.error || 'Failed to delete customer');\r\n      // Optimistic update: remove locally\r\n      setCustomers(prev => prev.filter(c => c.id !== id));\r\n      setTotalCount(c => Math.max(0, c - 1));\r\n      // Update cache immediately for current page\r\n      queryClient.setQueryData(queryKey, (old: any) => {\r\n        if (!old) return old;\r\n        const { customers: oldCustomers, count } = old;\r\n        const newCustomers = (oldCustomers as Customer[]).filter(c => c.id !== id);\r\n        return { customers: newCustomers, count: Math.max(0, (count || 0) - 1) };\r\n      });\r\n      queryClient.invalidateQueries({ queryKey });\r\n\r\n      // Log activity\r\n      if (customer) {\r\n        await logActivity({\r\n          activityType: 'DELETE',\r\n          module: 'CUSTOMERS',\r\n          entityType: 'customer',\r\n          entityId: id,\r\n          entityName: customer.fullName,\r\n          description: `Deleted customer \"${customer.fullName}\"`,\r\n          metadata: {\r\n            phoneNumber: customer.phoneNumber,\r\n            email: customer.email\r\n          }\r\n        });\r\n      }\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Customer deleted successfully\"\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting customer:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete customer. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Initial load handled by React Query; no manual trigger needed\r\n\r\n  // Realtime: invalidate customer list when changes occur for this location\r\n  // Commented out since we are moving away from Supabase client realtime subscriptions\r\n  // useEffect(() => {\r\n  //   if (!currentBusiness?.id) return;\r\n\r\n  //   const channel = supabase\r\n  //     .channel('customers_changes')\r\n  //     .on('postgres_changes', {\r\n  //       event: '*',\r\n  //       schema: 'public',\r\n  //       table: 'customers',\r\n  //       filter: `location_id=eq.${currentBusiness.id}`\r\n  //     }, () => {\r\n  //       queryClient.invalidateQueries({ queryKey });\r\n  //     })\r\n  //     .subscribe();\r\n\r\n  //   return () => {\r\n  //     supabase.removeChannel(channel);\r\n  //   };\r\n  // }, [currentBusiness?.id, page, pageSize]);\r\n\r\n  return {\r\n    customers,\r\n    isLoading,\r\n    createCustomer,\r\n    addCustomer,\r\n    updateCustomer,\r\n    deleteCustomer,\r\n    loadCustomers,\r\n    page,\r\n    setPage,\r\n    pageSize,\r\n    setPageSize,\r\n    totalCount\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1069, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/messages/MessageHeader.tsx"],"sourcesContent":["import React from 'react';\r\nimport { MessageSquare, Plus, FileText, Zap, CreditCard, Users } from 'lucide-react';\r\nimport { Button } from '@/components/ui/button';\r\n\r\ninterface MessageHeaderProps {\r\n  onNewMessage: () => void;\r\n  onNewTemplate: () => void;\r\n  onTopUp: () => void;\r\n  onBulkMessage: () => void;\r\n  smsCredits: number;\r\n  canCreate?: boolean;\r\n}\r\n\r\nconst MessageHeader: React.FC<MessageHeaderProps> = ({\r\n  onNewMessage,\r\n  onNewTemplate,\r\n  onTopUp,\r\n  onBulkMessage,\r\n  smsCredits,\r\n  canCreate = true\r\n}) => {\r\n  return (\r\n    <div className=\"flex flex-col md:flex-row justify-between items-start md:items-center gap-4\">\r\n      <div>\r\n        <h1 className=\"text-3xl font-bold text-gray-900 flex items-center gap-2\">\r\n          <MessageSquare className=\"w-8 h-8 text-blue-600\" />\r\n          Messages\r\n        </h1>\r\n        <p className=\"text-gray-500 mt-1\">Send SMS to your customers</p>\r\n      </div>\r\n\r\n      <div className=\"flex flex-wrap items-center gap-3\">\r\n        {canCreate && (\r\n          <>\r\n            <Button\r\n              onClick={onTopUp}\r\n              variant=\"outline\"\r\n              className=\"flex items-center gap-2 border-green-500 text-green-700 hover:bg-green-50\"\r\n            >\r\n              <CreditCard className=\"w-4 h-4\" />\r\n              Top Up\r\n            </Button>\r\n\r\n            <Button\r\n              onClick={onNewTemplate}\r\n              variant=\"outline\"\r\n              className=\"flex items-center gap-2\"\r\n            >\r\n              <FileText className=\"w-4 h-4\" />\r\n              New Template\r\n            </Button>\r\n\r\n            <Button\r\n              onClick={onBulkMessage}\r\n              variant=\"outline\"\r\n              className=\"flex items-center gap-2 border-purple-500 text-purple-700 hover:bg-purple-50\"\r\n            >\r\n              <Users className=\"w-4 h-4\" />\r\n              Bulk SMS\r\n            </Button>\r\n\r\n            <Button\r\n              onClick={onNewMessage}\r\n              className=\"flex items-center gap-2 bg-blue-600 hover:bg-blue-700\"\r\n            >\r\n              <Plus className=\"w-4 h-4\" />\r\n              New Message\r\n            </Button>\r\n          </>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default MessageHeader;"],"names":[],"mappings":";;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAWA,MAAM,gBAA8C,CAAC,EACnD,YAAY,EACZ,aAAa,EACb,OAAO,EACP,aAAa,EACb,UAAU,EACV,YAAY,IAAI,EACjB;IACC,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC;;kCACC,6LAAC;wBAAG,WAAU;;0CACZ,6LAAC,4OAAa;gCAAC,WAAU;;;;;;4BAA0B;;;;;;;kCAGrD,6LAAC;wBAAE,WAAU;kCAAqB;;;;;;;;;;;;0BAGpC,6LAAC;gBAAI,WAAU;0BACZ,2BACC;;sCACE,6LAAC,+IAAM;4BACL,SAAS;4BACT,SAAQ;4BACR,WAAU;;8CAEV,6LAAC,mOAAU;oCAAC,WAAU;;;;;;gCAAY;;;;;;;sCAIpC,6LAAC,+IAAM;4BACL,SAAS;4BACT,SAAQ;4BACR,WAAU;;8CAEV,6LAAC,6NAAQ;oCAAC,WAAU;;;;;;gCAAY;;;;;;;sCAIlC,6LAAC,+IAAM;4BACL,SAAS;4BACT,SAAQ;4BACR,WAAU;;8CAEV,6LAAC,gNAAK;oCAAC,WAAU;;;;;;gCAAY;;;;;;;sCAI/B,6LAAC,+IAAM;4BACL,SAAS;4BACT,WAAU;;8CAEV,6LAAC,6MAAI;oCAAC,WAAU;;;;;;gCAAY;;;;;;;;;;;;;;;;;;;;AAQ1C;KA5DM;uCA8DS"}},
    {"offset": {"line": 1224, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/messages/MessageStatsCards.tsx"],"sourcesContent":["import React from 'react';\r\nimport { \r\n  MessageSquare, \r\n  CheckCircle, \r\n  XCircle, \r\n  Clock, \r\n  CreditCard,\r\n  Wallet \r\n} from 'lucide-react';\r\n\r\ninterface MessageStatsCardsProps {\r\n  stats: {\r\n    total: number;\r\n    sent: number;\r\n    failed: number;\r\n    pending: number;\r\n    totalCreditsUsed: number;\r\n    creditsRemaining: number;  // New field\r\n  };\r\n}\r\n\r\nconst MessageStatsCards = ({ stats }: MessageStatsCardsProps) => {\r\n  const isLowBalance = stats.creditsRemaining <= 50;\r\n  const isCritical = stats.creditsRemaining <= 20;\r\n\r\n  return (\r\n    <div className=\"grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4\">\r\n      {/* Credits Remaining - 6th Card */}\r\n      <div className={`p-5 rounded-xl shadow-sm border-2 transition-all hover:shadow-lg ${\r\n        isCritical \r\n          ? 'bg-red-50 border-red-400' \r\n          : isLowBalance \r\n            ? 'bg-amber-50 border-amber-400' \r\n            : 'bg-emerald-50 border-emerald-400'\r\n      }`}>\r\n        <div className={`flex items-center gap-3 mb-2 ${\r\n          isCritical ? 'text-red-700' : isLowBalance ? 'text-amber-700' : 'text-emerald-700'\r\n        }`}>\r\n          <Wallet className=\"w-5 h-5\" />\r\n          <span className=\"text-sm font-medium\">Credit Bal.</span>\r\n        </div>\r\n        <p className={`text-3xl font-bold ${\r\n          isCritical ? 'text-red-700' : isLowBalance ? 'text-amber-700' : 'text-emerald-700'\r\n        }`}>\r\n          {stats.creditsRemaining.toLocaleString()}\r\n        </p>\r\n\r\n      </div>\r\n      {/* Total Messages */}\r\n      <div className=\"bg-white p-5 rounded-xl shadow-sm border border-gray-200 hover:shadow-md transition-shadow\">\r\n        <div className=\"flex items-center gap-3 text-gray-600 mb-2\">\r\n          <MessageSquare className=\"w-5 h-5\" />\r\n          <span className=\"text-sm font-medium\">Total</span>\r\n        </div>\r\n        <p className=\"text-3xl font-bold text-gray-900\">{stats.total.toLocaleString()}</p>\r\n      </div>\r\n\r\n      {/* Sent */}\r\n      <div className=\"bg-white p-5 rounded-xl shadow-sm border border-gray-200 hover:shadow-md transition-shadow\">\r\n        <div className=\"flex items-center gap-3 text-green-600 mb-2\">\r\n          <CheckCircle className=\"w-5 h-5\" />\r\n          <span className=\"text-sm font-medium\">Sent</span>\r\n        </div>\r\n        <p className=\"text-3xl font-bold text-green-600\">{stats.sent.toLocaleString()}</p>\r\n      </div>\r\n\r\n      {/* Pending */}\r\n      <div className=\"bg-white p-5 rounded-xl shadow-sm border border-gray-200 hover:shadow-md transition-shadow\">\r\n        <div className=\"flex items-center gap-3 text-amber-600 mb-2\">\r\n          <Clock className=\"w-5 h-5\" />\r\n          <span className=\"text-sm font-medium\">Pending</span>\r\n        </div>\r\n        <p className=\"text-3xl font-bold text-amber-600\">{stats.pending}</p>\r\n      </div>\r\n\r\n      {/* Failed */}\r\n      <div className=\"bg-white p-5 rounded-xl shadow-sm border border-gray-200 hover:shadow-md transition-shadow\">\r\n        <div className=\"flex items-center gap-3 text-red-600 mb-2\">\r\n          <XCircle className=\"w-5 h-5\" />\r\n          <span className=\"text-sm font-medium\">Failed</span>\r\n        </div>\r\n        <p className=\"text-3xl font-bold text-red-600\">{stats.failed}</p>\r\n      </div>\r\n\r\n      {/* Credits Used */}\r\n      <div className=\"bg-white p-5 rounded-xl shadow-sm border border-gray-200 hover:shadow-md transition-shadow\">\r\n        <div className=\"flex items-center gap-3 text-blue-600 mb-2\">\r\n          <CreditCard className=\"w-5 h-5\" />\r\n          <span className=\"text-sm font-medium\">Credits Used</span>\r\n        </div>\r\n        <p className=\"text-3xl font-bold text-blue-600\">{stats.totalCreditsUsed.toLocaleString()}</p>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default MessageStatsCards;"],"names":[],"mappings":";;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAoBA,MAAM,oBAAoB,CAAC,EAAE,KAAK,EAA0B;IAC1D,MAAM,eAAe,MAAM,gBAAgB,IAAI;IAC/C,MAAM,aAAa,MAAM,gBAAgB,IAAI;IAE7C,qBACE,6LAAC;QAAI,WAAU;;0BAEb,6LAAC;gBAAI,WAAW,CAAC,iEAAiE,EAChF,aACI,6BACA,eACE,iCACA,oCACN;;kCACA,6LAAC;wBAAI,WAAW,CAAC,6BAA6B,EAC5C,aAAa,iBAAiB,eAAe,mBAAmB,oBAChE;;0CACA,6LAAC,mNAAM;gCAAC,WAAU;;;;;;0CAClB,6LAAC;gCAAK,WAAU;0CAAsB;;;;;;;;;;;;kCAExC,6LAAC;wBAAE,WAAW,CAAC,mBAAmB,EAChC,aAAa,iBAAiB,eAAe,mBAAmB,oBAChE;kCACC,MAAM,gBAAgB,CAAC,cAAc;;;;;;;;;;;;0BAK1C,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;wBAAI,WAAU;;0CACb,6LAAC,4OAAa;gCAAC,WAAU;;;;;;0CACzB,6LAAC;gCAAK,WAAU;0CAAsB;;;;;;;;;;;;kCAExC,6LAAC;wBAAE,WAAU;kCAAoC,MAAM,KAAK,CAAC,cAAc;;;;;;;;;;;;0BAI7E,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;wBAAI,WAAU;;0CACb,6LAAC,6OAAW;gCAAC,WAAU;;;;;;0CACvB,6LAAC;gCAAK,WAAU;0CAAsB;;;;;;;;;;;;kCAExC,6LAAC;wBAAE,WAAU;kCAAqC,MAAM,IAAI,CAAC,cAAc;;;;;;;;;;;;0BAI7E,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;wBAAI,WAAU;;0CACb,6LAAC,gNAAK;gCAAC,WAAU;;;;;;0CACjB,6LAAC;gCAAK,WAAU;0CAAsB;;;;;;;;;;;;kCAExC,6LAAC;wBAAE,WAAU;kCAAqC,MAAM,OAAO;;;;;;;;;;;;0BAIjE,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;wBAAI,WAAU;;0CACb,6LAAC,0NAAO;gCAAC,WAAU;;;;;;0CACnB,6LAAC;gCAAK,WAAU;0CAAsB;;;;;;;;;;;;kCAExC,6LAAC;wBAAE,WAAU;kCAAmC,MAAM,MAAM;;;;;;;;;;;;0BAI9D,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;wBAAI,WAAU;;0CACb,6LAAC,mOAAU;gCAAC,WAAU;;;;;;0CACtB,6LAAC;gCAAK,WAAU;0CAAsB;;;;;;;;;;;;kCAExC,6LAAC;wBAAE,WAAU;kCAAoC,MAAM,gBAAgB,CAAC,cAAc;;;;;;;;;;;;;;;;;;AAI9F;KAzEM;uCA2ES"}},
    {"offset": {"line": 1507, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/messages/MessageContent.tsx"],"sourcesContent":["import React from 'react';\r\nimport { Search, Filter, MessageSquare } from 'lucide-react';\r\nimport { Message } from '@/hooks/useMessages';\r\nimport { Customer } from '@/hooks/useCustomers';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\r\n\r\ninterface MessageContentProps {\r\n  messages: Message[];\r\n  customers: Customer[];\r\n  searchTerm: string;\r\n  setSearchTerm: (term: string) => void;\r\n  statusFilter: string;\r\n  setStatusFilter: (status: string) => void;\r\n}\r\n\r\nconst MessageContent = ({\r\n  messages,\r\n  customers,\r\n  searchTerm,\r\n  setSearchTerm,\r\n  statusFilter,\r\n  setStatusFilter\r\n}: MessageContentProps) => {\r\n  \r\n  const getCustomer = (customerId?: string) => {\r\n    if (!customerId) return null;\r\n    return customers.find(c => c.id === customerId);\r\n  };\r\n\r\n  const getStatusBadge = (status: string) => {\r\n    const styles = {\r\n      pending: 'bg-amber-100 text-amber-800',\r\n      sent: 'bg-green-100 text-green-800',\r\n      delivered: 'bg-blue-100 text-blue-800',\r\n      failed: 'bg-red-100 text-red-800'\r\n    };\r\n    return styles[status as keyof typeof styles] || 'bg-gray-100 text-gray-800';\r\n  };\r\n\r\n  // Filter messages by search and status\r\n  const filteredMessages = messages.filter(msg => {\r\n    const customer = getCustomer(msg.customerId);\r\n    const name = customer ? (customer.full_name || customer.fullName || customer.name) : '';\r\n    const phone = msg.phoneNumber;\r\n    const content = msg.content;\r\n\r\n    const matchesSearch = searchTerm\r\n      ? name.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n        phone.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n        content.toLowerCase().includes(searchTerm.toLowerCase())\r\n      : true;\r\n\r\n    const matchesStatus = statusFilter === 'all' || msg.status === statusFilter;\r\n\r\n    return matchesSearch && matchesStatus;\r\n  });\r\n\r\n  return (\r\n    <div className=\"space-y-4\">\r\n      {/* Filters */}\r\n      <div className=\"flex flex-col md:flex-row gap-4\">\r\n        <div className=\"flex-1 relative\">\r\n          <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4\" />\r\n          <Input\r\n            type=\"text\"\r\n            placeholder=\"Search messages...\"\r\n            value={searchTerm}\r\n            onChange={(e) => setSearchTerm(e.target.value)}\r\n            className=\"pl-10\"\r\n          />\r\n        </div>\r\n        \r\n        <Select value={statusFilter} onValueChange={setStatusFilter}>\r\n          <SelectTrigger className=\"w-full md:w-48\">\r\n            <Filter className=\"w-4 h-4 mr-2\" />\r\n            <SelectValue placeholder=\"Filter by status\" />\r\n          </SelectTrigger>\r\n          <SelectContent>\r\n            <SelectItem value=\"all\">All Messages</SelectItem>\r\n            <SelectItem value=\"pending\">Pending</SelectItem>\r\n            <SelectItem value=\"sent\">Sent</SelectItem>\r\n            <SelectItem value=\"failed\">Failed</SelectItem>\r\n          </SelectContent>\r\n        </Select>\r\n      </div>\r\n\r\n      {/* Messages List */}\r\n      <div className=\"space-y-3\">\r\n        {filteredMessages.length === 0 ? (\r\n          <div className=\"text-center py-12 bg-white rounded-lg border\">\r\n            <MessageSquare className=\"w-12 h-12 text-gray-300 mx-auto mb-3\" />\r\n            <p className=\"text-gray-500\">No messages found</p>\r\n          </div>\r\n        ) : (\r\n          filteredMessages.map(msg => {\r\n            const customer = getCustomer(msg.customerId);\r\n            const name = customer ? (customer.full_name || customer.fullName || customer.name) : '';\r\n\r\n            return (\r\n              <div\r\n                key={msg.id}\r\n                className=\"bg-white p-4 rounded-lg shadow border hover:shadow-md transition-shadow\"\r\n              >\r\n                <div className=\"flex justify-between items-start mb-2\">\r\n                  <div>\r\n                    <div className=\"flex items-center gap-2\">\r\n                      <p className=\"font-medium text-gray-900\">\r\n                        {name ? `${name} (${msg.phoneNumber})` : msg.phoneNumber}\r\n                      </p>\r\n                      <span className={`text-xs px-2 py-1 rounded-full ${getStatusBadge(msg.status)}`}>\r\n                        {msg.status}\r\n                      </span>\r\n                    </div>\r\n                  </div>\r\n                  <div className=\"text-right\">\r\n                    <p className=\"text-xs text-gray-400\">{new Date(msg.createdAt).toLocaleDateString()}</p>\r\n                    <p className=\"text-xs text-gray-400\">{new Date(msg.createdAt).toLocaleTimeString()}</p>\r\n                  </div>\r\n                </div>\r\n\r\n                <p className=\"text-sm text-gray-600 mb-2\">{msg.content}</p>\r\n\r\n                <div className=\"flex justify-between items-center text-xs text-gray-400\">\r\n                  <span>{msg.smsCreditsUsed} credit{msg.smsCreditsUsed > 1 ? 's' : ''} used</span>\r\n                  {msg.errorMessage && <span className=\"text-red-600\">{msg.errorMessage}</span>}\r\n                </div>\r\n              </div>\r\n            );\r\n          })\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default MessageContent;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1820, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/textarea.tsx"],"sourcesContent":["import * as React from \"react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nexport interface TextareaProps\r\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\r\n\r\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\r\n  ({ className, ...props }, ref) => {\r\n    return (\r\n      <textarea\r\n        className={cn(\r\n          \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\r\n          className\r\n        )}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    )\r\n  }\r\n)\r\nTextarea.displayName = \"Textarea\"\r\n\r\nexport { Textarea }\r\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAKA,MAAM,yBAAW,2KAAgB,MAC/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE;IACxB,qBACE,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,wSACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;;AAEF,SAAS,WAAW,GAAG"}},
    {"offset": {"line": 1854, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/messages/NewMessageDialog.tsx"],"sourcesContent":["import React, { useState, useEffect, useMemo } from 'react';\r\nimport { Send } from 'lucide-react';\r\nimport { Customer } from '@/hooks/useCustomers';\r\nimport { MessageTemplate } from '@/hooks/useMessages';\r\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Textarea } from '@/components/ui/textarea';\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\r\n\r\ninterface NewMessageDialogProps {\r\n  open: boolean;\r\n  onClose: () => void;\r\n  onSend: (data: { phoneNumber: string; content: string; customerId?: string; templateId?: string }) => Promise<{ success: number; failed: number; errors?: string[] }>;\r\n  customers: Customer[];\r\n  templates: MessageTemplate[];\r\n}\r\n\r\nconst NewMessageDialog = ({ open, onClose, onSend, customers, templates }: NewMessageDialogProps) => {\r\n  const [phoneNumber, setPhoneNumber] = useState('');\r\n  const [content, setContent] = useState('');\r\n  const [selectedCustomer, setSelectedCustomer] = useState<string>('none');\r\n  const [selectedTemplate, setSelectedTemplate] = useState<string>('none');\r\n  const [isSending, setIsSending] = useState(false);\r\n  const [sendResult, setSendResult] = useState<{ success: number; failed: number; errors: string[] } | null>(null);\r\n  const [searchTerm, setSearchTerm] = useState('');\r\n\r\n  // Reset state when dialog closes\r\n  useEffect(() => {\r\n    if (!open) {\r\n      setPhoneNumber('');\r\n      setContent('');\r\n      setSelectedCustomer('none');\r\n      setSelectedTemplate('none');\r\n      setSendResult(null);\r\n      setSearchTerm('');\r\n    }\r\n  }, [open]);\r\n\r\n  // Populate phone number when customer is selected\r\n  useEffect(() => {\r\n    if (selectedCustomer && selectedCustomer !== 'none') {\r\n      const customer = customers.find(c => c.id === selectedCustomer);\r\n      const phone = getCustomerPhone(customer);\r\n      setPhoneNumber(phone);\r\n    }\r\n  }, [selectedCustomer, customers]);\r\n\r\n  // Populate message content when template is selected\r\n  useEffect(() => {\r\n    if (selectedTemplate && selectedTemplate !== 'none') {\r\n      const template = templates.find(t => t.id === selectedTemplate);\r\n      if (template) setContent(template.content);\r\n    }\r\n  }, [selectedTemplate, templates]);\r\n\r\n  const getCustomerPhone = (customer?: Customer) =>\r\n    (customer?.phone_number || customer?.phoneNumber || customer?.phone || customer?.contact || '').trim();\r\n\r\n  const filteredCustomers = useMemo(() => {\r\n    const term = (searchTerm || '').toLowerCase();\r\n    return customers\r\n      .filter(c => getCustomerPhone(c)) // only customers with phone\r\n      .filter(c => {\r\n        const name = (c.full_name || c.fullName || c.name || '').toLowerCase();\r\n        const phone = getCustomerPhone(c).toLowerCase();\r\n        return !term || name.includes(term) || phone.includes(term);\r\n      });\r\n  }, [customers, searchTerm]);\r\n\r\n\r\n  const handleSend = async () => {\r\n    if (!phoneNumber || !content) return;\r\n\r\n    setIsSending(true);\r\n    const result = await onSend({\r\n      phoneNumber,\r\n      content,\r\n      customerId: selectedCustomer && selectedCustomer !== 'none' ? selectedCustomer : undefined,\r\n      templateId: selectedTemplate && selectedTemplate !== 'none' ? selectedTemplate : undefined,\r\n    });\r\n    setIsSending(false);\r\n\r\n    setSendResult({\r\n      success: result.success,\r\n      failed: result.failed,\r\n      errors: result.errors || [],\r\n    });\r\n\r\n    if ((result.failed || 0) === 0) {\r\n      setTimeout(() => onClose(), 3000); // auto-close if all succeed\r\n    }\r\n  };\r\n\r\n  const messageLength = content.length;\r\n  const smsCredits = Math.ceil(messageLength / 160) || 1;\r\n\r\n  return (\r\n    <Dialog open={open} onOpenChange={onClose}>\r\n      <DialogContent className=\"sm:max-w-lg max-h-[90vh] overflow-y-auto\">\r\n        <DialogHeader>\r\n          <DialogTitle className=\"flex items-center gap-2\">\r\n            <Send className=\"w-5 h-5\" />\r\n            Send New Message\r\n          </DialogTitle>\r\n        </DialogHeader>\r\n\r\n        {sendResult ? (\r\n          <div className=\"space-y-4\">\r\n            <div className={`p-4 rounded-lg border ${sendResult.failed === 0 ? 'bg-green-50 border-green-200' : 'bg-amber-50 border-amber-200'}`}>\r\n              <h3 className=\"font-semibold text-lg mb-2\">\r\n                {sendResult.failed === 0 ? ' Message Sent Successfully!' : ' Sending Completed with Errors'}\r\n              </h3>\r\n              <div className=\"space-y-1 text-sm\">\r\n                <p className=\"text-green-700\"> Successfully sent: {sendResult.success}</p>\r\n                {sendResult.failed > 0 && <p className=\"text-red-700\"> Failed: {sendResult.failed}</p>}\r\n              </div>\r\n            </div>\r\n\r\n            {sendResult.errors.length > 0 && (\r\n              <div className=\"bg-red-50 border border-red-200 rounded-lg p-4\">\r\n                <h4 className=\"font-semibold text-red-900 mb-2\">Errors:</h4>\r\n                <ul className=\"text-sm text-red-800 space-y-1 max-h-[200px] overflow-y-auto\">\r\n                  {sendResult.errors.map((err, idx) => <li key={idx}> {err}</li>)}\r\n                </ul>\r\n              </div>\r\n            )}\r\n\r\n            <Button onClick={onClose} className=\"w-full\">Close</Button>\r\n          </div>\r\n        ) : (\r\n          <div className=\"space-y-4\">\r\n            {/* Customer Dropdown */}\r\n            <div>\r\n              <label className=\"text-sm font-medium text-gray-700 mb-1 block\">Select Customer (Optional)</label>\r\n              <Select value={selectedCustomer} onValueChange={setSelectedCustomer}>\r\n                <SelectTrigger className=\"w-full\">\r\n                  <SelectValue placeholder=\"Search or select a customer...\" />\r\n                </SelectTrigger>\r\n                <SelectContent className=\"max-h-[300px] overflow-y-auto\">\r\n                  <div className=\"p-2\">\r\n                    <Input\r\n                      type=\"text\"\r\n                      placeholder=\"Type to search...\"\r\n                      value={searchTerm}\r\n                      onChange={e => setSearchTerm(e.target.value)}\r\n                      className=\"mb-2\"\r\n                    />\r\n                  </div>\r\n                  <SelectItem value=\"none\">None - Enter Customer Name or Phone Number</SelectItem>\r\n                  {filteredCustomers.map(c => (\r\n                    <SelectItem key={c.id} value={c.id}>\r\n                      {c.full_name || c.fullName || c.name || 'Unnamed Customer'} - {getCustomerPhone(c)}\r\n                    </SelectItem>\r\n                  ))}\r\n                </SelectContent>\r\n              </Select>\r\n            </div>\r\n\r\n            {/* Phone Number */}\r\n            <div>\r\n              <label className=\"text-sm font-medium text-gray-700 mb-1 block\">Phone Number *</label>\r\n              <Input type=\"tel\" placeholder=\"+256700000000\" value={phoneNumber} onChange={e => setPhoneNumber(e.target.value)} className=\"w-full\" />\r\n            </div>\r\n\r\n            {/* Template */}\r\n            <div>\r\n              <label className=\"text-sm font-medium text-gray-700 mb-1 block\">Use Template (Optional)</label>\r\n              <Select value={selectedTemplate} onValueChange={setSelectedTemplate}>\r\n                <SelectTrigger className=\"w-full\">\r\n                  <SelectValue placeholder=\"Choose a template...\" />\r\n                </SelectTrigger>\r\n                <SelectContent className=\"max-h-[300px] overflow-y-auto\">\r\n                  <SelectItem value=\"none\">None - Type custom message</SelectItem>\r\n                  {templates.map(t => <SelectItem key={t.id} value={t.id}>{t.name}</SelectItem>)}\r\n                </SelectContent>\r\n              </Select>\r\n            </div>\r\n\r\n            {/* Message */}\r\n            <div>\r\n              <label className=\"text-sm font-medium text-gray-700 mb-1 block\">Message * (Max 160 Characters)</label>\r\n              <Textarea\r\n                placeholder=\"Type your message...\"\r\n                value={content}\r\n                onChange={e => setContent(e.target.value)}\r\n                rows={5}\r\n                required\r\n                className=\"w-full resize-none\"\r\n              />\r\n              <div className=\"flex justify-between mt-1 text-xs text-gray-500\">\r\n                <span>{messageLength} characters</span>\r\n                <span>{smsCredits} SMS credit{smsCredits > 1 ? 's' : ''} will be used</span>\r\n              </div>\r\n            </div>\r\n\r\n            {/* Actions */}\r\n            <div className=\"flex justify-end gap-2 pt-4 border-t\">\r\n              <Button variant=\"outline\" onClick={onClose} disabled={isSending}>Cancel</Button>\r\n              <Button\r\n                onClick={handleSend}\r\n                disabled={!phoneNumber || !content || isSending}\r\n                className=\"bg-blue-600 hover:bg-blue-700\"\r\n              >\r\n                {isSending ? <span className=\"animate-spin mr-2\"></span> : <>\r\n                  <Send className=\"w-4 h-4 mr-2\" />\r\n                  Send Message\r\n                </>}\r\n              </Button>\r\n            </div>\r\n          </div>\r\n        )}\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n};\r\n\r\nexport default NewMessageDialog;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2414, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/messages/MessageTemplateDialog.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\r\nimport { FileText, Save } from 'lucide-react';\r\nimport { MessageTemplate } from '@/hooks/useMessages';\r\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Textarea } from '@/components/ui/textarea';\r\nimport {\r\n  Select,\r\n  SelectTrigger,\r\n  SelectValue,\r\n  SelectContent,\r\n  SelectItem\r\n} from '@/components/ui/select';\r\n\r\ninterface MessageTemplateDialogProps {\r\n  open: boolean;\r\n  onClose: () => void;\r\n  onSave: (data: Omit<MessageTemplate, 'id' | 'userId' | 'locationId' | 'createdAt' | 'updatedAt'>) => Promise<boolean>;\r\n  initialData?: MessageTemplate;\r\n}\r\n\r\n// Predefined SMS Categories with Custom option\r\nconst TEMPLATE_CATEGORIES = [\r\n  { value: \"ThankYou\", label: \"Thank You (After Sale)\" },\r\n  { value: \"Birthday\", label: \"Birthday Wishes\" },\r\n  { value: \"PaymentReminder\", label: \"Payment Reminder\" },\r\n  { value: \"Holiday\", label: \"Public Holiday\" },\r\n  { value: \"Inactive\", label: \"We Miss You / Inactive Customer\" },\r\n  { value: \"Custom\", label: \"Custom\" } // Custom option\r\n];\r\n\r\nconst MessageTemplateDialog = ({ open, onClose, onSave, initialData }: MessageTemplateDialogProps) => {\r\n  const [name, setName] = useState('');\r\n  const [content, setContent] = useState('');\r\n  const [category, setCategory] = useState('');\r\n  const [customCategory, setCustomCategory] = useState(''); // For typing custom category\r\n  const [variables, setVariables] = useState<string[]>([]);\r\n  const [isSaving, setIsSaving] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (open && initialData) {\r\n      setName(initialData.name);\r\n      setContent(initialData.content);\r\n      setCategory(initialData.category || '');\r\n      setCustomCategory(initialData.category && !TEMPLATE_CATEGORIES.some(c => c.value === initialData.category) ? initialData.category : '');\r\n      setVariables(initialData.variables || []);\r\n    } else if (!open) {\r\n      setName('');\r\n      setContent('');\r\n      setCategory('');\r\n      setCustomCategory('');\r\n      setVariables([]);\r\n    }\r\n  }, [open, initialData]);\r\n\r\n  const handleSave = async () => {\r\n    if (!name || !content) return;\r\n\r\n    const finalCategory = category === \"Custom\" ? customCategory : category;\r\n\r\n    setIsSaving(true);\r\n    const success = await onSave({\r\n      name,\r\n      content,\r\n      category: finalCategory || undefined,\r\n      variables,\r\n      isDefault: false\r\n    });\r\n    setIsSaving(false);\r\n\r\n    if (success) {\r\n      onClose();\r\n    }\r\n  };\r\n\r\n  const extractVariables = (text: string) => {\r\n    const regex = /\\{([^}]+)\\}/g;\r\n    const matches = text.match(regex);\r\n    if (matches) {\r\n      const vars = matches.map(m => m.slice(1, -1));\r\n      setVariables([...new Set(vars)]);\r\n    } else {\r\n      setVariables([]);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Dialog\r\n        open={open}\r\n        onOpenChange={(isOpen) => {\r\n          if (!isOpen) onClose();\r\n        }}\r\n      >\r\n      <DialogContent className=\"sm:max-w-lg max-h-[80vh] overflow-y-auto\">\r\n        <DialogHeader>\r\n          <DialogTitle className=\"flex items-center gap-2\">\r\n            <FileText className=\"w-5 h-5\" />\r\n            {initialData ? 'Edit Template' : 'Create New Template'}\r\n          </DialogTitle>\r\n        </DialogHeader>\r\n\r\n        <div className=\"space-y-4\">\r\n          {/* Template Name */}\r\n          <div>\r\n            <label className=\"text-sm font-medium text-gray-700 mb-1 block\">\r\n              Template Name *\r\n            </label>\r\n            <Textarea\r\n              placeholder=\"e.g., Welcome Message\"\r\n              value={name}\r\n              onChange={(e) => setName(e.target.value)}\r\n              rows={1}\r\n              className=\"resize-none\"\r\n            />\r\n          </div>\r\n\r\n          {/* Category */}\r\n          <div>\r\n            <label className=\"text-sm font-medium text-gray-700 mb-1 block\">\r\n              Category *\r\n            </label>\r\n            <Select value={category} onValueChange={setCategory}>\r\n              <SelectTrigger>\r\n                <SelectValue placeholder=\"Select category...\" />\r\n              </SelectTrigger>\r\n              <SelectContent>\r\n                {TEMPLATE_CATEGORIES.map(c => (\r\n                  <SelectItem key={c.value} value={c.value}>\r\n                    {c.label}\r\n                  </SelectItem>\r\n                ))}\r\n              </SelectContent>\r\n            </Select>\r\n\r\n            {category === \"Custom\" && (\r\n              <Textarea\r\n                placeholder=\"Type custom category...\"\r\n                value={customCategory}\r\n                onChange={(e) => setCustomCategory(e.target.value)}\r\n                rows={1}\r\n                className=\"mt-2 resize-none\"\r\n              />\r\n            )}\r\n          </div>\r\n\r\n          {/* Template Content */}\r\n          <div>\r\n            <label className=\"text-sm font-medium text-gray-700 mb-1 block\">\r\n              Message Content *\r\n            </label>\r\n            <Textarea\r\n              placeholder=\"Type your template here... Use {variable} for dynamic content\"\r\n              value={content}\r\n              onChange={(e) => {\r\n                setContent(e.target.value);\r\n                extractVariables(e.target.value);\r\n              }}\r\n              rows={6}\r\n              className=\"resize-none\"\r\n            />\r\n            <p className=\"text-xs text-gray-500 mt-1\">\r\n              Use curly braces for variables: {'{customer_name}'}, {'{customer_phone}'}, etc.\r\n            </p>\r\n          </div>\r\n\r\n          {/* Detected Variables */}\r\n          {variables.length > 0 && (\r\n            <div>\r\n              <label className=\"text-sm font-medium text-gray-700 mb-1 block\">\r\n                Detected Variables\r\n              </label>\r\n              <div className=\"flex flex-wrap gap-2\">\r\n                {variables.map(v => (\r\n                  <span key={v} className=\"text-xs px-2 py-1 bg-blue-50 text-blue-600 rounded\">\r\n                    {v}\r\n                  </span>\r\n                ))}\r\n              </div>\r\n            </div>\r\n          )}\r\n\r\n          {/* Available Variables */}\r\n          <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-3\">\r\n            <p className=\"text-xs font-medium text-blue-900 mb-2\">\r\n              Available Variables\r\n            </p>\r\n            <div className=\"text-xs text-blue-800 space-y-1\">\r\n              <p> <code className=\"bg-blue-100 px-1 rounded\">{'{customer_name}'}</code> - Full customer name</p>\r\n              <p> <code className=\"bg-blue-100 px-1 rounded\">{'{first_name}'}</code> - Customer first name</p>\r\n              <p> <code className=\"bg-blue-100 px-1 rounded\">{'{last_name}'}</code> - Customer last name</p>\r\n              <p> <code className=\"bg-blue-100 px-1 rounded\">{'{customer_phone}'}</code> - Customer phone number</p>\r\n              <p> <code className=\"bg-blue-100 px-1 rounded\">{'{customer_email}'}</code> - Customer email</p>\r\n            </div>\r\n            <p className=\"text-xs text-blue-700 mt-2\">\r\n              These will be automatically replaced when sending to a customer\r\n            </p>\r\n          </div>\r\n\r\n          {/* Action Buttons */}\r\n          <div className=\"flex justify-end gap-2 pt-4\">\r\n            <Button variant=\"outline\" onClick={onClose} disabled={isSaving}>\r\n              Cancel\r\n            </Button>\r\n            <Button\r\n              onClick={handleSave}\r\n              disabled={!name || !content || (!category || (category === \"Custom\" && !customCategory)) || isSaving}\r\n              className=\"bg-blue-600 hover:bg-blue-700\"\r\n            >\r\n              <Save className=\"w-4 h-4 mr-2\" />\r\n              {isSaving ? 'Saving...' : 'Save Template'}\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n};\r\n\r\nexport default MessageTemplateDialog;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2911, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/messages/TopUpCreditsDialog.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\r\nimport { CreditCard, DollarSign } from 'lucide-react';\r\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\n\r\ninterface TopUpCreditsDialogProps {\r\n  open: boolean;\r\n  onClose: () => void;\r\n  onTopUp: (credits: number, phoneNumber: string) => Promise<boolean>;\r\n}\r\n\r\nconst TopUpCreditsDialog = ({ open, onClose, onTopUp }: TopUpCreditsDialogProps) => {\r\n  const [credits, setCredits] = useState<number>(10);\r\n  const [phoneNumber, setPhoneNumber] = useState('');\r\n  const [isProcessing, setIsProcessing] = useState(false);\r\n\r\n  const creditCost = Number(import.meta.env.VITE_SMS_CREDIT_COST || 100);\r\n  const totalCost = credits * creditCost;\r\n\r\n  // Debug: Dialog opened / closed\r\n  useEffect(() => {\r\n    console.log('[TopUpCreditsDialog] Dialog open state:', open);\r\n    if (open) {\r\n      console.log('[TopUpCreditsDialog] Dialog opened  resetting form');\r\n      setCredits(10);\r\n      setPhoneNumber('');\r\n      setIsProcessing(false);\r\n    }\r\n  }, [open]);\r\n\r\n  // Debug: Form state changes\r\n  useEffect(() => {\r\n    console.log('[TopUpCreditsDialog] Current state  Credits:', credits, '| Phone:', phoneNumber, '| Total Cost: UGX', totalCost.toLocaleString());\r\n  }, [credits, phoneNumber, totalCost]);\r\n\r\n  const handleTopUp = async () => {\r\n    console.log('[TopUpCreditsDialog] Top-up requested!');\r\n    console.log('    Credits:', credits);\r\n    console.log('    Phone Number:', phoneNumber);\r\n    console.log('    Total Cost: UGX', totalCost.toLocaleString());\r\n\r\n    if (!phoneNumber || credits < 1) {\r\n      console.warn('[TopUpCreditsDialog] Invalid input  blocking submit');\r\n      return;\r\n    }\r\n\r\n    setIsProcessing(true);\r\n    console.log('[TopUpCreditsDialog] Calling onTopUp...');\r\n\r\n    try {\r\n      const success = await onTopUp(credits, phoneNumber);\r\n      console.log('[TopUpCreditsDialog] onTopUp result:', success ? 'SUCCESS' : 'FAILED');\r\n\r\n      if (success) {\r\n        console.log('[TopUpCreditsDialog] Payment successful  closing dialog');\r\n        onClose();\r\n      } else {\r\n        console.error('[TopUpCreditsDialog] Payment failed (returned false)');\r\n      }\r\n    } catch (err) {\r\n      console.error('[TopUpCreditsDialog] onTopUp threw an error:', err);\r\n    } finally {\r\n      setIsProcessing(false);\r\n    }\r\n  };\r\n\r\n  const quickAmounts = [10, 25, 50, 100];\r\n\r\n  return (\r\n    <Dialog open={open} onOpenChange={onClose}>\r\n      <DialogContent className=\"sm:max-w-lg\">\r\n        <DialogHeader>\r\n          <DialogTitle className=\"flex items-center gap-2\">\r\n            <CreditCard className=\"w-5 h-5\" />\r\n            Top Up SMS Credits\r\n          </DialogTitle>\r\n        </DialogHeader>\r\n\r\n        <div className=\"space-y-6\">\r\n          {/* Credit Amount Selection */}\r\n          <div>\r\n            <label className=\"text-sm font-medium text-gray-700 mb-2 block\">\r\n              Number of Credits *\r\n            </label>\r\n            <Input\r\n              type=\"number\"\r\n              min=\"1\"\r\n              value={credits}\r\n              onChange={(e) => {\r\n                const val = Math.max(1, parseInt(e.target.value) || 1);\r\n                console.log('[TopUpCreditsDialog] Credits input changed ', val);\r\n                setCredits(val);\r\n              }}\r\n              className=\"text-lg font-semibold\"\r\n            />\r\n\r\n            {/* Quick Amount Buttons */}\r\n            <div className=\"mt-3 flex flex-wrap gap-2\">\r\n              {quickAmounts.map(amount => (\r\n                <button\r\n                  key={amount}\r\n                  type=\"button\"\r\n                  onClick={() => {\r\n                    console.log('[TopUpCreditsDialog] Quick amount clicked ', amount, 'credits');\r\n                    setCredits(amount);\r\n                  }}\r\n                  className={`px-3 py-1 text-sm rounded-md border transition-colors ${\r\n                    credits === amount\r\n                      ? 'bg-blue-600 text-white border-blue-600'\r\n                      : 'bg-white text-gray-700 border-gray-300 hover:border-blue-400'\r\n                  }`}\r\n                >\r\n                  {amount} credits\r\n                </button>\r\n              ))}\r\n            </div>\r\n          </div>\r\n\r\n          {/* Cost Display */}\r\n          <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4\">\r\n            <div className=\"flex items-center justify-between mb-2\">\r\n              <span className=\"text-sm text-gray-600\">Credit Cost:</span>\r\n              <span className=\"text-sm font-medium\">UGX {creditCost} per credit</span>\r\n            </div>\r\n            <div className=\"flex items-center justify-between mb-2\">\r\n              <span className=\"text-sm text-gray-600\">Quantity:</span>\r\n              <span className=\"text-sm font-medium\">{credits} credits</span>\r\n            </div>\r\n            <div className=\"border-t border-blue-300 pt-2 mt-2\">\r\n              <div className=\"flex items-center justify-between\">\r\n                <span className=\"text-base font-semibold text-gray-900\">Total Amount:</span>\r\n                <span className=\"text-xl font-bold text-blue-600\">\r\n                  UGX {totalCost.toLocaleString()}\r\n                </span>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Phone Number for Payment */}\r\n          <div>\r\n            <label className=\"text-sm font-medium text-gray-700 mb-1 block\">\r\n              Mobile Money Phone Number *\r\n            </label>\r\n            <Input\r\n              type=\"tel\"\r\n              placeholder=\"+256700000000\"\r\n              value={phoneNumber}\r\n              onChange={(e) => {\r\n                console.log('[TopUpCreditsDialog] Phone number changed ', e.target.value);\r\n                setPhoneNumber(e.target.value);\r\n              }}\r\n            />\r\n            <p className=\"text-xs text-gray-500 mt-1\">\r\n              You will receive a payment prompt on this number\r\n            </p>\r\n          </div>\r\n\r\n          {/* Action Buttons */}\r\n          <div className=\"flex justify-end gap-2 pt-4\">\r\n            <Button variant=\"outline\" onClick={onClose} disabled={isProcessing}>\r\n              Cancel\r\n            </Button>\r\n            <Button\r\n              onClick={handleTopUp}\r\n              disabled={!phoneNumber || credits < 1 || isProcessing}\r\n              className=\"bg-green-600 hover:bg-green-700\"\r\n            >\r\n              <DollarSign className=\"w-4 h-4 mr-2\" />\r\n              {isProcessing ? 'Processing...' : `Pay UGX ${totalCost.toLocaleString()}`}\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n};\r\n\r\nexport default TopUpCreditsDialog;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3289, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/checkbox.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\r\nimport { Check } from \"lucide-react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Checkbox = React.forwardRef<\r\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\r\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\r\n>(({ className, ...props }, ref) => (\r\n  <CheckboxPrimitive.Root\r\n    ref={ref}\r\n    className={cn(\r\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\r\n      className\r\n    )}\r\n    {...props}\r\n  >\r\n    <CheckboxPrimitive.Indicator\r\n      className={cn(\"flex items-center justify-center text-current\")}\r\n    >\r\n      <Check className=\"h-4 w-4\" />\r\n    </CheckboxPrimitive.Indicator>\r\n  </CheckboxPrimitive.Root>\r\n))\r\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\r\n\r\nexport { Checkbox }\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,yBAAW,2KAAgB,MAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,+KAAsB;QACrB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,kTACA;QAED,GAAG,KAAK;kBAET,cAAA,6LAAC,oLAA2B;YAC1B,WAAW,IAAA,4HAAE,EAAC;sBAEd,cAAA,6LAAC,gNAAK;gBAAC,WAAU;;;;;;;;;;;;;;;;;AAIvB,SAAS,WAAW,GAAG,+KAAsB,CAAC,WAAW"}},
    {"offset": {"line": 3339, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/types/index.ts"],"sourcesContent":["// Sale item type definition\r\nexport interface SaleItem {\r\n  description: string;\r\n  quantity: number;\r\n  price: number;\r\n  cost: number;\r\n  productId?: string;\r\n  discountPercentage?: number;\r\n  discountType?: 'percentage' | 'amount';\r\n  discountAmount?: number;\r\n}\r\n\r\nexport interface SalesCategory {\r\n  id: string;\r\n  user_id: string;\r\n  location_id?: string;\r\n  name: string;\r\n  is_default: boolean;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface Sale {\r\n  id: string;\r\n  receiptNumber: string;\r\n  customerName: string;\r\n  customerAddress?: string;\r\n  customerContact?: string;\r\n  customerId?: string;\r\n  items: SaleItem[];\r\n  paymentStatus: 'Paid' | 'NOT PAID' | 'Quote' | 'Installment Sale';\r\n  profit: number;\r\n  date: Date;\r\n  taxRate?: number;\r\n  cashTransactionId?: string;\r\n  amountPaid?: number;\r\n  amountDue?: number;\r\n  notes?: string;\r\n  categoryId?: string;\r\n  installments?: Array<{\r\n    date?: string | Date;\r\n    amountPaid?: number;\r\n  }>;\r\n  createdAt: Date;\r\n}\r\n\r\n// Supabase database schema and Json type\r\nexport type Json =\r\n  | string\r\n  | number\r\n  | boolean\r\n  | null\r\n  | { [key: string]: Json | undefined }\r\n  | Json[];\r\n\r\n// Supabase database sale structure\r\nexport interface DbSale {\r\n  id: string;\r\n  user_id: string;\r\n  location_id: string;\r\n  receipt_number: string;\r\n  customer_name: string;\r\n  customer_address?: string | null;\r\n  customer_contact?: string | null;\r\n  customer_id?: string | null;\r\n  items: Json;\r\n  payment_status: string;\r\n  profit: number;\r\n  date: string;\r\n  tax_rate?: number | null;\r\n  created_at: string;\r\n  updated_at: string;\r\n  cash_transaction_id?: string | null;\r\n  amount_paid?: number | null;\r\n  amount_due?: number | null;\r\n  notes?: string | null;\r\n  category_id?: string | null;\r\n}\r\n\r\n// Expense interface - add cashTransactionId field\r\nexport interface Expense {\r\n  id: string;\r\n  amount: number;\r\n  description: string;\r\n  category: string | null;\r\n  date: Date;\r\n  paymentMethod: string | null;\r\n  personInCharge: string | null;\r\n  receiptImage: string | null;\r\n  cashAccountId: string | null;\r\n  cashTransactionId: string | null; // Add this field\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\n// Supabase database expense structure\r\nexport interface DbExpense {\r\n  id: string;\r\n  user_id: string;\r\n  amount: number;\r\n  description: string;\r\n  category: string | null;\r\n  date: string;\r\n  payment_method: string | null;\r\n  person_in_charge: string | null;\r\n  receipt_image: string | null;\r\n  cash_account_id: string | null;\r\n  cash_transaction_id: string | null; // Add this field\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface SaleFormData {\r\n  customerName: string;\r\n  customerAddress: string;\r\n  customerContact: string;\r\n  customerId?: string; // Added customerId field\r\n  items: SaleItem[];\r\n  paymentStatus: \"Paid\" | \"NOT PAID\" | \"Quote\" | \"Installment Sale\";\r\n  receiptNumber?: string;\r\n  taxRate?: number | null;\r\n  amountPaid?: number;\r\n  amountDue?: number;\r\n  notes?: string;\r\n  categoryId?: string;\r\n}\r\n\r\n// Analytics data type\r\nexport interface AnalyticsData {\r\n  totalSales: number;\r\n  totalProfit: number;\r\n  totalCost: number;\r\n  paidSalesCount: number;\r\n  pendingSalesCount: number;\r\n}\r\n\r\n// Form validation errors\r\nexport interface FormErrors {\r\n  customerName?: string;\r\n  customerAddress?: string;\r\n  customerContact?: string;\r\n  itemDescription?: string;\r\n  quantity?: string;\r\n  salePrice?: string;\r\n  costOfProduction?: string;\r\n  taxRate?: string;\r\n}\r\n\r\n// BusinessSettings interface to include paymentInfo\r\nexport interface BusinessSettings {\r\n  businessName: string;\r\n  businessAddress: string;\r\n  businessPhone: string;\r\n  businessEmail: string;\r\n  businessLogo?: string;\r\n  currency: string;\r\n  signature?: string;\r\n  paymentInfo?: string; // Added payment information field\r\n  defaultPrintFormat?: 'standard' | 'thermal'; // Added default print format\r\n  defaultPrinterName?: string; // Added default printer name\r\n  defaultPrinterType?: 'USB' | 'Bluetooth'; // Added default printer type\r\n}\r\n\r\n// Database business settings structure\r\nexport interface DbBusinessSettings {\r\n  id?: string;\r\n  user_id: string; // Make sure this is required, not optional\r\n  business_name: string;\r\n  business_address: string;\r\n  business_phone: string;\r\n  business_email: string;\r\n  business_logo?: string;\r\n  currency: string;\r\n  signature?: string;\r\n  metadata?: Json | null; // Add metadata field\r\n  created_at?: string;\r\n  updated_at?: string;\r\n}\r\n\r\n// Updated UserProfile interface to match the Supabase database structure\r\nexport interface UserProfile {\r\n  id: string;\r\n  full_name: string | null;\r\n  display_name: string | null;\r\n  avatar_url: string | null;\r\n  created_at: string | null;\r\n  updated_at: string | null;\r\n}\r\n\r\n// New interfaces for Product management - ADDED itemNumber\r\nexport interface Product {\r\n  id: string;\r\n  itemNumber: string; // Added item number field\r\n  barcode: string | null; // Added barcode field\r\n  manufacturerBarcode: string | null; // Added manufacturer barcode field\r\n  name: string;\r\n  description: string | null;\r\n  category: string;\r\n  quantity: number;\r\n  costPrice: number;\r\n  sellingPrice: number;\r\n  supplier: string | null;\r\n  imageUrl: string | null;\r\n  minimumStock: number;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface DbProduct {\r\n  id: string;\r\n  user_id: string;\r\n  item_number: string; // Added item number field\r\n  barcode: string | null; // Added barcode field\r\n  manufacturer_barcode: string | null; // Added manufacturer barcode field\r\n  name: string;\r\n  description: string | null;\r\n  category: string;\r\n  quantity: number;\r\n  cost_price: number;\r\n  selling_price: number;\r\n  supplier: string | null;\r\n  image_url: string | null;\r\n  minimum_stock: number;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface ProductFormData {\r\n  name: string;\r\n  barcode?: string; // Added barcode field\r\n  manufacturerBarcode?: string; // Added manufacturer barcode field\r\n  description?: string;\r\n  category?: string;\r\n  quantity: number; // Always a number, never undefined\r\n  costPrice?: number;\r\n  sellingPrice?: number;\r\n  supplier?: string;\r\n  minimumStock?: number;\r\n  imageFile?: File | null;\r\n  imageUrl?: string | null;\r\n  createdAt?: Date; // Added created date field\r\n}\r\n\r\nexport interface ProductCategory {\r\n  id: string;\r\n  name: string;\r\n  createdAt?: Date;\r\n}\r\n\r\nexport interface DbProductCategory {\r\n  id: string;\r\n  user_id: string;\r\n  name: string;\r\n  created_at: string;\r\n}\r\n\r\nexport interface StockHistoryEntry {\r\n  id: string;\r\n  productId: string;\r\n  oldQuantity: number;\r\n  newQuantity: number;\r\n  changeReason: string;\r\n  referenceId?: string | null;\r\n  receiptNumber?: string;\r\n  createdAt: Date;\r\n  product?: {\r\n    name: string;\r\n    costPrice: number;\r\n    sellingPrice: number;\r\n    itemNumber: string;\r\n  };\r\n}\r\n\r\nexport interface DbStockHistoryEntry {\r\n  id: string;\r\n  user_id: string;\r\n  product_id: string;\r\n  previous_quantity: number;\r\n  new_quantity: number;\r\n  change_reason: string;\r\n  reference_id?: string | null;\r\n  created_at: string;\r\n}\r\n\r\nexport interface ProductFilters {\r\n  search: string;\r\n  category: string;\r\n  stockStatus: 'all' | 'inStock' | 'lowStock' | 'outOfStock';\r\n}\r\n\r\n// Customer management types\r\nexport interface Customer {\r\n  id: string;\r\n  fullName: string;\r\n  email: string | null;\r\n  phoneNumber: string | null;\r\n  birthday: Date | null;\r\n  location: string | null;\r\n  categoryId: string | null; // Added category relationship\r\n  socialMedia: {\r\n    facebook?: string;\r\n    instagram?: string;\r\n    twitter?: string;\r\n    linkedin?: string;\r\n    other?: string;\r\n  } | null;\r\n  gender: string | null;\r\n  tags: string[] | null;\r\n  notes: string | null;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface DbCustomer {\r\n  id: string;\r\n  user_id: string;\r\n  full_name: string;\r\n  email: string | null;\r\n  phone_number: string | null;\r\n  birthday: string | null;\r\n  location: string | null;\r\n  category_id: string | null; // Added category relationship\r\n  social_media: Json | null;\r\n  gender: string | null;\r\n  tags: string[] | null;\r\n  notes: string | null;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface CustomerFormData {\r\n  fullName: string;\r\n  email: string;\r\n  phoneNumber: string;\r\n  birthday: Date | null;\r\n  location: string;\r\n  categoryId: string | null; // Added category field\r\n  socialMedia: {\r\n    facebook?: string;\r\n    instagram?: string;\r\n    twitter?: string;\r\n    linkedin?: string;\r\n    other?: string;\r\n  };\r\n  gender: string;\r\n  tags: string[];\r\n  notes: string;\r\n}\r\n\r\n// Utility functions for database conversions\r\nexport const mapDbSaleToSale = (dbSale: DbSale): Sale => {\r\n  // Parse items and ensure numeric fields are numbers, not strings\r\n  // This is critical for discount calculations to work correctly\r\n  const items = (Array.isArray(dbSale.items) ? dbSale.items : []).map((item: any) => {\r\n    const discountPercentage = item.discountPercentage !== undefined ? Number(item.discountPercentage) : undefined;\r\n    const discountAmount = item.discountAmount !== undefined ? Number(item.discountAmount) : undefined;\r\n\r\n    // Infer discountType if missing (for legacy data)\r\n    let discountType = item.discountType as 'percentage' | 'amount' | undefined;\r\n    if (!discountType) {\r\n      if (discountPercentage && discountPercentage > 0) {\r\n        discountType = 'percentage';\r\n      } else if (discountAmount && discountAmount > 0) {\r\n        discountType = 'amount';\r\n      }\r\n    }\r\n\r\n    return {\r\n      description: item.description || '',\r\n      quantity: Number(item.quantity) || 0,\r\n      price: Number(item.price) || 0,\r\n      cost: Number(item.cost) || 0,\r\n      productId: item.productId || undefined,\r\n      discountType,\r\n      discountPercentage,\r\n      discountAmount,\r\n      createdAt: item.createdAt || undefined,\r\n    };\r\n  }) as SaleItem[];\r\n\r\n  return {\r\n    id: dbSale.id,\r\n    receiptNumber: dbSale.receipt_number,\r\n    customerName: dbSale.customer_name,\r\n    customerAddress: dbSale.customer_address || '',\r\n    customerContact: dbSale.customer_contact || '',\r\n    customerId: dbSale.customer_id || undefined,\r\n    items,\r\n    paymentStatus: dbSale.payment_status as 'Paid' | 'NOT PAID' | 'Quote' | 'Installment Sale',\r\n    profit: Number(dbSale.profit),\r\n    date: new Date(dbSale.date),\r\n    taxRate: dbSale.tax_rate ? Number(dbSale.tax_rate) : 0,\r\n    cashTransactionId: dbSale.cash_transaction_id || undefined,\r\n    amountPaid: dbSale.amount_paid ? Number(dbSale.amount_paid) : undefined,\r\n    amountDue: dbSale.amount_due ? Number(dbSale.amount_due) : undefined,\r\n    notes: dbSale.notes || '',\r\n    categoryId: dbSale.category_id || undefined,\r\n    createdAt: new Date(dbSale.created_at),\r\n  };\r\n};\r\n\r\nexport const mapSaleToDbSale = (\r\n  saleData: SaleFormData,\r\n  selectedDate: Date,\r\n  profit: number,\r\n  receiptNumber: string,\r\n  userId: string,\r\n  locationId: string,\r\n  cashTransactionId?: string | null\r\n): Omit<DbSale, 'id' | 'created_at' | 'updated_at'> => {\r\n  return {\r\n    user_id: userId,\r\n    location_id: locationId,\r\n    receipt_number: receiptNumber,\r\n    customer_name: saleData.customerName,\r\n    customer_address: saleData.customerAddress || null,\r\n    customer_contact: saleData.customerContact || null,\r\n    customer_id: saleData.customerId || null, // Include customer_id\r\n    items: (saleData.items as unknown) as Json,\r\n    payment_status: saleData.paymentStatus,\r\n    profit: profit,\r\n    date: selectedDate.toISOString().split('T')[0],\r\n    tax_rate: saleData.taxRate || 0,\r\n    cash_transaction_id: cashTransactionId || null,\r\n    amount_paid: saleData.amountPaid || null,\r\n    amount_due: saleData.amountDue || null,\r\n    notes: saleData.notes || null,\r\n    category_id: saleData.categoryId || null,\r\n  };\r\n};\r\n\r\n// Conversion functions for business settings\r\nexport const mapDbBusinessSettingsToBusinessSettings = (dbSettings: DbBusinessSettings): BusinessSettings => {\r\n  return {\r\n    businessName: dbSettings.business_name,\r\n    businessAddress: dbSettings.business_address,\r\n    businessPhone: dbSettings.business_phone,\r\n    businessEmail: dbSettings.business_email,\r\n    businessLogo: dbSettings.business_logo,\r\n    currency: dbSettings.currency,\r\n    signature: dbSettings.signature,\r\n    paymentInfo: dbSettings.metadata && typeof dbSettings.metadata === 'object' ?\r\n      (dbSettings.metadata as Record<string, unknown>).payment_info as string || '' : '',\r\n    defaultPrintFormat: dbSettings.metadata && typeof dbSettings.metadata === 'object' ?\r\n      (dbSettings.metadata as Record<string, unknown>).default_print_format as 'standard' | 'thermal' || 'standard' : 'standard',\r\n    defaultPrinterName: dbSettings.metadata && typeof dbSettings.metadata === 'object' ?\r\n      (dbSettings.metadata as Record<string, unknown>).default_printer_name as string || '' : '',\r\n    defaultPrinterType: dbSettings.metadata && typeof dbSettings.metadata === 'object' ?\r\n      (dbSettings.metadata as Record<string, unknown>).default_printer_type as 'USB' | 'Bluetooth' || 'USB' : 'USB'\r\n  };\r\n};\r\n\r\nexport const mapBusinessSettingsToDbBusinessSettings = (\r\n  settings: BusinessSettings,\r\n  userId: string\r\n): DbBusinessSettings => {\r\n  // Create metadata object with payment_info\r\n  const metadata: Json = {\r\n    payment_info: settings.paymentInfo || '',\r\n    default_print_format: settings.defaultPrintFormat || 'standard',\r\n    default_printer_name: settings.defaultPrinterName || '',\r\n    default_printer_type: settings.defaultPrinterType || 'USB'\r\n  };\r\n\r\n  return {\r\n    user_id: userId,\r\n    business_name: settings.businessName,\r\n    business_address: settings.businessAddress,\r\n    business_phone: settings.businessPhone,\r\n    business_email: settings.businessEmail,\r\n    business_logo: settings.businessLogo,\r\n    currency: settings.currency,\r\n    signature: settings.signature,\r\n    metadata: metadata, // Include metadata in the return object\r\n    updated_at: new Date().toISOString()\r\n  };\r\n};\r\n\r\n// Conversion functions for products and categories - ADDED itemNumber\r\nexport const mapDbProductToProduct = (dbProduct: DbProduct): Product => {\r\n  return {\r\n    id: dbProduct.id,\r\n    itemNumber: dbProduct.item_number, // Added item number mapping\r\n    barcode: dbProduct.barcode, // Added barcode mapping\r\n    manufacturerBarcode: dbProduct.manufacturer_barcode, // Added manufacturer barcode mapping\r\n    name: dbProduct.name,\r\n    description: dbProduct.description,\r\n    category: dbProduct.category,\r\n    quantity: dbProduct.quantity,\r\n    costPrice: Number(dbProduct.cost_price),\r\n    sellingPrice: Number(dbProduct.selling_price),\r\n    supplier: dbProduct.supplier,\r\n    imageUrl: dbProduct.image_url,\r\n    minimumStock: dbProduct.minimum_stock,\r\n    createdAt: new Date(dbProduct.created_at),\r\n    updatedAt: new Date(dbProduct.updated_at)\r\n  };\r\n};\r\n\r\nexport const mapProductToDbProduct = (product: Partial<Product>, userId: string): Partial<DbProduct> => {\r\n  const result: Partial<DbProduct> = {\r\n    user_id: userId\r\n  };\r\n\r\n  if (product.id) result.id = product.id;\r\n  if (product.itemNumber) result.item_number = product.itemNumber; // Added item number mapping\r\n  if (product.barcode !== undefined) result.barcode = product.barcode; // Added barcode mapping\r\n  if (product.manufacturerBarcode !== undefined) result.manufacturer_barcode = product.manufacturerBarcode; // Added manufacturer barcode mapping\r\n  if (product.name) result.name = product.name;\r\n  result.description = product.description;\r\n  if (product.category) result.category = product.category;\r\n  if (product.quantity !== undefined) result.quantity = product.quantity;\r\n  if (product.costPrice !== undefined) {\r\n    result.cost_price = product.costPrice;\r\n    console.log(`DEBUG: Mapping costPrice ${product.costPrice} to cost_price`);\r\n  }\r\n  if (product.sellingPrice !== undefined) {\r\n    result.selling_price = product.sellingPrice;\r\n    console.log(`DEBUG: Mapping sellingPrice ${product.sellingPrice} to selling_price`);\r\n  }\r\n  result.supplier = product.supplier;\r\n  result.image_url = product.imageUrl;\r\n  if (product.minimumStock !== undefined) result.minimum_stock = product.minimumStock;\r\n\r\n  return result;\r\n};\r\n\r\nexport const mapDbProductCategoryToProductCategory = (dbCategory: DbProductCategory): ProductCategory => {\r\n  return {\r\n    id: dbCategory.id,\r\n    name: dbCategory.name\r\n  };\r\n};\r\n\r\nexport const mapDbStockHistoryToStockHistory = (dbHistory: DbStockHistoryEntry): StockHistoryEntry => {\r\n  return {\r\n    id: dbHistory.id,\r\n    productId: dbHistory.product_id,\r\n    oldQuantity: dbHistory.previous_quantity,\r\n    newQuantity: dbHistory.new_quantity,\r\n    changeReason: dbHistory.change_reason,\r\n    referenceId: dbHistory.reference_id || null,\r\n    createdAt: new Date(dbHistory.created_at)\r\n  };\r\n};\r\n\r\n// Updated Customer mapping functions to include categoryId\r\nexport const mapDbCustomerToCustomer = (dbCustomer: DbCustomer): Customer => {\r\n  let birthday = null;\r\n\r\n  if (dbCustomer.birthday) {\r\n    try {\r\n      const birthdayStr = String(dbCustomer.birthday);\r\n      const [year, month, day] = birthdayStr.split('-').map(Number);\r\n\r\n      if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {\r\n        birthday = new Date(Date.UTC(year, month - 1, day, 12, 0, 0));\r\n\r\n        console.log(\r\n          'Converting DB birthday to Date object:',\r\n          dbCustomer.birthday,\r\n          '',\r\n          birthday,\r\n          '(UTC string:',\r\n          birthday.toISOString(),\r\n          ')'\r\n        );\r\n      } else {\r\n        console.error('Invalid date components in birthday:', dbCustomer.birthday);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error parsing birthday:', error, dbCustomer.birthday);\r\n    }\r\n  }\r\n\r\n  return {\r\n    id: dbCustomer.id,\r\n    fullName: dbCustomer.full_name,\r\n    email: dbCustomer.email,\r\n    phoneNumber: dbCustomer.phone_number,\r\n    birthday: birthday,\r\n    location: dbCustomer.location,\r\n    categoryId: dbCustomer.category_id, // Added category mapping\r\n    socialMedia: dbCustomer.social_media as any,\r\n    gender: dbCustomer.gender,\r\n    tags: dbCustomer.tags,\r\n    notes: dbCustomer.notes,\r\n    createdAt: new Date(dbCustomer.created_at),\r\n    updatedAt: new Date(dbCustomer.updated_at)\r\n  };\r\n};\r\n\r\nexport const mapCustomerToDbCustomer = (customer: Partial<Customer>, userId: string): Partial<DbCustomer> => {\r\n  const result: Partial<DbCustomer> = {\r\n    user_id: userId\r\n  };\r\n\r\n  if (customer.id) result.id = customer.id;\r\n  if (customer.fullName) result.full_name = customer.fullName;\r\n  result.email = customer.email;\r\n  result.phone_number = customer.phoneNumber;\r\n  if (customer.birthday) result.birthday = customer.birthday.toISOString().split('T')[0];\r\n  result.location = customer.location;\r\n  result.category_id = customer.categoryId; // Added category mapping\r\n  result.social_media = customer.socialMedia as Json;\r\n  result.gender = customer.gender;\r\n  result.tags = customer.tags;\r\n  result.notes = customer.notes;\r\n\r\n  return result;\r\n};\r\n\r\n// Conversion functions for expenses\r\nexport const mapDbExpenseToExpense = (dbExpense: DbExpense): Expense => {\r\n  return {\r\n    id: dbExpense.id,\r\n    amount: Number(dbExpense.amount),\r\n    description: dbExpense.description,\r\n    category: dbExpense.category,\r\n    date: new Date(dbExpense.date),\r\n    paymentMethod: dbExpense.payment_method,\r\n    personInCharge: dbExpense.person_in_charge,\r\n    receiptImage: dbExpense.receipt_image,\r\n    cashAccountId: dbExpense.cash_account_id,\r\n    cashTransactionId: dbExpense.cash_transaction_id,\r\n    createdAt: new Date(dbExpense.created_at),\r\n    updatedAt: new Date(dbExpense.updated_at)\r\n  };\r\n};\r\n\r\nexport const mapExpenseToDbExpense = (expense: Partial<Expense>, userId: string): Partial<DbExpense> => {\r\n  const result: Partial<DbExpense> = {\r\n    user_id: userId\r\n  };\r\n\r\n  if (expense.id) result.id = expense.id;\r\n  if (expense.amount !== undefined) result.amount = expense.amount;\r\n  if (expense.description) result.description = expense.description;\r\n  result.category = expense.category;\r\n  if (expense.date) result.date = expense.date.toISOString().split('T')[0];\r\n  result.payment_method = expense.paymentMethod;\r\n  result.person_in_charge = expense.personInCharge;\r\n  result.receipt_image = expense.receiptImage;\r\n  result.cash_account_id = expense.cashAccountId;\r\n  result.cash_transaction_id = expense.cashTransactionId;\r\n\r\n  return result;\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3619, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 3636, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAgCsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gEAAA"}},
    {"offset": {"line": 3653, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useBusinessSettings.ts"],"sourcesContent":["\r\nimport { useState, useEffect } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { getBusinessSettingsAction, upsertBusinessSettingsAction } from '@/app/actions/business-settings';\r\n\r\nexport interface BusinessSettings {\r\n  id?: string;\r\n  businessName: string;\r\n  businessAddress: string;\r\n  businessPhone: string;\r\n  businessEmail: string;\r\n  businessLogo?: string;\r\n  currency: string;\r\n  signature?: string;\r\n  paymentInfo?: string;\r\n  defaultPrintFormat?: 'standard' | 'thermal';\r\n  defaultPrinterName?: string;\r\n  defaultPrinterType?: 'USB' | 'Bluetooth';\r\n  printerPaperSize?: '58mm' | '80mm';\r\n}\r\n\r\n// Utility function to parse payment info text into structured format\r\nexport const parsePaymentInfo = (paymentInfo: string): { method: string, accountNumber: string, accountName: string }[] => {\r\n  if (!paymentInfo || paymentInfo.trim() === '') {\r\n    return [];\r\n  }\r\n\r\n  const lines = paymentInfo.split('\\n').filter(line => line.trim() !== '');\r\n  const methods: { method: string, accountNumber: string, accountName: string }[] = [];\r\n\r\n  for (let i = 0; i < lines.length; i += 3) {\r\n    if (i + 2 < lines.length) {\r\n      methods.push({\r\n        method: lines[i].trim(),\r\n        accountNumber: lines[i + 1].trim(),\r\n        accountName: lines[i + 2].trim()\r\n      });\r\n    }\r\n  }\r\n\r\n  return methods;\r\n};\r\n\r\n// Utility function to convert payment methods array back to string format\r\nexport const convertPaymentMethodsToString = (paymentMethods: { method: string, accountNumber: string, accountName: string }[]): string => {\r\n  return paymentMethods\r\n    .filter(pm => pm.method.trim() !== '' || pm.accountNumber.trim() !== '' || pm.accountName.trim() !== '')\r\n    .map(pm => `${pm.method}\\n${pm.accountNumber}\\n${pm.accountName}`)\r\n    .join('\\n');\r\n};\r\n\r\n// Default settings for new businesses\r\nconst getDefaultSettings = (): BusinessSettings => ({\r\n  businessName: '',\r\n  businessAddress: '',\r\n  businessPhone: '',\r\n  businessEmail: '',\r\n  currency: 'UGX',\r\n  paymentInfo: '',\r\n  defaultPrintFormat: 'standard'\r\n});\r\n\r\nexport const useBusinessSettings = () => {\r\n  const [settings, setSettings] = useState<BusinessSettings>(getDefaultSettings());\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const loadSettings = async (): Promise<BusinessSettings> => {\r\n    if (!currentBusiness) {\r\n      return getDefaultSettings();\r\n    }\r\n\r\n    try {\r\n      const data = await getBusinessSettingsAction(currentBusiness.id);\r\n\r\n      if (data) {\r\n        // Extract payment info from metadata\r\n        const paymentInfo = data.metadata && typeof data.metadata === 'object' ?\r\n          (data.metadata as Record<string, unknown>).payment_info as string || '' : '';\r\n\r\n        return {\r\n          id: data.id,\r\n          businessName: data.business_name || '',\r\n          businessAddress: data.business_address || '',\r\n          businessPhone: data.business_phone || '',\r\n          businessEmail: data.business_email || '',\r\n          businessLogo: data.business_logo || undefined,\r\n          currency: data.currency || 'UGX',\r\n          signature: data.signature || undefined,\r\n          paymentInfo: paymentInfo,\r\n          defaultPrintFormat: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_print_format as 'standard' | 'thermal' || 'standard' : 'standard',\r\n          defaultPrinterName: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_name as string || '' : '',\r\n          defaultPrinterType: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_type as 'USB' | 'Bluetooth' || 'USB' : 'USB',\r\n          printerPaperSize: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).printer_paper_size as '58mm' | '80mm' || '58mm' : '58mm'\r\n        };\r\n      } else {\r\n        return getDefaultSettings();\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return getDefaultSettings();\r\n    }\r\n  };\r\n\r\n  const updateSettings = async (newSettings: Partial<BusinessSettings>) => {\r\n    if (!currentBusiness) {\r\n      console.error('No business selected for updating settings');\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"No business selected\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const userData = { user: { id: '00000000-0000-0000-0000-000000000000' } }; // Mocked user id for now\r\n\r\n      // Prepare the metadata object with payment info\r\n      const metadata = {\r\n        payment_info: newSettings.hasOwnProperty('paymentInfo') ? newSettings.paymentInfo : settings.paymentInfo || '',\r\n        default_print_format: newSettings.hasOwnProperty('defaultPrintFormat') ? newSettings.defaultPrintFormat : settings.defaultPrintFormat || 'standard',\r\n        default_printer_name: newSettings.hasOwnProperty('defaultPrinterName') ? newSettings.defaultPrinterName : settings.defaultPrinterName || '',\r\n        default_printer_type: newSettings.hasOwnProperty('defaultPrinterType') ? newSettings.defaultPrinterType : settings.defaultPrinterType || 'USB',\r\n        printer_paper_size: newSettings.hasOwnProperty('printerPaperSize') ? newSettings.printerPaperSize : settings.printerPaperSize || '58mm'\r\n      };\r\n\r\n      const updateData = {\r\n        business_name: newSettings.hasOwnProperty('businessName') ? newSettings.businessName : settings.businessName,\r\n        business_address: newSettings.hasOwnProperty('businessAddress') ? newSettings.businessAddress : settings.businessAddress,\r\n        business_phone: newSettings.hasOwnProperty('businessPhone') ? newSettings.businessPhone : settings.businessPhone,\r\n        business_email: newSettings.hasOwnProperty('businessEmail') ? newSettings.businessEmail : settings.businessEmail,\r\n        business_logo: newSettings.hasOwnProperty('businessLogo') ? newSettings.businessLogo : settings.businessLogo,\r\n        currency: newSettings.hasOwnProperty('currency') ? newSettings.currency : settings.currency,\r\n        signature: newSettings.hasOwnProperty('signature') ? newSettings.signature : settings.signature,\r\n        metadata: metadata\r\n      };\r\n\r\n      const response = await upsertBusinessSettingsAction(currentBusiness.id, userData.user.id, updateData);\r\n\r\n      if (!response.success) {\r\n        console.error('Supabase error updating business settings:', response.error);\r\n        throw new Error(response.error);\r\n      }\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Business settings updated successfully\"\r\n      });\r\n\r\n      // Refetch settings after update\r\n      refetch();\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // React Query for settings loading with proper caching\r\n  const { data: queriedData, isLoading: isQueryLoading, isFetching, refetch } = useQuery({\r\n    queryKey: ['businessSettings', currentBusiness?.id],\r\n    queryFn: loadSettings,\r\n    enabled: !!currentBusiness?.id,\r\n    staleTime: 5 * 60_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: false,\r\n    refetchOnReconnect: false,\r\n  });\r\n\r\n  // Sync React Query data with local state\r\n  useEffect(() => {\r\n    if (queriedData) {\r\n      setSettings(queriedData);\r\n    } else if (!currentBusiness) {\r\n      setSettings(getDefaultSettings());\r\n    }\r\n  }, [queriedData, currentBusiness]);\r\n\r\n  // Sync loading state from React Query\r\n  useEffect(() => {\r\n    setIsLoading(isQueryLoading || isFetching);\r\n  }, [isQueryLoading, isFetching]);\r\n\r\n  return {\r\n    settings,\r\n    isLoading,\r\n    updateSettings,\r\n    loadSettings\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3858, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/utils/inventoryCacheUtils.ts"],"sourcesContent":["import { QueryClient } from \"@tanstack/react-query\";\r\n\r\n/**\r\n * Utility to clear inventory-related caches (both localStorage and React Query)\r\n * to ensure real-time data accuracy.\r\n */\r\nexport const clearInventoryCaches = (queryClient?: QueryClient) => {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    // 1. Clear LocalStorage (Legacy / Manual caches)\r\n    const keys = Object.keys(localStorage);\r\n    const patterns = [\r\n        'allProductsStats_',\r\n        'stockSummary_',\r\n        'soldItems_',\r\n        'dashboardData_',\r\n        'analyticsData_'\r\n    ];\r\n\r\n    let clearedCount = 0;\r\n    keys.forEach(key => {\r\n        if (patterns.some(pattern => key.startsWith(pattern))) {\r\n            localStorage.removeItem(key);\r\n            clearedCount++;\r\n        }\r\n    });\r\n\r\n    if (clearedCount > 0) {\r\n        console.log(`[Cache] Cleared ${clearedCount} inventory-related localStorage entries.`);\r\n    }\r\n\r\n    // 2. Invalidate React Query Keys (Modern State)\r\n    if (queryClient) {\r\n        console.log('[Cache] Invalidating React Query inventory keys...');\r\n        // Invalidate specific keys used in the inventory module\r\n        queryClient.invalidateQueries({ queryKey: ['inventory_global_stats'] });\r\n        queryClient.invalidateQueries({ queryKey: ['stockSummary'] });\r\n        queryClient.invalidateQueries({ queryKey: ['products'] });\r\n        queryClient.invalidateQueries({ queryKey: ['sales'] });\r\n        queryClient.invalidateQueries({ queryKey: ['all-products-for-scanner'] });\r\n        queryClient.invalidateQueries({ queryKey: ['all-products'] });\r\n    }\r\n};\r\n"],"names":[],"mappings":";;;;AAMO,MAAM,uBAAuB,CAAC;IACjC;;IAEA,iDAAiD;IACjD,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,MAAM,WAAW;QACb;QACA;QACA;QACA;QACA;KACH;IAED,IAAI,eAAe;IACnB,KAAK,OAAO,CAAC,CAAA;QACT,IAAI,SAAS,IAAI,CAAC,CAAA,UAAW,IAAI,UAAU,CAAC,WAAW;YACnD,aAAa,UAAU,CAAC;YACxB;QACJ;IACJ;IAEA,IAAI,eAAe,GAAG;QAClB,QAAQ,GAAG,CAAC,CAAC,gBAAgB,EAAE,aAAa,wCAAwC,CAAC;IACzF;IAEA,gDAAgD;IAChD,IAAI,aAAa;QACb,QAAQ,GAAG,CAAC;QACZ,wDAAwD;QACxD,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAyB;QAAC;QACrE,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAe;QAAC;QAC3D,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAW;QAAC;QACvD,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAQ;QAAC;QACpD,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAA2B;QAAC;QACvE,YAAY,iBAAiB,CAAC;YAAE,UAAU;gBAAC;aAAe;QAAC;IAC/D;AACJ"}},
    {"offset": {"line": 3927, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qDAAA"}},
    {"offset": {"line": 3944, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqLsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 3961, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 3978, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqUsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 3995, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAkVsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 4012, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useProducts.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useMemo } from 'react';\r\nimport { Product, ProductFormData, ProductFilters } from '@/types';\r\nimport { useBusinessSettings } from './useBusinessSettings';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { clearInventoryCaches } from '@/utils/inventoryCacheUtils';\r\n\r\n// Import our new Server Actions\r\nimport {\r\n  getProductsAction,\r\n  createProductAction,\r\n  updateProductAction,\r\n  deleteProductAction,\r\n  updateProductsBulkAction\r\n} from '@/app/actions/products';\r\n\r\nexport const useProducts = (userId: string | undefined, initialPageSize: number = 50) => {\r\n  const [products, setProducts] = useState<Product[]>([]);\r\n  const [page, setPage] = useState(1);\r\n  const [pageSize, setPageSize] = useState(initialPageSize);\r\n  const [totalCount, setTotalCount] = useState(0);\r\n  const [isTyping, setIsTyping] = useState(false);\r\n  const { settings } = useBusinessSettings();\r\n  const { currentBusiness } = useBusiness();\r\n  const queryClient = useQueryClient();\r\n\r\n  const [filters, setFilters] = useState<ProductFilters>({\r\n    search: '',\r\n    category: 'all',\r\n    stockStatus: 'all'\r\n  });\r\n\r\n  const [typingTimer, setTypingTimer] = useState<NodeJS.Timeout | null>(null);\r\n\r\n  const setFiltersWithTypingState = useCallback((newFilters: ProductFilters) => {\r\n    if (newFilters.search !== filters.search) {\r\n      setIsTyping(true);\r\n      if (typingTimer) clearTimeout(typingTimer);\r\n      const timer = setTimeout(() => {\r\n        setIsTyping(false);\r\n      }, 600);\r\n      setTypingTimer(timer);\r\n    }\r\n    setFilters(newFilters);\r\n  }, [filters.search, typingTimer]);\r\n\r\n  // Use Server Action instead of Supabase\r\n  const loadProducts = useCallback(async (): Promise<{ products: Product[], count: number }> => {\r\n    if (!userId || !currentBusiness) {\r\n      return { products: [], count: 0 };\r\n    }\r\n\r\n    try {\r\n      // Server Action call\r\n      const result = await getProductsAction({\r\n        userId,\r\n        businessId: currentBusiness.id,\r\n        page,\r\n        pageSize,\r\n        search: filters.search,\r\n        category: filters.category === 'all' ? undefined : filters.category,\r\n        stockStatus: filters.stockStatus,\r\n      });\r\n      return result as { products: Product[], count: number };\r\n    } catch (error) {\r\n      console.error('Error loading products from server action:', error);\r\n      return { products: [], count: 0 };\r\n    }\r\n  }, [userId, currentBusiness?.id, page, pageSize, filters.search, filters.category, filters.stockStatus]);\r\n\r\n  const baseQueryKey = useMemo(() => ['products', userId, currentBusiness?.id], [userId, currentBusiness?.id]);\r\n  const queryKey = useMemo(() => [...baseQueryKey, page, pageSize, filters.search, filters.category, filters.stockStatus], [baseQueryKey, page, pageSize, filters.search, filters.category, filters.stockStatus]);\r\n\r\n  const { data: queriedData, isLoading: isQueryLoading, isFetching, refetch } = useQuery({\r\n    queryKey,\r\n    queryFn: loadProducts,\r\n    enabled: !!userId && !!currentBusiness?.id,\r\n    staleTime: 30_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: true,\r\n    refetchOnReconnect: true,\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (queriedData) {\r\n      setProducts(queriedData.products);\r\n      setTotalCount(queriedData.count);\r\n    }\r\n  }, [queriedData]);\r\n\r\n  const isLoading = (isQueryLoading && !queriedData) && !isTyping;\r\n\r\n  // Supabase Storage remains untouched since Prisma doesn't do file storage\r\n  // but we isolate it here.\r\n  const uploadProductImage = async (imageFile: File): Promise<string | null> => {\r\n    try {\r\n      if (!userId) return null;\r\n\r\n      // We will implement a server action for this. \r\n      // For now, let's assume we have an uploadImageAction.\r\n      // const formData = new FormData();\r\n      // formData.append('file', imageFile);\r\n      // formData.append('userId', userId);\r\n      // const result = await uploadImageAction(formData);\r\n      // return result.url;\r\n\r\n      console.warn('Image upload redirecting to server action (TODO)');\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error in uploadProductImage:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const createProduct = async (productData: ProductFormData): Promise<Product | null> => {\r\n    try {\r\n      if (!userId || !currentBusiness) return null;\r\n\r\n      const result = await createProductAction({\r\n        ...productData,\r\n        userId,\r\n        businessId: currentBusiness.id\r\n      });\r\n\r\n      if (!result) return null;\r\n\r\n      const newProduct = result as Product;\r\n\r\n      setProducts(prev => [newProduct, ...prev]);\r\n      setTotalCount(c => c + 1);\r\n\r\n      queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n      clearInventoryCaches(queryClient);\r\n\r\n      return newProduct;\r\n    } catch (error) {\r\n      console.error('Error creating product:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updateProduct = async (\r\n    id: string,\r\n    updates: Partial<Product>,\r\n    imageFile?: File | null,\r\n    isFromSale = false,\r\n    customChangeReason?: string,\r\n    adjustmentDate?: Date,\r\n    referenceId?: string,\r\n    receiptNumber?: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      let imageUrl = updates.imageUrl;\r\n      if (imageFile) {\r\n        imageUrl = await uploadProductImage(imageFile);\r\n      }\r\n\r\n      const result = await updateProductAction(id, {\r\n        ...updates,\r\n        imageUrl,\r\n        userId,\r\n        businessId: currentBusiness.id,\r\n        isFromSale,\r\n        customChangeReason,\r\n        referenceId\r\n      });\r\n\r\n      if (!result) return false;\r\n\r\n      queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n      clearInventoryCaches(queryClient);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating product:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteProduct = async (id: string): Promise<boolean> => {\r\n    try {\r\n      if (!userId) return false;\r\n\r\n      const success = await deleteProductAction(id);\r\n\r\n      if (success) {\r\n        queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n        clearInventoryCaches(queryClient);\r\n        return true;\r\n      }\r\n      return false;\r\n    } catch (error) {\r\n      console.error('Error deleting product:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const updateProductsBulk = async (\r\n    updates: Array<{ id: string; updated: Partial<Product>; imageFile?: File | null }>,\r\n    userIdForHistory?: string,\r\n    changeReason?: string,\r\n    referenceId?: string,\r\n    adjustmentDate?: Date,\r\n    receiptNumber?: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      if (!userId || !currentBusiness) return false;\r\n\r\n      const success = await updateProductsBulkAction(\r\n        updates.map(u => ({ id: u.id, updated: u.updated })),\r\n        currentBusiness.id\r\n      );\r\n\r\n      if (success) {\r\n        queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n        clearInventoryCaches(queryClient);\r\n      }\r\n\r\n      return success;\r\n    } catch (error) {\r\n      console.error('Error in bulk update:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  return {\r\n    products,\r\n    isLoading,\r\n    loadProducts,\r\n    page,\r\n    setPage,\r\n    pageSize,\r\n    setPageSize,\r\n    totalCount,\r\n    createProduct,\r\n    updateProduct,\r\n    updateProductsBulk,\r\n    deleteProduct,\r\n    uploadProductImage,\r\n    refetch,\r\n    isFetching,\r\n    filters,\r\n    setFilters: setFiltersWithTypingState,\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4296, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA+IsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,0DAAA"}},
    {"offset": {"line": 4313, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useInventoryActions.ts"],"sourcesContent":["import { useProducts } from './useProducts';\r\nimport { SaleItem, Product } from '@/types';\r\nimport { toast } from 'sonner';\r\nimport { getProductsByIdsAction } from '@/app/actions/products';\r\n\r\nexport const useInventoryActions = (userId: string | undefined) => {\r\n    const { updateProductsBulk } = useProducts(userId);\r\n\r\n    /**\r\n     * Helper to fetch fresh product data from DB to avoid race conditions/stale data\r\n     */\r\n    const fetchFreshProducts = async (productIds: string[], locationId?: string) => {\r\n        if (!productIds.length) return [];\r\n\r\n        try {\r\n            const result = await getProductsByIdsAction(productIds, locationId);\r\n            return result as Product[];\r\n        } catch (error) {\r\n            console.error('Error fetching fresh products:', error);\r\n            throw error;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Deduct stock for a new sale\r\n     */\r\n    const deductStockForSale = async (\r\n        items: SaleItem[],\r\n        saleId?: string,\r\n        saleDate?: Date,\r\n        receiptNumber?: string,\r\n        locationId?: string\r\n    ): Promise<boolean> => {\r\n        if (!userId) return false;\r\n\r\n        try {\r\n            const itemsWithProductIds = items.filter(item => item.productId);\r\n            if (itemsWithProductIds.length === 0) return true;\r\n\r\n            const uniqueIds = [...new Set(itemsWithProductIds.map(item => item.productId!))];\r\n            const freshProducts = await fetchFreshProducts(uniqueIds, locationId);\r\n\r\n            if (freshProducts.length === 0) return false;\r\n\r\n            // Calculate total quantity to deduct per product\r\n            const quantityChanges = new Map<string, number>();\r\n            for (const item of itemsWithProductIds) {\r\n                const existing = quantityChanges.get(item.productId!) || 0;\r\n                quantityChanges.set(item.productId!, existing + item.quantity);\r\n            }\r\n\r\n            const bulkUpdates = [];\r\n            for (const [productId, quantityToDeduct] of quantityChanges.entries()) {\r\n                const product = freshProducts.find(p => p.id === productId);\r\n                if (!product) continue;\r\n\r\n                const newQuantity = product.quantity - quantityToDeduct;\r\n\r\n                bulkUpdates.push({\r\n                    id: productId,\r\n                    updated: { ...product, quantity: newQuantity }\r\n                });\r\n\r\n                if (newQuantity < 0) {\r\n                    toast.warning(`${product.name} inventory is now negative (${newQuantity}). Please restock soon.`);\r\n                }\r\n            }\r\n\r\n            if (bulkUpdates.length > 0) {\r\n                await updateProductsBulk(bulkUpdates, userId, 'Sale', saleId, saleDate, receiptNumber);\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error deducting stock for sale:', error);\r\n            return false;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Restore stock (e.g. when deleting a sale)\r\n     */\r\n    const restoreStockForSale = async (\r\n        items: SaleItem[],\r\n        saleId?: string, // Reference ID for history\r\n        receiptNumber?: string, // Reference receipt number\r\n        locationId?: string\r\n    ): Promise<boolean> => {\r\n        if (!userId) return false;\r\n\r\n        try {\r\n            const itemsWithProductIds = items.filter(item => item.productId);\r\n            if (itemsWithProductIds.length === 0) return true;\r\n\r\n            const uniqueIds = [...new Set(itemsWithProductIds.map(item => item.productId!))];\r\n            const freshProducts = await fetchFreshProducts(uniqueIds, locationId);\r\n\r\n            // Calculate total quantity to restore\r\n            const quantityChanges = new Map<string, number>();\r\n            for (const item of itemsWithProductIds) {\r\n                const existing = quantityChanges.get(item.productId!) || 0;\r\n                quantityChanges.set(item.productId!, existing + item.quantity);\r\n            }\r\n\r\n            const bulkUpdates = [];\r\n            for (const [productId, quantityToRestore] of quantityChanges.entries()) {\r\n                const product = freshProducts.find(p => p.id === productId);\r\n                if (!product) continue;\r\n\r\n                const newQuantity = product.quantity + quantityToRestore;\r\n\r\n                bulkUpdates.push({\r\n                    id: productId,\r\n                    updated: { ...product, quantity: newQuantity }\r\n                });\r\n            }\r\n\r\n            if (bulkUpdates.length > 0) {\r\n                await updateProductsBulk(bulkUpdates, userId, 'Deleted Sale', saleId, undefined, receiptNumber);\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error restoring stock for sale:', error);\r\n            return false;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Adjust stock for an edited sale (Handle both adding and removing items)\r\n     */\r\n    const adjustStockForEditedSale = async (\r\n        originalItems: SaleItem[],\r\n        newItems: SaleItem[],\r\n        saleId?: string,\r\n        saleDate?: Date,\r\n        receiptNumber?: string,\r\n        locationId?: string\r\n    ): Promise<boolean> => {\r\n        if (!userId) return false;\r\n\r\n        try {\r\n            const allProductIds = [\r\n                ...originalItems.filter(i => i.productId).map(i => i.productId!),\r\n                ...newItems.filter(i => i.productId).map(i => i.productId!)\r\n            ];\r\n            const uniqueIds = [...new Set(allProductIds)];\r\n            if (uniqueIds.length === 0) return true;\r\n\r\n            const freshProducts = await fetchFreshProducts(uniqueIds, locationId);\r\n\r\n            const productNetChanges = new Map<string, number>();\r\n\r\n            // 1. Restore original items (add back to stock)\r\n            for (const item of originalItems.filter(i => i.productId)) {\r\n                const current = productNetChanges.get(item.productId!) || 0;\r\n                productNetChanges.set(item.productId!, current + item.quantity);\r\n            }\r\n\r\n            // 2. Deduct new items (remove from stock)\r\n            for (const item of newItems.filter(i => i.productId)) {\r\n                const current = productNetChanges.get(item.productId!) || 0;\r\n                productNetChanges.set(item.productId!, current - item.quantity);\r\n            }\r\n\r\n            const bulkUpdates = [];\r\n            for (const [productId, netChange] of productNetChanges.entries()) {\r\n                if (netChange === 0) continue;\r\n\r\n                const product = freshProducts.find(p => p.id === productId);\r\n                if (!product) continue;\r\n\r\n                const newQuantity = product.quantity + netChange;\r\n\r\n                bulkUpdates.push({\r\n                    id: productId,\r\n                    updated: { ...product, quantity: newQuantity }\r\n                });\r\n\r\n                if (newQuantity < 0) {\r\n                    toast.warning(`${product.name} inventory is now negative (${newQuantity}). Please restock soon.`);\r\n                }\r\n            }\r\n\r\n            if (bulkUpdates.length > 0) {\r\n                await updateProductsBulk(bulkUpdates, userId, 'Sale Status/Qty Edit', saleId, saleDate, receiptNumber);\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error adjusting stock for edited sale:', error);\r\n            return false;\r\n        }\r\n    };\r\n\r\n    return {\r\n        deductStockForSale,\r\n        restoreStockForSale,\r\n        adjustStockForEditedSale\r\n    };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4490, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/sales.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getSalesAction(businessId: string, sortOrder: 'asc' | 'desc' = 'desc', pageSize?: number) {\r\n    try {\r\n        const queryOptions: any = {\r\n            where: {\r\n                branchId: businessId,\r\n            },\r\n            orderBy: {\r\n                createdAt: sortOrder,\r\n            },\r\n            include: {\r\n                cashTransaction: true,\r\n            }\r\n        };\r\n\r\n        if (pageSize && pageSize > 0) {\r\n            queryOptions.take = pageSize;\r\n        }\r\n\r\n        const sales = await db.sale.findMany(queryOptions);\r\n\r\n        // Provide default mappings to existing React components\r\n        return sales.map((item: any) => ({\r\n            id: item.id,\r\n            user_id: item.userId,\r\n            location_id: item.branchId,\r\n            receipt_number: item.saleNumber,\r\n            customer_name: item.customerName,\r\n            customer_address: item.customerAddress,\r\n            customer_contact: item.customerPhone,\r\n            customer_id: item.customerId,\r\n            items: item.items as any, // jsonb type\r\n            payment_status: item.paymentStatus,\r\n            profit: 0, // Profit not stored directly\r\n            date: item.date.toISOString(),\r\n            tax_rate: item.taxRate ? Number(item.taxRate) : 0,\r\n            created_at: item.createdAt.toISOString(),\r\n            updated_at: item.updatedAt.toISOString(),\r\n            cash_transaction_id: item.cashTransactionId,\r\n            amount_paid: Number(item.amountPaid),\r\n            amount_due: Number(item.balance),\r\n            category_id: item.categoryId,\r\n            notes: item.notes\r\n        }));\r\n    } catch (error) {\r\n        console.error('Error fetching sales:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function deleteSaleAction(id: string, businessId: string) {\r\n    try {\r\n        const sale = await db.sale.findUnique({\r\n            where: { id },\r\n            include: { cashTransaction: true, installmentPayments: true }\r\n        });\r\n\r\n        if (!sale || sale.branchId !== businessId) {\r\n            return { success: false, error: 'Sale not found or unauthorized' };\r\n        }\r\n\r\n        await db.$transaction(async (tx) => {\r\n            // Delete installments\r\n            await tx.installmentPayment.deleteMany({\r\n                where: { saleId: id }\r\n            });\r\n\r\n            // Delete associated cash transaction\r\n            if (sale.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: sale.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            // Delete the sale itself\r\n            await tx.sale.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            sale: {\r\n                receiptNumber: sale.saleNumber,\r\n                customerName: sale.customerName,\r\n                customerAddress: sale.customerAddress,\r\n                customerContact: sale.customerPhone,\r\n                paymentStatus: sale.paymentStatus,\r\n                cashTransactionId: sale.cashTransactionId,\r\n                items: sale.items as any,\r\n                amountPaid: Number(sale.amountPaid),\r\n                amountDue: Number(sale.balance),\r\n                profit: 0,\r\n                taxRate: Number(sale.taxRate),\r\n                notes: sale.notes\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error deleting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to delete sale' };\r\n    }\r\n}\r\n\r\nexport async function upsertSaleAction(saleDbData: any, isUpdate: boolean, updateId?: string) {\r\n    try {\r\n        // Map PaymentStatus if needed\r\n        let status = saleDbData.payment_status;\r\n        if (status === 'NOT PAID') status = 'UNPAID';\r\n        else if (status === 'Installment Sale') status = 'INSTALLMENT';\r\n        else if (status === 'Paid') status = 'PAID';\r\n        else if (status === 'Quote') status = 'QUOTE';\r\n\r\n        const prismaData: any = {\r\n            userId: saleDbData.user_id,\r\n            branchId: saleDbData.location_id,\r\n            saleNumber: saleDbData.receipt_number,\r\n            customerName: saleDbData.customer_name,\r\n            customerAddress: saleDbData.customer_address,\r\n            customerPhone: saleDbData.customer_contact,\r\n            customerId: saleDbData.customer_id,\r\n            items: saleDbData.items,\r\n            paymentStatus: status,\r\n            date: new Date(saleDbData.date),\r\n            taxRate: saleDbData.tax_rate,\r\n            cashTransactionId: saleDbData.cash_transaction_id,\r\n            amountPaid: saleDbData.amount_paid,\r\n            balance: saleDbData.amount_due,\r\n            categoryId: saleDbData.category_id,\r\n            notes: saleDbData.notes,\r\n            subtotal: 0, // Placeholder\r\n            total: 0,     // Placeholder\r\n        };\r\n\r\n        if (isUpdate && updateId) {\r\n            const updated = await db.sale.update({\r\n                where: { id: updateId },\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: updated };\r\n        } else {\r\n            const created = await db.sale.create({\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: created };\r\n        }\r\n    } catch (error: any) {\r\n        console.error('Error upserting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to preserve sale' };\r\n    }\r\n}\r\n\r\nexport async function createReceiptAction(saleData: any, businessId: string, userId: string) {\r\n    try {\r\n        let status = saleData.paymentStatus;\r\n        if (status === 'NOT PAID') status = 'UNPAID';\r\n        else if (status === 'Installment Sale') status = 'INSTALLMENT';\r\n        else if (status === 'Paid') status = 'PAID';\r\n        else if (status === 'Quote') status = 'QUOTE';\r\n\r\n        const created = await db.sale.create({\r\n            data: {\r\n                userId: userId,\r\n                branchId: businessId,\r\n                saleNumber: saleData.receiptNumber,\r\n                customerName: saleData.customerName,\r\n                customerId: saleData.customerId,\r\n                date: new Date(saleData.date),\r\n                items: saleData.items,\r\n                paymentStatus: status,\r\n                amountPaid: saleData.amountPaid || 0,\r\n                balance: saleData.amountDue || 0,\r\n                cashAccountId: saleData.cashAccountId,\r\n                notes: saleData.notes,\r\n                subtotal: 0,\r\n                total: 0,\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        revalidatePath('/customers');\r\n\r\n        return { success: true, data: created };\r\n    } catch (error: any) {\r\n        console.error('Error creating receipt:', error);\r\n        return { success: false, error: error.message || 'Failed to create receipt' };\r\n    }\r\n}\r\n\r\n// --- SALES CATEGORIES ---\r\n\r\nexport async function getSalesCategoriesAction(businessId: string) {\r\n    try {\r\n        const categories = await db.saleCategory.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return { success: true, data: categories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching sales categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createSalesCategoryAction(businessId: string, userId: string, name: string, isDefault: boolean = false) {\r\n    try {\r\n        const category = await db.saleCategory.create({\r\n            data: {\r\n                branchId: businessId,\r\n                userId,\r\n                name,\r\n                is_default: isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating sales category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateSalesCategoryAction(id: string, name: string) {\r\n    try {\r\n        const category = await db.saleCategory.update({\r\n            where: { id },\r\n            data: { name }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating sales category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteSalesCategoryAction(id: string) {\r\n    try {\r\n        await db.saleCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting sales category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,kDAAA"}},
    {"offset": {"line": 4507, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/sales.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getSalesAction(businessId: string, sortOrder: 'asc' | 'desc' = 'desc', pageSize?: number) {\r\n    try {\r\n        const queryOptions: any = {\r\n            where: {\r\n                branchId: businessId,\r\n            },\r\n            orderBy: {\r\n                createdAt: sortOrder,\r\n            },\r\n            include: {\r\n                cashTransaction: true,\r\n            }\r\n        };\r\n\r\n        if (pageSize && pageSize > 0) {\r\n            queryOptions.take = pageSize;\r\n        }\r\n\r\n        const sales = await db.sale.findMany(queryOptions);\r\n\r\n        // Provide default mappings to existing React components\r\n        return sales.map((item: any) => ({\r\n            id: item.id,\r\n            user_id: item.userId,\r\n            location_id: item.branchId,\r\n            receipt_number: item.saleNumber,\r\n            customer_name: item.customerName,\r\n            customer_address: item.customerAddress,\r\n            customer_contact: item.customerPhone,\r\n            customer_id: item.customerId,\r\n            items: item.items as any, // jsonb type\r\n            payment_status: item.paymentStatus,\r\n            profit: 0, // Profit not stored directly\r\n            date: item.date.toISOString(),\r\n            tax_rate: item.taxRate ? Number(item.taxRate) : 0,\r\n            created_at: item.createdAt.toISOString(),\r\n            updated_at: item.updatedAt.toISOString(),\r\n            cash_transaction_id: item.cashTransactionId,\r\n            amount_paid: Number(item.amountPaid),\r\n            amount_due: Number(item.balance),\r\n            category_id: item.categoryId,\r\n            notes: item.notes\r\n        }));\r\n    } catch (error) {\r\n        console.error('Error fetching sales:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function deleteSaleAction(id: string, businessId: string) {\r\n    try {\r\n        const sale = await db.sale.findUnique({\r\n            where: { id },\r\n            include: { cashTransaction: true, installmentPayments: true }\r\n        });\r\n\r\n        if (!sale || sale.branchId !== businessId) {\r\n            return { success: false, error: 'Sale not found or unauthorized' };\r\n        }\r\n\r\n        await db.$transaction(async (tx) => {\r\n            // Delete installments\r\n            await tx.installmentPayment.deleteMany({\r\n                where: { saleId: id }\r\n            });\r\n\r\n            // Delete associated cash transaction\r\n            if (sale.cashTransactionId) {\r\n                await tx.cashTransaction.delete({\r\n                    where: { id: sale.cashTransactionId }\r\n                });\r\n            }\r\n\r\n            // Delete the sale itself\r\n            await tx.sale.delete({\r\n                where: { id }\r\n            });\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            sale: {\r\n                receiptNumber: sale.saleNumber,\r\n                customerName: sale.customerName,\r\n                customerAddress: sale.customerAddress,\r\n                customerContact: sale.customerPhone,\r\n                paymentStatus: sale.paymentStatus,\r\n                cashTransactionId: sale.cashTransactionId,\r\n                items: sale.items as any,\r\n                amountPaid: Number(sale.amountPaid),\r\n                amountDue: Number(sale.balance),\r\n                profit: 0,\r\n                taxRate: Number(sale.taxRate),\r\n                notes: sale.notes\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error deleting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to delete sale' };\r\n    }\r\n}\r\n\r\nexport async function upsertSaleAction(saleDbData: any, isUpdate: boolean, updateId?: string) {\r\n    try {\r\n        // Map PaymentStatus if needed\r\n        let status = saleDbData.payment_status;\r\n        if (status === 'NOT PAID') status = 'UNPAID';\r\n        else if (status === 'Installment Sale') status = 'INSTALLMENT';\r\n        else if (status === 'Paid') status = 'PAID';\r\n        else if (status === 'Quote') status = 'QUOTE';\r\n\r\n        const prismaData: any = {\r\n            userId: saleDbData.user_id,\r\n            branchId: saleDbData.location_id,\r\n            saleNumber: saleDbData.receipt_number,\r\n            customerName: saleDbData.customer_name,\r\n            customerAddress: saleDbData.customer_address,\r\n            customerPhone: saleDbData.customer_contact,\r\n            customerId: saleDbData.customer_id,\r\n            items: saleDbData.items,\r\n            paymentStatus: status,\r\n            date: new Date(saleDbData.date),\r\n            taxRate: saleDbData.tax_rate,\r\n            cashTransactionId: saleDbData.cash_transaction_id,\r\n            amountPaid: saleDbData.amount_paid,\r\n            balance: saleDbData.amount_due,\r\n            categoryId: saleDbData.category_id,\r\n            notes: saleDbData.notes,\r\n            subtotal: 0, // Placeholder\r\n            total: 0,     // Placeholder\r\n        };\r\n\r\n        if (isUpdate && updateId) {\r\n            const updated = await db.sale.update({\r\n                where: { id: updateId },\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: updated };\r\n        } else {\r\n            const created = await db.sale.create({\r\n                data: prismaData\r\n            });\r\n            return { success: true, data: created };\r\n        }\r\n    } catch (error: any) {\r\n        console.error('Error upserting sale:', error);\r\n        return { success: false, error: error.message || 'Failed to preserve sale' };\r\n    }\r\n}\r\n\r\nexport async function createReceiptAction(saleData: any, businessId: string, userId: string) {\r\n    try {\r\n        let status = saleData.paymentStatus;\r\n        if (status === 'NOT PAID') status = 'UNPAID';\r\n        else if (status === 'Installment Sale') status = 'INSTALLMENT';\r\n        else if (status === 'Paid') status = 'PAID';\r\n        else if (status === 'Quote') status = 'QUOTE';\r\n\r\n        const created = await db.sale.create({\r\n            data: {\r\n                userId: userId,\r\n                branchId: businessId,\r\n                saleNumber: saleData.receiptNumber,\r\n                customerName: saleData.customerName,\r\n                customerId: saleData.customerId,\r\n                date: new Date(saleData.date),\r\n                items: saleData.items,\r\n                paymentStatus: status,\r\n                amountPaid: saleData.amountPaid || 0,\r\n                balance: saleData.amountDue || 0,\r\n                cashAccountId: saleData.cashAccountId,\r\n                notes: saleData.notes,\r\n                subtotal: 0,\r\n                total: 0,\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        revalidatePath('/customers');\r\n\r\n        return { success: true, data: created };\r\n    } catch (error: any) {\r\n        console.error('Error creating receipt:', error);\r\n        return { success: false, error: error.message || 'Failed to create receipt' };\r\n    }\r\n}\r\n\r\n// --- SALES CATEGORIES ---\r\n\r\nexport async function getSalesCategoriesAction(businessId: string) {\r\n    try {\r\n        const categories = await db.saleCategory.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return { success: true, data: categories };\r\n    } catch (error: any) {\r\n        console.error('Error fetching sales categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createSalesCategoryAction(businessId: string, userId: string, name: string, isDefault: boolean = false) {\r\n    try {\r\n        const category = await db.saleCategory.create({\r\n            data: {\r\n                branchId: businessId,\r\n                userId,\r\n                name,\r\n                is_default: isDefault\r\n            }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating sales category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateSalesCategoryAction(id: string, name: string) {\r\n    try {\r\n        const category = await db.saleCategory.update({\r\n            where: { id },\r\n            data: { name }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating sales category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteSalesCategoryAction(id: string) {\r\n    try {\r\n        await db.saleCategory.delete({\r\n            where: { id }\r\n        });\r\n\r\n        revalidatePath('/sales');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting sales category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAsDsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,oDAAA"}},
    {"offset": {"line": 4524, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useSalesData.ts"],"sourcesContent":["import { useState, useEffect, useMemo, useCallback } from 'react';\r\nimport { Sale, DbSale, mapDbSaleToSale } from '@/types';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport { useActivityLogger } from '@/hooks/useActivityLogger';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useProducts } from '@/hooks/useProducts';\r\nimport { useInventoryActions } from '@/hooks/useInventoryActions';\r\nimport { clearInventoryCaches } from '@/utils/inventoryCacheUtils';\r\nimport { getSalesAction, deleteSaleAction } from '@/app/actions/sales';\r\n\r\nexport interface TopCustomer {\r\n  id?: string;\r\n  name: string;\r\n  totalPurchases: number;\r\n  orderCount: number;\r\n}\r\n\r\nexport const useSalesData = (userId: string | undefined, sortOrder: string = 'desc', pageSize?: number) => {\r\n\r\n  const queryClient = useQueryClient();\r\n  const { toast } = useToast();\r\n  const { logActivity } = useActivityLogger();\r\n  const { currentBusiness } = useBusiness();\r\n  const { restoreStockForSale } = useInventoryActions(userId);\r\n\r\n  const loadSales = useCallback(async (): Promise<Sale[]> => {\r\n    try {\r\n      if (!userId || !currentBusiness) {\r\n        return [];\r\n      }\r\n\r\n      // If pageSize is specified, load only that many records\r\n      const salesData = await getSalesAction(currentBusiness.id, sortOrder as any, pageSize);\r\n\r\n      const formattedSales: Sale[] = salesData ? salesData.map((item: any) => {\r\n        const dbSale: DbSale = {\r\n          id: item.id,\r\n          user_id: item.user_id,\r\n          location_id: item.location_id,\r\n          receipt_number: item.receipt_number,\r\n          customer_name: item.customer_name,\r\n          customer_address: item.customer_address,\r\n          customer_contact: item.customer_contact,\r\n          customer_id: item.customer_id,\r\n          items: item.items as any,\r\n          payment_status: item.payment_status,\r\n          profit: item.profit ? Number(item.profit) : 0,\r\n          date: item.date,\r\n          tax_rate: item.tax_rate || 0,\r\n          created_at: item.created_at,\r\n          updated_at: item.updated_at,\r\n          cash_transaction_id: item.cash_transaction_id,\r\n          amount_paid: item.amount_paid ? Number(item.amount_paid) : undefined,\r\n          amount_due: item.amount_due ? Number(item.amount_due) : undefined,\r\n          category_id: item.category_id,\r\n          notes: item.notes\r\n        };\r\n        return mapDbSaleToSale(dbSale);\r\n      }) : [];\r\n\r\n      return formattedSales;\r\n\r\n    } catch (error) {\r\n      console.error('Error loading sales:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load sales data. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return [];\r\n    }\r\n  }, [userId, currentBusiness?.id, sortOrder, pageSize, toast]);\r\n\r\n  // React Query caching with persistent storage for improved performance\r\n  const baseQueryKey = useMemo(() => ['sales', currentBusiness?.id, userId], [currentBusiness?.id, userId]);\r\n  const queryKey = useMemo(() => [...baseQueryKey, sortOrder, pageSize], [baseQueryKey, sortOrder, pageSize]);\r\n\r\n  const {\r\n    data: sales = [],\r\n    isLoading: isQueryLoading,\r\n    isFetching,\r\n    refetch\r\n  } = useQuery({\r\n    queryKey,\r\n    queryFn: loadSales,\r\n    enabled: !!userId && !!currentBusiness?.id,\r\n    staleTime: 30_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: true,\r\n    refetchOnReconnect: true,\r\n  });\r\n\r\n  // Derived loading state\r\n  const isLoading = isQueryLoading || (isFetching && sales.length === 0);\r\n\r\n  const getTopCustomers = useMemo((): TopCustomer[] => {\r\n    // Skip quotes since they're not actual purchases\r\n    const nonQuoteSales = sales.filter(sale => sale.paymentStatus !== \"Quote\");\r\n\r\n    // Group sales by customer name\r\n    const customerMap = new Map<string, { total: number, count: number, customerId?: string }>();\r\n\r\n    nonQuoteSales.forEach(sale => {\r\n      const customerName = sale.customerName;\r\n      const saleTotal = sale.items.reduce((sum, item) => sum + (item.price * item.quantity), 0);\r\n\r\n      if (!customerMap.has(customerName)) {\r\n        customerMap.set(customerName, {\r\n          total: saleTotal,\r\n          count: 1,\r\n          customerId: sale.customerId\r\n        });\r\n      } else {\r\n        const current = customerMap.get(customerName)!;\r\n        customerMap.set(customerName, {\r\n          total: current.total + saleTotal,\r\n          count: current.count + 1,\r\n          customerId: current.customerId || sale.customerId\r\n        });\r\n      }\r\n    });\r\n\r\n    // Convert map to array and sort by total purchases\r\n    return Array.from(customerMap.entries())\r\n      .map(([name, data]) => ({\r\n        id: data.customerId,\r\n        name,\r\n        totalPurchases: data.total,\r\n        orderCount: data.count\r\n      }))\r\n      .sort((a, b) => b.totalPurchases - a.totalPurchases);\r\n  }, [sales]);\r\n\r\n  // Memoize customer lifetime purchases function\r\n  const getCustomerLifetimePurchases = useMemo(() => {\r\n    return (customerName: string) => {\r\n      // Filter sales by customer name and exclude quotes\r\n      const customerSales = sales.filter(sale =>\r\n        sale.customerName.toLowerCase() === customerName.toLowerCase() &&\r\n        sale.paymentStatus !== \"Quote\"\r\n      );\r\n\r\n      // Calculate total purchase amount and count\r\n      const total = customerSales.reduce((sum, sale) =>\r\n        sum + sale.items.reduce((itemSum, item) => itemSum + (item.price * item.quantity), 0), 0\r\n      );\r\n\r\n      return {\r\n        total,\r\n        count: customerSales.length\r\n      };\r\n    };\r\n  }, [sales]);\r\n\r\n  const deleteSale = async (id: string) => {\r\n    try {\r\n      // First, find the sale to get its details for logging\r\n      const saleToDelete = sales.find(sale => sale.id === id);\r\n      if (!saleToDelete) {\r\n        throw new Error('Sale not found');\r\n      }\r\n\r\n      // Restore product quantities back to inventory (Only if it wasn't a quote which doesn't deduct stock)\r\n      if (saleToDelete.paymentStatus !== 'Quote' && saleToDelete.items.length > 0) {\r\n        console.log('Restoring product quantities via useInventoryActions...');\r\n        const success = await restoreStockForSale(saleToDelete.items, id, saleToDelete.receiptNumber, currentBusiness?.id);\r\n\r\n        if (!success) {\r\n          toast({\r\n            title: \"Inventory Update Warning\",\r\n            description: \"Sale deleted, but inventory restoration might have failed. Please check your stock levels.\",\r\n            variant: \"destructive\"\r\n          });\r\n        }\r\n      }\r\n\r\n      // Proceed to delete the sale via API Action\r\n      if (!currentBusiness?.id) {\r\n        throw new Error('Business context missing for deletion');\r\n      }\r\n\r\n      const result = await deleteSaleAction(id, currentBusiness.id);\r\n\r\n      if (!result.success) {\r\n        throw new Error(result.error);\r\n      }\r\n\r\n      // Update React Query cache\r\n      queryClient.setQueryData(queryKey, (oldData: Sale[] | undefined) => {\r\n        return oldData ? oldData.filter(sale => sale.id !== id) : [];\r\n      });\r\n      queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n\r\n      // Clear sold items cache after deletion\r\n      clearSoldItemsCache();\r\n\r\n      // Log activity for sale deletion\r\n      await logActivity({\r\n        activityType: 'DELETE',\r\n        module: 'SALES',\r\n        entityType: 'sale',\r\n        entityId: id,\r\n        entityName: `Sale #${saleToDelete.receiptNumber}`,\r\n        description: `Deleted sale for ${saleToDelete.customerName} - Total: UGX ${((saleToDelete.amountPaid || 0) + (saleToDelete.amountDue || 0)).toLocaleString()} (Stock restored)`,\r\n        metadata: {\r\n          receiptNumber: saleToDelete.receiptNumber,\r\n          customerName: saleToDelete.customerName,\r\n          customerAddress: saleToDelete.customerAddress,\r\n          customerContact: saleToDelete.customerContact,\r\n          totalAmount: (saleToDelete.amountPaid || 0) + (saleToDelete.amountDue || 0),\r\n          amountPaid: saleToDelete.amountPaid,\r\n          profit: saleToDelete.profit,\r\n          paymentStatus: saleToDelete.paymentStatus,\r\n          taxRate: saleToDelete.taxRate,\r\n          itemCount: saleToDelete.items.length,\r\n          items: saleToDelete.items.map(item => ({\r\n            description: item.description,\r\n            quantity: item.quantity,\r\n            price: item.price,\r\n            cost: item.cost,\r\n            total: item.quantity * item.price,\r\n            discountPercentage: item.discountPercentage,\r\n            discountAmount: item.discountAmount\r\n          })),\r\n          notes: saleToDelete.notes,\r\n          cashTransactionDeleted: !!saleToDelete.cashTransactionId\r\n        }\r\n      });\r\n\r\n      toast({\r\n        title: \"Sale Deleted\",\r\n        description: \"The sale record and associated data have been successfully deleted.\"\r\n      });\r\n\r\n      clearInventoryCaches();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting sale:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to delete sale. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const clearSoldItemsCache = useCallback(() => {\r\n    if (!currentBusiness?.id) return;\r\n    const key = `soldItemsFilters_${currentBusiness.id}`;\r\n    localStorage.removeItem(key);\r\n\r\n    // Also clear legacy keys for safety\r\n    localStorage.removeItem('soldItemsFilters');\r\n  }, [currentBusiness?.id]);\r\n\r\n  const addSale = useCallback((newSale: Sale) => {\r\n    queryClient.setQueryData(queryKey, (oldData: Sale[] | undefined) => {\r\n      return oldData ? [newSale, ...oldData] : [newSale];\r\n    });\r\n    queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n    clearSoldItemsCache();\r\n    clearInventoryCaches();\r\n  }, [queryClient, queryKey, baseQueryKey, clearSoldItemsCache, clearInventoryCaches]);\r\n\r\n  const updateSale = useCallback((updatedSale: Sale) => {\r\n    queryClient.setQueryData(queryKey, (oldData: Sale[] | undefined) => {\r\n      return oldData ? oldData.map(s => s.id === updatedSale.id ? updatedSale : s) : [updatedSale];\r\n    });\r\n    queryClient.invalidateQueries({ queryKey: baseQueryKey });\r\n    clearSoldItemsCache();\r\n    clearInventoryCaches();\r\n  }, [queryClient, queryKey, baseQueryKey, clearSoldItemsCache, clearInventoryCaches]);\r\n\r\n  return {\r\n    sales,\r\n    isLoading,\r\n    deleteSale,\r\n    addSale,\r\n    updateSale,\r\n    getTopCustomers,\r\n    getCustomerLifetimePurchases,\r\n    clearSoldItemsCache,\r\n    refetch,\r\n    isFetching\r\n  };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;AASO,MAAM,eAAe,CAAC,QAA4B,YAAoB,MAAM,EAAE;;IAEnF,MAAM,cAAc,IAAA,2MAAc;IAClC,MAAM,EAAE,KAAK,EAAE,GAAG,IAAA,2IAAQ;IAC1B,MAAM,EAAE,WAAW,EAAE,GAAG,IAAA,yJAAiB;IACzC,MAAM,EAAE,eAAe,EAAE,GAAG,IAAA,qJAAW;IACvC,MAAM,EAAE,mBAAmB,EAAE,GAAG,IAAA,6JAAmB,EAAC;IAEpD,MAAM,YAAY,IAAA,4KAAW;+CAAC;YAC5B,IAAI;gBACF,IAAI,CAAC,UAAU,CAAC,iBAAiB;oBAC/B,OAAO,EAAE;gBACX;gBAEA,wDAAwD;gBACxD,MAAM,YAAY,MAAM,IAAA,kLAAc,EAAC,gBAAgB,EAAE,EAAE,WAAkB;gBAE7E,MAAM,iBAAyB,YAAY,UAAU,GAAG;2DAAC,CAAC;wBACxD,MAAM,SAAiB;4BACrB,IAAI,KAAK,EAAE;4BACX,SAAS,KAAK,OAAO;4BACrB,aAAa,KAAK,WAAW;4BAC7B,gBAAgB,KAAK,cAAc;4BACnC,eAAe,KAAK,aAAa;4BACjC,kBAAkB,KAAK,gBAAgB;4BACvC,kBAAkB,KAAK,gBAAgB;4BACvC,aAAa,KAAK,WAAW;4BAC7B,OAAO,KAAK,KAAK;4BACjB,gBAAgB,KAAK,cAAc;4BACnC,QAAQ,KAAK,MAAM,GAAG,OAAO,KAAK,MAAM,IAAI;4BAC5C,MAAM,KAAK,IAAI;4BACf,UAAU,KAAK,QAAQ,IAAI;4BAC3B,YAAY,KAAK,UAAU;4BAC3B,YAAY,KAAK,UAAU;4BAC3B,qBAAqB,KAAK,mBAAmB;4BAC7C,aAAa,KAAK,WAAW,GAAG,OAAO,KAAK,WAAW,IAAI;4BAC3D,YAAY,KAAK,UAAU,GAAG,OAAO,KAAK,UAAU,IAAI;4BACxD,aAAa,KAAK,WAAW;4BAC7B,OAAO,KAAK,KAAK;wBACnB;wBACA,OAAO,IAAA,2IAAe,EAAC;oBACzB;4DAAK,EAAE;gBAEP,OAAO;YAET,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,wBAAwB;gBACtC,MAAM;oBACJ,OAAO;oBACP,aAAa;oBACb,SAAS;gBACX;gBACA,OAAO,EAAE;YACX;QACF;8CAAG;QAAC;QAAQ,iBAAiB;QAAI;QAAW;QAAU;KAAM;IAE5D,uEAAuE;IACvE,MAAM,eAAe,IAAA,wKAAO;8CAAC,IAAM;gBAAC;gBAAS,iBAAiB;gBAAI;aAAO;6CAAE;QAAC,iBAAiB;QAAI;KAAO;IACxG,MAAM,WAAW,IAAA,wKAAO;0CAAC,IAAM;mBAAI;gBAAc;gBAAW;aAAS;yCAAE;QAAC;QAAc;QAAW;KAAS;IAE1G,MAAM,EACJ,MAAM,QAAQ,EAAE,EAChB,WAAW,cAAc,EACzB,UAAU,EACV,OAAO,EACR,GAAG,IAAA,0LAAQ,EAAC;QACX;QACA,SAAS;QACT,SAAS,CAAC,CAAC,UAAU,CAAC,CAAC,iBAAiB;QACxC,WAAW;QACX,QAAQ,KAAK;QACb,sBAAsB;QACtB,oBAAoB;IACtB;IAEA,wBAAwB;IACxB,MAAM,YAAY,kBAAmB,cAAc,MAAM,MAAM,KAAK;IAEpE,MAAM,kBAAkB,IAAA,wKAAO;iDAAC;YAC9B,iDAAiD;YACjD,MAAM,gBAAgB,MAAM,MAAM;uEAAC,CAAA,OAAQ,KAAK,aAAa,KAAK;;YAElE,+BAA+B;YAC/B,MAAM,cAAc,IAAI;YAExB,cAAc,OAAO;yDAAC,CAAA;oBACpB,MAAM,eAAe,KAAK,YAAY;oBACtC,MAAM,YAAY,KAAK,KAAK,CAAC,MAAM;2EAAC,CAAC,KAAK,OAAS,MAAO,KAAK,KAAK,GAAG,KAAK,QAAQ;0EAAG;oBAEvF,IAAI,CAAC,YAAY,GAAG,CAAC,eAAe;wBAClC,YAAY,GAAG,CAAC,cAAc;4BAC5B,OAAO;4BACP,OAAO;4BACP,YAAY,KAAK,UAAU;wBAC7B;oBACF,OAAO;wBACL,MAAM,UAAU,YAAY,GAAG,CAAC;wBAChC,YAAY,GAAG,CAAC,cAAc;4BAC5B,OAAO,QAAQ,KAAK,GAAG;4BACvB,OAAO,QAAQ,KAAK,GAAG;4BACvB,YAAY,QAAQ,UAAU,IAAI,KAAK,UAAU;wBACnD;oBACF;gBACF;;YAEA,mDAAmD;YACnD,OAAO,MAAM,IAAI,CAAC,YAAY,OAAO,IAClC,GAAG;yDAAC,CAAC,CAAC,MAAM,KAAK,GAAK,CAAC;wBACtB,IAAI,KAAK,UAAU;wBACnB;wBACA,gBAAgB,KAAK,KAAK;wBAC1B,YAAY,KAAK,KAAK;oBACxB,CAAC;wDACA,IAAI;yDAAC,CAAC,GAAG,IAAM,EAAE,cAAc,GAAG,EAAE,cAAc;;QACvD;gDAAG;QAAC;KAAM;IAEV,+CAA+C;IAC/C,MAAM,+BAA+B,IAAA,wKAAO;8DAAC;YAC3C;sEAAO,CAAC;oBACN,mDAAmD;oBACnD,MAAM,gBAAgB,MAAM,MAAM;4FAAC,CAAA,OACjC,KAAK,YAAY,CAAC,WAAW,OAAO,aAAa,WAAW,MAC5D,KAAK,aAAa,KAAK;;oBAGzB,4CAA4C;oBAC5C,MAAM,QAAQ,cAAc,MAAM;oFAAC,CAAC,KAAK,OACvC,MAAM,KAAK,KAAK,CAAC,MAAM;4FAAC,CAAC,SAAS,OAAS,UAAW,KAAK,KAAK,GAAG,KAAK,QAAQ;2FAAG;mFAAI;oBAGzF,OAAO;wBACL;wBACA,OAAO,cAAc,MAAM;oBAC7B;gBACF;;QACF;6DAAG;QAAC;KAAM;IAEV,MAAM,aAAa,OAAO;QACxB,IAAI;YACF,sDAAsD;YACtD,MAAM,eAAe,MAAM,IAAI,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;YACpD,IAAI,CAAC,cAAc;gBACjB,MAAM,IAAI,MAAM;YAClB;YAEA,sGAAsG;YACtG,IAAI,aAAa,aAAa,KAAK,WAAW,aAAa,KAAK,CAAC,MAAM,GAAG,GAAG;gBAC3E,QAAQ,GAAG,CAAC;gBACZ,MAAM,UAAU,MAAM,oBAAoB,aAAa,KAAK,EAAE,IAAI,aAAa,aAAa,EAAE,iBAAiB;gBAE/G,IAAI,CAAC,SAAS;oBACZ,MAAM;wBACJ,OAAO;wBACP,aAAa;wBACb,SAAS;oBACX;gBACF;YACF;YAEA,4CAA4C;YAC5C,IAAI,CAAC,iBAAiB,IAAI;gBACxB,MAAM,IAAI,MAAM;YAClB;YAEA,MAAM,SAAS,MAAM,IAAA,oLAAgB,EAAC,IAAI,gBAAgB,EAAE;YAE5D,IAAI,CAAC,OAAO,OAAO,EAAE;gBACnB,MAAM,IAAI,MAAM,OAAO,KAAK;YAC9B;YAEA,2BAA2B;YAC3B,YAAY,YAAY,CAAC,UAAU,CAAC;gBAClC,OAAO,UAAU,QAAQ,MAAM,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK,MAAM,EAAE;YAC9D;YACA,YAAY,iBAAiB,CAAC;gBAAE,UAAU;YAAa;YAEvD,wCAAwC;YACxC;YAEA,iCAAiC;YACjC,MAAM,YAAY;gBAChB,cAAc;gBACd,QAAQ;gBACR,YAAY;gBACZ,UAAU;gBACV,YAAY,CAAC,MAAM,EAAE,aAAa,aAAa,EAAE;gBACjD,aAAa,CAAC,iBAAiB,EAAE,aAAa,YAAY,CAAC,cAAc,EAAE,CAAC,CAAC,aAAa,UAAU,IAAI,CAAC,IAAI,CAAC,aAAa,SAAS,IAAI,CAAC,CAAC,EAAE,cAAc,GAAG,iBAAiB,CAAC;gBAC/K,UAAU;oBACR,eAAe,aAAa,aAAa;oBACzC,cAAc,aAAa,YAAY;oBACvC,iBAAiB,aAAa,eAAe;oBAC7C,iBAAiB,aAAa,eAAe;oBAC7C,aAAa,CAAC,aAAa,UAAU,IAAI,CAAC,IAAI,CAAC,aAAa,SAAS,IAAI,CAAC;oBAC1E,YAAY,aAAa,UAAU;oBACnC,QAAQ,aAAa,MAAM;oBAC3B,eAAe,aAAa,aAAa;oBACzC,SAAS,aAAa,OAAO;oBAC7B,WAAW,aAAa,KAAK,CAAC,MAAM;oBACpC,OAAO,aAAa,KAAK,CAAC,GAAG,CAAC,CAAA,OAAQ,CAAC;4BACrC,aAAa,KAAK,WAAW;4BAC7B,UAAU,KAAK,QAAQ;4BACvB,OAAO,KAAK,KAAK;4BACjB,MAAM,KAAK,IAAI;4BACf,OAAO,KAAK,QAAQ,GAAG,KAAK,KAAK;4BACjC,oBAAoB,KAAK,kBAAkB;4BAC3C,gBAAgB,KAAK,cAAc;wBACrC,CAAC;oBACD,OAAO,aAAa,KAAK;oBACzB,wBAAwB,CAAC,CAAC,aAAa,iBAAiB;gBAC1D;YACF;YAEA,MAAM;gBACJ,OAAO;gBACP,aAAa;YACf;YAEA,IAAA,8JAAoB;YACpB,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wBAAwB;YACtC,MAAM;gBACJ,OAAO;gBACP,aAAa;gBACb,SAAS;YACX;YACA,OAAO;QACT;IACF;IAEA,MAAM,sBAAsB,IAAA,4KAAW;yDAAC;YACtC,IAAI,CAAC,iBAAiB,IAAI;YAC1B,MAAM,MAAM,CAAC,iBAAiB,EAAE,gBAAgB,EAAE,EAAE;YACpD,aAAa,UAAU,CAAC;YAExB,oCAAoC;YACpC,aAAa,UAAU,CAAC;QAC1B;wDAAG;QAAC,iBAAiB;KAAG;IAExB,MAAM,UAAU,IAAA,4KAAW;6CAAC,CAAC;YAC3B,YAAY,YAAY,CAAC;qDAAU,CAAC;oBAClC,OAAO,UAAU;wBAAC;2BAAY;qBAAQ,GAAG;wBAAC;qBAAQ;gBACpD;;YACA,YAAY,iBAAiB,CAAC;gBAAE,UAAU;YAAa;YACvD;YACA,IAAA,8JAAoB;QACtB;4CAAG;QAAC;QAAa;QAAU;QAAc;QAAqB,8JAAoB;KAAC;IAEnF,MAAM,aAAa,IAAA,4KAAW;gDAAC,CAAC;YAC9B,YAAY,YAAY,CAAC;wDAAU,CAAC;oBAClC,OAAO,UAAU,QAAQ,GAAG;gEAAC,CAAA,IAAK,EAAE,EAAE,KAAK,YAAY,EAAE,GAAG,cAAc;iEAAK;wBAAC;qBAAY;gBAC9F;;YACA,YAAY,iBAAiB,CAAC;gBAAE,UAAU;YAAa;YACvD;YACA,IAAA,8JAAoB;QACtB;+CAAG;QAAC;QAAa;QAAU;QAAc;QAAqB,8JAAoB;KAAC;IAEnF,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF;GA7Qa;;QAES,2MAAc;QAChB,2IAAQ;QACF,yJAAiB;QACb,qJAAW;QACP,6JAAmB;QA2D/C,0LAAQ"}},
    {"offset": {"line": 4886, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/messages/BulkMessageDialog.tsx"],"sourcesContent":["import React, { useEffect, useState, useMemo } from 'react';\r\nimport { Send, Users, AlertCircle } from 'lucide-react';\r\nimport { Customer } from '@/hooks/useCustomers';\r\nimport { MessageTemplate } from '@/hooks/useMessages';\r\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Textarea } from '@/components/ui/textarea';\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\r\nimport { Checkbox } from '@/components/ui/checkbox';\r\nimport { Input } from '@/components/ui/input';\r\nimport { useSalesData } from '@/hooks/useSalesData';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { subDays, subMonths, subYears } from 'date-fns';\r\n\r\ntype StatusOption = 'all' | 'paid' | 'unpaid' | 'quote' | 'installment' | 'inactive';\r\ntype InactivityPeriod = '30days' | '60days' | '90days' | '6months' | '1year';\r\n\r\ninterface BulkMessageDialogProps {\r\n  open: boolean;\r\n  onClose: () => void;\r\n  onSend: (data: { customerIds: string[]; content: string; templateId?: string }) => Promise<{ success: number; failed: number; errors: string[] }>;\r\n  customers: Customer[];\r\n  templates?: MessageTemplate[];\r\n  searchTerm: string;\r\n  setSearchTerm: (term: string) => void;\r\n}\r\n\r\nconst BulkMessageDialog: React.FC<BulkMessageDialogProps> = ({\r\n  open,\r\n  onClose,\r\n  onSend,\r\n  customers,\r\n  templates = [],\r\n  searchTerm,\r\n  setSearchTerm,\r\n}) => {\r\n  const [content, setContent] = useState('');\r\n  const [selectedCustomers, setSelectedCustomers] = useState<string[]>([]);\r\n  const [selectedTemplate, setSelectedTemplate] = useState<string>('none');\r\n  const [isSending, setIsSending] = useState(false);\r\n  const [statusSelection, setStatusSelection] = useState<StatusOption>('all');\r\n  const [inactivityPeriod, setInactivityPeriod] = useState<InactivityPeriod>('90days');\r\n  const [sendResult, setSendResult] = useState<{ success: number; failed: number; errors: string[] } | null>(null);\r\n\r\n  const { currentBusiness } = useBusiness();\r\n  const { sales, isLoading } = useSalesData(currentBusiness?.id);\r\n\r\n  // Capitalize utility\r\n  const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1);\r\n\r\n  // Map customers to statuses including inactive\r\n  const customerStatusesMap = useMemo(() => {\r\n    const map: Record<string, Set<StatusOption>> = {};\r\n    if (!sales || sales.length === 0) return map;\r\n\r\n    const now = new Date();\r\n    let cutoffDate = now;\r\n    switch (inactivityPeriod) {\r\n      case '30days': cutoffDate = subDays(now, 30); break;\r\n      case '60days': cutoffDate = subDays(now, 60); break;\r\n      case '90days': cutoffDate = subDays(now, 90); break;\r\n      case '6months': cutoffDate = subMonths(now, 6); break;\r\n      case '1year': cutoffDate = subYears(now, 1); break;\r\n    }\r\n\r\n    customers.forEach(customer => {\r\n      const customerName = (customer.full_name || customer.fullName || customer.name || '').toLowerCase();\r\n      const customerSales = sales.filter(s =>\r\n        s.customerId === customer.id || s.customerName?.toLowerCase().trim() === customerName\r\n      );\r\n\r\n      const statuses = new Set<StatusOption>();\r\n\r\n      if (customerSales.length === 0) {\r\n        statuses.add('inactive');\r\n      } else {\r\n        const lastPurchaseDate = new Date(Math.max(...customerSales.map(s => new Date(s.date).getTime())));\r\n        if (lastPurchaseDate < cutoffDate) statuses.add('inactive');\r\n\r\n        customerSales.forEach(sale => {\r\n          const status = (sale.paymentStatus || '').toUpperCase().trim();\r\n          if (status === 'PAID') statuses.add('paid');\r\n          else if (status === 'QUOTE') statuses.add('quote');\r\n          else if (status === 'INSTALLMENT SALE') statuses.add('installment');\r\n          else if (['NOT PAID', 'UNPAID', 'OPEN'].includes(status)) statuses.add('unpaid');\r\n        });\r\n      }\r\n\r\n      map[customer.id] = statuses;\r\n    });\r\n\r\n    return map;\r\n  }, [customers, sales, inactivityPeriod]);\r\n\r\n  useEffect(() => {\r\n    if (!open) {\r\n      setContent('');\r\n      setSelectedCustomers([]);\r\n      setSelectedTemplate('none');\r\n      setStatusSelection('all');\r\n      setSendResult(null);\r\n    }\r\n  }, [open]);\r\n\r\n  useEffect(() => {\r\n    if (selectedTemplate && selectedTemplate !== 'none') {\r\n      const template = templates.find(t => t.id === selectedTemplate);\r\n      if (template) setContent(template.content);\r\n    }\r\n  }, [selectedTemplate, templates]);\r\n\r\n  const getCustomerPhone = (customer: Customer) =>\r\n    customer.phone_number || customer.phoneNumber || customer.phone || customer.contact || '';\r\n\r\n  const filteredCustomers = useMemo(() => {\r\n    return customers.filter(customer => {\r\n      const phone = getCustomerPhone(customer) || '';\r\n      if (!phone) return false;\r\n\r\n      const name = (customer.full_name || customer.fullName || customer.name || '').toLowerCase();\r\n      const term = (searchTerm || '').toLowerCase();\r\n      const searchMatch = !term || name.includes(term) || phone.toLowerCase().includes(term);\r\n\r\n      const statuses = customerStatusesMap[customer.id] || new Set<StatusOption>();\r\n      let statusMatch = true;\r\n      if (statusSelection !== 'all') {\r\n        statusMatch = statuses.has(statusSelection);\r\n      }\r\n\r\n      return searchMatch && statusMatch;\r\n    });\r\n  }, [customers, searchTerm, statusSelection, customerStatusesMap]);\r\n\r\n  const handleToggleCustomer = (id: string) => {\r\n    setSelectedCustomers(prev =>\r\n      prev.includes(id) ? prev.filter(c => c !== id) : [...prev, id]\r\n    );\r\n  };\r\n\r\n  // Select all / deselect all\r\n  const handleToggleAll = () => {\r\n    if (selectedCustomers.length === filteredCustomers.length) {\r\n      setSelectedCustomers([]);\r\n    } else {\r\n      setSelectedCustomers(filteredCustomers.map(c => c.id));\r\n    }\r\n  };\r\n\r\n  const handleSend = async () => {\r\n    if (!content || selectedCustomers.length === 0) return;\r\n    setIsSending(true);\r\n    const result = await onSend({\r\n      customerIds: selectedCustomers,\r\n      content,\r\n      templateId: selectedTemplate !== 'none' ? selectedTemplate : undefined,\r\n    });\r\n    setIsSending(false);\r\n    setSendResult(result);\r\n    if (result.failed === 0) setTimeout(() => onClose(), 3000);\r\n  };\r\n\r\n  const totalSMS = selectedCustomers.length * Math.ceil((content.length || 1) / 160);\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <Dialog open={open} onOpenChange={onClose}>\r\n        <DialogContent className=\"sm:max-w-3xl max-h-[90vh] overflow-y-auto\">\r\n          <div className=\"p-4 text-center text-gray-500\">Loading sales data...</div>\r\n        </DialogContent>\r\n      </Dialog>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <Dialog open={open} onOpenChange={onClose}>\r\n      <DialogContent className=\"sm:max-w-3xl max-h-[90vh] overflow-y-auto\">\r\n        <DialogHeader>\r\n          <DialogTitle className=\"flex items-center gap-2\">\r\n            <Users className=\"w-5 h-5\" />\r\n            Send Bulk SMS\r\n          </DialogTitle>\r\n        </DialogHeader>\r\n\r\n        {sendResult ? (\r\n          <div className=\"space-y-4\">\r\n            <div className={`p-4 rounded-lg border ${sendResult.failed === 0 ? 'bg-green-50 border-green-200' : 'bg-amber-50 border-amber-200'}`}>\r\n              <h3 className=\"font-semibold text-lg mb-2\">\r\n                {sendResult.failed === 0 ? ' Messages Sent Successfully!' : ' Sending Complete with Errors'}\r\n              </h3>\r\n              <div className=\"space-y-1 text-sm\">\r\n                <p className=\"text-green-700\"> Successfully sent: {sendResult.success}</p>\r\n                {sendResult.failed > 0 && <p className=\"text-red-700\"> Failed: {sendResult.failed}</p>}\r\n              </div>\r\n            </div>\r\n\r\n            {sendResult.errors.length > 0 && (\r\n              <div className=\"bg-red-50 border border-red-200 rounded-lg p-4\">\r\n                <h4 className=\"font-semibold text-red-900 mb-2\">Errors:</h4>\r\n                <ul className=\"text-sm text-red-800 space-y-1 max-h-[200px] overflow-y-auto\">\r\n                  {sendResult.errors.map((err, idx) => <li key={idx}> {err}</li>)}\r\n                </ul>\r\n              </div>\r\n            )}\r\n\r\n            <Button onClick={onClose} className=\"w-full\">Close</Button>\r\n          </div>\r\n        ) : (\r\n          <div className=\"space-y-4\">\r\n            {/* Template */}\r\n            <div>\r\n              <label className=\"text-sm font-medium text-gray-700 mb-1 block\">Use Template (Optional)</label>\r\n              <Select value={selectedTemplate} onValueChange={setSelectedTemplate}>\r\n                <SelectTrigger className=\"w-full\">\r\n                  <SelectValue placeholder=\"Choose a template...\" />\r\n                </SelectTrigger>\r\n                <SelectContent className=\"max-h-[300px] overflow-y-auto\">\r\n                  <SelectItem value=\"none\">None - Type custom message</SelectItem>\r\n                  {templates.map(t => <SelectItem key={t.id} value={t.id}>{t.name}</SelectItem>)}\r\n                </SelectContent>\r\n              </Select>\r\n            </div>\r\n\r\n            {/* Message */}\r\n            <div>\r\n              <label className=\"text-sm font-medium text-gray-700 mb-1 block\">Message * (Max 160 Characters)</label>\r\n              <Textarea\r\n                placeholder=\"Type your message here... Use {customer_name} for personalization\"\r\n                value={content}\r\n                onChange={e => setContent(e.target.value)}\r\n                rows={4}\r\n                maxLength={160}\r\n                required\r\n                className=\"resize-none w-full\"\r\n              />\r\n              <div className=\"flex justify-between mt-1 text-xs text-gray-500\">\r\n                <span>{content.length} characters</span>\r\n                <span className=\"font-medium text-blue-600\">{totalSMS} total SMS credits will be used</span>\r\n              </div>\r\n            </div>\r\n\r\n            {/* Status selection */}\r\n            <div className=\"flex gap-2 mb-2 flex-wrap items-center\">\r\n              {(['all','paid','unpaid','quote','installment','inactive'] as StatusOption[]).map(status => (\r\n                <Button\r\n                  key={status}\r\n                  size=\"sm\"\r\n                  variant={statusSelection === status ? 'default' : 'outline'}\r\n                  onClick={() => setStatusSelection(status)}\r\n                >\r\n                  {capitalize(status)}\r\n                </Button>\r\n              ))}\r\n\r\n              {/* Inactivity period selector */}\r\n              {statusSelection === 'inactive' && (\r\n                <Select value={inactivityPeriod} onValueChange={(v: InactivityPeriod) => setInactivityPeriod(v)}>\r\n                  <SelectTrigger className=\"w-[120px] text-xs\">\r\n                    <SelectValue placeholder=\"Select period\" />\r\n                  </SelectTrigger>\r\n                  <SelectContent>\r\n                    <SelectItem value=\"30days\">30 days</SelectItem>\r\n                    <SelectItem value=\"60days\">60 days</SelectItem>\r\n                    <SelectItem value=\"90days\">90 days</SelectItem>\r\n                    <SelectItem value=\"6months\">6 months</SelectItem>\r\n                    <SelectItem value=\"1year\">1 year</SelectItem>\r\n                  </SelectContent>\r\n                </Select>\r\n              )}\r\n\r\n              <Button size=\"sm\" variant=\"outline\" onClick={handleToggleAll}>\r\n                {selectedCustomers.length === filteredCustomers.length \r\n                  ? `Deselect All ${capitalize(statusSelection)} Customers` \r\n                  : `Select All ${capitalize(statusSelection)} Customers`}\r\n              </Button>\r\n\r\n            </div>\r\n\r\n            {/* Search */}\r\n            <Input type=\"text\" placeholder=\"Search customers...\" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} className=\"mb-2\" />\r\n\r\n            {/* Customer list */}\r\n            <div className=\"border rounded-lg max-h-[300px] overflow-y-auto\">\r\n              {filteredCustomers.length === 0 ? (\r\n                <div className=\"p-4 text-center text-gray-500\">\r\n                  <AlertCircle className=\"w-8 h-8 mx-auto mb-2 text-gray-400\" />\r\n                  <p>No customers match your search</p>\r\n                </div>\r\n              ) : (\r\n                filteredCustomers.map(customer => {\r\n                  const phone = getCustomerPhone(customer);\r\n                  const statuses = Array.from(customerStatusesMap[customer.id] || []);\r\n                  return (\r\n                    <div\r\n                      key={customer.id}\r\n                      className=\"flex items-center gap-3 p-3 hover:bg-gray-50 border-b last:border-b-0 cursor-pointer\"\r\n                      onClick={() => handleToggleCustomer(customer.id)}\r\n                    >\r\n                      <Checkbox checked={selectedCustomers.includes(customer.id)} onCheckedChange={() => handleToggleCustomer(customer.id)} />\r\n                      <div className=\"flex-1\">\r\n                        <p className=\"font-medium text-gray-900\">{customer.full_name || customer.fullName || customer.name || 'Unnamed Customer'}</p>\r\n                        <p className=\"text-xs text-gray-500\">{phone}</p>\r\n                        <span className=\"text-xs text-gray-400\">Status: {statuses.map(s => s.toUpperCase()).join(', ')}</span>\r\n                      </div>\r\n                    </div>\r\n                  );\r\n                })\r\n              )}\r\n            </div>\r\n\r\n            {/* Action */}\r\n            <div className=\"flex justify-end gap-2 pt-4 border-t\">\r\n              <Button variant=\"outline\" onClick={onClose} disabled={isSending}>Cancel</Button>\r\n              <Button\r\n                onClick={handleSend}\r\n                disabled={selectedCustomers.length === 0 || !content || isSending}\r\n                className=\"bg-blue-600 hover:bg-blue-700\"\r\n              >\r\n                {isSending ? (\r\n                  <span className=\"animate-spin mr-2\"></span>\r\n                ) : (\r\n                  <>\r\n                    <Send className=\"w-4 h-4 mr-2\" />\r\n                    Send to {selectedCustomers.length} Customer{selectedCustomers.length !== 1 ? 's' : ''}\r\n                  </>\r\n                )}\r\n              </Button>\r\n\r\n\r\n            </div>\r\n          </div>\r\n        )}\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n};\r\n\r\nexport default BulkMessageDialog;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5643, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/messages/PurchaseHistoryTable.tsx"],"sourcesContent":["import React from 'react';\r\nimport { CreditCard, CheckCircle, XCircle, Clock } from 'lucide-react';\r\n\r\ninterface Purchase {\r\n    id: string;\r\n    credits_amount?: number;\r\n    creditsAmount?: number;\r\n    total_cost?: number;\r\n    totalCost?: number;\r\n    payment_phone_number?: string;\r\n    paymentPhoneNumber?: string;\r\n    payment_status?: string;\r\n    paymentStatus?: string;\r\n    payment_method?: string;\r\n    paymentMethod?: string;\r\n    created_at?: string;\r\n    createdAt?: string;\r\n}\r\n\r\ninterface PurchaseHistoryTableProps {\r\n    purchases: Purchase[];\r\n}\r\n\r\nconst formatDate = (dateString: string) => {\r\n    const date = new Date(dateString);\r\n    return date.toLocaleDateString('en-US', {\r\n        month: 'short',\r\n        day: 'numeric',\r\n        year: 'numeric',\r\n        hour: '2-digit',\r\n        minute: '2-digit'\r\n    });\r\n};\r\n\r\nconst PurchaseHistoryTable: React.FC<PurchaseHistoryTableProps> = ({ purchases }) => {\r\n    const getStatusBadge = (status: string) => {\r\n        switch (status.toLowerCase()) {\r\n            case 'completed':\r\n                return (\r\n                    <span className=\"inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800\">\r\n                        <CheckCircle className=\"w-3 h-3\" />\r\n                        Completed\r\n                    </span>\r\n                );\r\n            case 'pending':\r\n                return (\r\n                    <span className=\"inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800\">\r\n                        <Clock className=\"w-3 h-3\" />\r\n                        Pending\r\n                    </span>\r\n                );\r\n            case 'failed':\r\n                return (\r\n                    <span className=\"inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-red-100 text-red-800\">\r\n                        <XCircle className=\"w-3 h-3\" />\r\n                        Failed\r\n                    </span>\r\n                );\r\n            default:\r\n                return (\r\n                    <span className=\"inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-800\">\r\n                        {status}\r\n                    </span>\r\n                );\r\n        }\r\n    };\r\n\r\n    if (purchases.length === 0) {\r\n        return (\r\n            <div className=\"bg-white rounded-lg shadow border p-8 text-center\">\r\n                <CreditCard className=\"w-12 h-12 mx-auto text-gray-400 mb-3\" />\r\n                <h3 className=\"text-lg font-medium text-gray-900 mb-1\">No Purchase History</h3>\r\n                <p className=\"text-sm text-gray-500\">Your credit purchase history will appear here.</p>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    return (\r\n        <div className=\"bg-white rounded-lg shadow border overflow-hidden\">\r\n            <div className=\"px-6 py-4 border-b bg-gray-50\">\r\n                <h3 className=\"text-lg font-semibold text-gray-900 flex items-center gap-2\">\r\n                    <CreditCard className=\"w-5 h-5\" />\r\n                    Purchase History\r\n                </h3>\r\n            </div>\r\n            <div className=\"overflow-x-auto\">\r\n                <table className=\"min-w-full divide-y divide-gray-200\">\r\n                    <thead className=\"bg-gray-50\">\r\n                        <tr>\r\n                            <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\r\n                                Date\r\n                            </th>\r\n                            <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\r\n                                Credits\r\n                            </th>\r\n                            <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\r\n                                Total Cost\r\n                            </th>\r\n                            <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\r\n                                Payment Phone\r\n                            </th>\r\n                            <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\r\n                                Status\r\n                            </th>\r\n                            <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\r\n                                Payment Method\r\n                            </th>\r\n                        </tr>\r\n                    </thead>\r\n                    <tbody className=\"bg-white divide-y divide-gray-200\">\r\n                        {purchases.map((purchase) => (\r\n                            <tr key={purchase.id} className=\"hover:bg-gray-50\">\r\n                                <td className=\"px-6 py-4 whitespace-nowrap text-sm text-gray-900\">\r\n                                    {formatDate(purchase.created_at || purchase.createdAt || '')}\r\n                                </td>\r\n                                <td className=\"px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900\">\r\n                                    {(purchase.credits_amount || purchase.creditsAmount || 0).toLocaleString()} credits\r\n                                </td>\r\n                                <td className=\"px-6 py-4 whitespace-nowrap text-sm text-gray-900\">\r\n                                    UGX {(purchase.total_cost || purchase.totalCost || 0).toLocaleString()}\r\n                                </td>\r\n                                <td className=\"px-6 py-4 whitespace-nowrap text-sm text-gray-600\">\r\n                                    {purchase.payment_phone_number || purchase.paymentPhoneNumber || '-'}\r\n                                </td>\r\n                                <td className=\"px-6 py-4 whitespace-nowrap\">\r\n                                    {getStatusBadge(purchase.payment_status || purchase.paymentStatus || 'pending')}\r\n                                </td>\r\n                                <td className=\"px-6 py-4 whitespace-nowrap text-sm text-gray-600\">\r\n                                    {purchase.payment_method || purchase.paymentMethod || '-'}\r\n                                </td>\r\n                            </tr>\r\n                        ))}\r\n                    </tbody>\r\n                </table>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default PurchaseHistoryTable;\r\n"],"names":[],"mappings":";;;;;AACA;AAAA;AAAA;AAAA;;;AAsBA,MAAM,aAAa,CAAC;IAChB,MAAM,OAAO,IAAI,KAAK;IACtB,OAAO,KAAK,kBAAkB,CAAC,SAAS;QACpC,OAAO;QACP,KAAK;QACL,MAAM;QACN,MAAM;QACN,QAAQ;IACZ;AACJ;AAEA,MAAM,uBAA4D,CAAC,EAAE,SAAS,EAAE;IAC5E,MAAM,iBAAiB,CAAC;QACpB,OAAQ,OAAO,WAAW;YACtB,KAAK;gBACD,qBACI,6LAAC;oBAAK,WAAU;;sCACZ,6LAAC,6OAAW;4BAAC,WAAU;;;;;;wBAAY;;;;;;;YAI/C,KAAK;gBACD,qBACI,6LAAC;oBAAK,WAAU;;sCACZ,6LAAC,gNAAK;4BAAC,WAAU;;;;;;wBAAY;;;;;;;YAIzC,KAAK;gBACD,qBACI,6LAAC;oBAAK,WAAU;;sCACZ,6LAAC,0NAAO;4BAAC,WAAU;;;;;;wBAAY;;;;;;;YAI3C;gBACI,qBACI,6LAAC;oBAAK,WAAU;8BACX;;;;;;QAGjB;IACJ;IAEA,IAAI,UAAU,MAAM,KAAK,GAAG;QACxB,qBACI,6LAAC;YAAI,WAAU;;8BACX,6LAAC,mOAAU;oBAAC,WAAU;;;;;;8BACtB,6LAAC;oBAAG,WAAU;8BAAyC;;;;;;8BACvD,6LAAC;oBAAE,WAAU;8BAAwB;;;;;;;;;;;;IAGjD;IAEA,qBACI,6LAAC;QAAI,WAAU;;0BACX,6LAAC;gBAAI,WAAU;0BACX,cAAA,6LAAC;oBAAG,WAAU;;sCACV,6LAAC,mOAAU;4BAAC,WAAU;;;;;;wBAAY;;;;;;;;;;;;0BAI1C,6LAAC;gBAAI,WAAU;0BACX,cAAA,6LAAC;oBAAM,WAAU;;sCACb,6LAAC;4BAAM,WAAU;sCACb,cAAA,6LAAC;;kDACG,6LAAC;wCAAG,WAAU;kDAAiF;;;;;;kDAG/F,6LAAC;wCAAG,WAAU;kDAAiF;;;;;;kDAG/F,6LAAC;wCAAG,WAAU;kDAAiF;;;;;;kDAG/F,6LAAC;wCAAG,WAAU;kDAAiF;;;;;;kDAG/F,6LAAC;wCAAG,WAAU;kDAAiF;;;;;;kDAG/F,6LAAC;wCAAG,WAAU;kDAAiF;;;;;;;;;;;;;;;;;sCAKvG,6LAAC;4BAAM,WAAU;sCACZ,UAAU,GAAG,CAAC,CAAC,yBACZ,6LAAC;oCAAqB,WAAU;;sDAC5B,6LAAC;4CAAG,WAAU;sDACT,WAAW,SAAS,UAAU,IAAI,SAAS,SAAS,IAAI;;;;;;sDAE7D,6LAAC;4CAAG,WAAU;;gDACT,CAAC,SAAS,cAAc,IAAI,SAAS,aAAa,IAAI,CAAC,EAAE,cAAc;gDAAG;;;;;;;sDAE/E,6LAAC;4CAAG,WAAU;;gDAAoD;gDACzD,CAAC,SAAS,UAAU,IAAI,SAAS,SAAS,IAAI,CAAC,EAAE,cAAc;;;;;;;sDAExE,6LAAC;4CAAG,WAAU;sDACT,SAAS,oBAAoB,IAAI,SAAS,kBAAkB,IAAI;;;;;;sDAErE,6LAAC;4CAAG,WAAU;sDACT,eAAe,SAAS,cAAc,IAAI,SAAS,aAAa,IAAI;;;;;;sDAEzE,6LAAC;4CAAG,WAAU;sDACT,SAAS,cAAc,IAAI,SAAS,aAAa,IAAI;;;;;;;mCAjBrD,SAAS,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BhD;KAvGM;uCAyGS"}},
    {"offset": {"line": 5960, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/messages/UsageHistoryTable.tsx"],"sourcesContent":["import React, { useState } from 'react';\r\nimport { MessageSquare, CheckCircle, XCircle, Clock, Send } from 'lucide-react';\r\n\r\ninterface Message {\r\n    id: string;\r\n    content: string;\r\n    phone_number?: string;\r\n    phoneNumber?: string;\r\n    sms_credits_used?: number;\r\n    smsCreditsUsed?: number;\r\n    status: string;\r\n    sent_at?: string;\r\n    sentAt?: string;\r\n    created_at?: string;\r\n    createdAt?: string;\r\n}\r\n\r\ninterface UsageHistoryTableProps {\r\n    messages: Message[];\r\n}\r\n\r\nconst formatDate = (dateString: string) => {\r\n    const date = new Date(dateString);\r\n    return date.toLocaleDateString('en-US', {\r\n        month: 'short',\r\n        day: 'numeric',\r\n        year: 'numeric',\r\n        hour: '2-digit',\r\n        minute: '2-digit'\r\n    });\r\n};\r\n\r\nconst UsageHistoryTable: React.FC<UsageHistoryTableProps> = ({ messages }) => {\r\n    const [expandedMessageId, setExpandedMessageId] = useState<string | null>(null);\r\n\r\n    const getStatusBadge = (status: string) => {\r\n        switch (status.toLowerCase()) {\r\n            case 'sent':\r\n            case 'delivered':\r\n                return (\r\n                    <span className=\"inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800\">\r\n                        <CheckCircle className=\"w-3 h-3\" />\r\n                        {status === 'delivered' ? 'Delivered' : 'Sent'}\r\n                    </span>\r\n                );\r\n            case 'pending':\r\n                return (\r\n                    <span className=\"inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800\">\r\n                        <Clock className=\"w-3 h-3\" />\r\n                        Pending\r\n                    </span>\r\n                );\r\n            case 'failed':\r\n                return (\r\n                    <span className=\"inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-red-100 text-red-800\">\r\n                        <XCircle className=\"w-3 h-3\" />\r\n                        Failed\r\n                    </span>\r\n                );\r\n            default:\r\n                return (\r\n                    <span className=\"inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-800\">\r\n                        {status}\r\n                    </span>\r\n                );\r\n        }\r\n    };\r\n\r\n    const truncateMessage = (content: string, maxLength: number = 50) => {\r\n        if (content.length <= maxLength) return content;\r\n        return content.substring(0, maxLength) + '...';\r\n    };\r\n\r\n    if (messages.length === 0) {\r\n        return (\r\n            <div className=\"bg-white rounded-lg shadow border p-8 text-center\">\r\n                <Send className=\"w-12 h-12 mx-auto text-gray-400 mb-3\" />\r\n                <h3 className=\"text-lg font-medium text-gray-900 mb-1\">No Usage History</h3>\r\n                <p className=\"text-sm text-gray-500\">Your sent messages will appear here.</p>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    return (\r\n        <div className=\"bg-white rounded-lg shadow border overflow-hidden\">\r\n            <div className=\"px-6 py-4 border-b bg-gray-50\">\r\n                <h3 className=\"text-lg font-semibold text-gray-900 flex items-center gap-2\">\r\n                    <MessageSquare className=\"w-5 h-5\" />\r\n                    Usage History\r\n                </h3>\r\n            </div>\r\n            <div className=\"overflow-x-auto\">\r\n                <table className=\"min-w-full divide-y divide-gray-200\">\r\n                    <thead className=\"bg-gray-50\">\r\n                        <tr>\r\n                            <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\r\n                                Date Sent\r\n                            </th>\r\n                            <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\r\n                                Phone Number\r\n                            </th>\r\n                            <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\r\n                                Message\r\n                            </th>\r\n                            <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\r\n                                Credits Used\r\n                            </th>\r\n                            <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\r\n                                Status\r\n                            </th>\r\n                        </tr>\r\n                    </thead>\r\n                    <tbody className=\"bg-white divide-y divide-gray-200\">\r\n                        {messages.map((message) => {\r\n                            const creditsUsed = message.sms_credits_used || message.smsCreditsUsed || 0;\r\n                            return (\r\n                                <tr key={message.id} className=\"hover:bg-gray-50\">\r\n                                    <td className=\"px-6 py-4 whitespace-nowrap text-sm text-gray-900\">\r\n                                        {formatDate(message.sent_at || message.sentAt || message.created_at || message.createdAt || '')}\r\n                                    </td>\r\n                                    <td className=\"px-6 py-4 whitespace-nowrap text-sm text-gray-600\">\r\n                                        {message.phone_number || message.phoneNumber || '-'}\r\n                                    </td>\r\n                                    <td className=\"px-6 py-4 text-sm text-gray-900 max-w-md\">\r\n                                        <div>\r\n                                            {expandedMessageId === message.id ? (\r\n                                                <div className=\"whitespace-pre-wrap\">\r\n                                                    {message.content}\r\n                                                    <button\r\n                                                        onClick={() => setExpandedMessageId(null)}\r\n                                                        className=\"text-blue-600 hover:text-blue-800 ml-2 text-xs\"\r\n                                                    >\r\n                                                        Show less\r\n                                                    </button>\r\n                                                </div>\r\n                                            ) : (\r\n                                                <div>\r\n                                                    {truncateMessage(message.content)}\r\n                                                    {message.content.length > 50 && (\r\n                                                        <button\r\n                                                            onClick={() => setExpandedMessageId(message.id)}\r\n                                                            className=\"text-blue-600 hover:text-blue-800 ml-2 text-xs\"\r\n                                                        >\r\n                                                            Show more\r\n                                                        </button>\r\n                                                    )}\r\n                                                </div>\r\n                                            )}\r\n                                        </div>\r\n                                    </td>\r\n                                    <td className=\"px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900\">\r\n                                        {creditsUsed} credit{creditsUsed > 1 ? 's' : ''}\r\n                                    </td>\r\n                                    <td className=\"px-6 py-4 whitespace-nowrap\">\r\n                                        {getStatusBadge(message.status)}\r\n                                    </td>\r\n                                </tr>\r\n                            );\r\n                        })}\r\n                    </tbody>\r\n                </table>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default UsageHistoryTable;\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAoBA,MAAM,aAAa,CAAC;IAChB,MAAM,OAAO,IAAI,KAAK;IACtB,OAAO,KAAK,kBAAkB,CAAC,SAAS;QACpC,OAAO;QACP,KAAK;QACL,MAAM;QACN,MAAM;QACN,QAAQ;IACZ;AACJ;AAEA,MAAM,oBAAsD,CAAC,EAAE,QAAQ,EAAE;;IACrE,MAAM,CAAC,mBAAmB,qBAAqB,GAAG,IAAA,yKAAQ,EAAgB;IAE1E,MAAM,iBAAiB,CAAC;QACpB,OAAQ,OAAO,WAAW;YACtB,KAAK;YACL,KAAK;gBACD,qBACI,6LAAC;oBAAK,WAAU;;sCACZ,6LAAC,6OAAW;4BAAC,WAAU;;;;;;wBACtB,WAAW,cAAc,cAAc;;;;;;;YAGpD,KAAK;gBACD,qBACI,6LAAC;oBAAK,WAAU;;sCACZ,6LAAC,gNAAK;4BAAC,WAAU;;;;;;wBAAY;;;;;;;YAIzC,KAAK;gBACD,qBACI,6LAAC;oBAAK,WAAU;;sCACZ,6LAAC,0NAAO;4BAAC,WAAU;;;;;;wBAAY;;;;;;;YAI3C;gBACI,qBACI,6LAAC;oBAAK,WAAU;8BACX;;;;;;QAGjB;IACJ;IAEA,MAAM,kBAAkB,CAAC,SAAiB,YAAoB,EAAE;QAC5D,IAAI,QAAQ,MAAM,IAAI,WAAW,OAAO;QACxC,OAAO,QAAQ,SAAS,CAAC,GAAG,aAAa;IAC7C;IAEA,IAAI,SAAS,MAAM,KAAK,GAAG;QACvB,qBACI,6LAAC;YAAI,WAAU;;8BACX,6LAAC,6MAAI;oBAAC,WAAU;;;;;;8BAChB,6LAAC;oBAAG,WAAU;8BAAyC;;;;;;8BACvD,6LAAC;oBAAE,WAAU;8BAAwB;;;;;;;;;;;;IAGjD;IAEA,qBACI,6LAAC;QAAI,WAAU;;0BACX,6LAAC;gBAAI,WAAU;0BACX,cAAA,6LAAC;oBAAG,WAAU;;sCACV,6LAAC,4OAAa;4BAAC,WAAU;;;;;;wBAAY;;;;;;;;;;;;0BAI7C,6LAAC;gBAAI,WAAU;0BACX,cAAA,6LAAC;oBAAM,WAAU;;sCACb,6LAAC;4BAAM,WAAU;sCACb,cAAA,6LAAC;;kDACG,6LAAC;wCAAG,WAAU;kDAAiF;;;;;;kDAG/F,6LAAC;wCAAG,WAAU;kDAAiF;;;;;;kDAG/F,6LAAC;wCAAG,WAAU;kDAAiF;;;;;;kDAG/F,6LAAC;wCAAG,WAAU;kDAAiF;;;;;;kDAG/F,6LAAC;wCAAG,WAAU;kDAAiF;;;;;;;;;;;;;;;;;sCAKvG,6LAAC;4BAAM,WAAU;sCACZ,SAAS,GAAG,CAAC,CAAC;gCACX,MAAM,cAAc,QAAQ,gBAAgB,IAAI,QAAQ,cAAc,IAAI;gCAC1E,qBACI,6LAAC;oCAAoB,WAAU;;sDAC3B,6LAAC;4CAAG,WAAU;sDACT,WAAW,QAAQ,OAAO,IAAI,QAAQ,MAAM,IAAI,QAAQ,UAAU,IAAI,QAAQ,SAAS,IAAI;;;;;;sDAEhG,6LAAC;4CAAG,WAAU;sDACT,QAAQ,YAAY,IAAI,QAAQ,WAAW,IAAI;;;;;;sDAEpD,6LAAC;4CAAG,WAAU;sDACV,cAAA,6LAAC;0DACI,sBAAsB,QAAQ,EAAE,iBAC7B,6LAAC;oDAAI,WAAU;;wDACV,QAAQ,OAAO;sEAChB,6LAAC;4DACG,SAAS,IAAM,qBAAqB;4DACpC,WAAU;sEACb;;;;;;;;;;;6GAKL,6LAAC;;wDACI,gBAAgB,QAAQ,OAAO;wDAC/B,QAAQ,OAAO,CAAC,MAAM,GAAG,oBACtB,6LAAC;4DACG,SAAS,IAAM,qBAAqB,QAAQ,EAAE;4DAC9C,WAAU;sEACb;;;;;;;;;;;;;;;;;;;;;;sDAQrB,6LAAC;4CAAG,WAAU;;gDACT;gDAAY;gDAAQ,cAAc,IAAI,MAAM;;;;;;;sDAEjD,6LAAC;4CAAG,WAAU;sDACT,eAAe,QAAQ,MAAM;;;;;;;mCAtC7B,QAAQ,EAAE;;;;;4BA0C3B;;;;;;;;;;;;;;;;;;;;;;;AAMxB;GApIM;KAAA;uCAsIS"}},
    {"offset": {"line": 6315, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/tabs.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Tabs = TabsPrimitive.Root\r\n\r\nconst TabsList = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.List>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.List\r\n    ref={ref}\r\n    className={cn(\r\n      \"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTabsList.displayName = TabsPrimitive.List.displayName\r\n\r\nconst TabsTrigger = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.Trigger\r\n    ref={ref}\r\n    className={cn(\r\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\r\n\r\nconst TabsContent = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.Content\r\n    ref={ref}\r\n    className={cn(\r\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTabsContent.displayName = TabsPrimitive.Content.displayName\r\n\r\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\r\n"],"names":[],"mappings":";;;;;;;;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,OAAO,2KAAkB;AAE/B,MAAM,yBAAW,2KAAgB,MAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,2KAAkB;QACjB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,8FACA;QAED,GAAG,KAAK;;;;;;;AAGb,SAAS,WAAW,GAAG,2KAAkB,CAAC,WAAW;AAErD,MAAM,4BAAc,2KAAgB,OAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,8KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,uYACA;QAED,GAAG,KAAK;;;;;;;AAGb,YAAY,WAAW,GAAG,8KAAqB,CAAC,WAAW;AAE3D,MAAM,4BAAc,2KAAgB,OAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,8KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,mIACA;QAED,GAAG,KAAK;;;;;;;AAGb,YAAY,WAAW,GAAG,8KAAqB,CAAC,WAAW"}},
    {"offset": {"line": 6382, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/pages/Messages.tsx"],"sourcesContent":["import React, { useState, useCallback } from 'react';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useMessages, Message, MessageTemplate, Purchase } from '@/hooks/useMessages';\r\nimport { useCustomers } from '@/hooks/useCustomers';\r\nimport { useProfiles } from '@/contexts/ProfileContext';\r\nimport MessageHeader from '@/components/messages/MessageHeader';\r\nimport MessageStatsCards from '@/components/messages/MessageStatsCards';\r\nimport MessageContent from '@/components/messages/MessageContent';\r\nimport NewMessageDialog from '@/components/messages/NewMessageDialog';\r\nimport MessageTemplateDialog from '@/components/messages/MessageTemplateDialog';\r\nimport TopUpCreditsDialog from '@/components/messages/TopUpCreditsDialog';\r\nimport BulkMessageDialog from '@/components/messages/BulkMessageDialog';\r\nimport PurchaseHistoryTable from '@/components/messages/PurchaseHistoryTable';\r\nimport UsageHistoryTable from '@/components/messages/UsageHistoryTable';\r\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\r\nimport { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';\r\nimport { AlertCircle, ArrowLeft } from 'lucide-react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { Button } from '@/components/ui/button';\r\n\r\nconst Messages = () => {\r\n  const { user } = useAuth();\r\n  const { currentBusiness, isLoading: businessLoading } = useBusiness();\r\n  const { currentProfile, hasPermission, isLoading: profilesLoading } = useProfiles();\r\n  const navigate = useNavigate();\r\n\r\n  // Permissions\r\n  const canView = hasPermission('messages', 'view');\r\n  const canCreate = hasPermission('messages', 'create');\r\n  const canEdit = hasPermission('messages', 'edit');\r\n  const canDelete = hasPermission('messages', 'delete');\r\n  const { messages, templates, purchases, isLoading, createMessage, createBulkMessages, createTemplate, updateTemplate, deleteTemplate, initiateCreditPurchase, getMessageStats } = useMessages(user?.id);\r\n\r\n  const { customers } = useCustomers();\r\n\r\n  const [newMessageOpen, setNewMessageOpen] = useState(false);\r\n  const [newTemplateOpen, setNewTemplateOpen] = useState(false);\r\n  const [bulkMessageOpen, setBulkMessageOpen] = useState(false);\r\n  const [topUpOpen, setTopUpOpen] = useState(false);\r\n  const [selectedTemplate, setSelectedTemplate] = useState<MessageTemplate | undefined>(undefined);\r\n  const [activeTab, setActiveTab] = useState('messages');\r\n  const [searchTerm, setSearchTerm] = useState('');\r\n  const [statusFilter, setStatusFilter] = useState<string>('all');\r\n\r\n  const stats = getMessageStats();\r\n\r\n  const handleSendMessage = async (messageData: {\r\n    phoneNumber: string;\r\n    content: string;\r\n    customerId?: string;\r\n    templateId?: string;\r\n  }) => {\r\n    try {\r\n      await createMessage(messageData);\r\n      return { success: 1, failed: 0, errors: [] };\r\n    } catch (error) {\r\n      console.error('Failed to send message:', error);\r\n      return { success: 0, failed: 1, errors: [error instanceof Error ? error.message : 'Unknown error'] };\r\n    }\r\n  };\r\n\r\n\r\n  const handleBulkSend = useCallback(async (data: {\r\n    customerIds: string[];\r\n    content: string;\r\n    templateId?: string;\r\n  }) => {\r\n    try {\r\n      const result = await createBulkMessages(data);\r\n      return result;\r\n    } catch (error) {\r\n      console.error('Failed to send bulk messages:', error);\r\n      alert(error instanceof Error ? error.message : 'Failed to send messages');\r\n      return { success: 0, failed: 0, errors: [error instanceof Error ? error.message : 'Unknown error'] };\r\n    }\r\n  }, [createBulkMessages]);\r\n\r\n  const handleSaveTemplate = useCallback(async (templateData: Omit<MessageTemplate, 'id' | 'userId' | 'locationId' | 'createdAt' | 'updatedAt'>) => {\r\n    if (selectedTemplate) {\r\n      await updateTemplate(selectedTemplate.id, templateData);\r\n    } else {\r\n      await createTemplate(templateData);\r\n    }\r\n    setNewTemplateOpen(false);\r\n    setSelectedTemplate(undefined);\r\n    return true;\r\n  }, [selectedTemplate, updateTemplate, createTemplate]);\r\n\r\n  const handleEditTemplate = useCallback((template: MessageTemplate) => {\r\n    setSelectedTemplate(template);\r\n    setNewTemplateOpen(true);\r\n  }, []);\r\n\r\n  const handleDeleteTemplate = useCallback(async (templateId: string) => {\r\n    if (confirm('Are you sure you want to delete this template?')) {\r\n      await deleteTemplate(templateId);\r\n    }\r\n  }, [deleteTemplate]);\r\n\r\n\r\n  const handleTopUpCredits = useCallback(async (credits: number, phoneNumber: string) => {\r\n    try {\r\n      const result = await initiateCreditPurchase(credits, phoneNumber);\r\n      // Redirect to payment page\r\n      window.open(result.redirectUrl, '_blank');\r\n      setTopUpOpen(false);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to initiate top-up:', error);\r\n      alert(error instanceof Error ? error.message : 'Failed to initiate payment');\r\n      return false;\r\n    }\r\n  }, [initiateCreditPurchase]);\r\n\r\n  if (businessLoading || !currentBusiness || isLoading || profilesLoading) {\r\n    return (\r\n      <div className=\"flex items-center justify-center h-96\">\r\n        <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600\"></div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!canView) {\r\n    return (\r\n      <div className=\"max-w-4xl mx-auto p-6\">\r\n        <Alert variant=\"destructive\">\r\n          <AlertCircle className=\"h-4 w-4\" />\r\n          <AlertTitle>Access Denied</AlertTitle>\r\n          <AlertDescription>\r\n            You do not have permission to view the messaging module.\r\n            Please contact your administrator if you believe this is an error.\r\n          </AlertDescription>\r\n        </Alert>\r\n        <div className=\"mt-4\">\r\n          <Button onClick={() => navigate('/')} variant=\"outline\" className=\"gap-2\">\r\n            <ArrowLeft className=\"h-4 w-4\" />\r\n            Back to Dashboard\r\n          </Button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const filteredMessages = messages.filter(msg => {\r\n    const phone = msg.phoneNumber || '';\r\n    const text = msg.content || '';\r\n    const matchesSearch = phone.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n      text.toLowerCase().includes(searchTerm.toLowerCase());\r\n    const matchesStatus = statusFilter === 'all' || msg.status === statusFilter;\r\n    return matchesSearch && matchesStatus;\r\n  });\r\n\r\n\r\n  return (\r\n    <div className=\"space-y-8\">\r\n      {/* Header Section */}\r\n      <MessageHeader\r\n        onNewMessage={() => setNewMessageOpen(true)}\r\n        onNewTemplate={() => {\r\n          setSelectedTemplate(undefined);\r\n          setNewTemplateOpen(true);\r\n        }}\r\n        onTopUp={() => setTopUpOpen(true)}\r\n        onBulkMessage={() => setBulkMessageOpen(true)}\r\n        smsCredits={currentProfile?.sms_credits || 0}\r\n        canCreate={canCreate}\r\n      />\r\n\r\n      {/* Stats Cards */}\r\n      <MessageStatsCards stats={stats} />\r\n\r\n      {/* Main Content */}\r\n      <Tabs value={activeTab} onValueChange={setActiveTab} className=\"w-full\">\r\n        <TabsList className=\"grid w-full max-w-2xl grid-cols-3\">\r\n          <TabsTrigger value=\"messages\">Messages</TabsTrigger>\r\n          <TabsTrigger value=\"templates\">Templates</TabsTrigger>\r\n          <TabsTrigger value=\"history\">History</TabsTrigger>\r\n        </TabsList>\r\n\r\n        <TabsContent value=\"messages\" className=\"space-y-4 mt-6\">\r\n          <MessageContent\r\n            messages={filteredMessages}\r\n            customers={customers}\r\n            searchTerm={searchTerm}\r\n            setSearchTerm={setSearchTerm}\r\n            statusFilter={statusFilter}\r\n            setStatusFilter={setStatusFilter}\r\n          />\r\n        </TabsContent>\r\n\r\n        <TabsContent value=\"templates\" className=\"space-y-4 mt-6\">\r\n          <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\r\n            {templates.map(template => (\r\n              <div\r\n                key={template.id}\r\n                className=\"bg-white p-4 rounded-lg shadow border hover:shadow-md transition-shadow\"\r\n              >\r\n                <div className=\"flex justify-between items-start mb-2\">\r\n                  <h3 className=\"font-semibold text-lg\">{template.name}</h3>\r\n                  <div className=\"flex gap-2\">\r\n                    {canEdit && (\r\n                      <button\r\n                        onClick={() => handleEditTemplate(template)}\r\n                        className=\"text-blue-600 hover:text-blue-800 text-sm\"\r\n                      >\r\n                        Edit\r\n                      </button>\r\n                    )}\r\n                    {canDelete && (\r\n                      <button\r\n                        onClick={() => handleDeleteTemplate(template.id)}\r\n                        className=\"text-red-600 hover:text-red-800 text-sm\"\r\n                      >\r\n                        Delete\r\n                      </button>\r\n                    )}\r\n                  </div>\r\n                </div>\r\n                {template.category && (\r\n                  <span className=\"text-xs px-2 py-1 bg-gray-100 rounded-full text-gray-600\">\r\n                    {template.category}\r\n                  </span>\r\n                )}\r\n                <p className=\"text-sm text-gray-600 mt-2 line-clamp-3\">\r\n                  {template.content}\r\n                </p>\r\n                {template.variables.length > 0 && (\r\n                  <div className=\"mt-2 flex flex-wrap gap-1\">\r\n                    {template.variables.map(v => (\r\n                      <span key={v} className=\"text-xs px-2 py-0.5 bg-blue-50 text-blue-600 rounded\">\r\n                        {v}\r\n                      </span>\r\n                    ))}\r\n                  </div>\r\n                )}\r\n              </div>\r\n            ))}\r\n          </div>\r\n        </TabsContent>\r\n\r\n        <TabsContent value=\"history\" className=\"space-y-6 mt-6\">\r\n          <PurchaseHistoryTable purchases={purchases} />\r\n          <UsageHistoryTable messages={messages} />\r\n        </TabsContent>\r\n      </Tabs>\r\n\r\n      {/* Dialogs */}\r\n\r\n      <MessageTemplateDialog\r\n        open={newTemplateOpen}\r\n        onClose={() => {\r\n          setNewTemplateOpen(false);\r\n          setSelectedTemplate(undefined);\r\n        }}\r\n        onSave={handleSaveTemplate}\r\n        initialData={selectedTemplate}\r\n      />\r\n\r\n      <TopUpCreditsDialog\r\n        open={topUpOpen}\r\n        onClose={() => setTopUpOpen(false)}\r\n        onTopUp={handleTopUpCredits}\r\n      />\r\n\r\n      <NewMessageDialog\r\n        open={newMessageOpen}\r\n        onClose={() => setNewMessageOpen(false)}\r\n        onSend={handleSendMessage}\r\n        customers={customers}\r\n        templates={templates}\r\n      />\r\n\r\n      <BulkMessageDialog\r\n        open={bulkMessageOpen}\r\n        onClose={() => setBulkMessageOpen(false)}\r\n        onSend={handleBulkSend}\r\n        customers={customers}\r\n        templates={templates}\r\n        searchTerm={searchTerm}       // reuse parent searchTerm\r\n        setSearchTerm={setSearchTerm} // reuse parent setter\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Messages;"],"names":[],"mappings":"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"}}]
}