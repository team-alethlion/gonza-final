{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/badge.tsx"],"sourcesContent":["\r\nimport * as React from \"react\"\r\nimport { cva, type VariantProps } from \"class-variance-authority\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst badgeVariants = cva(\r\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default:\r\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\r\n        secondary:\r\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        destructive:\r\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\r\n        outline: \"text-foreground\",\r\n        warning:\r\n          \"border-transparent bg-amber-500 text-white hover:bg-amber-600\",\r\n        success:\r\n          \"border-transparent bg-green-600 text-white hover:bg-green-700\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n    },\r\n  }\r\n)\r\n\r\nexport interface BadgeProps\r\n  extends React.HTMLAttributes<HTMLDivElement>,\r\n    VariantProps<typeof badgeVariants> {}\r\n\r\nfunction Badge({ className, variant, ...props }: BadgeProps) {\r\n  return (\r\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\r\n  )\r\n}\r\n\r\nexport { Badge, badgeVariants }\r\n"],"names":[],"mappings":";;;;;;;AAEA;AAEA;;;;AAEA,MAAM,gBAAgB,IAAA,0KAAG,EACvB,0KACA;IACE,UAAU;QACR,SAAS;YACP,SACE;YACF,WACE;YACF,aACE;YACF,SAAS;YACT,SACE;YACF,SACE;QACJ;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAOF,SAAS,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAmB;IACzD,qBACE,6LAAC;QAAI,WAAW,IAAA,4HAAE,EAAC,cAAc;YAAE;QAAQ,IAAI;QAAa,GAAG,KAAK;;;;;;AAExE;KAJS"}},
    {"offset": {"line": 54, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/business-settings.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function getBusinessSettingsAction(branchId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId }\r\n        });\r\n\r\n        if (!settings) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            id: settings.id,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            currency: settings.currency,\r\n            signature: settings.signatureImage,\r\n            metadata: settings.metadata || {}\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching business settings:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function upsertBusinessSettingsAction(branchId: string, userId: string, updateData: any) {\r\n    try {\r\n        // Validate user access to branch\r\n        const branch = await db.branch.findFirst({\r\n            where: {\r\n                id: branchId,\r\n                OR: [\r\n                    { adminId: userId },\r\n                    { users: { some: { id: userId } } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!branch) {\r\n            return { success: false, error: 'Unauthorized to update branch settings' };\r\n        }\r\n\r\n        const data = {\r\n            businessName: updateData.business_name,\r\n            address: updateData.business_address,\r\n            phone: updateData.business_phone,\r\n            email: updateData.business_email,\r\n            logo: updateData.business_logo,\r\n            currency: updateData.currency,\r\n            signatureImage: updateData.signature,\r\n            metadata: updateData.metadata\r\n        };\r\n\r\n        const upserted = await db.branchSettings.upsert({\r\n            where: { branchId: branchId },\r\n            update: data,\r\n            create: {\r\n                branchId: branchId,\r\n                ...data\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: upserted.id,\r\n                business_name: upserted.businessName,\r\n                business_address: upserted.address,\r\n                business_phone: upserted.phone,\r\n                business_email: upserted.email,\r\n                business_logo: upserted.logo,\r\n                currency: upserted.currency,\r\n                signature: upserted.signatureImage,\r\n                metadata: upserted.metadata\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error upserting business settings:', error);\r\n        return { success: false, error: error.message || 'Failed to update settings' };\r\n    }\r\n}\r\n\r\nexport async function getAccountStatusAction(userId: string) {\r\n    try {\r\n        const user = await db.user.findUnique({\r\n            where: { id: userId },\r\n            select: {\r\n                isFrozen: true,\r\n                createdAt: true,\r\n                subscriptions: {\r\n                    where: { status: 'active' },\r\n                    orderBy: { endDate: 'desc' },\r\n                    take: 1\r\n                },\r\n                branches: {\r\n                    select: { id: true }\r\n                }\r\n            }\r\n        });\r\n\r\n        if (!user) return null;\r\n\r\n        const activeSub = user.subscriptions[0];\r\n        const now = new Date();\r\n        const daysRemaining = activeSub ? Math.ceil((activeSub.endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)) : 0;\r\n\r\n        return {\r\n            is_frozen: user.isFrozen,\r\n            location_limit: 1, // Traditional limit or from subscription\r\n            billing_amount: activeSub ? Number(activeSub.amount) : 50000,\r\n            billing_duration: 'Monthly',\r\n            days_remaining: Math.max(0, daysRemaining),\r\n            next_billing_date: activeSub?.endDate.toISOString() || ''\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching account status:', error);\r\n        return { is_frozen: false, location_limit: 1, billing_amount: 50000, billing_duration: 'Monthly', days_remaining: 30, next_billing_date: '' };\r\n    }\r\n}\r\n\r\nexport async function getOnboardingStatusAction(locationId: string) {\r\n    try {\r\n        const settings = await db.branchSettings.findUnique({\r\n            where: { branchId: locationId }\r\n        });\r\n\r\n        if (!settings) return null;\r\n\r\n        return {\r\n            id: settings.id,\r\n            location_id: settings.branchId,\r\n            business_name: settings.businessName,\r\n            business_address: settings.address,\r\n            business_phone: settings.phone,\r\n            business_email: settings.email,\r\n            business_logo: settings.logo,\r\n            completed: !!settings.businessName && !!settings.phone, // Simplified completion check\r\n            is_frozen: false // Should come from branch or user status\r\n        };\r\n    } catch (error) {\r\n        console.error('Error fetching onboarding status:', error);\r\n        return null;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6DAAA"}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useBusinessSettings.ts"],"sourcesContent":["\r\nimport { useState, useEffect } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { getBusinessSettingsAction, upsertBusinessSettingsAction } from '@/app/actions/business-settings';\r\n\r\nexport interface BusinessSettings {\r\n  id?: string;\r\n  businessName: string;\r\n  businessAddress: string;\r\n  businessPhone: string;\r\n  businessEmail: string;\r\n  businessLogo?: string;\r\n  currency: string;\r\n  signature?: string;\r\n  paymentInfo?: string;\r\n  defaultPrintFormat?: 'standard' | 'thermal';\r\n  defaultPrinterName?: string;\r\n  defaultPrinterType?: 'USB' | 'Bluetooth';\r\n  printerPaperSize?: '58mm' | '80mm';\r\n}\r\n\r\n// Utility function to parse payment info text into structured format\r\nexport const parsePaymentInfo = (paymentInfo: string): { method: string, accountNumber: string, accountName: string }[] => {\r\n  if (!paymentInfo || paymentInfo.trim() === '') {\r\n    return [];\r\n  }\r\n\r\n  const lines = paymentInfo.split('\\n').filter(line => line.trim() !== '');\r\n  const methods: { method: string, accountNumber: string, accountName: string }[] = [];\r\n\r\n  for (let i = 0; i < lines.length; i += 3) {\r\n    if (i + 2 < lines.length) {\r\n      methods.push({\r\n        method: lines[i].trim(),\r\n        accountNumber: lines[i + 1].trim(),\r\n        accountName: lines[i + 2].trim()\r\n      });\r\n    }\r\n  }\r\n\r\n  return methods;\r\n};\r\n\r\n// Utility function to convert payment methods array back to string format\r\nexport const convertPaymentMethodsToString = (paymentMethods: { method: string, accountNumber: string, accountName: string }[]): string => {\r\n  return paymentMethods\r\n    .filter(pm => pm.method.trim() !== '' || pm.accountNumber.trim() !== '' || pm.accountName.trim() !== '')\r\n    .map(pm => `${pm.method}\\n${pm.accountNumber}\\n${pm.accountName}`)\r\n    .join('\\n');\r\n};\r\n\r\n// Default settings for new businesses\r\nconst getDefaultSettings = (): BusinessSettings => ({\r\n  businessName: '',\r\n  businessAddress: '',\r\n  businessPhone: '',\r\n  businessEmail: '',\r\n  currency: 'UGX',\r\n  paymentInfo: '',\r\n  defaultPrintFormat: 'standard'\r\n});\r\n\r\nexport const useBusinessSettings = () => {\r\n  const [settings, setSettings] = useState<BusinessSettings>(getDefaultSettings());\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const { toast } = useToast();\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const loadSettings = async (): Promise<BusinessSettings> => {\r\n    if (!currentBusiness) {\r\n      return getDefaultSettings();\r\n    }\r\n\r\n    try {\r\n      const data = await getBusinessSettingsAction(currentBusiness.id);\r\n\r\n      if (data) {\r\n        // Extract payment info from metadata\r\n        const paymentInfo = data.metadata && typeof data.metadata === 'object' ?\r\n          (data.metadata as Record<string, unknown>).payment_info as string || '' : '';\r\n\r\n        return {\r\n          id: data.id,\r\n          businessName: data.business_name || '',\r\n          businessAddress: data.business_address || '',\r\n          businessPhone: data.business_phone || '',\r\n          businessEmail: data.business_email || '',\r\n          businessLogo: data.business_logo || undefined,\r\n          currency: data.currency || 'UGX',\r\n          signature: data.signature || undefined,\r\n          paymentInfo: paymentInfo,\r\n          defaultPrintFormat: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_print_format as 'standard' | 'thermal' || 'standard' : 'standard',\r\n          defaultPrinterName: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_name as string || '' : '',\r\n          defaultPrinterType: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).default_printer_type as 'USB' | 'Bluetooth' || 'USB' : 'USB',\r\n          printerPaperSize: data.metadata && typeof data.metadata === 'object' ?\r\n            (data.metadata as Record<string, unknown>).printer_paper_size as '58mm' | '80mm' || '58mm' : '58mm'\r\n        };\r\n      } else {\r\n        return getDefaultSettings();\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to load business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return getDefaultSettings();\r\n    }\r\n  };\r\n\r\n  const updateSettings = async (newSettings: Partial<BusinessSettings>) => {\r\n    if (!currentBusiness) {\r\n      console.error('No business selected for updating settings');\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"No business selected\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const userData = { user: { id: '00000000-0000-0000-0000-000000000000' } }; // Mocked user id for now\r\n\r\n      // Prepare the metadata object with payment info\r\n      const metadata = {\r\n        payment_info: newSettings.hasOwnProperty('paymentInfo') ? newSettings.paymentInfo : settings.paymentInfo || '',\r\n        default_print_format: newSettings.hasOwnProperty('defaultPrintFormat') ? newSettings.defaultPrintFormat : settings.defaultPrintFormat || 'standard',\r\n        default_printer_name: newSettings.hasOwnProperty('defaultPrinterName') ? newSettings.defaultPrinterName : settings.defaultPrinterName || '',\r\n        default_printer_type: newSettings.hasOwnProperty('defaultPrinterType') ? newSettings.defaultPrinterType : settings.defaultPrinterType || 'USB',\r\n        printer_paper_size: newSettings.hasOwnProperty('printerPaperSize') ? newSettings.printerPaperSize : settings.printerPaperSize || '58mm'\r\n      };\r\n\r\n      const updateData = {\r\n        business_name: newSettings.hasOwnProperty('businessName') ? newSettings.businessName : settings.businessName,\r\n        business_address: newSettings.hasOwnProperty('businessAddress') ? newSettings.businessAddress : settings.businessAddress,\r\n        business_phone: newSettings.hasOwnProperty('businessPhone') ? newSettings.businessPhone : settings.businessPhone,\r\n        business_email: newSettings.hasOwnProperty('businessEmail') ? newSettings.businessEmail : settings.businessEmail,\r\n        business_logo: newSettings.hasOwnProperty('businessLogo') ? newSettings.businessLogo : settings.businessLogo,\r\n        currency: newSettings.hasOwnProperty('currency') ? newSettings.currency : settings.currency,\r\n        signature: newSettings.hasOwnProperty('signature') ? newSettings.signature : settings.signature,\r\n        metadata: metadata\r\n      };\r\n\r\n      const response = await upsertBusinessSettingsAction(currentBusiness.id, userData.user.id, updateData);\r\n\r\n      if (!response.success) {\r\n        console.error('Supabase error updating business settings:', response.error);\r\n        throw new Error(response.error);\r\n      }\r\n\r\n      toast({\r\n        title: \"Success\",\r\n        description: \"Business settings updated successfully\"\r\n      });\r\n\r\n      // Refetch settings after update\r\n      refetch();\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating business settings:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Failed to update business settings. Please try again.\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // React Query for settings loading with proper caching\r\n  const { data: queriedData, isLoading: isQueryLoading, isFetching, refetch } = useQuery({\r\n    queryKey: ['businessSettings', currentBusiness?.id],\r\n    queryFn: loadSettings,\r\n    enabled: !!currentBusiness?.id,\r\n    staleTime: 5 * 60_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: false,\r\n    refetchOnReconnect: false,\r\n  });\r\n\r\n  // Sync React Query data with local state\r\n  useEffect(() => {\r\n    if (queriedData) {\r\n      setSettings(queriedData);\r\n    } else if (!currentBusiness) {\r\n      setSettings(getDefaultSettings());\r\n    }\r\n  }, [queriedData, currentBusiness]);\r\n\r\n  // Sync loading state from React Query\r\n  useEffect(() => {\r\n    setIsLoading(isQueryLoading || isFetching);\r\n  }, [isQueryLoading, isFetching]);\r\n\r\n  return {\r\n    settings,\r\n    isLoading,\r\n    updateSettings,\r\n    loadSettings\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 276, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useFinancialVisibility.ts"],"sourcesContent":["import { useProfiles } from '@/contexts/ProfileContext';\r\n\r\n/**\r\n * Hook to handle financial data visibility based on permissions\r\n */\r\nexport const useFinancialVisibility = () => {\r\n    const { hasPermission } = useProfiles();\r\n\r\n    const canViewCostPrice = hasPermission('inventory', 'view_cost_price');\r\n    const canViewProfit = hasPermission('inventory', 'view_profit');\r\n    const canViewSellingPrice = hasPermission('inventory', 'view_selling_price');\r\n\r\n    // Dashboard-specific permissions\r\n    const canViewTotalSales = hasPermission('dashboard', 'view_total_sales');\r\n    const canViewTotalGrossProfit = hasPermission('dashboard', 'view_gross_profit');\r\n    const canViewTotalExpenses = hasPermission('dashboard', 'view_total_expenses');\r\n    const canViewInventoryValue = hasPermission('dashboard', 'view_inventory_value');\r\n    const canViewSalesTypes = hasPermission('dashboard', 'view_sales_types');\r\n    const canViewAvgPrice = hasPermission('dashboard', 'view_avg_price');\r\n    const canViewTotalAmount = hasPermission('dashboard', 'view_total_amount');\r\n\r\n    // Finance and Expenses permissions\r\n    const canManageFinanceAccounts = hasPermission('finance', 'manage_accounts');\r\n    const canViewFinance = hasPermission('finance', 'view');\r\n    const canViewExpenses = hasPermission('expenses', 'view');\r\n    const canCreateExpenses = hasPermission('expenses', 'create');\r\n    const canEditExpenses = hasPermission('expenses', 'edit');\r\n    const canDeleteExpenses = hasPermission('expenses', 'delete');\r\n\r\n    /**\r\n     * Format a financial value or return a hidden indicator\r\n     */\r\n    const formatFinancial = (value: number | null | undefined, type: 'cost' | 'selling' | 'profit'): string => {\r\n        const hasAccess =\r\n            (type === 'cost' && canViewCostPrice) ||\r\n            (type === 'selling' && canViewSellingPrice) ||\r\n            (type === 'profit' && canViewProfit);\r\n\r\n        if (!hasAccess) {\r\n            return '•••';\r\n        }\r\n\r\n        return value?.toLocaleString() || '0';\r\n    };\r\n\r\n    return {\r\n        canViewCostPrice,\r\n        canViewProfit,\r\n        canViewSellingPrice,\r\n        canViewTotalSales,\r\n        canViewTotalGrossProfit,\r\n        canViewTotalExpenses,\r\n        canViewInventoryValue,\r\n        canViewSalesTypes,\r\n        canViewAvgPrice,\r\n        canViewTotalAmount,\r\n        canManageFinanceAccounts,\r\n        canViewFinance,\r\n        canViewExpenses,\r\n        canCreateExpenses,\r\n        canEditExpenses,\r\n        canDeleteExpenses,\r\n        formatFinancial,\r\n    };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;;;AAKO,MAAM,yBAAyB;;IAClC,MAAM,EAAE,aAAa,EAAE,GAAG,IAAA,oJAAW;IAErC,MAAM,mBAAmB,cAAc,aAAa;IACpD,MAAM,gBAAgB,cAAc,aAAa;IACjD,MAAM,sBAAsB,cAAc,aAAa;IAEvD,iCAAiC;IACjC,MAAM,oBAAoB,cAAc,aAAa;IACrD,MAAM,0BAA0B,cAAc,aAAa;IAC3D,MAAM,uBAAuB,cAAc,aAAa;IACxD,MAAM,wBAAwB,cAAc,aAAa;IACzD,MAAM,oBAAoB,cAAc,aAAa;IACrD,MAAM,kBAAkB,cAAc,aAAa;IACnD,MAAM,qBAAqB,cAAc,aAAa;IAEtD,mCAAmC;IACnC,MAAM,2BAA2B,cAAc,WAAW;IAC1D,MAAM,iBAAiB,cAAc,WAAW;IAChD,MAAM,kBAAkB,cAAc,YAAY;IAClD,MAAM,oBAAoB,cAAc,YAAY;IACpD,MAAM,kBAAkB,cAAc,YAAY;IAClD,MAAM,oBAAoB,cAAc,YAAY;IAEpD;;KAEC,GACD,MAAM,kBAAkB,CAAC,OAAkC;QACvD,MAAM,YACF,AAAC,SAAS,UAAU,oBACnB,SAAS,aAAa,uBACtB,SAAS,YAAY;QAE1B,IAAI,CAAC,WAAW;YACZ,OAAO;QACX;QAEA,OAAO,OAAO,oBAAoB;IACtC;IAEA,OAAO;QACH;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACJ;AACJ;GA3Da;;QACiB,oJAAW"}},
    {"offset": {"line": 345, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.branchId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title || '',\r\n                items: (req.items as any) || [],\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- STOCK RECONCILIATION & REPAIRS ---\r\n\r\nexport async function getProductReconciliationAction(businessId: string, productId: string) {\r\n    try {\r\n        const product = await db.product.findUnique({\r\n            where: { id: productId },\r\n            include: { category: true }\r\n        });\r\n\r\n        if (!product) return { success: false, error: 'Product not found' };\r\n\r\n        // Fetch all history entries\r\n        const history = await db.productHistory.findMany({\r\n            where: { productId, locationId: businessId },\r\n            orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n        });\r\n\r\n        // Fetch all sales containing this product\r\n        const sales = await db.sale.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const openingStock = history.length > 0 ? history[0].newStock : 0;\r\n        const openingDate = history.length > 0 ? history[0].createdAt : null;\r\n\r\n        const dailyTransactions = new Map<string, any>();\r\n        let excludedSalesQty = 0;\r\n\r\n        sales.forEach(sale => {\r\n            const items = (sale.items as any[]) || [];\r\n            const soldQty = items\r\n                .filter(item => item.productId === productId)\r\n                .reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);\r\n\r\n            if (soldQty > 0) {\r\n                if (openingDate && sale.date < openingDate) {\r\n                    excludedSalesQty += soldQty;\r\n                } else {\r\n                    const dateStr = sale.date.toISOString().split('T')[0];\r\n                    const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n                    day.itemsSold += soldQty;\r\n                    dailyTransactions.set(dateStr, day);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Movements (excluding initial entry)\r\n        const movements = history.slice(1);\r\n        movements.forEach(h => {\r\n            const dateStr = h.createdAt.toISOString().split('T')[0];\r\n            const delta = h.newStock - h.oldStock;\r\n            const reason = (h.changeReason || '').toLowerCase();\r\n\r\n            const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n\r\n            if (h.type === 'RESTOCK' || reason.includes('purchase') || reason.includes('addition')) {\r\n                day.stockAdded += delta;\r\n            } else if (reason.includes('transfer out')) {\r\n                day.transferOut += Math.abs(delta);\r\n            } else if (reason.includes('customer return')) {\r\n                day.returnIn += delta;\r\n            } else if (reason.includes('return to supplier')) {\r\n                day.returnOut += Math.abs(delta);\r\n            } else if (h.type !== 'SALE') {\r\n                day.adjustments += delta;\r\n            }\r\n            dailyTransactions.set(dateStr, day);\r\n        });\r\n\r\n        const sortedDates = Array.from(dailyTransactions.keys()).sort();\r\n        const dailyBreakdown = [];\r\n        let runningStock = openingStock;\r\n\r\n        for (const date of sortedDates) {\r\n            const day = dailyTransactions.get(date);\r\n            const startingStock = runningStock;\r\n            const endingStock = startingStock - day.itemsSold + day.stockAdded - day.transferOut + day.returnIn - day.returnOut + day.adjustments;\r\n\r\n            dailyBreakdown.push({\r\n                date,\r\n                startingStock,\r\n                ...day,\r\n                endingStock\r\n            });\r\n            runningStock = endingStock;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                product: {\r\n                    id: product.id,\r\n                    name: product.name,\r\n                    quantity: product.stock,\r\n                    itemNumber: product.sku\r\n                },\r\n                currentStock: product.stock,\r\n                calculatedStock: runningStock,\r\n                discrepancy: product.stock - runningStock,\r\n                openingStock,\r\n                openingDate: openingDate?.toISOString(),\r\n                excludedSalesQty,\r\n                dailyBreakdown\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error in reconciliation action:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getStockRepairsPreviewAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true, name: true, stock: true }\r\n        });\r\n\r\n        const brokenChains = [];\r\n\r\n        for (const product of products) {\r\n            const history = await db.productHistory.findMany({\r\n                where: { productId: product.id, locationId: businessId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) continue;\r\n\r\n            let runningQuantity = 0;\r\n            const brokenEntries = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newStock - entry.oldStock;\r\n                const expectedPrev = runningQuantity;\r\n                const expectedNext = expectedPrev + change;\r\n\r\n                if (entry.oldStock !== expectedPrev || entry.newStock !== expectedNext) {\r\n                    brokenEntries.push({\r\n                        entryId: entry.id,\r\n                        createdAt: entry.createdAt.toISOString(),\r\n                        changeReason: entry.changeReason,\r\n                        currentPrevQty: entry.oldStock,\r\n                        currentNewQty: entry.newStock,\r\n                        fixedPrevQty: expectedPrev,\r\n                        fixedNewQty: expectedNext\r\n                    });\r\n                }\r\n                runningQuantity = expectedNext;\r\n            }\r\n\r\n            if (brokenEntries.length > 0 || Math.abs(product.stock - runningQuantity) > 0.001) {\r\n                brokenChains.push({\r\n                    productId: product.id,\r\n                    productName: product.name,\r\n                    totalEntries: history.length,\r\n                    brokenEntries,\r\n                    finalFixedQty: runningQuantity,\r\n                    currentProductQty: product.stock\r\n                });\r\n            }\r\n        }\r\n\r\n        return { success: true, data: brokenChains };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function repairStockChainsAction(businessId: string, productIds?: string[]) {\r\n    try {\r\n        const ids = productIds || (await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true }\r\n        })).map(p => p.id);\r\n\r\n        let repaired = 0;\r\n        let failed = 0;\r\n\r\n        for (const id of ids) {\r\n            try {\r\n                await recalculateStockChainAction(id, businessId);\r\n                repaired++;\r\n            } catch (err) {\r\n                failed++;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: { repaired, failed } };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getActivityByEntityIdsAction(entityIds: string[]) {\r\n    try {\r\n        const records = await db.activityHistory.findMany({\r\n            where: { entityId: { in: entityIds } },\r\n            select: { entityId: true, entityName: true }\r\n        });\r\n        return { success: true, data: records };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message, data: [] };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesAction(entryIds: string[], newDate: string) {\r\n    try {\r\n        await db.productHistory.updateMany({\r\n            where: { id: { in: entryIds } },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAmasB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,mEAAA"}},
    {"offset": {"line": 362, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqQsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,uDAAA"}},
    {"offset": {"line": 379, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/inventory/StockReconciliation.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\r\nimport { Button } from '@/components/ui/button';\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogFooter,\r\n  DialogHeader,\r\n  DialogTitle,\r\n} from '@/components/ui/dialog';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { ScrollArea } from '@/components/ui/scroll-area';\r\nimport { AlertCircle, CheckCircle, TrendingDown, TrendingUp, PackagePlus, PackageMinus } from 'lucide-react';\r\nimport { Product } from '@/types';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { toast } from 'sonner';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { useBusinessSettings } from '@/hooks/useBusinessSettings';\r\nimport { useFinancialVisibility } from '@/hooks/useFinancialVisibility';\r\nimport { getProductReconciliationAction } from '@/app/actions/inventory';\r\nimport { updateProductAction } from '@/app/actions/products';\r\n\r\ninterface StockReconciliationProps {\r\n  product: Product;\r\n  onClose: () => void;\r\n  onReconciled: () => void;\r\n}\r\n\r\ninterface ReconciliationData {\r\n  currentStock: number;\r\n  openingStock: number;\r\n  itemsSold: number;\r\n  stockAdded: number;\r\n  transferOut: number;\r\n  returnIn: number;\r\n  returnOut: number;\r\n  adjustments: number;\r\n  calculatedClosingStock: number;\r\n  discrepancy: number;\r\n  openingDate: string | null;\r\n  excludedSalesQty: number;\r\n  dailyBreakdown: DailyBreakdown[];\r\n}\r\n\r\ninterface DailyBreakdown {\r\n  date: string;\r\n  startingStock: number;\r\n  itemsSold: number;\r\n  stockAdded: number;\r\n  transferOut: number;\r\n  returnIn: number;\r\n  returnOut: number;\r\n  adjustments: number;\r\n  endingStock: number;\r\n}\r\n\r\nconst StockReconciliation: React.FC<StockReconciliationProps> = ({\r\n  product,\r\n  onClose,\r\n  onReconciled,\r\n}) => {\r\n  const { user } = useAuth();\r\n  const { currentBusiness } = useBusiness();\r\n  const { settings } = useBusinessSettings();\r\n  const { canViewCostPrice, canViewSellingPrice, formatFinancial } = useFinancialVisibility();\r\n  const [isApplying, setIsApplying] = useState(false);\r\n  const [showPreview, setShowPreview] = useState(false);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [reconciliationData, setReconciliationData] = useState<ReconciliationData>({\r\n    currentStock: 0,\r\n    openingStock: 0,\r\n    itemsSold: 0,\r\n    stockAdded: 0,\r\n    transferOut: 0,\r\n    returnIn: 0,\r\n    returnOut: 0,\r\n    adjustments: 0,\r\n    calculatedClosingStock: 0,\r\n    discrepancy: 0,\r\n    openingDate: null,\r\n    excludedSalesQty: 0,\r\n    dailyBreakdown: [],\r\n  });\r\n\r\n  // Updated state for price adjustments\r\n  const [adjustedCostPrice, setAdjustedCostPrice] = useState<number>(product.costPrice || 0);\r\n  const [adjustedSellingPrice, setAdjustedSellingPrice] = useState<number>(product.sellingPrice || 0);\r\n\r\n  // Initialize prices when product changes\r\n  useEffect(() => {\r\n    setAdjustedCostPrice(product.costPrice || 0);\r\n    setAdjustedSellingPrice(product.sellingPrice || 0);\r\n  }, [product.id, product.costPrice, product.sellingPrice]);\r\n\r\n  useEffect(() => {\r\n    const calculateReconciliation = async () => {\r\n      if (!currentBusiness?.id) return;\r\n\r\n      setIsLoading(true);\r\n      try {\r\n        const result = await getProductReconciliationAction(currentBusiness.id, product.id);\r\n        if (result.success && result.data) {\r\n          setReconciliationData(result.data as ReconciliationData);\r\n        } else {\r\n          toast.error(result.error || 'Failed to calculate reconciliation data');\r\n        }\r\n      } catch (error) {\r\n        console.error('Error calculating reconciliation:', error);\r\n        toast.error('An unexpected error occurred during reconciliation calculation');\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n\r\n    calculateReconciliation();\r\n  }, [currentBusiness?.id, product.id]);\r\n\r\n  // Valuation calculations\r\n  const currentCostValue = reconciliationData.currentStock * (product.costPrice || 0);\r\n  const currentStockValue = reconciliationData.currentStock * (product.sellingPrice || 0);\r\n\r\n  const reconciledCostValue = reconciliationData.calculatedClosingStock * adjustedCostPrice;\r\n  const reconciledStockValue = reconciliationData.calculatedClosingStock * adjustedSellingPrice;\r\n\r\n  const costValueDiff = reconciledCostValue - currentCostValue;\r\n  const stockValueDiff = reconciledStockValue - currentStockValue;\r\n\r\n  const hasDiscrepancy = Math.abs(reconciliationData.discrepancy) > 0.01;\r\n\r\n  const handleApplyCorrection = async () => {\r\n    if (!user?.id || !currentBusiness?.id) return;\r\n\r\n    setIsApplying(true);\r\n    try {\r\n      // Use the updated updateProductAction which handles history internally\r\n      const result = await updateProductAction(product.id, {\r\n        userId: user.id,\r\n        quantity: reconciliationData.calculatedClosingStock,\r\n        costPrice: adjustedCostPrice,\r\n        sellingPrice: adjustedSellingPrice,\r\n        customChangeReason: 'Stock Reconciliation'\r\n      });\r\n\r\n      if (result) {\r\n        toast.success(\r\n          `Stock reconciled successfully! Corrected ${Math.abs(\r\n            reconciliationData.discrepancy\r\n          ).toFixed(2)} units.`\r\n        );\r\n        onReconciled();\r\n        onClose();\r\n      } else {\r\n        throw new Error('Update failed');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error reconciling stock:', error);\r\n      toast.error('Failed to reconcile stock. Please try again.');\r\n    } finally {\r\n      setIsApplying(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Dialog open onOpenChange={onClose}>\r\n      <DialogContent className=\"max-w-2xl max-h-[90vh] overflow-y-auto\">\r\n        <DialogHeader>\r\n          <DialogTitle className=\"flex items-center gap-2\">\r\n            {hasDiscrepancy ? (\r\n              <AlertCircle className=\"h-5 w-5 text-orange-500\" />\r\n            ) : (\r\n              <CheckCircle className=\"h-5 w-5 text-green-500\" />\r\n            )}\r\n            Stock Reconciliation - {product.name}\r\n          </DialogTitle>\r\n          <DialogDescription>\r\n            Review stock calculations and apply corrections if needed\r\n          </DialogDescription>\r\n        </DialogHeader>\r\n\r\n        {isLoading ? (\r\n          <div className=\"flex items-center justify-center py-8\">\r\n            <div className=\"text-muted-foreground\">Loading reconciliation data...</div>\r\n          </div>\r\n        ) : (\r\n          <div className=\"space-y-4\">\r\n            {/* Summary Cards */}\r\n            <div className=\"grid grid-cols-2 gap-4\">\r\n              <Card>\r\n                <CardHeader className=\"pb-3\">\r\n                  <CardTitle className=\"text-sm font-medium\">Current Stock</CardTitle>\r\n                </CardHeader>\r\n                <CardContent>\r\n                  <div className=\"text-2xl font-bold\">\r\n                    {reconciliationData.currentStock.toFixed(2)}\r\n                  </div>\r\n                </CardContent>\r\n              </Card>\r\n\r\n              <Card>\r\n                <CardHeader className=\"pb-3\">\r\n                  <CardTitle className=\"text-sm font-medium\">\r\n                    Calculated Stock\r\n                  </CardTitle>\r\n                </CardHeader>\r\n                <CardContent>\r\n                  <div className=\"text-2xl font-bold\">\r\n                    {reconciliationData.calculatedClosingStock.toFixed(2)}\r\n                  </div>\r\n                </CardContent>\r\n              </Card>\r\n            </div>\r\n\r\n            {/* Pricing Adjustments */}\r\n            <Card className=\"border-sales-primary/20 bg-sales-primary/5\">\r\n              <CardHeader className=\"pb-3\">\r\n                <CardTitle className=\"text-base flex items-center gap-2\">\r\n                  <TrendingUp className=\"h-4 w-4 text-sales-primary\" />\r\n                  Valuation & Price Adjustment\r\n                </CardTitle>\r\n              </CardHeader>\r\n              <CardContent>\r\n                <div className=\"grid grid-cols-2 gap-6\">\r\n                  {canViewCostPrice && (\r\n                    <div className=\"space-y-2\">\r\n                      <label className=\"text-xs font-semibold text-muted-foreground uppercase tracking-wider\">Adjustment Cost Price</label>\r\n                      <div className=\"relative\">\r\n                        <span className=\"absolute left-3 top-1/2 -translate-y-1/2 text-muted-foreground text-sm\">{settings.currency}</span>\r\n                        <input\r\n                          type=\"number\"\r\n                          value={adjustedCostPrice}\r\n                          onChange={(e) => setAdjustedCostPrice(Number(e.target.value))}\r\n                          className=\"w-full pl-12 pr-4 py-2 bg-white border rounded-md text-sm focus:ring-2 focus:ring-sales-primary/20 outline-none transition-all\"\r\n                        />\r\n                      </div>\r\n                      <p className=\"text-[10px] text-muted-foreground\">Affects Cost Value</p>\r\n                    </div>\r\n                  )}\r\n                  {canViewSellingPrice && (\r\n                    <div className=\"space-y-2\">\r\n                      <label className=\"text-xs font-semibold text-muted-foreground uppercase tracking-wider\">Adjustment Selling Price</label>\r\n                      <div className=\"relative\">\r\n                        <span className=\"absolute left-3 top-1/2 -translate-y-1/2 text-muted-foreground text-sm\">{settings.currency}</span>\r\n                        <input\r\n                          type=\"number\"\r\n                          value={adjustedSellingPrice}\r\n                          onChange={(e) => setAdjustedSellingPrice(Number(e.target.value))}\r\n                          className=\"w-full pl-12 pr-4 py-2 bg-white border rounded-md text-sm focus:ring-2 focus:ring-sales-primary/20 outline-none transition-all\"\r\n                        />\r\n                      </div>\r\n                      <p className=\"text-[10px] text-muted-foreground\">Affects Stock Value</p>\r\n                    </div>\r\n                  )}\r\n                </div>\r\n\r\n                <div className=\"mt-4 pt-4 border-t border-sales-primary/10 grid grid-cols-2 gap-4\">\r\n                  {canViewCostPrice && (\r\n                    <div className=\"p-3 rounded-lg bg-white border shadow-sm\">\r\n                      <p className=\"text-[10px] font-bold text-muted-foreground uppercase mb-1\">Cost Valuation Impact</p>\r\n                      <div className=\"flex items-end justify-between\">\r\n                        <span className={`text-base font-bold ${costValueDiff >= 0 ? 'text-emerald-600' : 'text-rose-600'}`}>\r\n                          {costValueDiff >= 0 ? '+' : ''}{formatFinancial(costValueDiff, 'cost')}\r\n                        </span>\r\n                      </div>\r\n                    </div>\r\n                  )}\r\n                  {canViewSellingPrice && (\r\n                    <div className=\"p-3 rounded-lg bg-white border shadow-sm\">\r\n                      <p className=\"text-[10px] font-bold text-muted-foreground uppercase mb-1\">Stock Valuation Impact</p>\r\n                      <div className=\"flex items-end justify-between\">\r\n                        <span className={`text-base font-bold ${stockValueDiff >= 0 ? 'text-violet-600' : 'text-rose-600'}`}>\r\n                          {stockValueDiff >= 0 ? '+' : ''}{formatFinancial(stockValueDiff, 'selling')}\r\n                        </span>\r\n                      </div>\r\n                    </div>\r\n                  )}\r\n                </div>\r\n              </CardContent>\r\n            </Card>\r\n\r\n            {/* Calculation Breakdown */}\r\n            <Card>\r\n              <CardHeader>\r\n                <CardTitle className=\"text-base\">Stock Calculation Summary</CardTitle>\r\n              </CardHeader>\r\n              <CardContent className=\"space-y-3\">\r\n                <div className=\"flex justify-between items-center\">\r\n                  <span className=\"text-sm text-muted-foreground\">Opening Stock</span>\r\n                  <span className=\"font-medium\">\r\n                    {reconciliationData.openingStock.toFixed(2)}\r\n                  </span>\r\n                </div>\r\n\r\n                <div className=\"flex justify-between items-center text-red-600\">\r\n                  <span className=\"text-sm flex items-center gap-1\">\r\n                    <TrendingDown className=\"h-4 w-4\" />\r\n                    Items Sold\r\n                  </span>\r\n                  <span className=\"font-medium\">\r\n                    - {reconciliationData.itemsSold.toFixed(2)}\r\n                  </span>\r\n                </div>\r\n\r\n                <div className=\"flex justify-between items-center text-emerald-600\">\r\n                  <span className=\"text-sm flex items-center gap-1\">\r\n                    <PackagePlus className=\"h-4 w-4\" />\r\n                    Stock Added\r\n                  </span>\r\n                  <span className=\"font-medium\">\r\n                    + {reconciliationData.stockAdded.toFixed(2)}\r\n                  </span>\r\n                </div>\r\n\r\n                <div className=\"flex justify-between items-center text-orange-600\">\r\n                  <span className=\"text-sm flex items-center gap-1\">\r\n                    <PackageMinus className=\"h-4 w-4\" />\r\n                    Transfer Out\r\n                  </span>\r\n                  <span className=\"font-medium\">\r\n                    - {reconciliationData.transferOut.toFixed(2)}\r\n                  </span>\r\n                </div>\r\n\r\n                <div className=\"flex justify-between items-center text-blue-600\">\r\n                  <span className=\"text-sm flex items-center gap-1\">\r\n                    <PackagePlus className=\"h-4 w-4\" />\r\n                    Return In\r\n                  </span>\r\n                  <span className=\"font-medium\">\r\n                    + {reconciliationData.returnIn.toFixed(2)}\r\n                  </span>\r\n                </div>\r\n\r\n                <div className=\"flex justify-between items-center text-purple-600\">\r\n                  <span className=\"text-sm flex items-center gap-1\">\r\n                    <PackageMinus className=\"h-4 w-4\" />\r\n                    Return Out\r\n                  </span>\r\n                  <span className=\"font-medium\">\r\n                    - {reconciliationData.returnOut.toFixed(2)}\r\n                  </span>\r\n                </div>\r\n\r\n                <div className=\"flex justify-between items-center text-amber-600\">\r\n                  <span className=\"text-sm flex items-center gap-1\">\r\n                    <AlertCircle className=\"h-4 w-4\" />\r\n                    Manual Adjustments\r\n                  </span>\r\n                  <span className=\"font-medium\">\r\n                    {reconciliationData.adjustments > 0 ? '+' : ''}{reconciliationData.adjustments.toFixed(2)}\r\n                  </span>\r\n                </div>\r\n\r\n                <div className=\"border-t pt-3 flex justify-between items-center font-semibold text-lg\">\r\n                  <span>Calculated Closing Stock</span>\r\n                  <span>{reconciliationData.calculatedClosingStock.toFixed(2)}</span>\r\n                </div>\r\n\r\n                {/* Discrepancy */}\r\n                {hasDiscrepancy && (\r\n                  <div\r\n                    className={`border-t pt-3 flex justify-between items-center ${reconciliationData.discrepancy > 0\r\n                      ? 'text-green-600'\r\n                      : 'text-red-600'\r\n                      }`}\r\n                  >\r\n                    <span className=\"font-semibold\">Actual vs Calculated Discrepancy</span>\r\n                    <Badge\r\n                      variant={\r\n                        reconciliationData.discrepancy > 0 ? 'default' : 'destructive'\r\n                      }\r\n                    >\r\n                      {reconciliationData.discrepancy > 0 ? '+' : ''}\r\n                      {reconciliationData.discrepancy.toFixed(2)} units\r\n                    </Badge>\r\n                  </div>\r\n                )}\r\n              </CardContent>\r\n            </Card>\r\n\r\n            {/* Daily Breakdown */}\r\n            <Card>\r\n              <CardHeader>\r\n                <CardTitle className=\"text-base\">Daily Breakdown</CardTitle>\r\n              </CardHeader>\r\n              <CardContent>\r\n                <ScrollArea className=\"h-[300px] pr-4\">\r\n                  <div className=\"space-y-3\">\r\n                    {reconciliationData.dailyBreakdown.length === 0 ? (\r\n                      <div className=\"text-center text-muted-foreground py-8\">\r\n                        No transactions found for this product\r\n                      </div>\r\n                    ) : (\r\n                      reconciliationData.dailyBreakdown.map((day, index) => (\r\n                        <Card key={index} className=\"p-3 bg-slate-50\">\r\n                          <div className=\"font-semibold text-sm mb-2 text-slate-700\">\r\n                            {new Date(day.date).toLocaleDateString('en-US', {\r\n                              weekday: 'short',\r\n                              year: 'numeric',\r\n                              month: 'short',\r\n                              day: 'numeric'\r\n                            })}\r\n                          </div>\r\n                          <div className=\"space-y-1.5 text-xs\">\r\n                            <div className=\"flex justify-between\">\r\n                              <span className=\"text-muted-foreground\">Starting Stock:</span>\r\n                              <span className=\"font-medium\">{day.startingStock.toFixed(2)}</span>\r\n                            </div>\r\n                            {day.itemsSold > 0 && (\r\n                              <div className=\"flex justify-between text-red-600\">\r\n                                <span>Items Sold:</span>\r\n                                <span className=\"font-medium\">-{day.itemsSold.toFixed(2)}</span>\r\n                              </div>\r\n                            )}\r\n                            {day.stockAdded > 0 && (\r\n                              <div className=\"flex justify-between text-emerald-600\">\r\n                                <span>Stock Added:</span>\r\n                                <span className=\"font-medium\">+{day.stockAdded.toFixed(2)}</span>\r\n                              </div>\r\n                            )}\r\n                            {day.transferOut > 0 && (\r\n                              <div className=\"flex justify-between text-orange-600\">\r\n                                <span>Transfer Out:</span>\r\n                                <span className=\"font-medium\">-{day.transferOut.toFixed(2)}</span>\r\n                              </div>\r\n                            )}\r\n                            {day.returnIn > 0 && (\r\n                              <div className=\"flex justify-between text-blue-600\">\r\n                                <span>Return In:</span>\r\n                                <span className=\"font-medium\">+{day.returnIn.toFixed(2)}</span>\r\n                              </div>\r\n                            )}\r\n                            {day.returnOut > 0 && (\r\n                              <div className=\"flex justify-between text-purple-600\">\r\n                                <span>Return Out:</span>\r\n                                <span className=\"font-medium\">-{day.returnOut.toFixed(2)}</span>\r\n                              </div>\r\n                            )}\r\n                            {day.adjustments !== 0 && (\r\n                              <div className=\"flex justify-between text-amber-600\">\r\n                                <span>Adjustments:</span>\r\n                                <span className=\"font-medium\">{day.adjustments > 0 ? '+' : ''}{day.adjustments.toFixed(2)}</span>\r\n                              </div>\r\n                            )}\r\n                            <div className=\"flex justify-between pt-1.5 border-t border-slate-200\">\r\n                              <span className=\"font-semibold text-slate-700\">Ending Stock:</span>\r\n                              <span className=\"font-bold text-slate-900\">{day.endingStock.toFixed(2)}</span>\r\n                            </div>\r\n                          </div>\r\n                        </Card>\r\n                      ))\r\n                    )}\r\n                  </div>\r\n                </ScrollArea>\r\n              </CardContent>\r\n            </Card>\r\n\r\n            {/* Preview Changes */}\r\n            {hasDiscrepancy && showPreview && (\r\n              <Card className=\"bg-blue-50 border-blue-200\">\r\n                <CardHeader>\r\n                  <CardTitle className=\"text-base text-blue-900\">\r\n                    Preview Correction\r\n                  </CardTitle>\r\n                </CardHeader>\r\n                <CardContent className=\"space-y-2\">\r\n                  <div className=\"flex justify-between\">\r\n                    <span className=\"text-sm text-blue-800\">Current (Recorded):</span>\r\n                    <span className=\"font-medium text-blue-900\">\r\n                      {reconciliationData.currentStock.toFixed(2)} units\r\n                    </span>\r\n                  </div>\r\n                  <div className=\"flex justify-between\">\r\n                    <span className=\"text-sm text-blue-800\">Calculated (History):</span>\r\n                    <span className=\"font-medium text-blue-900\">\r\n                      {reconciliationData.calculatedClosingStock.toFixed(2)} units\r\n                    </span>\r\n                  </div>\r\n                  <div className=\"flex justify-between pt-2 border-t border-blue-200\">\r\n                    <span className=\"text-sm font-semibold text-blue-800\">\r\n                      Correction Amount:\r\n                    </span>\r\n                    <span className=\"font-semibold text-blue-900\">\r\n                      {reconciliationData.discrepancy > 0 ? '+' : ''}\r\n                      {Math.abs(reconciliationData.discrepancy).toFixed(2)} units\r\n                    </span>\r\n                  </div>\r\n                </CardContent>\r\n              </Card>\r\n            )}\r\n\r\n            {/* Status Message */}\r\n            {!hasDiscrepancy && (\r\n              <div className=\"flex items-center gap-2 p-4 bg-green-50 border border-green-200 rounded-lg\">\r\n                <CheckCircle className=\"h-5 w-5 text-green-600\" />\r\n                <p className=\"text-sm text-green-800\">\r\n                  Stock levels are accurate based on transaction history.\r\n                </p>\r\n              </div>\r\n            )}\r\n          </div>\r\n        )}\r\n\r\n        <DialogFooter>\r\n          <Button variant=\"outline\" onClick={onClose}>\r\n            Cancel\r\n          </Button>\r\n          {hasDiscrepancy && (\r\n            <>\r\n              {!showPreview ? (\r\n                <Button onClick={() => setShowPreview(true)}>\r\n                  Preview Correction\r\n                </Button>\r\n              ) : (\r\n                <Button\r\n                  onClick={handleApplyCorrection}\r\n                  disabled={isApplying}\r\n                  className=\"bg-blue-600 hover:bg-blue-700\"\r\n                >\r\n                  {isApplying ? 'Applying...' : 'Apply Correction'}\r\n                </Button>\r\n              )}\r\n            </>\r\n          )}\r\n        </DialogFooter>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n};\r\n\r\nexport default StockReconciliation;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1732, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/inventory/InventoryPageSkeleton.tsx"],"sourcesContent":["import React from 'react';\r\nimport { Skeleton } from '@/components/ui/skeleton';\r\n\r\nconst InventoryPageSkeleton = () => (\r\n  <div className=\"space-y-6\">\r\n    <div className=\"mb-6 flex flex-col gap-4 md:flex-row md:items-center md:justify-between\">\r\n      <div>\r\n        <Skeleton className=\"h-8 w-48 mb-2\" />\r\n        <Skeleton className=\"h-4 w-64\" />\r\n      </div>\r\n      <div className=\"flex items-center gap-2\">\r\n        <Skeleton className=\"h-9 w-9\" />\r\n        <Skeleton className=\"h-9 w-24\" />\r\n        <Skeleton className=\"h-9 w-32\" />\r\n      </div>\r\n    </div>\r\n\r\n    <div className=\"mb-4\">\r\n      <Skeleton className=\"h-10 w-full max-w-md\" />\r\n    </div>\r\n\r\n    <div className=\"mb-6\">\r\n      <div className=\"grid grid-cols-1 md:grid-cols-4 gap-4\">\r\n        {[...Array(4)].map((_, i) => (\r\n          <Skeleton key={i} className=\"h-24\" />\r\n        ))}\r\n      </div>\r\n    </div>\r\n\r\n    <Skeleton className=\"h-64 mb-6\" />\r\n    <Skeleton className=\"h-96\" />\r\n  </div>\r\n);\r\n\r\nexport default InventoryPageSkeleton;"],"names":[],"mappings":";;;;;AACA;;;AAEA,MAAM,wBAAwB,kBAC5B,6LAAC;QAAI,WAAU;;0BACb,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;;0CACC,6LAAC,mJAAQ;gCAAC,WAAU;;;;;;0CACpB,6LAAC,mJAAQ;gCAAC,WAAU;;;;;;;;;;;;kCAEtB,6LAAC;wBAAI,WAAU;;0CACb,6LAAC,mJAAQ;gCAAC,WAAU;;;;;;0CACpB,6LAAC,mJAAQ;gCAAC,WAAU;;;;;;0CACpB,6LAAC,mJAAQ;gCAAC,WAAU;;;;;;;;;;;;;;;;;;0BAIxB,6LAAC;gBAAI,WAAU;0BACb,cAAA,6LAAC,mJAAQ;oBAAC,WAAU;;;;;;;;;;;0BAGtB,6LAAC;gBAAI,WAAU;0BACb,cAAA,6LAAC;oBAAI,WAAU;8BACZ;2BAAI,MAAM;qBAAG,CAAC,GAAG,CAAC,CAAC,GAAG,kBACrB,6LAAC,mJAAQ;4BAAS,WAAU;2BAAb;;;;;;;;;;;;;;;0BAKrB,6LAAC,mJAAQ;gBAAC,WAAU;;;;;;0BACpB,6LAAC,mJAAQ;gBAAC,WAAU;;;;;;;;;;;;KA3BlB;uCA+BS"}},
    {"offset": {"line": 1872, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/products.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { Product, ProductFormData, mapDbProductToProduct, mapProductToDbProduct } from '@/types';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// We implement server actions for the products here\r\n\r\nexport async function getProductsAction({\r\n  userId,\r\n  businessId,\r\n  page,\r\n  pageSize,\r\n  search,\r\n  category,\r\n  stockStatus,\r\n}: {\r\n  userId: string;\r\n  businessId: string;\r\n  page: number;\r\n  pageSize: number;\r\n  search?: string;\r\n  category?: string;\r\n  stockStatus?: 'inStock' | 'outOfStock' | 'lowStock' | 'all';\r\n}) {\r\n  if (!userId || !businessId) return { products: [], count: 0 };\r\n\r\n  const skip = (page - 1) * pageSize;\r\n  const take = pageSize;\r\n\r\n  let whereClause: any = {\r\n    userId: userId,\r\n    branchId: businessId,\r\n  };\r\n\r\n  if (search) {\r\n    whereClause.OR = [\r\n      { name: { contains: search, mode: 'insensitive' } },\r\n      { description: { contains: search, mode: 'insensitive' } },\r\n      { sku: { contains: search, mode: 'insensitive' } },\r\n      { barcode: { contains: search, mode: 'insensitive' } },\r\n    ];\r\n  }\r\n\r\n  if (category) {\r\n    whereClause.category = { name: category };\r\n  }\r\n\r\n  if (stockStatus === 'outOfStock') {\r\n    whereClause.stock = 0;\r\n  } else if (stockStatus === 'inStock') {\r\n    whereClause.stock = { gt: 0 };\r\n  } else if (stockStatus === 'lowStock') {\r\n    // Handling lowStock is complex because minStock is compared locally or using direct SQL in Prisma\r\n    // For now, we will handle it with Prisma's raw query or by filtering in memory if necessary\r\n    // Fortunately, since PRISMA 5.0, column comparison still needs raw queries or we can fetch and filter if small\r\n    // Here we'll fetch them all if lowStock is enabled, or add a generated column. \r\n    // We will do a basic fetch and filter later if needed.\r\n  }\r\n\r\n  try {\r\n    const [productsData, totalCount] = await Promise.all([\r\n      db.product.findMany({\r\n        where: whereClause,\r\n        skip,\r\n        take,\r\n        orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      }),\r\n      db.product.count({ where: whereClause })\r\n    ]);\r\n\r\n    // Map the Prisma product model back to the application's Product type\r\n    let formattedProducts = productsData.map((p: any) => {\r\n      // Assuming mapping exists, we will map it\r\n      return {\r\n        id: p.id,\r\n        name: p.name,\r\n        description: p.description || '',\r\n        category: p.category?.name || 'Uncategorized',\r\n        quantity: p.stock,\r\n        costPrice: p.costPrice,\r\n        sellingPrice: p.sellingPrice,\r\n        supplier: p.supplier?.name,\r\n        imageUrl: p.image,\r\n        barcode: p.barcode,\r\n        itemNumber: p.sku || '',\r\n        minimumStock: p.minStock,\r\n        createdAt: p.createdAt,\r\n      };\r\n    });\r\n\r\n    if (stockStatus === 'lowStock') {\r\n      formattedProducts = formattedProducts.filter((p: any) => p.quantity > 0 && p.quantity <= p.minimumStock);\r\n    }\r\n\r\n    return { products: formattedProducts as any[], count: totalCount };\r\n  } catch (error) {\r\n    console.error('Error fetching products from DB:', error);\r\n    return { products: [], count: 0 };\r\n  }\r\n}\r\n\r\nexport async function getAllProductsAction(userId: string, businessId: string) {\r\n  if (!userId || !businessId) return [];\r\n\r\n  try {\r\n    const productsData = await db.product.findMany({\r\n      where: {\r\n        userId: userId,\r\n        branchId: businessId,\r\n      },\r\n      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return productsData.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: Number(p.stock),\r\n      costPrice: Number(p.costPrice),\r\n      sellingPrice: Number(p.sellingPrice),\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: Number(p.minStock),\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching all products from DB:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function getProductsByIdsAction(ids: string[], businessId?: string) {\r\n  try {\r\n    const where: any = {\r\n      id: { in: ids }\r\n    };\r\n    if (businessId) {\r\n      where.branchId = businessId;\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      include: {\r\n        category: true,\r\n        supplier: true,\r\n      }\r\n    });\r\n\r\n    return products.map((p: any) => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      description: p.description || '',\r\n      category: p.category?.name || 'Uncategorized',\r\n      quantity: p.stock,\r\n      costPrice: p.costPrice,\r\n      sellingPrice: p.sellingPrice,\r\n      supplier: p.supplier?.name,\r\n      imageUrl: p.image,\r\n      barcode: p.barcode,\r\n      itemNumber: p.sku || '',\r\n      minimumStock: p.minStock,\r\n      createdAt: p.createdAt,\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching products by ids:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function createProductAction(data: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Generate next SKU/itemNumber for this branch\r\n      const lastProduct = await tx.product.findFirst({\r\n        where: { branchId: data.businessId },\r\n        orderBy: { sku: 'desc' },\r\n        select: { sku: true }\r\n      });\r\n\r\n      let nextSku = \"PROD-0001\";\r\n      if (lastProduct && lastProduct.sku) {\r\n        const currentNumber = parseInt(lastProduct.sku.replace(\"PROD-\", \"\")) || 0;\r\n        nextSku = `PROD-${(currentNumber + 1).toString().padStart(4, '0')}`;\r\n      }\r\n\r\n      // 2. Create the product\r\n      const product = await tx.product.create({\r\n        data: {\r\n          name: data.name,\r\n          description: data.description,\r\n          branchId: data.businessId,\r\n          userId: data.userId,\r\n          categoryId: data.categoryId || null,\r\n          supplierId: data.supplierId || null,\r\n          sku: nextSku,\r\n          barcode: data.barcode,\r\n          image: data.imageUrl,\r\n          costPrice: data.costPrice || 0,\r\n          sellingPrice: data.sellingPrice || 0,\r\n          stock: data.quantity || 0,\r\n          minStock: data.minimumStock || 0,\r\n          createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n        },\r\n        include: {\r\n          category: true,\r\n          supplier: true,\r\n        }\r\n      });\r\n\r\n      // 3. Create initial stock history if quantity > 0\r\n      if (data.quantity > 0) {\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: data.userId,\r\n            productId: product.id,\r\n            type: 'CREATED',\r\n            oldStock: 0,\r\n            newStock: data.quantity,\r\n            quantityChange: data.quantity,\r\n            reason: `[${product.name}] | Initial stock`,\r\n            createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),\r\n          }\r\n        });\r\n      }\r\n\r\n      return product;\r\n    });\r\n\r\n    return {\r\n      id: result.id,\r\n      name: result.name,\r\n      description: result.description || '',\r\n      category: result.category?.name || 'Uncategorized',\r\n      quantity: result.stock,\r\n      costPrice: result.costPrice,\r\n      sellingPrice: result.sellingPrice,\r\n      supplier: result.supplier?.name,\r\n      imageUrl: result.image,\r\n      barcode: result.barcode,\r\n      itemNumber: result.sku || '',\r\n      minimumStock: result.minStock,\r\n      createdAt: result.createdAt,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error creating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updateProductAction(id: string, updates: any) {\r\n  try {\r\n    const result = await db.$transaction(async (tx: any) => {\r\n      // 1. Get current product state\r\n      const current = await tx.product.findUnique({\r\n        where: { id },\r\n        select: { stock: true, name: true }\r\n      });\r\n\r\n      if (!current) throw new Error(\"Product not found\");\r\n\r\n      // 2. Perform update\r\n      const updated = await tx.product.update({\r\n        where: { id },\r\n        data: {\r\n          name: updates.name,\r\n          description: updates.description,\r\n          categoryId: updates.categoryId !== undefined ? updates.categoryId : undefined,\r\n          supplierId: updates.supplierId !== undefined ? updates.supplierId : undefined,\r\n          sku: updates.itemNumber || updates.sku,\r\n          barcode: updates.barcode,\r\n          image: updates.imageUrl,\r\n          costPrice: updates.costPrice,\r\n          sellingPrice: updates.sellingPrice,\r\n          stock: updates.quantity,\r\n          minStock: updates.minimumStock,\r\n        }\r\n      });\r\n\r\n      // 3. Create history if quantity changed\r\n      if (updates.quantity !== undefined && updates.quantity !== current.stock && updates.customChangeReason !== 'skip-history') {\r\n        let changeReason = updates.customChangeReason;\r\n        if (!changeReason) {\r\n          if (updates.isFromSale) changeReason = \"Sale\";\r\n          else if (updates.quantity > current.stock) changeReason = \"Manual stock addition\";\r\n          else changeReason = \"Manual stock reduction\";\r\n        }\r\n\r\n        const snapshottedReason = `[${updated.name}] | ${changeReason}`;\r\n\r\n        await tx.productHistory.create({\r\n          data: {\r\n            userId: updates.userId,\r\n            productId: updated.id,\r\n            type: updates.isFromSale ? 'SALE' : (updates.quantity > current.stock ? 'RESTOCK' : 'ADJUSTMENT'),\r\n            oldStock: current.stock,\r\n            newStock: updates.quantity,\r\n            quantityChange: updates.quantity - current.stock,\r\n            reason: snapshottedReason,\r\n            referenceId: updates.referenceId || null,\r\n          }\r\n        });\r\n      }\r\n\r\n      return updated;\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Error updating product:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function deleteProductAction(id: string) {\r\n  try {\r\n    await db.product.delete({\r\n      where: { id }\r\n    });\r\n    // revalidatePath('/inventory/products');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting product:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function updateProductsBulkAction(\r\n  updates: Array<{ id: string; updated: Partial<any> }>,\r\n  businessId: string\r\n) {\r\n  try {\r\n    // Prisma transaction for bulk updates\r\n    const updatePromises = updates.map(u =>\r\n      db.product.update({\r\n        where: { id: u.id },\r\n        data: {\r\n          ...(u.updated.name && { name: u.updated.name }),\r\n          ...(u.updated.description !== undefined && { description: u.updated.description }),\r\n          ...(u.updated.categoryId !== undefined && { categoryId: u.updated.categoryId }),\r\n          ...(u.updated.supplierId !== undefined && { supplierId: u.updated.supplierId }),\r\n          ...(u.updated.sku !== undefined && { sku: u.updated.sku }),\r\n          ...(u.updated.barcode !== undefined && { barcode: u.updated.barcode }),\r\n          ...(u.updated.costPrice !== undefined && { costPrice: u.updated.costPrice }),\r\n          ...(u.updated.sellingPrice !== undefined && { sellingPrice: u.updated.sellingPrice }),\r\n          ...(u.updated.quantity !== undefined && { stock: u.updated.quantity }),\r\n          ...(u.updated.minimumStock !== undefined && { minStock: u.updated.minimumStock }),\r\n        }\r\n      })\r\n    );\r\n\r\n    await db.$transaction(updatePromises);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error performing bulk update:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// --- PRODUCT CATEGORIES ---\r\n\r\nexport async function getProductCategoriesAction(locationId: string) {\r\n  try {\r\n    const categories = await db.category.findMany({\r\n      where: { branchId: locationId },\r\n      orderBy: { name: 'asc' }\r\n    });\r\n\r\n    return {\r\n      success: true,\r\n      data: categories.map((c: any) => ({\r\n        id: c.id,\r\n        name: c.name,\r\n        created_at: c.createdAt.toISOString(),\r\n      }))\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error fetching categories:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function createProductCategoryAction(locationId: string, userId: string, name: string) {\r\n  try {\r\n    const category = await db.category.create({\r\n      data: {\r\n        branchId: locationId,\r\n        userId,\r\n        name\r\n      }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error creating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function updateProductCategoryAction(id: string, name: string) {\r\n  try {\r\n    const category = await db.category.update({\r\n      where: { id },\r\n      data: { name }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true, data: category };\r\n  } catch (error: any) {\r\n    console.error('Error updating category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\nexport async function deleteProductCategoryAction(id: string) {\r\n  try {\r\n    // Check if any products are using this category\r\n    const usageCount = await db.product.count({\r\n      where: { categoryId: id }\r\n    });\r\n\r\n    if (usageCount > 0) {\r\n      return {\r\n        success: false,\r\n        error: 'Cannot delete category: it is being used by one or more products.'\r\n      };\r\n    }\r\n\r\n    await db.category.delete({\r\n      where: { id }\r\n    });\r\n\r\n    revalidatePath('/inventory');\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('Error deleting category:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- PRODUCT STATS ---\r\n\r\nexport async function getProductStatsAction(businessId: string) {\r\n  if (!businessId) return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId: businessId },\r\n      select: {\r\n        stock: true,\r\n        costPrice: true,\r\n        sellingPrice: true,\r\n        minStock: true,\r\n      }\r\n    });\r\n\r\n    let costValue = 0;\r\n    let lowStock = 0;\r\n    let outOfStock = 0;\r\n    let stockValue = 0;\r\n\r\n    products.forEach((p: any) => {\r\n      const qty = Number(p.stock) || 0;\r\n      const cost = Number(p.costPrice) || 0;\r\n      const selling = Number(p.sellingPrice) || 0;\r\n      const minStock = Number(p.minStock) || 0;\r\n\r\n      costValue += cost * qty;\r\n      stockValue += selling * qty;\r\n\r\n      if (qty === 0) {\r\n        outOfStock++;\r\n      } else if (qty > 0 && qty <= minStock) {\r\n        lowStock++;\r\n      }\r\n    });\r\n\r\n    return { costValue, lowStock, outOfStock, stockValue };\r\n  } catch (error) {\r\n    console.error('Error fetching product stats:', error);\r\n    return { costValue: 0, lowStock: 0, outOfStock: 0, stockValue: 0 };\r\n  }\r\n}\r\n\r\n// --- BARCODE LOOKUP ---\r\n\r\nexport async function lookupProductByBarcodeAction(code: string, branchId: string) {\r\n  if (!code || !branchId) return null;\r\n  try {\r\n    const lowerCode = code.toLowerCase();\r\n    const product = await db.product.findFirst({\r\n      where: {\r\n        branchId,\r\n        OR: [\r\n          { barcode: { contains: lowerCode, mode: 'insensitive' } },\r\n          { sku: { contains: lowerCode, mode: 'insensitive' } },\r\n        ]\r\n      }\r\n    });\r\n    return product;\r\n  } catch (error) {\r\n    console.error('[lookupProductByBarcodeAction] Error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- BARCODE SCANNER (all products for scanner preload) ---\r\n\r\nexport async function getProductsForBarcodeScannerAction(branchId: string) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const products = await db.product.findMany({\r\n      where: { branchId },\r\n      select: {\r\n        id: true, name: true, barcode: true, sku: true,\r\n        sellingPrice: true, costPrice: true, stock: true,\r\n        description: true, categoryId: true, branchId: true,\r\n        minStock: true, imageUrl: true, createdAt: true, updatedAt: true,\r\n      },\r\n    });\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getProductsForBarcodeScannerAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// --- SALE CASH TRANSACTION ID UPDATE ---\r\n\r\nexport async function updateSaleCashTransactionAction(saleId: string, cashTransactionId: string) {\r\n  try {\r\n    await db.sale.update({\r\n      where: { id: saleId },\r\n      data: { cashTransactionId },\r\n    });\r\n    return { success: true };\r\n  } catch (error: any) {\r\n    console.error('[updateSaleCashTransactionAction] Error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n// --- FILTERED PRODUCTS FOR EXPORT (all pages) ---\r\n\r\nexport async function getFilteredProductsForExportAction(\r\n  branchId: string,\r\n  filters?: { search?: string; category?: string; stockStatus?: string }\r\n) {\r\n  if (!branchId) return [];\r\n  try {\r\n    const where: any = { branchId };\r\n\r\n    if (filters?.search) {\r\n      const s = filters.search;\r\n      where.OR = [\r\n        { name: { contains: s, mode: 'insensitive' } },\r\n        { description: { contains: s, mode: 'insensitive' } },\r\n        { sku: { contains: s, mode: 'insensitive' } },\r\n      ];\r\n    }\r\n\r\n    if (filters?.stockStatus === 'outOfStock') {\r\n      where.stock = 0;\r\n    } else if (filters?.stockStatus === 'inStock') {\r\n      where.stock = { gt: 0 };\r\n    }\r\n\r\n    const products = await db.product.findMany({\r\n      where,\r\n      orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return products;\r\n  } catch (error) {\r\n    console.error('[getFilteredProductsForExportAction] Error:', error);\r\n    return [];\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0GsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,wDAAA"}},
    {"offset": {"line": 1889, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.branchId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title || '',\r\n                items: (req.items as any) || [],\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- STOCK RECONCILIATION & REPAIRS ---\r\n\r\nexport async function getProductReconciliationAction(businessId: string, productId: string) {\r\n    try {\r\n        const product = await db.product.findUnique({\r\n            where: { id: productId },\r\n            include: { category: true }\r\n        });\r\n\r\n        if (!product) return { success: false, error: 'Product not found' };\r\n\r\n        // Fetch all history entries\r\n        const history = await db.productHistory.findMany({\r\n            where: { productId, locationId: businessId },\r\n            orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n        });\r\n\r\n        // Fetch all sales containing this product\r\n        const sales = await db.sale.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const openingStock = history.length > 0 ? history[0].newStock : 0;\r\n        const openingDate = history.length > 0 ? history[0].createdAt : null;\r\n\r\n        const dailyTransactions = new Map<string, any>();\r\n        let excludedSalesQty = 0;\r\n\r\n        sales.forEach(sale => {\r\n            const items = (sale.items as any[]) || [];\r\n            const soldQty = items\r\n                .filter(item => item.productId === productId)\r\n                .reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);\r\n\r\n            if (soldQty > 0) {\r\n                if (openingDate && sale.date < openingDate) {\r\n                    excludedSalesQty += soldQty;\r\n                } else {\r\n                    const dateStr = sale.date.toISOString().split('T')[0];\r\n                    const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n                    day.itemsSold += soldQty;\r\n                    dailyTransactions.set(dateStr, day);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Movements (excluding initial entry)\r\n        const movements = history.slice(1);\r\n        movements.forEach(h => {\r\n            const dateStr = h.createdAt.toISOString().split('T')[0];\r\n            const delta = h.newStock - h.oldStock;\r\n            const reason = (h.changeReason || '').toLowerCase();\r\n\r\n            const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n\r\n            if (h.type === 'RESTOCK' || reason.includes('purchase') || reason.includes('addition')) {\r\n                day.stockAdded += delta;\r\n            } else if (reason.includes('transfer out')) {\r\n                day.transferOut += Math.abs(delta);\r\n            } else if (reason.includes('customer return')) {\r\n                day.returnIn += delta;\r\n            } else if (reason.includes('return to supplier')) {\r\n                day.returnOut += Math.abs(delta);\r\n            } else if (h.type !== 'SALE') {\r\n                day.adjustments += delta;\r\n            }\r\n            dailyTransactions.set(dateStr, day);\r\n        });\r\n\r\n        const sortedDates = Array.from(dailyTransactions.keys()).sort();\r\n        const dailyBreakdown = [];\r\n        let runningStock = openingStock;\r\n\r\n        for (const date of sortedDates) {\r\n            const day = dailyTransactions.get(date);\r\n            const startingStock = runningStock;\r\n            const endingStock = startingStock - day.itemsSold + day.stockAdded - day.transferOut + day.returnIn - day.returnOut + day.adjustments;\r\n\r\n            dailyBreakdown.push({\r\n                date,\r\n                startingStock,\r\n                ...day,\r\n                endingStock\r\n            });\r\n            runningStock = endingStock;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                product: {\r\n                    id: product.id,\r\n                    name: product.name,\r\n                    quantity: product.stock,\r\n                    itemNumber: product.sku\r\n                },\r\n                currentStock: product.stock,\r\n                calculatedStock: runningStock,\r\n                discrepancy: product.stock - runningStock,\r\n                openingStock,\r\n                openingDate: openingDate?.toISOString(),\r\n                excludedSalesQty,\r\n                dailyBreakdown\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error in reconciliation action:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getStockRepairsPreviewAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true, name: true, stock: true }\r\n        });\r\n\r\n        const brokenChains = [];\r\n\r\n        for (const product of products) {\r\n            const history = await db.productHistory.findMany({\r\n                where: { productId: product.id, locationId: businessId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) continue;\r\n\r\n            let runningQuantity = 0;\r\n            const brokenEntries = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newStock - entry.oldStock;\r\n                const expectedPrev = runningQuantity;\r\n                const expectedNext = expectedPrev + change;\r\n\r\n                if (entry.oldStock !== expectedPrev || entry.newStock !== expectedNext) {\r\n                    brokenEntries.push({\r\n                        entryId: entry.id,\r\n                        createdAt: entry.createdAt.toISOString(),\r\n                        changeReason: entry.changeReason,\r\n                        currentPrevQty: entry.oldStock,\r\n                        currentNewQty: entry.newStock,\r\n                        fixedPrevQty: expectedPrev,\r\n                        fixedNewQty: expectedNext\r\n                    });\r\n                }\r\n                runningQuantity = expectedNext;\r\n            }\r\n\r\n            if (brokenEntries.length > 0 || Math.abs(product.stock - runningQuantity) > 0.001) {\r\n                brokenChains.push({\r\n                    productId: product.id,\r\n                    productName: product.name,\r\n                    totalEntries: history.length,\r\n                    brokenEntries,\r\n                    finalFixedQty: runningQuantity,\r\n                    currentProductQty: product.stock\r\n                });\r\n            }\r\n        }\r\n\r\n        return { success: true, data: brokenChains };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function repairStockChainsAction(businessId: string, productIds?: string[]) {\r\n    try {\r\n        const ids = productIds || (await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true }\r\n        })).map(p => p.id);\r\n\r\n        let repaired = 0;\r\n        let failed = 0;\r\n\r\n        for (const id of ids) {\r\n            try {\r\n                await recalculateStockChainAction(id, businessId);\r\n                repaired++;\r\n            } catch (err) {\r\n                failed++;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: { repaired, failed } };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getActivityByEntityIdsAction(entityIds: string[]) {\r\n    try {\r\n        const records = await db.activityHistory.findMany({\r\n            where: { entityId: { in: entityIds } },\r\n            select: { entityId: true, entityName: true }\r\n        });\r\n        return { success: true, data: records };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message, data: [] };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesAction(entryIds: string[], newDate: string) {\r\n    try {\r\n        await db.productHistory.updateMany({\r\n            where: { id: { in: entryIds } },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAihBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,iEAAA"}},
    {"offset": {"line": 1906, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.branchId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title || '',\r\n                items: (req.items as any) || [],\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- STOCK RECONCILIATION & REPAIRS ---\r\n\r\nexport async function getProductReconciliationAction(businessId: string, productId: string) {\r\n    try {\r\n        const product = await db.product.findUnique({\r\n            where: { id: productId },\r\n            include: { category: true }\r\n        });\r\n\r\n        if (!product) return { success: false, error: 'Product not found' };\r\n\r\n        // Fetch all history entries\r\n        const history = await db.productHistory.findMany({\r\n            where: { productId, locationId: businessId },\r\n            orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n        });\r\n\r\n        // Fetch all sales containing this product\r\n        const sales = await db.sale.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const openingStock = history.length > 0 ? history[0].newStock : 0;\r\n        const openingDate = history.length > 0 ? history[0].createdAt : null;\r\n\r\n        const dailyTransactions = new Map<string, any>();\r\n        let excludedSalesQty = 0;\r\n\r\n        sales.forEach(sale => {\r\n            const items = (sale.items as any[]) || [];\r\n            const soldQty = items\r\n                .filter(item => item.productId === productId)\r\n                .reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);\r\n\r\n            if (soldQty > 0) {\r\n                if (openingDate && sale.date < openingDate) {\r\n                    excludedSalesQty += soldQty;\r\n                } else {\r\n                    const dateStr = sale.date.toISOString().split('T')[0];\r\n                    const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n                    day.itemsSold += soldQty;\r\n                    dailyTransactions.set(dateStr, day);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Movements (excluding initial entry)\r\n        const movements = history.slice(1);\r\n        movements.forEach(h => {\r\n            const dateStr = h.createdAt.toISOString().split('T')[0];\r\n            const delta = h.newStock - h.oldStock;\r\n            const reason = (h.changeReason || '').toLowerCase();\r\n\r\n            const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n\r\n            if (h.type === 'RESTOCK' || reason.includes('purchase') || reason.includes('addition')) {\r\n                day.stockAdded += delta;\r\n            } else if (reason.includes('transfer out')) {\r\n                day.transferOut += Math.abs(delta);\r\n            } else if (reason.includes('customer return')) {\r\n                day.returnIn += delta;\r\n            } else if (reason.includes('return to supplier')) {\r\n                day.returnOut += Math.abs(delta);\r\n            } else if (h.type !== 'SALE') {\r\n                day.adjustments += delta;\r\n            }\r\n            dailyTransactions.set(dateStr, day);\r\n        });\r\n\r\n        const sortedDates = Array.from(dailyTransactions.keys()).sort();\r\n        const dailyBreakdown = [];\r\n        let runningStock = openingStock;\r\n\r\n        for (const date of sortedDates) {\r\n            const day = dailyTransactions.get(date);\r\n            const startingStock = runningStock;\r\n            const endingStock = startingStock - day.itemsSold + day.stockAdded - day.transferOut + day.returnIn - day.returnOut + day.adjustments;\r\n\r\n            dailyBreakdown.push({\r\n                date,\r\n                startingStock,\r\n                ...day,\r\n                endingStock\r\n            });\r\n            runningStock = endingStock;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                product: {\r\n                    id: product.id,\r\n                    name: product.name,\r\n                    quantity: product.stock,\r\n                    itemNumber: product.sku\r\n                },\r\n                currentStock: product.stock,\r\n                calculatedStock: runningStock,\r\n                discrepancy: product.stock - runningStock,\r\n                openingStock,\r\n                openingDate: openingDate?.toISOString(),\r\n                excludedSalesQty,\r\n                dailyBreakdown\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error in reconciliation action:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getStockRepairsPreviewAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true, name: true, stock: true }\r\n        });\r\n\r\n        const brokenChains = [];\r\n\r\n        for (const product of products) {\r\n            const history = await db.productHistory.findMany({\r\n                where: { productId: product.id, locationId: businessId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) continue;\r\n\r\n            let runningQuantity = 0;\r\n            const brokenEntries = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newStock - entry.oldStock;\r\n                const expectedPrev = runningQuantity;\r\n                const expectedNext = expectedPrev + change;\r\n\r\n                if (entry.oldStock !== expectedPrev || entry.newStock !== expectedNext) {\r\n                    brokenEntries.push({\r\n                        entryId: entry.id,\r\n                        createdAt: entry.createdAt.toISOString(),\r\n                        changeReason: entry.changeReason,\r\n                        currentPrevQty: entry.oldStock,\r\n                        currentNewQty: entry.newStock,\r\n                        fixedPrevQty: expectedPrev,\r\n                        fixedNewQty: expectedNext\r\n                    });\r\n                }\r\n                runningQuantity = expectedNext;\r\n            }\r\n\r\n            if (brokenEntries.length > 0 || Math.abs(product.stock - runningQuantity) > 0.001) {\r\n                brokenChains.push({\r\n                    productId: product.id,\r\n                    productName: product.name,\r\n                    totalEntries: history.length,\r\n                    brokenEntries,\r\n                    finalFixedQty: runningQuantity,\r\n                    currentProductQty: product.stock\r\n                });\r\n            }\r\n        }\r\n\r\n        return { success: true, data: brokenChains };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function repairStockChainsAction(businessId: string, productIds?: string[]) {\r\n    try {\r\n        const ids = productIds || (await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true }\r\n        })).map(p => p.id);\r\n\r\n        let repaired = 0;\r\n        let failed = 0;\r\n\r\n        for (const id of ids) {\r\n            try {\r\n                await recalculateStockChainAction(id, businessId);\r\n                repaired++;\r\n            } catch (err) {\r\n                failed++;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: { repaired, failed } };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getActivityByEntityIdsAction(entityIds: string[]) {\r\n    try {\r\n        const records = await db.activityHistory.findMany({\r\n            where: { entityId: { in: entityIds } },\r\n            select: { entityId: true, entityName: true }\r\n        });\r\n        return { success: true, data: records };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message, data: [] };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesAction(entryIds: string[], newDate: string) {\r\n    try {\r\n        await db.productHistory.updateMany({\r\n            where: { id: { in: entryIds } },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0kBsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 1923, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/inventory.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n// --- STOCK HISTORY ---\r\n\r\nexport async function getStockHistoryAction(locationId: string, productId?: string) {\r\n    try {\r\n        const where: any = { locationId };\r\n        if (productId) where.productId = productId;\r\n\r\n        const history = await db.productHistory.findMany({\r\n            where,\r\n            include: {\r\n                product: {\r\n                    select: {\r\n                        name: true,\r\n                        costPrice: true,\r\n                        sellingPrice: true,\r\n                        sku: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: [{ createdAt: 'desc' }, { id: 'desc' }]\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: history.map((h: any) => ({\r\n                id: h.id,\r\n                productId: h.productId,\r\n                oldQuantity: h.previousQuantity,\r\n                newQuantity: h.newQuantity,\r\n                changeReason: h.changeReason,\r\n                createdAt: h.createdAt.toISOString(),\r\n                referenceId: h.referenceId,\r\n                receiptNumber: h.receiptNumber,\r\n                product: h.product ? {\r\n                    name: h.product.name,\r\n                    costPrice: h.product.costPrice,\r\n                    sellingPrice: h.product.sellingPrice,\r\n                    itemNumber: h.product.sku\r\n                } : undefined\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createStockHistoryAction(data: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entry = await tx.productHistory.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    productId: data.productId,\r\n                    previousQuantity: data.previousQuantity,\r\n                    newQuantity: data.newQuantity,\r\n                    changeReason: data.changeReason,\r\n                    referenceId: data.referenceId || null,\r\n                    receiptNumber: data.receiptNumber || null,\r\n                    createdAt: data.createdAt ? new Date(data.createdAt) : undefined\r\n                }\r\n            });\r\n\r\n            // Update product stock as well\r\n            await tx.product.update({\r\n                where: { id: data.productId },\r\n                data: { stock: data.newQuantity }\r\n            });\r\n\r\n            return entry;\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating stock history:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function recalculateStockChainAction(productId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const history = await tx.productHistory.findMany({\r\n                where: { productId, locationId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) return { finalQuantity: 0 };\r\n\r\n            let runningQuantity = 0;\r\n            const updates = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newQuantity - entry.previousQuantity;\r\n                const newPrev = runningQuantity;\r\n                const newNext = newPrev + change;\r\n\r\n                if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n                    updates.push(tx.productHistory.update({\r\n                        where: { id: entry.id },\r\n                        data: { previousQuantity: newPrev, newQuantity: newNext }\r\n                    }));\r\n                }\r\n                runningQuantity = newNext;\r\n            }\r\n\r\n            if (updates.length > 0) {\r\n                await Promise.all(updates);\r\n            }\r\n\r\n            // Update product\r\n            await tx.product.update({\r\n                where: { id: productId },\r\n                data: { stock: runningQuantity }\r\n            });\r\n\r\n            return { finalQuantity: runningQuantity };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error recalculating stock chain:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteStockHistoryEntriesByReferenceAction(referenceId: string, locationId: string) {\r\n    try {\r\n        const result = await db.$transaction(async (tx: any) => {\r\n            const entries = await tx.productHistory.findMany({\r\n                where: { referenceId, locationId },\r\n                select: { productId: true }\r\n            });\r\n\r\n            const productIds = [...new Set(entries.map((e: any) => e.productId as string))];\r\n\r\n            await tx.productHistory.deleteMany({\r\n                where: { referenceId, locationId }\r\n            });\r\n\r\n            // Recalculate chains for affected products\r\n            for (const productId of productIds) {\r\n                await recalculateStockChainInternal(tx, productId as string, locationId);\r\n            }\r\n\r\n            return { affectedProducts: productIds.length };\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error deleting stock history by reference:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesByReferenceAction(referenceId: string, locationId: string, newDate: string) {\r\n    try {\r\n        const result = await db.productHistory.updateMany({\r\n            where: { referenceId, locationId },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n\r\n        revalidatePath('/inventory');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating stock history dates:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// Internal helper for use within transactions\r\nasync function recalculateStockChainInternal(tx: any, productId: string, locationId: string) {\r\n    const history = await tx.productHistory.findMany({\r\n        where: { productId, locationId },\r\n        orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n    });\r\n\r\n    let runningQuantity = 0;\r\n    for (const entry of history) {\r\n        const change = entry.newQuantity - entry.previousQuantity;\r\n        const newPrev = runningQuantity;\r\n        const newNext = newPrev + change;\r\n\r\n        if (entry.previousQuantity !== newPrev || entry.newQuantity !== newNext) {\r\n            await tx.productHistory.update({\r\n                where: { id: entry.id },\r\n                data: { previousQuantity: newPrev, newQuantity: newNext }\r\n            });\r\n        }\r\n        runningQuantity = newNext;\r\n    }\r\n\r\n    await tx.product.update({\r\n        where: { id: productId },\r\n        data: { stock: runningQuantity }\r\n    });\r\n}\r\n\r\n// --- REQUISITIONS ---\r\n\r\nexport async function getRequisitionsAction(userId: string, locationId: string) {\r\n    try {\r\n        const requisitions = await db.requisition.findMany({\r\n            where: {\r\n                userId,\r\n                locationId\r\n            },\r\n            orderBy: {\r\n                createdAt: 'desc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: requisitions.map((req: any) => ({\r\n                id: req.id,\r\n                userId: req.userId,\r\n                locationId: req.branchId,\r\n                requisitionNumber: req.requisitionNumber,\r\n                title: req.title || '',\r\n                items: (req.items as any) || [],\r\n                notes: req.notes,\r\n                status: req.status,\r\n                createdAt: req.createdAt.toISOString(),\r\n                updatedAt: req.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching requisitions:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createRequisitionAction(data: any) {\r\n    try {\r\n        const requisition = await db.requisition.create({\r\n            data: {\r\n                userId: data.userId,\r\n                branchId: data.locationId,\r\n                requisitionNumber: data.requisitionNumber,\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status || 'draft'\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error creating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateRequisitionAction(id: string, userId: string, data: any) {\r\n    try {\r\n        const requisition = await db.requisition.update({\r\n            where: { id, userId },\r\n            data: {\r\n                title: data.title,\r\n                items: data.items,\r\n                notes: data.notes,\r\n                status: data.status,\r\n                updatedAt: new Date()\r\n            }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return {\r\n            success: true,\r\n            data: {\r\n                id: requisition.id,\r\n                userId: requisition.userId,\r\n                locationId: requisition.branchId,\r\n                requisitionNumber: requisition.requisitionNumber,\r\n                title: requisition.title || '',\r\n                items: (requisition.items as any) || [],\r\n                notes: requisition.notes,\r\n                status: requisition.status,\r\n                createdAt: requisition.createdAt.toISOString(),\r\n                updatedAt: requisition.updatedAt.toISOString()\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error updating requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteRequisitionAction(id: string, userId: string) {\r\n    try {\r\n        await db.requisition.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        revalidatePath('/requisitions');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting requisition:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- REPORTS / ANALYTICS ---\r\n\r\nexport async function getStockSummaryReportAction(locationId: string, startDate: string, endDate: string) {\r\n    try {\r\n        const start = new Date(startDate);\r\n        const end = new Date(endDate);\r\n\r\n        // Fetch all products for the location\r\n        const products = await db.product.findMany({\r\n            where: { branchId: locationId },\r\n            include: { category: true }\r\n        });\r\n\r\n        const reportData = await Promise.all(products.map(async (product: any) => {\r\n            // This is a simplified version of the logic that was likely in the RPC\r\n            // In a real production app, we'd use complex SQL or dedicated aggregate tables\r\n\r\n            // Get history for this product in the date range\r\n            const history = await db.productHistory.findMany({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: {\r\n                        gte: start,\r\n                        lte: end\r\n                    }\r\n                },\r\n                orderBy: { createdAt: 'asc' }\r\n            });\r\n\r\n            // Calculate metrics from history\r\n            let itemsSold = 0;\r\n            let stockIn = 0;\r\n            let adjustmentsIn = 0;\r\n            let adjustmentsOut = 0;\r\n\r\n            history.forEach((h: any) => {\r\n                const change = h.newQuantity - h.previousQuantity;\r\n                if (h.changeReason === 'SALE') {\r\n                    itemsSold += Math.abs(change);\r\n                } else if (h.changeReason === 'STOCK_IN' || h.changeReason === 'RESTOCK') {\r\n                    stockIn += change;\r\n                } else if (change > 0) {\r\n                    adjustmentsIn += change;\r\n                } else {\r\n                    adjustmentsOut += Math.abs(change);\r\n                }\r\n            });\r\n\r\n            // Get closing stock at end date (or current if after end date)\r\n            const closingStockEntry = await db.productHistory.findFirst({\r\n                where: {\r\n                    productId: product.id,\r\n                    locationId,\r\n                    createdAt: { lte: end }\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            });\r\n\r\n            const closingStock = closingStockEntry ? closingStockEntry.newQuantity : 0;\r\n            const openingStock = closingStock - (stockIn + adjustmentsIn - itemsSold - adjustmentsOut);\r\n\r\n            return {\r\n                productId: product.id,\r\n                productName: product.name,\r\n                itemNumber: product.sku || product.id,\r\n                imageUrl: product.imageUrl,\r\n                costPrice: Number(product.costPrice),\r\n                sellingPrice: Number(product.sellingPrice),\r\n                category: product.category?.name,\r\n                openingStock,\r\n                itemsSold,\r\n                stockIn,\r\n                transferOut: 0,\r\n                returnIn: 0,\r\n                returnOut: 0,\r\n                adjustmentsIn,\r\n                adjustmentsOut,\r\n                closingStock,\r\n                revaluation: closingStock * Number(product.costPrice)\r\n            };\r\n        }));\r\n\r\n        return { success: true, data: reportData };\r\n    } catch (error: any) {\r\n        console.error('Error generating stock summary report:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- STOCK RECONCILIATION & REPAIRS ---\r\n\r\nexport async function getProductReconciliationAction(businessId: string, productId: string) {\r\n    try {\r\n        const product = await db.product.findUnique({\r\n            where: { id: productId },\r\n            include: { category: true }\r\n        });\r\n\r\n        if (!product) return { success: false, error: 'Product not found' };\r\n\r\n        // Fetch all history entries\r\n        const history = await db.productHistory.findMany({\r\n            where: { productId, locationId: businessId },\r\n            orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n        });\r\n\r\n        // Fetch all sales containing this product\r\n        const sales = await db.sale.findMany({\r\n            where: { branchId: businessId },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const openingStock = history.length > 0 ? history[0].newStock : 0;\r\n        const openingDate = history.length > 0 ? history[0].createdAt : null;\r\n\r\n        const dailyTransactions = new Map<string, any>();\r\n        let excludedSalesQty = 0;\r\n\r\n        sales.forEach(sale => {\r\n            const items = (sale.items as any[]) || [];\r\n            const soldQty = items\r\n                .filter(item => item.productId === productId)\r\n                .reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);\r\n\r\n            if (soldQty > 0) {\r\n                if (openingDate && sale.date < openingDate) {\r\n                    excludedSalesQty += soldQty;\r\n                } else {\r\n                    const dateStr = sale.date.toISOString().split('T')[0];\r\n                    const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n                    day.itemsSold += soldQty;\r\n                    dailyTransactions.set(dateStr, day);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Movements (excluding initial entry)\r\n        const movements = history.slice(1);\r\n        movements.forEach(h => {\r\n            const dateStr = h.createdAt.toISOString().split('T')[0];\r\n            const delta = h.newStock - h.oldStock;\r\n            const reason = (h.changeReason || '').toLowerCase();\r\n\r\n            const day = dailyTransactions.get(dateStr) || { itemsSold: 0, stockAdded: 0, transferOut: 0, returnIn: 0, returnOut: 0, adjustments: 0 };\r\n\r\n            if (h.type === 'RESTOCK' || reason.includes('purchase') || reason.includes('addition')) {\r\n                day.stockAdded += delta;\r\n            } else if (reason.includes('transfer out')) {\r\n                day.transferOut += Math.abs(delta);\r\n            } else if (reason.includes('customer return')) {\r\n                day.returnIn += delta;\r\n            } else if (reason.includes('return to supplier')) {\r\n                day.returnOut += Math.abs(delta);\r\n            } else if (h.type !== 'SALE') {\r\n                day.adjustments += delta;\r\n            }\r\n            dailyTransactions.set(dateStr, day);\r\n        });\r\n\r\n        const sortedDates = Array.from(dailyTransactions.keys()).sort();\r\n        const dailyBreakdown = [];\r\n        let runningStock = openingStock;\r\n\r\n        for (const date of sortedDates) {\r\n            const day = dailyTransactions.get(date);\r\n            const startingStock = runningStock;\r\n            const endingStock = startingStock - day.itemsSold + day.stockAdded - day.transferOut + day.returnIn - day.returnOut + day.adjustments;\r\n\r\n            dailyBreakdown.push({\r\n                date,\r\n                startingStock,\r\n                ...day,\r\n                endingStock\r\n            });\r\n            runningStock = endingStock;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                product: {\r\n                    id: product.id,\r\n                    name: product.name,\r\n                    quantity: product.stock,\r\n                    itemNumber: product.sku\r\n                },\r\n                currentStock: product.stock,\r\n                calculatedStock: runningStock,\r\n                discrepancy: product.stock - runningStock,\r\n                openingStock,\r\n                openingDate: openingDate?.toISOString(),\r\n                excludedSalesQty,\r\n                dailyBreakdown\r\n            }\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error in reconciliation action:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getStockRepairsPreviewAction(businessId: string) {\r\n    try {\r\n        const products = await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true, name: true, stock: true }\r\n        });\r\n\r\n        const brokenChains = [];\r\n\r\n        for (const product of products) {\r\n            const history = await db.productHistory.findMany({\r\n                where: { productId: product.id, locationId: businessId },\r\n                orderBy: [{ createdAt: 'asc' }, { id: 'asc' }]\r\n            });\r\n\r\n            if (history.length === 0) continue;\r\n\r\n            let runningQuantity = 0;\r\n            const brokenEntries = [];\r\n\r\n            for (const entry of history) {\r\n                const change = entry.newStock - entry.oldStock;\r\n                const expectedPrev = runningQuantity;\r\n                const expectedNext = expectedPrev + change;\r\n\r\n                if (entry.oldStock !== expectedPrev || entry.newStock !== expectedNext) {\r\n                    brokenEntries.push({\r\n                        entryId: entry.id,\r\n                        createdAt: entry.createdAt.toISOString(),\r\n                        changeReason: entry.changeReason,\r\n                        currentPrevQty: entry.oldStock,\r\n                        currentNewQty: entry.newStock,\r\n                        fixedPrevQty: expectedPrev,\r\n                        fixedNewQty: expectedNext\r\n                    });\r\n                }\r\n                runningQuantity = expectedNext;\r\n            }\r\n\r\n            if (brokenEntries.length > 0 || Math.abs(product.stock - runningQuantity) > 0.001) {\r\n                brokenChains.push({\r\n                    productId: product.id,\r\n                    productName: product.name,\r\n                    totalEntries: history.length,\r\n                    brokenEntries,\r\n                    finalFixedQty: runningQuantity,\r\n                    currentProductQty: product.stock\r\n                });\r\n            }\r\n        }\r\n\r\n        return { success: true, data: brokenChains };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function repairStockChainsAction(businessId: string, productIds?: string[]) {\r\n    try {\r\n        const ids = productIds || (await db.product.findMany({\r\n            where: { branchId: businessId },\r\n            select: { id: true }\r\n        })).map(p => p.id);\r\n\r\n        let repaired = 0;\r\n        let failed = 0;\r\n\r\n        for (const id of ids) {\r\n            try {\r\n                await recalculateStockChainAction(id, businessId);\r\n                repaired++;\r\n            } catch (err) {\r\n                failed++;\r\n            }\r\n        }\r\n\r\n        return { success: true, data: { repaired, failed } };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function getActivityByEntityIdsAction(entityIds: string[]) {\r\n    try {\r\n        const records = await db.activityHistory.findMany({\r\n            where: { entityId: { in: entityIds } },\r\n            select: { entityId: true, entityName: true }\r\n        });\r\n        return { success: true, data: records };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message, data: [] };\r\n    }\r\n}\r\n\r\nexport async function updateStockHistoryDatesAction(entryIds: string[], newDate: string) {\r\n    try {\r\n        await db.productHistory.updateMany({\r\n            where: { id: { in: entryIds } },\r\n            data: { createdAt: new Date(newDate) }\r\n        });\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAoDsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 1940, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/pages/StockReconciliationPage.tsx"],"sourcesContent":["\r\nimport React, { useState, useMemo } from 'react';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Progress } from '@/components/ui/progress';\r\nimport { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { ScrollArea } from '@/components/ui/scroll-area';\r\nimport StockReconciliation from '@/components/inventory/StockReconciliation';\r\nimport InventoryPageSkeleton from '@/components/inventory/InventoryPageSkeleton';\r\nimport { Product } from '@/types';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { toast } from 'sonner';\r\nimport { AlertCircle, TrendingDown, TrendingUp, PackagePlus, PackageMinus, Wrench } from 'lucide-react';\r\nimport { useProfiles } from '@/contexts/ProfileContext';\r\nimport { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport {\r\n  getAllProductsAction\r\n} from '@/app/actions/products';\r\nimport {\r\n  getProductReconciliationAction,\r\n  getStockRepairsPreviewAction,\r\n  repairStockChainsAction,\r\n  createStockHistoryAction\r\n} from '@/app/actions/inventory';\r\nimport { format } from 'date-fns';\r\n\r\ninterface ReconciliationPreview {\r\n  product: Product;\r\n  currentStock: number;\r\n  calculatedStock: number;\r\n  discrepancy: number;\r\n  openingStock: number;\r\n  itemsSold: number;\r\n  stockAdded: number;\r\n  transferOut: number;\r\n  returnIn: number;\r\n  returnOut: number;\r\n  adjustments: number;\r\n  excludedSalesQty: number;\r\n  openingDate: string | null;\r\n  dailyBreakdown: Array<{\r\n    date: string;\r\n    startingStock: number;\r\n    itemsSold: number;\r\n    stockAdded: number;\r\n    transferOut: number;\r\n    returnIn: number;\r\n    returnOut: number;\r\n    adjustments: number;\r\n    endingStock: number;\r\n  }>;\r\n}\r\n\r\nconst StockReconciliationPage: React.FC = () => {\r\n  const { user } = useAuth();\r\n  const navigate = useNavigate();\r\n  const { currentBusiness, isLoading: businessLoading } = useBusiness();\r\n  const { hasPermission, isLoading: profilesLoading } = useProfiles();\r\n\r\n  const [search, setSearch] = useState('');\r\n  const [dialogProduct, setDialogProduct] = React.useState<Product | null>(null);\r\n  const [isBulkReconciling, setIsBulkReconciling] = useState(false);\r\n  const [isCalculatingPreview, setIsCalculatingPreview] = useState(false);\r\n  const [showBulkPreview, setShowBulkPreview] = useState(false);\r\n  const [reconciliationPreviews, setReconciliationPreviews] = useState<ReconciliationPreview[]>([]);\r\n  const [selectedPreview, setSelectedPreview] = useState<ReconciliationPreview | null>(null);\r\n  const [isRepairingChains, setIsRepairingChains] = useState(false);\r\n  const [repairPreviews, setRepairPreviews] = useState<any[]>([]);\r\n  const [showRepairPreview, setShowRepairPreview] = useState(false);\r\n  const [isCalculatingRepairPreview, setIsCalculatingRepairPreview] = useState(false);\r\n\r\n  // Load ALL products\r\n  const { data: allProducts = [], isLoading } = useQuery({\r\n    queryKey: ['all-products-reconciliation', user?.id, currentBusiness?.id],\r\n    queryFn: async () => {\r\n      if (!user?.id || !currentBusiness?.id) return [];\r\n      return await getAllProductsAction(user.id, currentBusiness.id);\r\n    },\r\n    enabled: !!user?.id && !!currentBusiness?.id,\r\n    staleTime: 2 * 60_000,\r\n  });\r\n\r\n  // Client-side filtering\r\n  const filteredProducts = useMemo(() => {\r\n    if (!search.trim()) return [];\r\n    const searchLower = search.toLowerCase();\r\n    return allProducts.filter((p) =>\r\n      p.name.toLowerCase().includes(searchLower) ||\r\n      p.itemNumber?.toLowerCase().includes(searchLower) ||\r\n      p.category?.toLowerCase().includes(searchLower) ||\r\n      p.supplier?.toLowerCase().includes(searchLower) ||\r\n      p.description?.toLowerCase().includes(searchLower)\r\n    );\r\n  }, [allProducts, search]);\r\n\r\n  const handleRepairAllChains = async () => {\r\n    if (!currentBusiness?.id) return;\r\n    setIsRepairingChains(true);\r\n    try {\r\n      const result = await repairStockChainsAction(currentBusiness.id);\r\n      if (result.success && result.data) {\r\n        const { repaired, failed } = result.data;\r\n        if (failed === 0) {\r\n          toast.success(`Stock chains repaired successfully for ${repaired} product(s).`);\r\n        } else {\r\n          toast.warning(`Repaired ${repaired} product(s). ${failed} failed.`);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error repairing stock chains:', error);\r\n      toast.error('Failed to repair stock chains.');\r\n    } finally {\r\n      setIsRepairingChains(false);\r\n      setShowRepairPreview(false);\r\n    }\r\n  };\r\n\r\n  const handleRepairPreview = async () => {\r\n    if (!currentBusiness?.id) return;\r\n    setIsCalculatingRepairPreview(true);\r\n    try {\r\n      const result = await getStockRepairsPreviewAction(currentBusiness.id);\r\n      if (result.success && result.data) {\r\n        setRepairPreviews(result.data);\r\n        if (result.data.length === 0) {\r\n          toast.success(\"No broken stock chains found!\");\r\n        } else {\r\n          setShowRepairPreview(true);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error previewing stock repairs:', error);\r\n      toast.error('Failed to preview stock repairs.');\r\n    } finally {\r\n      setIsCalculatingRepairPreview(false);\r\n    }\r\n  };\r\n\r\n  const calculateBulkPreview = async () => {\r\n    if (!currentBusiness?.id) return;\r\n\r\n    setIsCalculatingPreview(true);\r\n    const previews: ReconciliationPreview[] = [];\r\n\r\n    try {\r\n      for (const product of allProducts) {\r\n        const result = await getProductReconciliationAction(currentBusiness.id, product.id);\r\n        if (result.success && result.data && Math.abs(result.data.discrepancy) > 0.01) {\r\n          previews.push(result.data as ReconciliationPreview);\r\n        }\r\n      }\r\n\r\n      setReconciliationPreviews(previews);\r\n      setShowBulkPreview(true);\r\n    } catch (error) {\r\n      console.error('Error calculating preview:', error);\r\n      toast.error('Failed to calculate reconciliation preview.');\r\n    } finally {\r\n      setIsCalculatingPreview(false);\r\n    }\r\n  };\r\n\r\n  const handleBulkReconciliation = async () => {\r\n    if (!user?.id || !currentBusiness?.id || reconciliationPreviews.length === 0) return;\r\n\r\n    setIsBulkReconciling(true);\r\n\r\n    try {\r\n      let successCount = 0;\r\n      let errorCount = 0;\r\n\r\n      for (const preview of reconciliationPreviews) {\r\n        try {\r\n          const result = await createStockHistoryAction({\r\n            userId: user.id,\r\n            locationId: currentBusiness.id,\r\n            productId: preview.product.id,\r\n            previousQuantity: preview.currentStock,\r\n            newQuantity: preview.calculatedStock,\r\n            changeReason: 'Bulk Stock Reconciliation',\r\n            createdAt: new Date().toISOString()\r\n          });\r\n\r\n          if (result.success) {\r\n            successCount++;\r\n          } else {\r\n            throw new Error(result.error);\r\n          }\r\n        } catch (error) {\r\n          errorCount++;\r\n          console.error(`Failed to reconcile ${preview.product.name}:`, error);\r\n        }\r\n      }\r\n\r\n      toast.success(`Bulk reconciliation complete! Updated ${successCount} product(s).`);\r\n      if (errorCount > 0) {\r\n        toast.error(`${errorCount} product(s) failed.`);\r\n      }\r\n\r\n      setShowBulkPreview(false);\r\n      setReconciliationPreviews([]);\r\n    } catch (error) {\r\n      console.error('Bulk reconciliation error:', error);\r\n      toast.error('Failed to complete bulk reconciliation.');\r\n    } finally {\r\n      setIsBulkReconciling(false);\r\n    }\r\n  };\r\n\r\n  if (businessLoading || profilesLoading || !currentBusiness) {\r\n    return <InventoryPageSkeleton />;\r\n  }\r\n\r\n  if (!hasPermission('inventory', 'stock_adjustment')) {\r\n    return (\r\n      <div className=\"max-w-4xl mx-auto p-6\">\r\n        <Alert variant=\"destructive\">\r\n          <AlertCircle className=\"h-4 w-4\" />\r\n          <AlertTitle>Access Denied</AlertTitle>\r\n          <AlertDescription>\r\n            You do not have permission to access stock reconciliation.\r\n          </AlertDescription>\r\n        </Alert>\r\n        <div className=\"mt-4\">\r\n          <Button onClick={() => navigate('/inventory')} variant=\"outline\">\r\n            Back to Inventory\r\n          </Button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"p-2 md:p-6 space-y-4 md:space-y-6 max-w-full\">\r\n      <div className=\"flex items-center justify-between gap-4\">\r\n        <div className=\"space-y-1\">\r\n          <h1 className=\"text-xl md:text-2xl lg:text-3xl font-bold text-sales-dark\">Stock Reconciliation</h1>\r\n          <p className=\"text-sm md:text-base text-muted-foreground\">Select a product, preview the correction, then apply.</p>\r\n        </div>\r\n        <div className=\"flex items-center gap-2\">\r\n          <Button\r\n            onClick={handleRepairPreview}\r\n            disabled={isRepairingChains || isCalculatingRepairPreview || isLoading || allProducts.length === 0}\r\n            variant=\"outline\"\r\n            size=\"lg\"\r\n          >\r\n            <AlertCircle className=\"h-4 w-4 mr-2\" />\r\n            {isCalculatingRepairPreview ? 'Scanning...' : 'Preview Repairs'}\r\n          </Button>\r\n          <Button\r\n            onClick={handleRepairAllChains}\r\n            disabled={isRepairingChains || isCalculatingRepairPreview || isLoading || allProducts.length === 0}\r\n            variant=\"secondary\"\r\n            size=\"lg\"\r\n          >\r\n            <Wrench className=\"h-4 w-4 mr-2\" />\r\n            {isRepairingChains ? 'Repairing...' : 'Quick Repair All'}\r\n          </Button>\r\n          <Button\r\n            onClick={calculateBulkPreview}\r\n            disabled={isCalculatingPreview || isLoading || allProducts.length === 0}\r\n            size=\"lg\"\r\n          >\r\n            {isCalculatingPreview ? 'Calculating...' : 'Reconcile All Products'}\r\n          </Button>\r\n        </div>\r\n      </div>\r\n\r\n      <Card>\r\n        <CardHeader>\r\n          <CardTitle className=\"text-base\">Search Product</CardTitle>\r\n        </CardHeader>\r\n        <CardContent className=\"space-y-3\">\r\n          <Input\r\n            placeholder=\"Search by name, item number, category, or supplier\"\r\n            value={search}\r\n            onChange={(e) => setSearch(e.target.value)}\r\n          />\r\n          {search && (\r\n            <div className=\"border rounded-md\">\r\n              <ScrollArea className=\"max-h-96\">\r\n                <ul className=\"divide-y\">\r\n                  {isLoading && (\r\n                    <li className=\"p-3 text-sm text-muted-foreground\">Loading products...</li>\r\n                  )}\r\n                  {(!isLoading && filteredProducts.length === 0) && (\r\n                    <li className=\"p-3 text-sm text-muted-foreground\">No matching products found</li>\r\n                  )}\r\n                  {(!isLoading && filteredProducts).map((p) => (\r\n                    <li key={p.id} className=\"p-3 hover:bg-muted/40 cursor-pointer\" onClick={() => setDialogProduct(p)}>\r\n                      <div className=\"font-medium\">{p.name}</div>\r\n                      <div className=\"text-xs text-muted-foreground\">\r\n                        {p.itemNumber ? `Item: ${p.itemNumber}` : '—'} • Qty: {p.quantity} • Cat: {p.category || '—'}\r\n                      </div>\r\n                    </li>\r\n                  ))}\r\n                </ul>\r\n              </ScrollArea>\r\n            </div>\r\n          )}\r\n        </CardContent>\r\n      </Card>\r\n\r\n      {dialogProduct && (\r\n        <StockReconciliation\r\n          product={dialogProduct}\r\n          onClose={() => setDialogProduct(null)}\r\n          onReconciled={() => setDialogProduct(null)}\r\n        />\r\n      )}\r\n\r\n      {/* Bulk Reconciliation Preview Dialog */}\r\n      <Dialog open={showBulkPreview} onOpenChange={setShowBulkPreview}>\r\n        <DialogContent className=\"max-w-6xl max-h-[90vh] overflow-y-auto\">\r\n          <DialogHeader>\r\n            <DialogTitle className=\"flex items-center gap-2\">\r\n              <AlertCircle className=\"h-5 w-5 text-orange-500\" />\r\n              Bulk Reconciliation Preview\r\n            </DialogTitle>\r\n            <DialogDescription>\r\n              {reconciliationPreviews.length} product(s) with discrepancies found.\r\n            </DialogDescription>\r\n          </DialogHeader>\r\n\r\n          <div className=\"space-y-4\">\r\n            <div className=\"grid grid-cols-2 gap-4\">\r\n              <Card>\r\n                <CardHeader className=\"pb-3\">\r\n                  <CardTitle className=\"text-sm\">Products to Update</CardTitle>\r\n                </CardHeader>\r\n                <CardContent>\r\n                  <div className=\"text-2xl font-bold\">{reconciliationPreviews.length}</div>\r\n                </CardContent>\r\n              </Card>\r\n              <Card>\r\n                <CardHeader className=\"pb-3\">\r\n                  <CardTitle className=\"text-sm\">Total Adjustment</CardTitle>\r\n                </CardHeader>\r\n                <CardContent>\r\n                  <div className=\"text-2xl font-bold\">\r\n                    {reconciliationPreviews.reduce((sum, p) => sum + Math.abs(p.discrepancy), 0).toFixed(2)} units\r\n                  </div>\r\n                </CardContent>\r\n              </Card>\r\n            </div>\r\n\r\n            <Card>\r\n              <CardHeader>\r\n                <CardTitle className=\"text-base\">Products with Discrepancies</CardTitle>\r\n              </CardHeader>\r\n              <CardContent>\r\n                <ScrollArea className=\"h-[400px]\">\r\n                  <div className=\"space-y-2\">\r\n                    {reconciliationPreviews.map((preview) => (\r\n                      <Card\r\n                        key={preview.product.id}\r\n                        className=\"p-3 cursor-pointer hover:bg-muted/50\"\r\n                        onClick={() => setSelectedPreview(preview)}\r\n                      >\r\n                        <div className=\"flex justify-between items-start\">\r\n                          <div className=\"flex-1\">\r\n                            <div className=\"font-semibold\">{preview.product.name}</div>\r\n                            <div className=\"text-xs text-muted-foreground\">\r\n                              {preview.product.itemNumber && `Item: ${preview.product.itemNumber}`}\r\n                            </div>\r\n                          </div>\r\n                          <div className=\"text-right\">\r\n                            <div className=\"text-sm\">\r\n                              <span className=\"text-muted-foreground\">Current:</span> {Number(preview.currentStock).toFixed(2)}\r\n                            </div>\r\n                            <div className=\"text-sm\">\r\n                              <span className=\"text-muted-foreground\">Calculated:</span> {Number(preview.calculatedStock).toFixed(2)}\r\n                            </div>\r\n                            <Badge variant={preview.discrepancy > 0 ? 'default' : 'destructive'} className=\"mt-1\">\r\n                              {preview.discrepancy > 0 ? '+' : ''}{preview.discrepancy.toFixed(2)}\r\n                            </Badge>\r\n                          </div>\r\n                        </div>\r\n                      </Card>\r\n                    ))}\r\n                  </div>\r\n                </ScrollArea>\r\n              </CardContent>\r\n            </Card>\r\n          </div>\r\n\r\n          <DialogFooter>\r\n            <Button variant=\"outline\" onClick={() => setShowBulkPreview(false)} disabled={isBulkReconciling}>\r\n              Cancel\r\n            </Button>\r\n            <Button onClick={handleBulkReconciliation} disabled={isBulkReconciling}>\r\n              {isBulkReconciling ? 'Applying...' : `Apply Reconciliation (${reconciliationPreviews.length} products)`}\r\n            </Button>\r\n          </DialogFooter>\r\n        </DialogContent>\r\n      </Dialog>\r\n\r\n      {/* Individual Product Detail Dialog */}\r\n      {selectedPreview && (\r\n        <Dialog open={!!selectedPreview} onOpenChange={() => setSelectedPreview(null)}>\r\n          <DialogContent className=\"max-w-4xl max-h-[90vh] overflow-y-auto\">\r\n            <DialogHeader>\r\n              <DialogTitle>{selectedPreview.product.name}</DialogTitle>\r\n              <DialogDescription>Detailed reconciliation breakdown</DialogDescription>\r\n            </DialogHeader>\r\n\r\n            <div className=\"space-y-4\">\r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <Card>\r\n                  <CardHeader className=\"pb-3\">\r\n                    <CardTitle className=\"text-sm\">Current Stock</CardTitle>\r\n                  </CardHeader>\r\n                  <CardContent>\r\n                    <div className=\"text-2xl font-bold\">{Number(selectedPreview.currentStock).toFixed(2)}</div>\r\n                  </CardContent>\r\n                </Card>\r\n                <Card>\r\n                  <CardHeader className=\"pb-3\">\r\n                    <CardTitle className=\"text-sm\">Calculated Stock</CardTitle>\r\n                  </CardHeader>\r\n                  <CardContent>\r\n                    <div className=\"text-2xl font-bold\">{Number(selectedPreview.calculatedStock).toFixed(2)}</div>\r\n                  </CardContent>\r\n                </Card>\r\n              </div>\r\n\r\n              <Card>\r\n                <CardHeader>\r\n                  <CardTitle className=\"text-base\">Stock Calculation</CardTitle>\r\n                </CardHeader>\r\n                <CardContent className=\"space-y-3\">\r\n                  <div className=\"flex justify-between\">\r\n                    <span className=\"text-sm text-muted-foreground\">Opening Stock</span>\r\n                    <span className=\"font-medium\">{Number(selectedPreview.openingStock).toFixed(2)}</span>\r\n                  </div>\r\n                  <div className=\"flex justify-between text-red-600\">\r\n                    <span className=\"text-sm flex items-center gap-1\">\r\n                      <TrendingDown className=\"h-4 w-4\" /> Items Sold\r\n                    </span>\r\n                    <span className=\"font-medium\">-{Number(selectedPreview.itemsSold).toFixed(2)}</span>\r\n                  </div>\r\n                  <div className=\"flex justify-between text-emerald-600\">\r\n                    <span className=\"text-sm flex items-center gap-1\">\r\n                      <PackagePlus className=\"h-4 w-4\" /> Stock Added\r\n                    </span>\r\n                    <span className=\"font-medium\">+{Number(selectedPreview.stockAdded).toFixed(2)}</span>\r\n                  </div>\r\n                  <div className=\"border-t pt-3 flex justify-between font-semibold\">\r\n                    <span>Calculated Closing Stock</span>\r\n                    <span>{Number(selectedPreview.calculatedStock).toFixed(2)}</span>\r\n                  </div>\r\n                </CardContent>\r\n              </Card>\r\n            </div>\r\n\r\n            <DialogFooter>\r\n              <Button onClick={() => setSelectedPreview(null)}>Close</Button>\r\n            </DialogFooter>\r\n          </DialogContent>\r\n        </Dialog>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default StockReconciliationPage;"],"names":[],"mappings":"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"}}]
}