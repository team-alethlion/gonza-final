{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/tabs.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Tabs = TabsPrimitive.Root\r\n\r\nconst TabsList = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.List>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.List\r\n    ref={ref}\r\n    className={cn(\r\n      \"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTabsList.displayName = TabsPrimitive.List.displayName\r\n\r\nconst TabsTrigger = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.Trigger\r\n    ref={ref}\r\n    className={cn(\r\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\r\n\r\nconst TabsContent = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.Content\r\n    ref={ref}\r\n    className={cn(\r\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTabsContent.displayName = TabsPrimitive.Content.displayName\r\n\r\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\r\n"],"names":[],"mappings":";;;;;;;;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,OAAO,2KAAkB;AAE/B,MAAM,yBAAW,2KAAgB,MAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,2KAAkB;QACjB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,8FACA;QAED,GAAG,KAAK;;;;;;;AAGb,SAAS,WAAW,GAAG,2KAAkB,CAAC,WAAW;AAErD,MAAM,4BAAc,2KAAgB,OAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,8KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,uYACA;QAED,GAAG,KAAK;;;;;;;AAGb,YAAY,WAAW,GAAG,8KAAqB,CAAC,WAAW;AAE3D,MAAM,4BAAc,2KAAgB,OAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,8KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,mIACA;QAED,GAAG,KAAK;;;;;;;AAGb,YAAY,WAAW,GAAG,8KAAqB,CAAC,WAAW"}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/tasks.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, TaskPriority, RecurrenceType } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { addDays, addWeeks, addMonths, format, parseISO } from 'date-fns';\r\n\r\n// --- TASKS ---\r\n\r\nexport interface CreateTaskInput {\r\n    userId: string;\r\n    locationId: string;\r\n    title: string;\r\n    description?: string | null;\r\n    priority: TaskPriority;\r\n    dueDate: Date;\r\n    category?: string | null;\r\n    reminderEnabled?: boolean;\r\n    reminderTime?: string | null;\r\n    isRecurring?: boolean;\r\n    recurrenceType?: RecurrenceType | null;\r\n    recurrenceEndDate?: Date | null;\r\n}\r\n\r\nexport async function getTasksAction(userId: string, locationId: string) {\r\n    try {\r\n        const tasks = await db.task.findMany({\r\n            where: {\r\n                userId,\r\n                locationId,\r\n                deletedAt: null\r\n            },\r\n            orderBy: {\r\n                dueDate: 'asc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: tasks.map(t => ({\r\n                ...t,\r\n                user_id: t.userId,\r\n                location_id: t.locationId,\r\n                due_date: t.dueDate.toISOString().split('T')[0],\r\n                completed_at: t.completedAt?.toISOString() || null,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                reminder_enabled: t.reminderEnabled,\r\n                reminder_time: t.reminderTime,\r\n                is_recurring: t.isRecurring,\r\n                recurrence_type: t.recurrenceType,\r\n                recurrence_end_date: t.recurrenceEndDate?.toISOString().split('T')[0] || null,\r\n                parent_task_id: t.parentTaskId,\r\n                recurrence_count: t.recurrenceCount\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskAction(data: CreateTaskInput) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the main task\r\n            const task = await tx.task.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    title: data.title,\r\n                    description: data.description || null,\r\n                    priority: data.priority,\r\n                    dueDate: data.dueDate,\r\n                    category: data.category || null,\r\n                    reminderEnabled: data.reminderEnabled || false,\r\n                    reminderTime: data.reminderTime || null,\r\n                    isRecurring: data.isRecurring || false,\r\n                    recurrenceType: data.recurrenceType || null,\r\n                    recurrenceEndDate: data.recurrenceEndDate || null\r\n                }\r\n            });\r\n\r\n            // 2. If it's recurring, create instances\r\n            if (task.isRecurring && task.recurrenceType && task.recurrenceEndDate) {\r\n                const instances = [];\r\n                let currentDate = task.dueDate;\r\n                const endDate = task.recurrenceEndDate;\r\n                let count = 0;\r\n\r\n                while (count < 365) {\r\n                    let nextDate: Date;\r\n                    switch (task.recurrenceType) {\r\n                        case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                        case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                        case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                        default: nextDate = currentDate;\r\n                    }\r\n\r\n                    if (nextDate > endDate) break;\r\n\r\n                    instances.push({\r\n                        userId: task.userId,\r\n                        locationId: task.locationId,\r\n                        title: task.title,\r\n                        description: task.description,\r\n                        priority: task.priority,\r\n                        dueDate: nextDate,\r\n                        category: task.category,\r\n                        completed: false,\r\n                        reminderEnabled: task.reminderEnabled,\r\n                        reminderTime: task.reminderTime,\r\n                        isRecurring: false,\r\n                        parentTaskId: task.id,\r\n                        recurrenceCount: count + 1\r\n                    });\r\n\r\n                    currentDate = nextDate;\r\n                    count++;\r\n                }\r\n\r\n                if (instances.length > 0) {\r\n                    await tx.task.createMany({\r\n                        data: instances\r\n                    });\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskAction(id: string, userId: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const task = await tx.task.update({\r\n                where: { id, userId },\r\n                data: {\r\n                    ...updates,\r\n                    // Map camelCase to PascalCase if necessary, but prisma models use camelCase for fields\r\n                }\r\n            });\r\n\r\n            // If recurring settings changed, we might need to recreate instances\r\n            if (task.isRecurring && (updates.recurrenceType || updates.recurrenceEndDate)) {\r\n                // Delete existing pending instances\r\n                await tx.task.deleteMany({\r\n                    where: { parentTaskId: id, completed: false }\r\n                });\r\n\r\n                // Create new ones\r\n                if (task.recurrenceType && task.recurrenceEndDate) {\r\n                    const instances = [];\r\n                    let currentDate = task.dueDate;\r\n                    const endDate = task.recurrenceEndDate;\r\n                    let count = 0;\r\n\r\n                    while (count < 365) {\r\n                        let nextDate: Date;\r\n                        switch (task.recurrenceType!) {\r\n                            case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                            case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                            case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                            default: nextDate = currentDate;\r\n                        }\r\n                        if (nextDate > endDate) break;\r\n\r\n                        instances.push({\r\n                            userId: task.userId,\r\n                            locationId: task.locationId,\r\n                            title: task.title,\r\n                            description: task.description,\r\n                            priority: task.priority,\r\n                            dueDate: nextDate,\r\n                            category: task.category,\r\n                            isRecurring: false,\r\n                            parentTaskId: task.id,\r\n                            recurrenceCount: count + 1\r\n                        });\r\n                        currentDate = nextDate;\r\n                        count++;\r\n                    }\r\n                    if (instances.length > 0) {\r\n                        await tx.task.createMany({ data: instances });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskAction(id: string, userId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Delete instances first\r\n            await tx.task.deleteMany({\r\n                where: { parentTaskId: id, completed: false }\r\n            });\r\n\r\n            await tx.task.delete({\r\n                where: { id, userId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function bulkUpdateTasksAction(ids: string[], userId: string, updates: any) {\r\n    try {\r\n        await db.task.updateMany({\r\n            where: { id: { in: ids }, userId },\r\n            data: updates\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error bulk updating tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CATEGORIES ---\r\n\r\nexport async function getTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const categories = await db.taskCategory.findMany({\r\n            where: { userId, locationId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map(c => ({\r\n                ...c,\r\n                user_id: c.userId,\r\n                location_id: c.locationId,\r\n                created_at: c.createdAt.toISOString(),\r\n                updated_at: c.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskCategoryAction(userId: string, locationId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.create({\r\n            data: { userId, locationId, name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskCategoryAction(id: string, userId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.update({\r\n            where: { id, userId },\r\n            data: { name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskCategoryAction(id: string, userId: string) {\r\n    try {\r\n        await db.taskCategory.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const defaultNames = ['General', 'Marketing', 'Operations', 'Finance', 'Follow-up'];\r\n\r\n        const existing = await db.taskCategory.findMany({\r\n            where: { userId, locationId, name: { in: defaultNames } },\r\n            select: { name: true }\r\n        });\r\n\r\n        const existingNames = new Set(existing.map(e => e.name));\r\n        const toCreate = defaultNames.filter(n => !existingNames.has(n)).map(name => ({\r\n            userId,\r\n            locationId,\r\n            name\r\n        }));\r\n\r\n        if (toCreate.length > 0) {\r\n            await db.taskCategory.createMany({ data: toCreate });\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAuBsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,kDAAA"}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/tasks.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, TaskPriority, RecurrenceType } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { addDays, addWeeks, addMonths, format, parseISO } from 'date-fns';\r\n\r\n// --- TASKS ---\r\n\r\nexport interface CreateTaskInput {\r\n    userId: string;\r\n    locationId: string;\r\n    title: string;\r\n    description?: string | null;\r\n    priority: TaskPriority;\r\n    dueDate: Date;\r\n    category?: string | null;\r\n    reminderEnabled?: boolean;\r\n    reminderTime?: string | null;\r\n    isRecurring?: boolean;\r\n    recurrenceType?: RecurrenceType | null;\r\n    recurrenceEndDate?: Date | null;\r\n}\r\n\r\nexport async function getTasksAction(userId: string, locationId: string) {\r\n    try {\r\n        const tasks = await db.task.findMany({\r\n            where: {\r\n                userId,\r\n                locationId,\r\n                deletedAt: null\r\n            },\r\n            orderBy: {\r\n                dueDate: 'asc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: tasks.map(t => ({\r\n                ...t,\r\n                user_id: t.userId,\r\n                location_id: t.locationId,\r\n                due_date: t.dueDate.toISOString().split('T')[0],\r\n                completed_at: t.completedAt?.toISOString() || null,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                reminder_enabled: t.reminderEnabled,\r\n                reminder_time: t.reminderTime,\r\n                is_recurring: t.isRecurring,\r\n                recurrence_type: t.recurrenceType,\r\n                recurrence_end_date: t.recurrenceEndDate?.toISOString().split('T')[0] || null,\r\n                parent_task_id: t.parentTaskId,\r\n                recurrence_count: t.recurrenceCount\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskAction(data: CreateTaskInput) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the main task\r\n            const task = await tx.task.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    title: data.title,\r\n                    description: data.description || null,\r\n                    priority: data.priority,\r\n                    dueDate: data.dueDate,\r\n                    category: data.category || null,\r\n                    reminderEnabled: data.reminderEnabled || false,\r\n                    reminderTime: data.reminderTime || null,\r\n                    isRecurring: data.isRecurring || false,\r\n                    recurrenceType: data.recurrenceType || null,\r\n                    recurrenceEndDate: data.recurrenceEndDate || null\r\n                }\r\n            });\r\n\r\n            // 2. If it's recurring, create instances\r\n            if (task.isRecurring && task.recurrenceType && task.recurrenceEndDate) {\r\n                const instances = [];\r\n                let currentDate = task.dueDate;\r\n                const endDate = task.recurrenceEndDate;\r\n                let count = 0;\r\n\r\n                while (count < 365) {\r\n                    let nextDate: Date;\r\n                    switch (task.recurrenceType) {\r\n                        case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                        case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                        case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                        default: nextDate = currentDate;\r\n                    }\r\n\r\n                    if (nextDate > endDate) break;\r\n\r\n                    instances.push({\r\n                        userId: task.userId,\r\n                        locationId: task.locationId,\r\n                        title: task.title,\r\n                        description: task.description,\r\n                        priority: task.priority,\r\n                        dueDate: nextDate,\r\n                        category: task.category,\r\n                        completed: false,\r\n                        reminderEnabled: task.reminderEnabled,\r\n                        reminderTime: task.reminderTime,\r\n                        isRecurring: false,\r\n                        parentTaskId: task.id,\r\n                        recurrenceCount: count + 1\r\n                    });\r\n\r\n                    currentDate = nextDate;\r\n                    count++;\r\n                }\r\n\r\n                if (instances.length > 0) {\r\n                    await tx.task.createMany({\r\n                        data: instances\r\n                    });\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskAction(id: string, userId: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const task = await tx.task.update({\r\n                where: { id, userId },\r\n                data: {\r\n                    ...updates,\r\n                    // Map camelCase to PascalCase if necessary, but prisma models use camelCase for fields\r\n                }\r\n            });\r\n\r\n            // If recurring settings changed, we might need to recreate instances\r\n            if (task.isRecurring && (updates.recurrenceType || updates.recurrenceEndDate)) {\r\n                // Delete existing pending instances\r\n                await tx.task.deleteMany({\r\n                    where: { parentTaskId: id, completed: false }\r\n                });\r\n\r\n                // Create new ones\r\n                if (task.recurrenceType && task.recurrenceEndDate) {\r\n                    const instances = [];\r\n                    let currentDate = task.dueDate;\r\n                    const endDate = task.recurrenceEndDate;\r\n                    let count = 0;\r\n\r\n                    while (count < 365) {\r\n                        let nextDate: Date;\r\n                        switch (task.recurrenceType!) {\r\n                            case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                            case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                            case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                            default: nextDate = currentDate;\r\n                        }\r\n                        if (nextDate > endDate) break;\r\n\r\n                        instances.push({\r\n                            userId: task.userId,\r\n                            locationId: task.locationId,\r\n                            title: task.title,\r\n                            description: task.description,\r\n                            priority: task.priority,\r\n                            dueDate: nextDate,\r\n                            category: task.category,\r\n                            isRecurring: false,\r\n                            parentTaskId: task.id,\r\n                            recurrenceCount: count + 1\r\n                        });\r\n                        currentDate = nextDate;\r\n                        count++;\r\n                    }\r\n                    if (instances.length > 0) {\r\n                        await tx.task.createMany({ data: instances });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskAction(id: string, userId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Delete instances first\r\n            await tx.task.deleteMany({\r\n                where: { parentTaskId: id, completed: false }\r\n            });\r\n\r\n            await tx.task.delete({\r\n                where: { id, userId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function bulkUpdateTasksAction(ids: string[], userId: string, updates: any) {\r\n    try {\r\n        await db.task.updateMany({\r\n            where: { id: { in: ids }, userId },\r\n            data: updates\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error bulk updating tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CATEGORIES ---\r\n\r\nexport async function getTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const categories = await db.taskCategory.findMany({\r\n            where: { userId, locationId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map(c => ({\r\n                ...c,\r\n                user_id: c.userId,\r\n                location_id: c.locationId,\r\n                created_at: c.createdAt.toISOString(),\r\n                updated_at: c.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskCategoryAction(userId: string, locationId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.create({\r\n            data: { userId, locationId, name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskCategoryAction(id: string, userId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.update({\r\n            where: { id, userId },\r\n            data: { name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskCategoryAction(id: string, userId: string) {\r\n    try {\r\n        await db.taskCategory.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const defaultNames = ['General', 'Marketing', 'Operations', 'Finance', 'Follow-up'];\r\n\r\n        const existing = await db.taskCategory.findMany({\r\n            where: { userId, locationId, name: { in: defaultNames } },\r\n            select: { name: true }\r\n        });\r\n\r\n        const existingNames = new Set(existing.map(e => e.name));\r\n        const toCreate = defaultNames.filter(n => !existingNames.has(n)).map(name => ({\r\n            userId,\r\n            locationId,\r\n            name\r\n        }));\r\n\r\n        if (toCreate.length > 0) {\r\n            await db.taskCategory.createMany({ data: toCreate });\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA6DsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,oDAAA"}},
    {"offset": {"line": 105, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/tasks.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, TaskPriority, RecurrenceType } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { addDays, addWeeks, addMonths, format, parseISO } from 'date-fns';\r\n\r\n// --- TASKS ---\r\n\r\nexport interface CreateTaskInput {\r\n    userId: string;\r\n    locationId: string;\r\n    title: string;\r\n    description?: string | null;\r\n    priority: TaskPriority;\r\n    dueDate: Date;\r\n    category?: string | null;\r\n    reminderEnabled?: boolean;\r\n    reminderTime?: string | null;\r\n    isRecurring?: boolean;\r\n    recurrenceType?: RecurrenceType | null;\r\n    recurrenceEndDate?: Date | null;\r\n}\r\n\r\nexport async function getTasksAction(userId: string, locationId: string) {\r\n    try {\r\n        const tasks = await db.task.findMany({\r\n            where: {\r\n                userId,\r\n                locationId,\r\n                deletedAt: null\r\n            },\r\n            orderBy: {\r\n                dueDate: 'asc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: tasks.map(t => ({\r\n                ...t,\r\n                user_id: t.userId,\r\n                location_id: t.locationId,\r\n                due_date: t.dueDate.toISOString().split('T')[0],\r\n                completed_at: t.completedAt?.toISOString() || null,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                reminder_enabled: t.reminderEnabled,\r\n                reminder_time: t.reminderTime,\r\n                is_recurring: t.isRecurring,\r\n                recurrence_type: t.recurrenceType,\r\n                recurrence_end_date: t.recurrenceEndDate?.toISOString().split('T')[0] || null,\r\n                parent_task_id: t.parentTaskId,\r\n                recurrence_count: t.recurrenceCount\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskAction(data: CreateTaskInput) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the main task\r\n            const task = await tx.task.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    title: data.title,\r\n                    description: data.description || null,\r\n                    priority: data.priority,\r\n                    dueDate: data.dueDate,\r\n                    category: data.category || null,\r\n                    reminderEnabled: data.reminderEnabled || false,\r\n                    reminderTime: data.reminderTime || null,\r\n                    isRecurring: data.isRecurring || false,\r\n                    recurrenceType: data.recurrenceType || null,\r\n                    recurrenceEndDate: data.recurrenceEndDate || null\r\n                }\r\n            });\r\n\r\n            // 2. If it's recurring, create instances\r\n            if (task.isRecurring && task.recurrenceType && task.recurrenceEndDate) {\r\n                const instances = [];\r\n                let currentDate = task.dueDate;\r\n                const endDate = task.recurrenceEndDate;\r\n                let count = 0;\r\n\r\n                while (count < 365) {\r\n                    let nextDate: Date;\r\n                    switch (task.recurrenceType) {\r\n                        case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                        case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                        case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                        default: nextDate = currentDate;\r\n                    }\r\n\r\n                    if (nextDate > endDate) break;\r\n\r\n                    instances.push({\r\n                        userId: task.userId,\r\n                        locationId: task.locationId,\r\n                        title: task.title,\r\n                        description: task.description,\r\n                        priority: task.priority,\r\n                        dueDate: nextDate,\r\n                        category: task.category,\r\n                        completed: false,\r\n                        reminderEnabled: task.reminderEnabled,\r\n                        reminderTime: task.reminderTime,\r\n                        isRecurring: false,\r\n                        parentTaskId: task.id,\r\n                        recurrenceCount: count + 1\r\n                    });\r\n\r\n                    currentDate = nextDate;\r\n                    count++;\r\n                }\r\n\r\n                if (instances.length > 0) {\r\n                    await tx.task.createMany({\r\n                        data: instances\r\n                    });\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskAction(id: string, userId: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const task = await tx.task.update({\r\n                where: { id, userId },\r\n                data: {\r\n                    ...updates,\r\n                    // Map camelCase to PascalCase if necessary, but prisma models use camelCase for fields\r\n                }\r\n            });\r\n\r\n            // If recurring settings changed, we might need to recreate instances\r\n            if (task.isRecurring && (updates.recurrenceType || updates.recurrenceEndDate)) {\r\n                // Delete existing pending instances\r\n                await tx.task.deleteMany({\r\n                    where: { parentTaskId: id, completed: false }\r\n                });\r\n\r\n                // Create new ones\r\n                if (task.recurrenceType && task.recurrenceEndDate) {\r\n                    const instances = [];\r\n                    let currentDate = task.dueDate;\r\n                    const endDate = task.recurrenceEndDate;\r\n                    let count = 0;\r\n\r\n                    while (count < 365) {\r\n                        let nextDate: Date;\r\n                        switch (task.recurrenceType!) {\r\n                            case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                            case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                            case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                            default: nextDate = currentDate;\r\n                        }\r\n                        if (nextDate > endDate) break;\r\n\r\n                        instances.push({\r\n                            userId: task.userId,\r\n                            locationId: task.locationId,\r\n                            title: task.title,\r\n                            description: task.description,\r\n                            priority: task.priority,\r\n                            dueDate: nextDate,\r\n                            category: task.category,\r\n                            isRecurring: false,\r\n                            parentTaskId: task.id,\r\n                            recurrenceCount: count + 1\r\n                        });\r\n                        currentDate = nextDate;\r\n                        count++;\r\n                    }\r\n                    if (instances.length > 0) {\r\n                        await tx.task.createMany({ data: instances });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskAction(id: string, userId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Delete instances first\r\n            await tx.task.deleteMany({\r\n                where: { parentTaskId: id, completed: false }\r\n            });\r\n\r\n            await tx.task.delete({\r\n                where: { id, userId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function bulkUpdateTasksAction(ids: string[], userId: string, updates: any) {\r\n    try {\r\n        await db.task.updateMany({\r\n            where: { id: { in: ids }, userId },\r\n            data: updates\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error bulk updating tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CATEGORIES ---\r\n\r\nexport async function getTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const categories = await db.taskCategory.findMany({\r\n            where: { userId, locationId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map(c => ({\r\n                ...c,\r\n                user_id: c.userId,\r\n                location_id: c.locationId,\r\n                created_at: c.createdAt.toISOString(),\r\n                updated_at: c.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskCategoryAction(userId: string, locationId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.create({\r\n            data: { userId, locationId, name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskCategoryAction(id: string, userId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.update({\r\n            where: { id, userId },\r\n            data: { name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskCategoryAction(id: string, userId: string) {\r\n    try {\r\n        await db.taskCategory.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const defaultNames = ['General', 'Marketing', 'Operations', 'Finance', 'Follow-up'];\r\n\r\n        const existing = await db.taskCategory.findMany({\r\n            where: { userId, locationId, name: { in: defaultNames } },\r\n            select: { name: true }\r\n        });\r\n\r\n        const existingNames = new Set(existing.map(e => e.name));\r\n        const toCreate = defaultNames.filter(n => !existingNames.has(n)).map(name => ({\r\n            userId,\r\n            locationId,\r\n            name\r\n        }));\r\n\r\n        if (toCreate.length > 0) {\r\n            await db.taskCategory.createMany({ data: toCreate });\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0IsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,oDAAA"}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/tasks.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, TaskPriority, RecurrenceType } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { addDays, addWeeks, addMonths, format, parseISO } from 'date-fns';\r\n\r\n// --- TASKS ---\r\n\r\nexport interface CreateTaskInput {\r\n    userId: string;\r\n    locationId: string;\r\n    title: string;\r\n    description?: string | null;\r\n    priority: TaskPriority;\r\n    dueDate: Date;\r\n    category?: string | null;\r\n    reminderEnabled?: boolean;\r\n    reminderTime?: string | null;\r\n    isRecurring?: boolean;\r\n    recurrenceType?: RecurrenceType | null;\r\n    recurrenceEndDate?: Date | null;\r\n}\r\n\r\nexport async function getTasksAction(userId: string, locationId: string) {\r\n    try {\r\n        const tasks = await db.task.findMany({\r\n            where: {\r\n                userId,\r\n                locationId,\r\n                deletedAt: null\r\n            },\r\n            orderBy: {\r\n                dueDate: 'asc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: tasks.map(t => ({\r\n                ...t,\r\n                user_id: t.userId,\r\n                location_id: t.locationId,\r\n                due_date: t.dueDate.toISOString().split('T')[0],\r\n                completed_at: t.completedAt?.toISOString() || null,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                reminder_enabled: t.reminderEnabled,\r\n                reminder_time: t.reminderTime,\r\n                is_recurring: t.isRecurring,\r\n                recurrence_type: t.recurrenceType,\r\n                recurrence_end_date: t.recurrenceEndDate?.toISOString().split('T')[0] || null,\r\n                parent_task_id: t.parentTaskId,\r\n                recurrence_count: t.recurrenceCount\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskAction(data: CreateTaskInput) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the main task\r\n            const task = await tx.task.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    title: data.title,\r\n                    description: data.description || null,\r\n                    priority: data.priority,\r\n                    dueDate: data.dueDate,\r\n                    category: data.category || null,\r\n                    reminderEnabled: data.reminderEnabled || false,\r\n                    reminderTime: data.reminderTime || null,\r\n                    isRecurring: data.isRecurring || false,\r\n                    recurrenceType: data.recurrenceType || null,\r\n                    recurrenceEndDate: data.recurrenceEndDate || null\r\n                }\r\n            });\r\n\r\n            // 2. If it's recurring, create instances\r\n            if (task.isRecurring && task.recurrenceType && task.recurrenceEndDate) {\r\n                const instances = [];\r\n                let currentDate = task.dueDate;\r\n                const endDate = task.recurrenceEndDate;\r\n                let count = 0;\r\n\r\n                while (count < 365) {\r\n                    let nextDate: Date;\r\n                    switch (task.recurrenceType) {\r\n                        case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                        case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                        case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                        default: nextDate = currentDate;\r\n                    }\r\n\r\n                    if (nextDate > endDate) break;\r\n\r\n                    instances.push({\r\n                        userId: task.userId,\r\n                        locationId: task.locationId,\r\n                        title: task.title,\r\n                        description: task.description,\r\n                        priority: task.priority,\r\n                        dueDate: nextDate,\r\n                        category: task.category,\r\n                        completed: false,\r\n                        reminderEnabled: task.reminderEnabled,\r\n                        reminderTime: task.reminderTime,\r\n                        isRecurring: false,\r\n                        parentTaskId: task.id,\r\n                        recurrenceCount: count + 1\r\n                    });\r\n\r\n                    currentDate = nextDate;\r\n                    count++;\r\n                }\r\n\r\n                if (instances.length > 0) {\r\n                    await tx.task.createMany({\r\n                        data: instances\r\n                    });\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskAction(id: string, userId: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const task = await tx.task.update({\r\n                where: { id, userId },\r\n                data: {\r\n                    ...updates,\r\n                    // Map camelCase to PascalCase if necessary, but prisma models use camelCase for fields\r\n                }\r\n            });\r\n\r\n            // If recurring settings changed, we might need to recreate instances\r\n            if (task.isRecurring && (updates.recurrenceType || updates.recurrenceEndDate)) {\r\n                // Delete existing pending instances\r\n                await tx.task.deleteMany({\r\n                    where: { parentTaskId: id, completed: false }\r\n                });\r\n\r\n                // Create new ones\r\n                if (task.recurrenceType && task.recurrenceEndDate) {\r\n                    const instances = [];\r\n                    let currentDate = task.dueDate;\r\n                    const endDate = task.recurrenceEndDate;\r\n                    let count = 0;\r\n\r\n                    while (count < 365) {\r\n                        let nextDate: Date;\r\n                        switch (task.recurrenceType!) {\r\n                            case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                            case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                            case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                            default: nextDate = currentDate;\r\n                        }\r\n                        if (nextDate > endDate) break;\r\n\r\n                        instances.push({\r\n                            userId: task.userId,\r\n                            locationId: task.locationId,\r\n                            title: task.title,\r\n                            description: task.description,\r\n                            priority: task.priority,\r\n                            dueDate: nextDate,\r\n                            category: task.category,\r\n                            isRecurring: false,\r\n                            parentTaskId: task.id,\r\n                            recurrenceCount: count + 1\r\n                        });\r\n                        currentDate = nextDate;\r\n                        count++;\r\n                    }\r\n                    if (instances.length > 0) {\r\n                        await tx.task.createMany({ data: instances });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskAction(id: string, userId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Delete instances first\r\n            await tx.task.deleteMany({\r\n                where: { parentTaskId: id, completed: false }\r\n            });\r\n\r\n            await tx.task.delete({\r\n                where: { id, userId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function bulkUpdateTasksAction(ids: string[], userId: string, updates: any) {\r\n    try {\r\n        await db.task.updateMany({\r\n            where: { id: { in: ids }, userId },\r\n            data: updates\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error bulk updating tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CATEGORIES ---\r\n\r\nexport async function getTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const categories = await db.taskCategory.findMany({\r\n            where: { userId, locationId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map(c => ({\r\n                ...c,\r\n                user_id: c.userId,\r\n                location_id: c.locationId,\r\n                created_at: c.createdAt.toISOString(),\r\n                updated_at: c.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskCategoryAction(userId: string, locationId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.create({\r\n            data: { userId, locationId, name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskCategoryAction(id: string, userId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.update({\r\n            where: { id, userId },\r\n            data: { name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskCategoryAction(id: string, userId: string) {\r\n    try {\r\n        await db.taskCategory.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const defaultNames = ['General', 'Marketing', 'Operations', 'Finance', 'Follow-up'];\r\n\r\n        const existing = await db.taskCategory.findMany({\r\n            where: { userId, locationId, name: { in: defaultNames } },\r\n            select: { name: true }\r\n        });\r\n\r\n        const existingNames = new Set(existing.map(e => e.name));\r\n        const toCreate = defaultNames.filter(n => !existingNames.has(n)).map(name => ({\r\n            userId,\r\n            locationId,\r\n            name\r\n        }));\r\n\r\n        if (toCreate.length > 0) {\r\n            await db.taskCategory.createMany({ data: toCreate });\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA6MsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,oDAAA"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/tasks.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, TaskPriority, RecurrenceType } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { addDays, addWeeks, addMonths, format, parseISO } from 'date-fns';\r\n\r\n// --- TASKS ---\r\n\r\nexport interface CreateTaskInput {\r\n    userId: string;\r\n    locationId: string;\r\n    title: string;\r\n    description?: string | null;\r\n    priority: TaskPriority;\r\n    dueDate: Date;\r\n    category?: string | null;\r\n    reminderEnabled?: boolean;\r\n    reminderTime?: string | null;\r\n    isRecurring?: boolean;\r\n    recurrenceType?: RecurrenceType | null;\r\n    recurrenceEndDate?: Date | null;\r\n}\r\n\r\nexport async function getTasksAction(userId: string, locationId: string) {\r\n    try {\r\n        const tasks = await db.task.findMany({\r\n            where: {\r\n                userId,\r\n                locationId,\r\n                deletedAt: null\r\n            },\r\n            orderBy: {\r\n                dueDate: 'asc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: tasks.map(t => ({\r\n                ...t,\r\n                user_id: t.userId,\r\n                location_id: t.locationId,\r\n                due_date: t.dueDate.toISOString().split('T')[0],\r\n                completed_at: t.completedAt?.toISOString() || null,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                reminder_enabled: t.reminderEnabled,\r\n                reminder_time: t.reminderTime,\r\n                is_recurring: t.isRecurring,\r\n                recurrence_type: t.recurrenceType,\r\n                recurrence_end_date: t.recurrenceEndDate?.toISOString().split('T')[0] || null,\r\n                parent_task_id: t.parentTaskId,\r\n                recurrence_count: t.recurrenceCount\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskAction(data: CreateTaskInput) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the main task\r\n            const task = await tx.task.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    title: data.title,\r\n                    description: data.description || null,\r\n                    priority: data.priority,\r\n                    dueDate: data.dueDate,\r\n                    category: data.category || null,\r\n                    reminderEnabled: data.reminderEnabled || false,\r\n                    reminderTime: data.reminderTime || null,\r\n                    isRecurring: data.isRecurring || false,\r\n                    recurrenceType: data.recurrenceType || null,\r\n                    recurrenceEndDate: data.recurrenceEndDate || null\r\n                }\r\n            });\r\n\r\n            // 2. If it's recurring, create instances\r\n            if (task.isRecurring && task.recurrenceType && task.recurrenceEndDate) {\r\n                const instances = [];\r\n                let currentDate = task.dueDate;\r\n                const endDate = task.recurrenceEndDate;\r\n                let count = 0;\r\n\r\n                while (count < 365) {\r\n                    let nextDate: Date;\r\n                    switch (task.recurrenceType) {\r\n                        case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                        case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                        case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                        default: nextDate = currentDate;\r\n                    }\r\n\r\n                    if (nextDate > endDate) break;\r\n\r\n                    instances.push({\r\n                        userId: task.userId,\r\n                        locationId: task.locationId,\r\n                        title: task.title,\r\n                        description: task.description,\r\n                        priority: task.priority,\r\n                        dueDate: nextDate,\r\n                        category: task.category,\r\n                        completed: false,\r\n                        reminderEnabled: task.reminderEnabled,\r\n                        reminderTime: task.reminderTime,\r\n                        isRecurring: false,\r\n                        parentTaskId: task.id,\r\n                        recurrenceCount: count + 1\r\n                    });\r\n\r\n                    currentDate = nextDate;\r\n                    count++;\r\n                }\r\n\r\n                if (instances.length > 0) {\r\n                    await tx.task.createMany({\r\n                        data: instances\r\n                    });\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskAction(id: string, userId: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const task = await tx.task.update({\r\n                where: { id, userId },\r\n                data: {\r\n                    ...updates,\r\n                    // Map camelCase to PascalCase if necessary, but prisma models use camelCase for fields\r\n                }\r\n            });\r\n\r\n            // If recurring settings changed, we might need to recreate instances\r\n            if (task.isRecurring && (updates.recurrenceType || updates.recurrenceEndDate)) {\r\n                // Delete existing pending instances\r\n                await tx.task.deleteMany({\r\n                    where: { parentTaskId: id, completed: false }\r\n                });\r\n\r\n                // Create new ones\r\n                if (task.recurrenceType && task.recurrenceEndDate) {\r\n                    const instances = [];\r\n                    let currentDate = task.dueDate;\r\n                    const endDate = task.recurrenceEndDate;\r\n                    let count = 0;\r\n\r\n                    while (count < 365) {\r\n                        let nextDate: Date;\r\n                        switch (task.recurrenceType!) {\r\n                            case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                            case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                            case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                            default: nextDate = currentDate;\r\n                        }\r\n                        if (nextDate > endDate) break;\r\n\r\n                        instances.push({\r\n                            userId: task.userId,\r\n                            locationId: task.locationId,\r\n                            title: task.title,\r\n                            description: task.description,\r\n                            priority: task.priority,\r\n                            dueDate: nextDate,\r\n                            category: task.category,\r\n                            isRecurring: false,\r\n                            parentTaskId: task.id,\r\n                            recurrenceCount: count + 1\r\n                        });\r\n                        currentDate = nextDate;\r\n                        count++;\r\n                    }\r\n                    if (instances.length > 0) {\r\n                        await tx.task.createMany({ data: instances });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskAction(id: string, userId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Delete instances first\r\n            await tx.task.deleteMany({\r\n                where: { parentTaskId: id, completed: false }\r\n            });\r\n\r\n            await tx.task.delete({\r\n                where: { id, userId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function bulkUpdateTasksAction(ids: string[], userId: string, updates: any) {\r\n    try {\r\n        await db.task.updateMany({\r\n            where: { id: { in: ids }, userId },\r\n            data: updates\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error bulk updating tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CATEGORIES ---\r\n\r\nexport async function getTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const categories = await db.taskCategory.findMany({\r\n            where: { userId, locationId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map(c => ({\r\n                ...c,\r\n                user_id: c.userId,\r\n                location_id: c.locationId,\r\n                created_at: c.createdAt.toISOString(),\r\n                updated_at: c.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskCategoryAction(userId: string, locationId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.create({\r\n            data: { userId, locationId, name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskCategoryAction(id: string, userId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.update({\r\n            where: { id, userId },\r\n            data: { name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskCategoryAction(id: string, userId: string) {\r\n    try {\r\n        await db.taskCategory.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const defaultNames = ['General', 'Marketing', 'Operations', 'Finance', 'Follow-up'];\r\n\r\n        const existing = await db.taskCategory.findMany({\r\n            where: { userId, locationId, name: { in: defaultNames } },\r\n            select: { name: true }\r\n        });\r\n\r\n        const existingNames = new Set(existing.map(e => e.name));\r\n        const toCreate = defaultNames.filter(n => !existingNames.has(n)).map(name => ({\r\n            userId,\r\n            locationId,\r\n            name\r\n        }));\r\n\r\n        if (toCreate.length > 0) {\r\n            await db.taskCategory.createMany({ data: toCreate });\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAkOsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,yDAAA"}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useTasks.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\nimport { Task, CreateTaskData, UpdateTaskData } from '@/types/task';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { toast } from 'sonner';\r\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\r\nimport {\r\n  getTasksAction,\r\n  createTaskAction,\r\n  updateTaskAction,\r\n  deleteTaskAction,\r\n  bulkUpdateTasksAction,\r\n  CreateTaskInput\r\n} from '@/app/actions/tasks';\r\n\r\nexport const useTasks = () => {\r\n  const [tasks, setTasks] = useState<Task[]>([]);\r\n  const { user } = useAuth();\r\n  const { currentBusiness } = useBusiness();\r\n  const queryClient = useQueryClient();\r\n\r\n  const loadTasks = useCallback(async (): Promise<Task[]> => {\r\n    if (!user?.id || !currentBusiness?.id) {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const result = await getTasksAction(user.id, currentBusiness.id);\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error || 'Failed to fetch tasks');\r\n      }\r\n\r\n      return result.data as Task[];\r\n    } catch (error) {\r\n      console.error('Error loading tasks:', error);\r\n      toast.error('Failed to load tasks');\r\n      return [];\r\n    }\r\n  }, [user?.id, currentBusiness?.id]);\r\n\r\n  // React Query caching\r\n  const queryKey = ['tasks', user?.id, currentBusiness?.id];\r\n  const { data: queriedTasks, isLoading: isQueryLoading, isFetching } = useQuery({\r\n    queryKey,\r\n    queryFn: loadTasks,\r\n    enabled: !!user?.id && !!currentBusiness?.id,\r\n    staleTime: 5 * 60_000,\r\n    gcTime: 30 * 60_000,\r\n    refetchOnWindowFocus: false,\r\n    refetchOnReconnect: false,\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (queriedTasks) {\r\n      setTasks(queriedTasks);\r\n    }\r\n  }, [queriedTasks]);\r\n\r\n  // Derived loading state to prevent flash when background fetching\r\n  const isLoading = isQueryLoading && !queriedTasks;\r\n\r\n  const createTask = async (taskData: CreateTaskData): Promise<Task | null> => {\r\n    if (!user?.id || !currentBusiness?.id) return null;\r\n\r\n    try {\r\n      const input: CreateTaskInput = {\r\n        userId: user.id,\r\n        locationId: currentBusiness.id,\r\n        title: taskData.title,\r\n        description: taskData.description,\r\n        priority: taskData.priority as any,\r\n        dueDate: new Date(taskData.due_date),\r\n        category: taskData.category,\r\n        reminderEnabled: taskData.reminder_enabled,\r\n        reminderTime: taskData.reminder_time && taskData.reminder_time.trim() !== '' ? taskData.reminder_time : null,\r\n        isRecurring: taskData.is_recurring,\r\n        recurrenceType: taskData.recurrence_type as any,\r\n        recurrenceEndDate: taskData.recurrence_end_date ? new Date(taskData.recurrence_end_date) : null\r\n      };\r\n\r\n      const result = await createTaskAction(input);\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error);\r\n      }\r\n\r\n      const data = result.data as any;\r\n      const newTask: Task = {\r\n        ...data,\r\n        user_id: data.userId,\r\n        location_id: data.locationId,\r\n        due_date: data.dueDate.toISOString().split('T')[0],\r\n        completed_at: data.completedAt?.toISOString() || null,\r\n        created_at: data.createdAt.toISOString(),\r\n        updated_at: data.updatedAt.toISOString(),\r\n        reminder_enabled: data.reminderEnabled,\r\n        reminder_time: data.reminderTime,\r\n        is_recurring: data.isRecurring,\r\n        recurrence_type: data.recurrenceType,\r\n        recurrence_end_date: data.recurrenceEndDate?.toISOString().split('T')[0] || null,\r\n        parent_task_id: data.parentTaskId,\r\n        recurrence_count: data.recurrenceCount\r\n      };\r\n\r\n      // Update local state and cache\r\n      setTasks(prev => [newTask, ...prev]);\r\n      queryClient.setQueryData(queryKey, (oldData: Task[] | undefined) => {\r\n        return oldData ? [newTask, ...oldData] : [newTask];\r\n      });\r\n\r\n      queryClient.invalidateQueries({ queryKey });\r\n      toast.success('Task created successfully');\r\n      return newTask;\r\n    } catch (error) {\r\n      console.error('Error creating task:', error);\r\n      toast.error('Failed to create task');\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updateTask = async (id: string, updates: UpdateTaskData): Promise<boolean> => {\r\n    if (!user?.id) return false;\r\n\r\n    try {\r\n      // Prepare updates for server action\r\n      const serverUpdates: any = {\r\n        ...updates,\r\n      };\r\n\r\n      if (updates.due_date) serverUpdates.dueDate = new Date(updates.due_date);\r\n      if (updates.completed_at) serverUpdates.completedAt = new Date(updates.completed_at);\r\n      if (updates.recurrence_end_date) serverUpdates.recurrenceEndDate = new Date(updates.recurrence_end_date);\r\n      if (updates.is_recurring !== undefined) serverUpdates.isRecurring = updates.is_recurring;\r\n      if (updates.recurrence_type) serverUpdates.recurrenceType = updates.recurrence_type;\r\n\r\n      // Clean reminder_time\r\n      if (updates.reminder_time !== undefined) {\r\n        serverUpdates.reminderTime = (updates.reminder_time && updates.reminder_time.trim() !== '' ? updates.reminder_time : null);\r\n      }\r\n\r\n      const result = await updateTaskAction(id, user.id, serverUpdates);\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error);\r\n      }\r\n\r\n      queryClient.invalidateQueries({ queryKey });\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating task:', error);\r\n      toast.error('Failed to update task');\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const toggleTaskCompletion = async (id: string): Promise<boolean> => {\r\n    const task = tasks.find(t => t.id === id);\r\n    if (!task) return false;\r\n\r\n    const updates: UpdateTaskData = {\r\n      completed: !task.completed,\r\n      completed_at: !task.completed ? new Date().toISOString() : null,\r\n    };\r\n\r\n    const success = await updateTask(id, updates);\r\n\r\n    if (success) {\r\n      if (!task.completed) {\r\n        toast.success('Well done!  Task completed');\r\n      } else {\r\n        toast.success('Task marked as pending');\r\n      }\r\n    }\r\n\r\n    return success;\r\n  };\r\n\r\n  const deleteTask = async (id: string): Promise<boolean> => {\r\n    if (!user?.id) return false;\r\n\r\n    try {\r\n      const result = await deleteTaskAction(id, user.id);\r\n\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      queryClient.invalidateQueries({ queryKey });\r\n      toast.success('Task deleted successfully');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting task:', error);\r\n      toast.error('Failed to delete task');\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const bulkUpdateTasks = async (taskIds: string[], updates: UpdateTaskData): Promise<boolean> => {\r\n    if (!user?.id || taskIds.length === 0) return false;\r\n\r\n    try {\r\n      // Map keys as in updateTask\r\n      const serverUpdates: any = { ...updates };\r\n      if (updates.completed !== undefined) serverUpdates.completed = updates.completed;\r\n      if (updates.completed_at !== undefined) serverUpdates.completedAt = updates.completed_at ? new Date(updates.completed_at) : null;\r\n\r\n      const result = await bulkUpdateTasksAction(taskIds, user.id, serverUpdates);\r\n\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      queryClient.invalidateQueries({ queryKey });\r\n      toast.success(`Updated ${taskIds.length} tasks`);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error bulk updating tasks:', error);\r\n      toast.error('Failed to update tasks');\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const refreshTasks = () => {\r\n    queryClient.invalidateQueries({ queryKey });\r\n  };\r\n\r\n  return {\r\n    tasks,\r\n    isLoading,\r\n    createTask,\r\n    updateTask,\r\n    deleteTask,\r\n    toggleTaskCompletion,\r\n    bulkUpdateTasks,\r\n    refreshTasks,\r\n  };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AASO,MAAM,WAAW;;IACtB,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAS,EAAE;IAC7C,MAAM,EAAE,IAAI,EAAE,GAAG,IAAA,wJAAO;IACxB,MAAM,EAAE,eAAe,EAAE,GAAG,IAAA,qJAAW;IACvC,MAAM,cAAc,IAAA,2MAAc;IAElC,MAAM,YAAY,IAAA,4KAAW;2CAAC;YAC5B,IAAI,CAAC,MAAM,MAAM,CAAC,iBAAiB,IAAI;gBACrC,OAAO,EAAE;YACX;YAEA,IAAI;gBACF,MAAM,SAAS,MAAM,IAAA,kLAAc,EAAC,KAAK,EAAE,EAAE,gBAAgB,EAAE;gBAE/D,IAAI,CAAC,OAAO,OAAO,IAAI,CAAC,OAAO,IAAI,EAAE;oBACnC,MAAM,IAAI,MAAM,OAAO,KAAK,IAAI;gBAClC;gBAEA,OAAO,OAAO,IAAI;YACpB,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,wBAAwB;gBACtC,oJAAK,CAAC,KAAK,CAAC;gBACZ,OAAO,EAAE;YACX;QACF;0CAAG;QAAC,MAAM;QAAI,iBAAiB;KAAG;IAElC,sBAAsB;IACtB,MAAM,WAAW;QAAC;QAAS,MAAM;QAAI,iBAAiB;KAAG;IACzD,MAAM,EAAE,MAAM,YAAY,EAAE,WAAW,cAAc,EAAE,UAAU,EAAE,GAAG,IAAA,0LAAQ,EAAC;QAC7E;QACA,SAAS;QACT,SAAS,CAAC,CAAC,MAAM,MAAM,CAAC,CAAC,iBAAiB;QAC1C,WAAW,IAAI;QACf,QAAQ,KAAK;QACb,sBAAsB;QACtB,oBAAoB;IACtB;IAEA,IAAA,0KAAS;8BAAC;YACR,IAAI,cAAc;gBAChB,SAAS;YACX;QACF;6BAAG;QAAC;KAAa;IAEjB,kEAAkE;IAClE,MAAM,YAAY,kBAAkB,CAAC;IAErC,MAAM,aAAa,OAAO;QACxB,IAAI,CAAC,MAAM,MAAM,CAAC,iBAAiB,IAAI,OAAO;QAE9C,IAAI;YACF,MAAM,QAAyB;gBAC7B,QAAQ,KAAK,EAAE;gBACf,YAAY,gBAAgB,EAAE;gBAC9B,OAAO,SAAS,KAAK;gBACrB,aAAa,SAAS,WAAW;gBACjC,UAAU,SAAS,QAAQ;gBAC3B,SAAS,IAAI,KAAK,SAAS,QAAQ;gBACnC,UAAU,SAAS,QAAQ;gBAC3B,iBAAiB,SAAS,gBAAgB;gBAC1C,cAAc,SAAS,aAAa,IAAI,SAAS,aAAa,CAAC,IAAI,OAAO,KAAK,SAAS,aAAa,GAAG;gBACxG,aAAa,SAAS,YAAY;gBAClC,gBAAgB,SAAS,eAAe;gBACxC,mBAAmB,SAAS,mBAAmB,GAAG,IAAI,KAAK,SAAS,mBAAmB,IAAI;YAC7F;YAEA,MAAM,SAAS,MAAM,IAAA,oLAAgB,EAAC;YAEtC,IAAI,CAAC,OAAO,OAAO,IAAI,CAAC,OAAO,IAAI,EAAE;gBACnC,MAAM,IAAI,MAAM,OAAO,KAAK;YAC9B;YAEA,MAAM,OAAO,OAAO,IAAI;YACxB,MAAM,UAAgB;gBACpB,GAAG,IAAI;gBACP,SAAS,KAAK,MAAM;gBACpB,aAAa,KAAK,UAAU;gBAC5B,UAAU,KAAK,OAAO,CAAC,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE;gBAClD,cAAc,KAAK,WAAW,EAAE,iBAAiB;gBACjD,YAAY,KAAK,SAAS,CAAC,WAAW;gBACtC,YAAY,KAAK,SAAS,CAAC,WAAW;gBACtC,kBAAkB,KAAK,eAAe;gBACtC,eAAe,KAAK,YAAY;gBAChC,cAAc,KAAK,WAAW;gBAC9B,iBAAiB,KAAK,cAAc;gBACpC,qBAAqB,KAAK,iBAAiB,EAAE,cAAc,MAAM,IAAI,CAAC,EAAE,IAAI;gBAC5E,gBAAgB,KAAK,YAAY;gBACjC,kBAAkB,KAAK,eAAe;YACxC;YAEA,+BAA+B;YAC/B,SAAS,CAAA,OAAQ;oBAAC;uBAAY;iBAAK;YACnC,YAAY,YAAY,CAAC,UAAU,CAAC;gBAClC,OAAO,UAAU;oBAAC;uBAAY;iBAAQ,GAAG;oBAAC;iBAAQ;YACpD;YAEA,YAAY,iBAAiB,CAAC;gBAAE;YAAS;YACzC,oJAAK,CAAC,OAAO,CAAC;YACd,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wBAAwB;YACtC,oJAAK,CAAC,KAAK,CAAC;YACZ,OAAO;QACT;IACF;IAEA,MAAM,aAAa,OAAO,IAAY;QACpC,IAAI,CAAC,MAAM,IAAI,OAAO;QAEtB,IAAI;YACF,oCAAoC;YACpC,MAAM,gBAAqB;gBACzB,GAAG,OAAO;YACZ;YAEA,IAAI,QAAQ,QAAQ,EAAE,cAAc,OAAO,GAAG,IAAI,KAAK,QAAQ,QAAQ;YACvE,IAAI,QAAQ,YAAY,EAAE,cAAc,WAAW,GAAG,IAAI,KAAK,QAAQ,YAAY;YACnF,IAAI,QAAQ,mBAAmB,EAAE,cAAc,iBAAiB,GAAG,IAAI,KAAK,QAAQ,mBAAmB;YACvG,IAAI,QAAQ,YAAY,KAAK,WAAW,cAAc,WAAW,GAAG,QAAQ,YAAY;YACxF,IAAI,QAAQ,eAAe,EAAE,cAAc,cAAc,GAAG,QAAQ,eAAe;YAEnF,sBAAsB;YACtB,IAAI,QAAQ,aAAa,KAAK,WAAW;gBACvC,cAAc,YAAY,GAAI,QAAQ,aAAa,IAAI,QAAQ,aAAa,CAAC,IAAI,OAAO,KAAK,QAAQ,aAAa,GAAG;YACvH;YAEA,MAAM,SAAS,MAAM,IAAA,oLAAgB,EAAC,IAAI,KAAK,EAAE,EAAE;YAEnD,IAAI,CAAC,OAAO,OAAO,IAAI,CAAC,OAAO,IAAI,EAAE;gBACnC,MAAM,IAAI,MAAM,OAAO,KAAK;YAC9B;YAEA,YAAY,iBAAiB,CAAC;gBAAE;YAAS;YACzC,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wBAAwB;YACtC,oJAAK,CAAC,KAAK,CAAC;YACZ,OAAO;QACT;IACF;IAEA,MAAM,uBAAuB,OAAO;QAClC,MAAM,OAAO,MAAM,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QACtC,IAAI,CAAC,MAAM,OAAO;QAElB,MAAM,UAA0B;YAC9B,WAAW,CAAC,KAAK,SAAS;YAC1B,cAAc,CAAC,KAAK,SAAS,GAAG,IAAI,OAAO,WAAW,KAAK;QAC7D;QAEA,MAAM,UAAU,MAAM,WAAW,IAAI;QAErC,IAAI,SAAS;YACX,IAAI,CAAC,KAAK,SAAS,EAAE;gBACnB,oJAAK,CAAC,OAAO,CAAC;YAChB,OAAO;gBACL,oJAAK,CAAC,OAAO,CAAC;YAChB;QACF;QAEA,OAAO;IACT;IAEA,MAAM,aAAa,OAAO;QACxB,IAAI,CAAC,MAAM,IAAI,OAAO;QAEtB,IAAI;YACF,MAAM,SAAS,MAAM,IAAA,oLAAgB,EAAC,IAAI,KAAK,EAAE;YAEjD,IAAI,CAAC,OAAO,OAAO,EAAE,MAAM,IAAI,MAAM,OAAO,KAAK;YAEjD,YAAY,iBAAiB,CAAC;gBAAE;YAAS;YACzC,oJAAK,CAAC,OAAO,CAAC;YACd,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wBAAwB;YACtC,oJAAK,CAAC,KAAK,CAAC;YACZ,OAAO;QACT;IACF;IAEA,MAAM,kBAAkB,OAAO,SAAmB;QAChD,IAAI,CAAC,MAAM,MAAM,QAAQ,MAAM,KAAK,GAAG,OAAO;QAE9C,IAAI;YACF,4BAA4B;YAC5B,MAAM,gBAAqB;gBAAE,GAAG,OAAO;YAAC;YACxC,IAAI,QAAQ,SAAS,KAAK,WAAW,cAAc,SAAS,GAAG,QAAQ,SAAS;YAChF,IAAI,QAAQ,YAAY,KAAK,WAAW,cAAc,WAAW,GAAG,QAAQ,YAAY,GAAG,IAAI,KAAK,QAAQ,YAAY,IAAI;YAE5H,MAAM,SAAS,MAAM,IAAA,yLAAqB,EAAC,SAAS,KAAK,EAAE,EAAE;YAE7D,IAAI,CAAC,OAAO,OAAO,EAAE,MAAM,IAAI,MAAM,OAAO,KAAK;YAEjD,YAAY,iBAAiB,CAAC;gBAAE;YAAS;YACzC,oJAAK,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,QAAQ,MAAM,CAAC,MAAM,CAAC;YAC/C,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,8BAA8B;YAC5C,oJAAK,CAAC,KAAK,CAAC;YACZ,OAAO;QACT;IACF;IAEA,MAAM,eAAe;QACnB,YAAY,iBAAiB,CAAC;YAAE;QAAS;IAC3C;IAEA,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF;GA1Na;;QAEM,wJAAO;QACI,qJAAW;QACnB,2MAAc;QAwBoC,0LAAQ"}},
    {"offset": {"line": 409, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/tasks.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, TaskPriority, RecurrenceType } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { addDays, addWeeks, addMonths, format, parseISO } from 'date-fns';\r\n\r\n// --- TASKS ---\r\n\r\nexport interface CreateTaskInput {\r\n    userId: string;\r\n    locationId: string;\r\n    title: string;\r\n    description?: string | null;\r\n    priority: TaskPriority;\r\n    dueDate: Date;\r\n    category?: string | null;\r\n    reminderEnabled?: boolean;\r\n    reminderTime?: string | null;\r\n    isRecurring?: boolean;\r\n    recurrenceType?: RecurrenceType | null;\r\n    recurrenceEndDate?: Date | null;\r\n}\r\n\r\nexport async function getTasksAction(userId: string, locationId: string) {\r\n    try {\r\n        const tasks = await db.task.findMany({\r\n            where: {\r\n                userId,\r\n                locationId,\r\n                deletedAt: null\r\n            },\r\n            orderBy: {\r\n                dueDate: 'asc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: tasks.map(t => ({\r\n                ...t,\r\n                user_id: t.userId,\r\n                location_id: t.locationId,\r\n                due_date: t.dueDate.toISOString().split('T')[0],\r\n                completed_at: t.completedAt?.toISOString() || null,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                reminder_enabled: t.reminderEnabled,\r\n                reminder_time: t.reminderTime,\r\n                is_recurring: t.isRecurring,\r\n                recurrence_type: t.recurrenceType,\r\n                recurrence_end_date: t.recurrenceEndDate?.toISOString().split('T')[0] || null,\r\n                parent_task_id: t.parentTaskId,\r\n                recurrence_count: t.recurrenceCount\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskAction(data: CreateTaskInput) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the main task\r\n            const task = await tx.task.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    title: data.title,\r\n                    description: data.description || null,\r\n                    priority: data.priority,\r\n                    dueDate: data.dueDate,\r\n                    category: data.category || null,\r\n                    reminderEnabled: data.reminderEnabled || false,\r\n                    reminderTime: data.reminderTime || null,\r\n                    isRecurring: data.isRecurring || false,\r\n                    recurrenceType: data.recurrenceType || null,\r\n                    recurrenceEndDate: data.recurrenceEndDate || null\r\n                }\r\n            });\r\n\r\n            // 2. If it's recurring, create instances\r\n            if (task.isRecurring && task.recurrenceType && task.recurrenceEndDate) {\r\n                const instances = [];\r\n                let currentDate = task.dueDate;\r\n                const endDate = task.recurrenceEndDate;\r\n                let count = 0;\r\n\r\n                while (count < 365) {\r\n                    let nextDate: Date;\r\n                    switch (task.recurrenceType) {\r\n                        case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                        case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                        case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                        default: nextDate = currentDate;\r\n                    }\r\n\r\n                    if (nextDate > endDate) break;\r\n\r\n                    instances.push({\r\n                        userId: task.userId,\r\n                        locationId: task.locationId,\r\n                        title: task.title,\r\n                        description: task.description,\r\n                        priority: task.priority,\r\n                        dueDate: nextDate,\r\n                        category: task.category,\r\n                        completed: false,\r\n                        reminderEnabled: task.reminderEnabled,\r\n                        reminderTime: task.reminderTime,\r\n                        isRecurring: false,\r\n                        parentTaskId: task.id,\r\n                        recurrenceCount: count + 1\r\n                    });\r\n\r\n                    currentDate = nextDate;\r\n                    count++;\r\n                }\r\n\r\n                if (instances.length > 0) {\r\n                    await tx.task.createMany({\r\n                        data: instances\r\n                    });\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskAction(id: string, userId: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const task = await tx.task.update({\r\n                where: { id, userId },\r\n                data: {\r\n                    ...updates,\r\n                    // Map camelCase to PascalCase if necessary, but prisma models use camelCase for fields\r\n                }\r\n            });\r\n\r\n            // If recurring settings changed, we might need to recreate instances\r\n            if (task.isRecurring && (updates.recurrenceType || updates.recurrenceEndDate)) {\r\n                // Delete existing pending instances\r\n                await tx.task.deleteMany({\r\n                    where: { parentTaskId: id, completed: false }\r\n                });\r\n\r\n                // Create new ones\r\n                if (task.recurrenceType && task.recurrenceEndDate) {\r\n                    const instances = [];\r\n                    let currentDate = task.dueDate;\r\n                    const endDate = task.recurrenceEndDate;\r\n                    let count = 0;\r\n\r\n                    while (count < 365) {\r\n                        let nextDate: Date;\r\n                        switch (task.recurrenceType!) {\r\n                            case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                            case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                            case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                            default: nextDate = currentDate;\r\n                        }\r\n                        if (nextDate > endDate) break;\r\n\r\n                        instances.push({\r\n                            userId: task.userId,\r\n                            locationId: task.locationId,\r\n                            title: task.title,\r\n                            description: task.description,\r\n                            priority: task.priority,\r\n                            dueDate: nextDate,\r\n                            category: task.category,\r\n                            isRecurring: false,\r\n                            parentTaskId: task.id,\r\n                            recurrenceCount: count + 1\r\n                        });\r\n                        currentDate = nextDate;\r\n                        count++;\r\n                    }\r\n                    if (instances.length > 0) {\r\n                        await tx.task.createMany({ data: instances });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskAction(id: string, userId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Delete instances first\r\n            await tx.task.deleteMany({\r\n                where: { parentTaskId: id, completed: false }\r\n            });\r\n\r\n            await tx.task.delete({\r\n                where: { id, userId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function bulkUpdateTasksAction(ids: string[], userId: string, updates: any) {\r\n    try {\r\n        await db.task.updateMany({\r\n            where: { id: { in: ids }, userId },\r\n            data: updates\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error bulk updating tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CATEGORIES ---\r\n\r\nexport async function getTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const categories = await db.taskCategory.findMany({\r\n            where: { userId, locationId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map(c => ({\r\n                ...c,\r\n                user_id: c.userId,\r\n                location_id: c.locationId,\r\n                created_at: c.createdAt.toISOString(),\r\n                updated_at: c.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskCategoryAction(userId: string, locationId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.create({\r\n            data: { userId, locationId, name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskCategoryAction(id: string, userId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.update({\r\n            where: { id, userId },\r\n            data: { name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskCategoryAction(id: string, userId: string) {\r\n    try {\r\n        await db.taskCategory.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const defaultNames = ['General', 'Marketing', 'Operations', 'Finance', 'Follow-up'];\r\n\r\n        const existing = await db.taskCategory.findMany({\r\n            where: { userId, locationId, name: { in: defaultNames } },\r\n            select: { name: true }\r\n        });\r\n\r\n        const existingNames = new Set(existing.map(e => e.name));\r\n        const toCreate = defaultNames.filter(n => !existingNames.has(n)).map(name => ({\r\n            userId,\r\n            locationId,\r\n            name\r\n        }));\r\n\r\n        if (toCreate.length > 0) {\r\n            await db.taskCategory.createMany({ data: toCreate });\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAmPsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,2DAAA"}},
    {"offset": {"line": 426, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/tasks.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, TaskPriority, RecurrenceType } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { addDays, addWeeks, addMonths, format, parseISO } from 'date-fns';\r\n\r\n// --- TASKS ---\r\n\r\nexport interface CreateTaskInput {\r\n    userId: string;\r\n    locationId: string;\r\n    title: string;\r\n    description?: string | null;\r\n    priority: TaskPriority;\r\n    dueDate: Date;\r\n    category?: string | null;\r\n    reminderEnabled?: boolean;\r\n    reminderTime?: string | null;\r\n    isRecurring?: boolean;\r\n    recurrenceType?: RecurrenceType | null;\r\n    recurrenceEndDate?: Date | null;\r\n}\r\n\r\nexport async function getTasksAction(userId: string, locationId: string) {\r\n    try {\r\n        const tasks = await db.task.findMany({\r\n            where: {\r\n                userId,\r\n                locationId,\r\n                deletedAt: null\r\n            },\r\n            orderBy: {\r\n                dueDate: 'asc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: tasks.map(t => ({\r\n                ...t,\r\n                user_id: t.userId,\r\n                location_id: t.locationId,\r\n                due_date: t.dueDate.toISOString().split('T')[0],\r\n                completed_at: t.completedAt?.toISOString() || null,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                reminder_enabled: t.reminderEnabled,\r\n                reminder_time: t.reminderTime,\r\n                is_recurring: t.isRecurring,\r\n                recurrence_type: t.recurrenceType,\r\n                recurrence_end_date: t.recurrenceEndDate?.toISOString().split('T')[0] || null,\r\n                parent_task_id: t.parentTaskId,\r\n                recurrence_count: t.recurrenceCount\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskAction(data: CreateTaskInput) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the main task\r\n            const task = await tx.task.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    title: data.title,\r\n                    description: data.description || null,\r\n                    priority: data.priority,\r\n                    dueDate: data.dueDate,\r\n                    category: data.category || null,\r\n                    reminderEnabled: data.reminderEnabled || false,\r\n                    reminderTime: data.reminderTime || null,\r\n                    isRecurring: data.isRecurring || false,\r\n                    recurrenceType: data.recurrenceType || null,\r\n                    recurrenceEndDate: data.recurrenceEndDate || null\r\n                }\r\n            });\r\n\r\n            // 2. If it's recurring, create instances\r\n            if (task.isRecurring && task.recurrenceType && task.recurrenceEndDate) {\r\n                const instances = [];\r\n                let currentDate = task.dueDate;\r\n                const endDate = task.recurrenceEndDate;\r\n                let count = 0;\r\n\r\n                while (count < 365) {\r\n                    let nextDate: Date;\r\n                    switch (task.recurrenceType) {\r\n                        case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                        case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                        case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                        default: nextDate = currentDate;\r\n                    }\r\n\r\n                    if (nextDate > endDate) break;\r\n\r\n                    instances.push({\r\n                        userId: task.userId,\r\n                        locationId: task.locationId,\r\n                        title: task.title,\r\n                        description: task.description,\r\n                        priority: task.priority,\r\n                        dueDate: nextDate,\r\n                        category: task.category,\r\n                        completed: false,\r\n                        reminderEnabled: task.reminderEnabled,\r\n                        reminderTime: task.reminderTime,\r\n                        isRecurring: false,\r\n                        parentTaskId: task.id,\r\n                        recurrenceCount: count + 1\r\n                    });\r\n\r\n                    currentDate = nextDate;\r\n                    count++;\r\n                }\r\n\r\n                if (instances.length > 0) {\r\n                    await tx.task.createMany({\r\n                        data: instances\r\n                    });\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskAction(id: string, userId: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const task = await tx.task.update({\r\n                where: { id, userId },\r\n                data: {\r\n                    ...updates,\r\n                    // Map camelCase to PascalCase if necessary, but prisma models use camelCase for fields\r\n                }\r\n            });\r\n\r\n            // If recurring settings changed, we might need to recreate instances\r\n            if (task.isRecurring && (updates.recurrenceType || updates.recurrenceEndDate)) {\r\n                // Delete existing pending instances\r\n                await tx.task.deleteMany({\r\n                    where: { parentTaskId: id, completed: false }\r\n                });\r\n\r\n                // Create new ones\r\n                if (task.recurrenceType && task.recurrenceEndDate) {\r\n                    const instances = [];\r\n                    let currentDate = task.dueDate;\r\n                    const endDate = task.recurrenceEndDate;\r\n                    let count = 0;\r\n\r\n                    while (count < 365) {\r\n                        let nextDate: Date;\r\n                        switch (task.recurrenceType!) {\r\n                            case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                            case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                            case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                            default: nextDate = currentDate;\r\n                        }\r\n                        if (nextDate > endDate) break;\r\n\r\n                        instances.push({\r\n                            userId: task.userId,\r\n                            locationId: task.locationId,\r\n                            title: task.title,\r\n                            description: task.description,\r\n                            priority: task.priority,\r\n                            dueDate: nextDate,\r\n                            category: task.category,\r\n                            isRecurring: false,\r\n                            parentTaskId: task.id,\r\n                            recurrenceCount: count + 1\r\n                        });\r\n                        currentDate = nextDate;\r\n                        count++;\r\n                    }\r\n                    if (instances.length > 0) {\r\n                        await tx.task.createMany({ data: instances });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskAction(id: string, userId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Delete instances first\r\n            await tx.task.deleteMany({\r\n                where: { parentTaskId: id, completed: false }\r\n            });\r\n\r\n            await tx.task.delete({\r\n                where: { id, userId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function bulkUpdateTasksAction(ids: string[], userId: string, updates: any) {\r\n    try {\r\n        await db.task.updateMany({\r\n            where: { id: { in: ids }, userId },\r\n            data: updates\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error bulk updating tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CATEGORIES ---\r\n\r\nexport async function getTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const categories = await db.taskCategory.findMany({\r\n            where: { userId, locationId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map(c => ({\r\n                ...c,\r\n                user_id: c.userId,\r\n                location_id: c.locationId,\r\n                created_at: c.createdAt.toISOString(),\r\n                updated_at: c.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskCategoryAction(userId: string, locationId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.create({\r\n            data: { userId, locationId, name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskCategoryAction(id: string, userId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.update({\r\n            where: { id, userId },\r\n            data: { name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskCategoryAction(id: string, userId: string) {\r\n    try {\r\n        await db.taskCategory.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const defaultNames = ['General', 'Marketing', 'Operations', 'Finance', 'Follow-up'];\r\n\r\n        const existing = await db.taskCategory.findMany({\r\n            where: { userId, locationId, name: { in: defaultNames } },\r\n            select: { name: true }\r\n        });\r\n\r\n        const existingNames = new Set(existing.map(e => e.name));\r\n        const toCreate = defaultNames.filter(n => !existingNames.has(n)).map(name => ({\r\n            userId,\r\n            locationId,\r\n            name\r\n        }));\r\n\r\n        if (toCreate.length > 0) {\r\n            await db.taskCategory.createMany({ data: toCreate });\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA0QsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 443, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/tasks.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, TaskPriority, RecurrenceType } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { addDays, addWeeks, addMonths, format, parseISO } from 'date-fns';\r\n\r\n// --- TASKS ---\r\n\r\nexport interface CreateTaskInput {\r\n    userId: string;\r\n    locationId: string;\r\n    title: string;\r\n    description?: string | null;\r\n    priority: TaskPriority;\r\n    dueDate: Date;\r\n    category?: string | null;\r\n    reminderEnabled?: boolean;\r\n    reminderTime?: string | null;\r\n    isRecurring?: boolean;\r\n    recurrenceType?: RecurrenceType | null;\r\n    recurrenceEndDate?: Date | null;\r\n}\r\n\r\nexport async function getTasksAction(userId: string, locationId: string) {\r\n    try {\r\n        const tasks = await db.task.findMany({\r\n            where: {\r\n                userId,\r\n                locationId,\r\n                deletedAt: null\r\n            },\r\n            orderBy: {\r\n                dueDate: 'asc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: tasks.map(t => ({\r\n                ...t,\r\n                user_id: t.userId,\r\n                location_id: t.locationId,\r\n                due_date: t.dueDate.toISOString().split('T')[0],\r\n                completed_at: t.completedAt?.toISOString() || null,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                reminder_enabled: t.reminderEnabled,\r\n                reminder_time: t.reminderTime,\r\n                is_recurring: t.isRecurring,\r\n                recurrence_type: t.recurrenceType,\r\n                recurrence_end_date: t.recurrenceEndDate?.toISOString().split('T')[0] || null,\r\n                parent_task_id: t.parentTaskId,\r\n                recurrence_count: t.recurrenceCount\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskAction(data: CreateTaskInput) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the main task\r\n            const task = await tx.task.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    title: data.title,\r\n                    description: data.description || null,\r\n                    priority: data.priority,\r\n                    dueDate: data.dueDate,\r\n                    category: data.category || null,\r\n                    reminderEnabled: data.reminderEnabled || false,\r\n                    reminderTime: data.reminderTime || null,\r\n                    isRecurring: data.isRecurring || false,\r\n                    recurrenceType: data.recurrenceType || null,\r\n                    recurrenceEndDate: data.recurrenceEndDate || null\r\n                }\r\n            });\r\n\r\n            // 2. If it's recurring, create instances\r\n            if (task.isRecurring && task.recurrenceType && task.recurrenceEndDate) {\r\n                const instances = [];\r\n                let currentDate = task.dueDate;\r\n                const endDate = task.recurrenceEndDate;\r\n                let count = 0;\r\n\r\n                while (count < 365) {\r\n                    let nextDate: Date;\r\n                    switch (task.recurrenceType) {\r\n                        case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                        case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                        case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                        default: nextDate = currentDate;\r\n                    }\r\n\r\n                    if (nextDate > endDate) break;\r\n\r\n                    instances.push({\r\n                        userId: task.userId,\r\n                        locationId: task.locationId,\r\n                        title: task.title,\r\n                        description: task.description,\r\n                        priority: task.priority,\r\n                        dueDate: nextDate,\r\n                        category: task.category,\r\n                        completed: false,\r\n                        reminderEnabled: task.reminderEnabled,\r\n                        reminderTime: task.reminderTime,\r\n                        isRecurring: false,\r\n                        parentTaskId: task.id,\r\n                        recurrenceCount: count + 1\r\n                    });\r\n\r\n                    currentDate = nextDate;\r\n                    count++;\r\n                }\r\n\r\n                if (instances.length > 0) {\r\n                    await tx.task.createMany({\r\n                        data: instances\r\n                    });\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskAction(id: string, userId: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const task = await tx.task.update({\r\n                where: { id, userId },\r\n                data: {\r\n                    ...updates,\r\n                    // Map camelCase to PascalCase if necessary, but prisma models use camelCase for fields\r\n                }\r\n            });\r\n\r\n            // If recurring settings changed, we might need to recreate instances\r\n            if (task.isRecurring && (updates.recurrenceType || updates.recurrenceEndDate)) {\r\n                // Delete existing pending instances\r\n                await tx.task.deleteMany({\r\n                    where: { parentTaskId: id, completed: false }\r\n                });\r\n\r\n                // Create new ones\r\n                if (task.recurrenceType && task.recurrenceEndDate) {\r\n                    const instances = [];\r\n                    let currentDate = task.dueDate;\r\n                    const endDate = task.recurrenceEndDate;\r\n                    let count = 0;\r\n\r\n                    while (count < 365) {\r\n                        let nextDate: Date;\r\n                        switch (task.recurrenceType!) {\r\n                            case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                            case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                            case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                            default: nextDate = currentDate;\r\n                        }\r\n                        if (nextDate > endDate) break;\r\n\r\n                        instances.push({\r\n                            userId: task.userId,\r\n                            locationId: task.locationId,\r\n                            title: task.title,\r\n                            description: task.description,\r\n                            priority: task.priority,\r\n                            dueDate: nextDate,\r\n                            category: task.category,\r\n                            isRecurring: false,\r\n                            parentTaskId: task.id,\r\n                            recurrenceCount: count + 1\r\n                        });\r\n                        currentDate = nextDate;\r\n                        count++;\r\n                    }\r\n                    if (instances.length > 0) {\r\n                        await tx.task.createMany({ data: instances });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskAction(id: string, userId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Delete instances first\r\n            await tx.task.deleteMany({\r\n                where: { parentTaskId: id, completed: false }\r\n            });\r\n\r\n            await tx.task.delete({\r\n                where: { id, userId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function bulkUpdateTasksAction(ids: string[], userId: string, updates: any) {\r\n    try {\r\n        await db.task.updateMany({\r\n            where: { id: { in: ids }, userId },\r\n            data: updates\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error bulk updating tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CATEGORIES ---\r\n\r\nexport async function getTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const categories = await db.taskCategory.findMany({\r\n            where: { userId, locationId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map(c => ({\r\n                ...c,\r\n                user_id: c.userId,\r\n                location_id: c.locationId,\r\n                created_at: c.createdAt.toISOString(),\r\n                updated_at: c.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskCategoryAction(userId: string, locationId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.create({\r\n            data: { userId, locationId, name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskCategoryAction(id: string, userId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.update({\r\n            where: { id, userId },\r\n            data: { name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskCategoryAction(id: string, userId: string) {\r\n    try {\r\n        await db.taskCategory.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const defaultNames = ['General', 'Marketing', 'Operations', 'Finance', 'Follow-up'];\r\n\r\n        const existing = await db.taskCategory.findMany({\r\n            where: { userId, locationId, name: { in: defaultNames } },\r\n            select: { name: true }\r\n        });\r\n\r\n        const existingNames = new Set(existing.map(e => e.name));\r\n        const toCreate = defaultNames.filter(n => !existingNames.has(n)).map(name => ({\r\n            userId,\r\n            locationId,\r\n            name\r\n        }));\r\n\r\n        if (toCreate.length > 0) {\r\n            await db.taskCategory.createMany({ data: toCreate });\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAuRsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 460, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/tasks.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, TaskPriority, RecurrenceType } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { addDays, addWeeks, addMonths, format, parseISO } from 'date-fns';\r\n\r\n// --- TASKS ---\r\n\r\nexport interface CreateTaskInput {\r\n    userId: string;\r\n    locationId: string;\r\n    title: string;\r\n    description?: string | null;\r\n    priority: TaskPriority;\r\n    dueDate: Date;\r\n    category?: string | null;\r\n    reminderEnabled?: boolean;\r\n    reminderTime?: string | null;\r\n    isRecurring?: boolean;\r\n    recurrenceType?: RecurrenceType | null;\r\n    recurrenceEndDate?: Date | null;\r\n}\r\n\r\nexport async function getTasksAction(userId: string, locationId: string) {\r\n    try {\r\n        const tasks = await db.task.findMany({\r\n            where: {\r\n                userId,\r\n                locationId,\r\n                deletedAt: null\r\n            },\r\n            orderBy: {\r\n                dueDate: 'asc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: tasks.map(t => ({\r\n                ...t,\r\n                user_id: t.userId,\r\n                location_id: t.locationId,\r\n                due_date: t.dueDate.toISOString().split('T')[0],\r\n                completed_at: t.completedAt?.toISOString() || null,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                reminder_enabled: t.reminderEnabled,\r\n                reminder_time: t.reminderTime,\r\n                is_recurring: t.isRecurring,\r\n                recurrence_type: t.recurrenceType,\r\n                recurrence_end_date: t.recurrenceEndDate?.toISOString().split('T')[0] || null,\r\n                parent_task_id: t.parentTaskId,\r\n                recurrence_count: t.recurrenceCount\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskAction(data: CreateTaskInput) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the main task\r\n            const task = await tx.task.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    title: data.title,\r\n                    description: data.description || null,\r\n                    priority: data.priority,\r\n                    dueDate: data.dueDate,\r\n                    category: data.category || null,\r\n                    reminderEnabled: data.reminderEnabled || false,\r\n                    reminderTime: data.reminderTime || null,\r\n                    isRecurring: data.isRecurring || false,\r\n                    recurrenceType: data.recurrenceType || null,\r\n                    recurrenceEndDate: data.recurrenceEndDate || null\r\n                }\r\n            });\r\n\r\n            // 2. If it's recurring, create instances\r\n            if (task.isRecurring && task.recurrenceType && task.recurrenceEndDate) {\r\n                const instances = [];\r\n                let currentDate = task.dueDate;\r\n                const endDate = task.recurrenceEndDate;\r\n                let count = 0;\r\n\r\n                while (count < 365) {\r\n                    let nextDate: Date;\r\n                    switch (task.recurrenceType) {\r\n                        case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                        case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                        case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                        default: nextDate = currentDate;\r\n                    }\r\n\r\n                    if (nextDate > endDate) break;\r\n\r\n                    instances.push({\r\n                        userId: task.userId,\r\n                        locationId: task.locationId,\r\n                        title: task.title,\r\n                        description: task.description,\r\n                        priority: task.priority,\r\n                        dueDate: nextDate,\r\n                        category: task.category,\r\n                        completed: false,\r\n                        reminderEnabled: task.reminderEnabled,\r\n                        reminderTime: task.reminderTime,\r\n                        isRecurring: false,\r\n                        parentTaskId: task.id,\r\n                        recurrenceCount: count + 1\r\n                    });\r\n\r\n                    currentDate = nextDate;\r\n                    count++;\r\n                }\r\n\r\n                if (instances.length > 0) {\r\n                    await tx.task.createMany({\r\n                        data: instances\r\n                    });\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskAction(id: string, userId: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const task = await tx.task.update({\r\n                where: { id, userId },\r\n                data: {\r\n                    ...updates,\r\n                    // Map camelCase to PascalCase if necessary, but prisma models use camelCase for fields\r\n                }\r\n            });\r\n\r\n            // If recurring settings changed, we might need to recreate instances\r\n            if (task.isRecurring && (updates.recurrenceType || updates.recurrenceEndDate)) {\r\n                // Delete existing pending instances\r\n                await tx.task.deleteMany({\r\n                    where: { parentTaskId: id, completed: false }\r\n                });\r\n\r\n                // Create new ones\r\n                if (task.recurrenceType && task.recurrenceEndDate) {\r\n                    const instances = [];\r\n                    let currentDate = task.dueDate;\r\n                    const endDate = task.recurrenceEndDate;\r\n                    let count = 0;\r\n\r\n                    while (count < 365) {\r\n                        let nextDate: Date;\r\n                        switch (task.recurrenceType!) {\r\n                            case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                            case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                            case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                            default: nextDate = currentDate;\r\n                        }\r\n                        if (nextDate > endDate) break;\r\n\r\n                        instances.push({\r\n                            userId: task.userId,\r\n                            locationId: task.locationId,\r\n                            title: task.title,\r\n                            description: task.description,\r\n                            priority: task.priority,\r\n                            dueDate: nextDate,\r\n                            category: task.category,\r\n                            isRecurring: false,\r\n                            parentTaskId: task.id,\r\n                            recurrenceCount: count + 1\r\n                        });\r\n                        currentDate = nextDate;\r\n                        count++;\r\n                    }\r\n                    if (instances.length > 0) {\r\n                        await tx.task.createMany({ data: instances });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskAction(id: string, userId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Delete instances first\r\n            await tx.task.deleteMany({\r\n                where: { parentTaskId: id, completed: false }\r\n            });\r\n\r\n            await tx.task.delete({\r\n                where: { id, userId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function bulkUpdateTasksAction(ids: string[], userId: string, updates: any) {\r\n    try {\r\n        await db.task.updateMany({\r\n            where: { id: { in: ids }, userId },\r\n            data: updates\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error bulk updating tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CATEGORIES ---\r\n\r\nexport async function getTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const categories = await db.taskCategory.findMany({\r\n            where: { userId, locationId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map(c => ({\r\n                ...c,\r\n                user_id: c.userId,\r\n                location_id: c.locationId,\r\n                created_at: c.createdAt.toISOString(),\r\n                updated_at: c.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskCategoryAction(userId: string, locationId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.create({\r\n            data: { userId, locationId, name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskCategoryAction(id: string, userId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.update({\r\n            where: { id, userId },\r\n            data: { name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskCategoryAction(id: string, userId: string) {\r\n    try {\r\n        await db.taskCategory.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const defaultNames = ['General', 'Marketing', 'Operations', 'Finance', 'Follow-up'];\r\n\r\n        const existing = await db.taskCategory.findMany({\r\n            where: { userId, locationId, name: { in: defaultNames } },\r\n            select: { name: true }\r\n        });\r\n\r\n        const existingNames = new Set(existing.map(e => e.name));\r\n        const toCreate = defaultNames.filter(n => !existingNames.has(n)).map(name => ({\r\n            userId,\r\n            locationId,\r\n            name\r\n        }));\r\n\r\n        if (toCreate.length > 0) {\r\n            await db.taskCategory.createMany({ data: toCreate });\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAqSsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4DAAA"}},
    {"offset": {"line": 477, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/app/actions/tasks.ts"],"sourcesContent":["'use server';\r\n\r\nimport { db, TaskPriority, RecurrenceType } from '../../../prisma/db';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { addDays, addWeeks, addMonths, format, parseISO } from 'date-fns';\r\n\r\n// --- TASKS ---\r\n\r\nexport interface CreateTaskInput {\r\n    userId: string;\r\n    locationId: string;\r\n    title: string;\r\n    description?: string | null;\r\n    priority: TaskPriority;\r\n    dueDate: Date;\r\n    category?: string | null;\r\n    reminderEnabled?: boolean;\r\n    reminderTime?: string | null;\r\n    isRecurring?: boolean;\r\n    recurrenceType?: RecurrenceType | null;\r\n    recurrenceEndDate?: Date | null;\r\n}\r\n\r\nexport async function getTasksAction(userId: string, locationId: string) {\r\n    try {\r\n        const tasks = await db.task.findMany({\r\n            where: {\r\n                userId,\r\n                locationId,\r\n                deletedAt: null\r\n            },\r\n            orderBy: {\r\n                dueDate: 'asc'\r\n            }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: tasks.map(t => ({\r\n                ...t,\r\n                user_id: t.userId,\r\n                location_id: t.locationId,\r\n                due_date: t.dueDate.toISOString().split('T')[0],\r\n                completed_at: t.completedAt?.toISOString() || null,\r\n                created_at: t.createdAt.toISOString(),\r\n                updated_at: t.updatedAt.toISOString(),\r\n                reminder_enabled: t.reminderEnabled,\r\n                reminder_time: t.reminderTime,\r\n                is_recurring: t.isRecurring,\r\n                recurrence_type: t.recurrenceType,\r\n                recurrence_end_date: t.recurrenceEndDate?.toISOString().split('T')[0] || null,\r\n                parent_task_id: t.parentTaskId,\r\n                recurrence_count: t.recurrenceCount\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskAction(data: CreateTaskInput) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            // 1. Create the main task\r\n            const task = await tx.task.create({\r\n                data: {\r\n                    userId: data.userId,\r\n                    locationId: data.locationId,\r\n                    title: data.title,\r\n                    description: data.description || null,\r\n                    priority: data.priority,\r\n                    dueDate: data.dueDate,\r\n                    category: data.category || null,\r\n                    reminderEnabled: data.reminderEnabled || false,\r\n                    reminderTime: data.reminderTime || null,\r\n                    isRecurring: data.isRecurring || false,\r\n                    recurrenceType: data.recurrenceType || null,\r\n                    recurrenceEndDate: data.recurrenceEndDate || null\r\n                }\r\n            });\r\n\r\n            // 2. If it's recurring, create instances\r\n            if (task.isRecurring && task.recurrenceType && task.recurrenceEndDate) {\r\n                const instances = [];\r\n                let currentDate = task.dueDate;\r\n                const endDate = task.recurrenceEndDate;\r\n                let count = 0;\r\n\r\n                while (count < 365) {\r\n                    let nextDate: Date;\r\n                    switch (task.recurrenceType) {\r\n                        case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                        case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                        case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                        default: nextDate = currentDate;\r\n                    }\r\n\r\n                    if (nextDate > endDate) break;\r\n\r\n                    instances.push({\r\n                        userId: task.userId,\r\n                        locationId: task.locationId,\r\n                        title: task.title,\r\n                        description: task.description,\r\n                        priority: task.priority,\r\n                        dueDate: nextDate,\r\n                        category: task.category,\r\n                        completed: false,\r\n                        reminderEnabled: task.reminderEnabled,\r\n                        reminderTime: task.reminderTime,\r\n                        isRecurring: false,\r\n                        parentTaskId: task.id,\r\n                        recurrenceCount: count + 1\r\n                    });\r\n\r\n                    currentDate = nextDate;\r\n                    count++;\r\n                }\r\n\r\n                if (instances.length > 0) {\r\n                    await tx.task.createMany({\r\n                        data: instances\r\n                    });\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error creating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskAction(id: string, userId: string, updates: any) {\r\n    try {\r\n        const result = await db.$transaction(async (tx) => {\r\n            const task = await tx.task.update({\r\n                where: { id, userId },\r\n                data: {\r\n                    ...updates,\r\n                    // Map camelCase to PascalCase if necessary, but prisma models use camelCase for fields\r\n                }\r\n            });\r\n\r\n            // If recurring settings changed, we might need to recreate instances\r\n            if (task.isRecurring && (updates.recurrenceType || updates.recurrenceEndDate)) {\r\n                // Delete existing pending instances\r\n                await tx.task.deleteMany({\r\n                    where: { parentTaskId: id, completed: false }\r\n                });\r\n\r\n                // Create new ones\r\n                if (task.recurrenceType && task.recurrenceEndDate) {\r\n                    const instances = [];\r\n                    let currentDate = task.dueDate;\r\n                    const endDate = task.recurrenceEndDate;\r\n                    let count = 0;\r\n\r\n                    while (count < 365) {\r\n                        let nextDate: Date;\r\n                        switch (task.recurrenceType!) {\r\n                            case 'daily': nextDate = addDays(currentDate, 1); break;\r\n                            case 'weekly': nextDate = addWeeks(currentDate, 1); break;\r\n                            case 'monthly': nextDate = addMonths(currentDate, 1); break;\r\n                            default: nextDate = currentDate;\r\n                        }\r\n                        if (nextDate > endDate) break;\r\n\r\n                        instances.push({\r\n                            userId: task.userId,\r\n                            locationId: task.locationId,\r\n                            title: task.title,\r\n                            description: task.description,\r\n                            priority: task.priority,\r\n                            dueDate: nextDate,\r\n                            category: task.category,\r\n                            isRecurring: false,\r\n                            parentTaskId: task.id,\r\n                            recurrenceCount: count + 1\r\n                        });\r\n                        currentDate = nextDate;\r\n                        count++;\r\n                    }\r\n                    if (instances.length > 0) {\r\n                        await tx.task.createMany({ data: instances });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return task;\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true, data: result };\r\n    } catch (error: any) {\r\n        console.error('Error updating task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskAction(id: string, userId: string) {\r\n    try {\r\n        await db.$transaction(async (tx) => {\r\n            // Delete instances first\r\n            await tx.task.deleteMany({\r\n                where: { parentTaskId: id, completed: false }\r\n            });\r\n\r\n            await tx.task.delete({\r\n                where: { id, userId }\r\n            });\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting task:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function bulkUpdateTasksAction(ids: string[], userId: string, updates: any) {\r\n    try {\r\n        await db.task.updateMany({\r\n            where: { id: { in: ids }, userId },\r\n            data: updates\r\n        });\r\n\r\n        revalidatePath('/tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error bulk updating tasks:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n// --- CATEGORIES ---\r\n\r\nexport async function getTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const categories = await db.taskCategory.findMany({\r\n            where: { userId, locationId },\r\n            orderBy: { name: 'asc' }\r\n        });\r\n\r\n        return {\r\n            success: true,\r\n            data: categories.map(c => ({\r\n                ...c,\r\n                user_id: c.userId,\r\n                location_id: c.locationId,\r\n                created_at: c.createdAt.toISOString(),\r\n                updated_at: c.updatedAt.toISOString()\r\n            }))\r\n        };\r\n    } catch (error: any) {\r\n        console.error('Error fetching categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createTaskCategoryAction(userId: string, locationId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.create({\r\n            data: { userId, locationId, name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error creating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function updateTaskCategoryAction(id: string, userId: string, name: string) {\r\n    try {\r\n        const category = await db.taskCategory.update({\r\n            where: { id, userId },\r\n            data: { name }\r\n        });\r\n\r\n        return { success: true, data: category };\r\n    } catch (error: any) {\r\n        console.error('Error updating category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function deleteTaskCategoryAction(id: string, userId: string) {\r\n    try {\r\n        await db.taskCategory.delete({\r\n            where: { id, userId }\r\n        });\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error deleting category:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\nexport async function createDefaultTaskCategoriesAction(userId: string, locationId: string) {\r\n    try {\r\n        const defaultNames = ['General', 'Marketing', 'Operations', 'Finance', 'Follow-up'];\r\n\r\n        const existing = await db.taskCategory.findMany({\r\n            where: { userId, locationId, name: { in: defaultNames } },\r\n            select: { name: true }\r\n        });\r\n\r\n        const existingNames = new Set(existing.map(e => e.name));\r\n        const toCreate = defaultNames.filter(n => !existingNames.has(n)).map(name => ({\r\n            userId,\r\n            locationId,\r\n            name\r\n        }));\r\n\r\n        if (toCreate.length > 0) {\r\n            await db.taskCategory.createMany({ data: toCreate });\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error creating default categories:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAkTsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,qEAAA"}},
    {"offset": {"line": 494, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useTaskCategories.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { TaskCategory } from '@/types/task';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useBusiness } from '@/contexts/BusinessContext';\r\nimport { toast } from 'sonner';\r\nimport {\r\n  getTaskCategoriesAction,\r\n  createTaskCategoryAction,\r\n  updateTaskCategoryAction,\r\n  deleteTaskCategoryAction,\r\n  createDefaultTaskCategoriesAction\r\n} from '@/app/actions/tasks';\r\n\r\nexport const useTaskCategories = () => {\r\n  const [categories, setCategories] = useState<TaskCategory[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const { user } = useAuth();\r\n  const { currentBusiness } = useBusiness();\r\n\r\n  const loadCategories = async () => {\r\n    if (!user?.id || !currentBusiness?.id) {\r\n      setCategories([]);\r\n      setIsLoading(false);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const result = await getTaskCategoriesAction(user.id, currentBusiness.id);\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error || 'Failed to fetch categories');\r\n      }\r\n\r\n      setCategories(result.data as any[]);\r\n    } catch (error) {\r\n      console.error('Error loading task categories:', error);\r\n      toast.error('Failed to load task categories');\r\n      setCategories([]);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const createCategory = async (name: string): Promise<TaskCategory | null> => {\r\n    if (!user?.id || !currentBusiness?.id) return null;\r\n\r\n    try {\r\n      const result = await createTaskCategoryAction(user.id, currentBusiness.id, name.trim());\r\n\r\n      if (!result.success || !result.data) {\r\n        throw new Error(result.error);\r\n      }\r\n\r\n      const data = result.data as any;\r\n      const newCategory: TaskCategory = {\r\n        ...data,\r\n        user_id: data.userId,\r\n        location_id: data.locationId,\r\n        created_at: data.createdAt.toISOString(),\r\n        updated_at: data.updatedAt.toISOString()\r\n      };\r\n\r\n      setCategories(prev => [...prev, newCategory]);\r\n      toast.success('Category created successfully');\r\n      return newCategory;\r\n    } catch (error) {\r\n      console.error('Error creating task category:', error);\r\n      toast.error('Failed to create category');\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updateCategory = async (id: string, name: string): Promise<boolean> => {\r\n    if (!user?.id) return false;\r\n\r\n    try {\r\n      const result = await updateTaskCategoryAction(id, user.id, name.trim());\r\n\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      setCategories(prev =>\r\n        prev.map(cat => (cat.id === id ? { ...cat, name: name.trim() } : cat))\r\n      );\r\n      toast.success('Category updated successfully');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating task category:', error);\r\n      toast.error('Failed to update category');\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const deleteCategory = async (id: string): Promise<boolean> => {\r\n    if (!user?.id) return false;\r\n\r\n    try {\r\n      const result = await deleteTaskCategoryAction(id, user.id);\r\n\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      setCategories(prev => prev.filter(cat => cat.id !== id));\r\n      toast.success('Category deleted successfully');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting task category:', error);\r\n      toast.error('Failed to delete category');\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const createDefaultCategories = async () => {\r\n    if (!user?.id || !currentBusiness?.id) return;\r\n\r\n    try {\r\n      const result = await createDefaultTaskCategoriesAction(user.id, currentBusiness.id);\r\n\r\n      if (!result.success) throw new Error(result.error);\r\n\r\n      // Refresh to get the new categories\r\n      await loadCategories();\r\n    } catch (error) {\r\n      console.error('Error creating default categories:', error);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    loadCategories();\r\n  }, [user?.id, currentBusiness?.id]);\r\n\r\n  return {\r\n    categories,\r\n    isLoading,\r\n    createCategory,\r\n    updateCategory,\r\n    deleteCategory,\r\n    createDefaultCategories,\r\n    refreshCategories: loadCategories,\r\n  };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 639, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/hooks/useTaskPageLogic.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\r\nimport { Task, CreateTaskData, UpdateTaskData } from '@/types/task';\r\nimport { isToday } from 'date-fns';\r\n\r\ninterface UseTaskPageLogicProps {\r\n  tasks: Task[];\r\n  createTask: (data: CreateTaskData) => Promise<Task | null>;\r\n  updateTask: (id: string, updates: UpdateTaskData) => Promise<boolean>;\r\n  deleteTask: (id: string) => Promise<boolean>;\r\n  toggleTaskCompletion: (id: string) => Promise<boolean>;\r\n  bulkUpdateTasks: (taskIds: string[], updates: UpdateTaskData) => Promise<boolean>;\r\n}\r\n\r\nexport const useTaskPageLogic = ({\r\n  tasks,\r\n  createTask,\r\n  updateTask,\r\n  deleteTask,\r\n  toggleTaskCompletion,\r\n  bulkUpdateTasks,\r\n}: UseTaskPageLogicProps) => {\r\n  const [isTaskFormOpen, setIsTaskFormOpen] = useState(false);\r\n  const [editingTask, setEditingTask] = useState<Task | null>(null);\r\n  const [selectedDate, setSelectedDate] = useState<Date | null>(null);\r\n  const [activeTab, setActiveTab] = useState('list');\r\n\r\n  const todayTasks = tasks.filter(task => isToday(new Date(task.due_date)));\r\n  const pendingTodayTasks = todayTasks.filter(task => !task.completed);\r\n\r\n  const handleCreateTask = useCallback(() => {\r\n    setEditingTask(null);\r\n    setSelectedDate(null);\r\n    setIsTaskFormOpen(true);\r\n  }, []);\r\n\r\n  const handleEditTask = useCallback((task: Task) => {\r\n    setEditingTask(task);\r\n    setIsTaskFormOpen(true);\r\n  }, []);\r\n\r\n  const handleDeleteTask = useCallback(async (id: string): Promise<boolean> => {\r\n    if (window.confirm('Are you sure you want to delete this task?')) {\r\n      return await deleteTask(id);\r\n    }\r\n    return false;\r\n  }, [deleteTask]);\r\n\r\n  const handleFormSubmit = useCallback(async (data: CreateTaskData) => {\r\n    try {\r\n      if (editingTask) {\r\n        await updateTask(editingTask.id, data as UpdateTaskData);\r\n      } else {\r\n        await createTask(data);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error in handleFormSubmit:', error);\r\n    }\r\n  }, [editingTask, updateTask, createTask]);\r\n\r\n  const handleBulkComplete = useCallback(async (taskIds: string[]): Promise<boolean> => {\r\n    return await bulkUpdateTasks(taskIds, { \r\n      completed: true, \r\n      completed_at: new Date().toISOString() \r\n    });\r\n  }, [bulkUpdateTasks]);\r\n\r\n  const handleFormClose = useCallback(() => {\r\n    setIsTaskFormOpen(false);\r\n    setEditingTask(null);\r\n    setSelectedDate(null);\r\n  }, []);\r\n\r\n  return {\r\n    // State\r\n    isTaskFormOpen,\r\n    editingTask,\r\n    selectedDate,\r\n    activeTab,\r\n    todayTasks,\r\n    pendingTodayTasks,\r\n    \r\n    // Actions\r\n    setActiveTab,\r\n    handleCreateTask,\r\n    handleEditTask,\r\n    handleDeleteTask,\r\n    handleFormSubmit,\r\n    handleBulkComplete,\r\n    handleFormClose,\r\n    \r\n    // Task operations\r\n    toggleTaskCompletion,\r\n  };\r\n};"],"names":[],"mappings":";;;;AAAA;AAEA;;;;AAWO,MAAM,mBAAmB,CAAC,EAC/B,KAAK,EACL,UAAU,EACV,UAAU,EACV,UAAU,EACV,oBAAoB,EACpB,eAAe,EACO;;IACtB,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,yKAAQ,EAAC;IACrD,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,yKAAQ,EAAc;IAC5D,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,yKAAQ,EAAc;IAC9D,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAC;IAE3C,MAAM,aAAa,MAAM,MAAM,CAAC,CAAA,OAAQ,IAAA,oJAAO,EAAC,IAAI,KAAK,KAAK,QAAQ;IACtE,MAAM,oBAAoB,WAAW,MAAM,CAAC,CAAA,OAAQ,CAAC,KAAK,SAAS;IAEnE,MAAM,mBAAmB,IAAA,4KAAW;0DAAC;YACnC,eAAe;YACf,gBAAgB;YAChB,kBAAkB;QACpB;yDAAG,EAAE;IAEL,MAAM,iBAAiB,IAAA,4KAAW;wDAAC,CAAC;YAClC,eAAe;YACf,kBAAkB;QACpB;uDAAG,EAAE;IAEL,MAAM,mBAAmB,IAAA,4KAAW;0DAAC,OAAO;YAC1C,IAAI,OAAO,OAAO,CAAC,+CAA+C;gBAChE,OAAO,MAAM,WAAW;YAC1B;YACA,OAAO;QACT;yDAAG;QAAC;KAAW;IAEf,MAAM,mBAAmB,IAAA,4KAAW;0DAAC,OAAO;YAC1C,IAAI;gBACF,IAAI,aAAa;oBACf,MAAM,WAAW,YAAY,EAAE,EAAE;gBACnC,OAAO;oBACL,MAAM,WAAW;gBACnB;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,8BAA8B;YAC9C;QACF;yDAAG;QAAC;QAAa;QAAY;KAAW;IAExC,MAAM,qBAAqB,IAAA,4KAAW;4DAAC,OAAO;YAC5C,OAAO,MAAM,gBAAgB,SAAS;gBACpC,WAAW;gBACX,cAAc,IAAI,OAAO,WAAW;YACtC;QACF;2DAAG;QAAC;KAAgB;IAEpB,MAAM,kBAAkB,IAAA,4KAAW;yDAAC;YAClC,kBAAkB;YAClB,eAAe;YACf,gBAAgB;QAClB;wDAAG,EAAE;IAEL,OAAO;QACL,QAAQ;QACR;QACA;QACA;QACA;QACA;QACA;QAEA,UAAU;QACV;QACA;QACA;QACA;QACA;QACA;QACA;QAEA,kBAAkB;QAClB;IACF;AACF;GAhFa"}},
    {"offset": {"line": 741, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/textarea.tsx"],"sourcesContent":["import * as React from \"react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nexport interface TextareaProps\r\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\r\n\r\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\r\n  ({ className, ...props }, ref) => {\r\n    return (\r\n      <textarea\r\n        className={cn(\r\n          \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\r\n          className\r\n        )}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    )\r\n  }\r\n)\r\nTextarea.displayName = \"Textarea\"\r\n\r\nexport { Textarea }\r\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAKA,MAAM,yBAAW,2KAAgB,MAC/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE;IACxB,qBACE,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,wSACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;;AAEF,SAAS,WAAW,GAAG"}},
    {"offset": {"line": 775, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/switch.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Switch = React.forwardRef<\r\n  React.ElementRef<typeof SwitchPrimitives.Root>,\r\n  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>\r\n>(({ className, ...props }, ref) => (\r\n  <SwitchPrimitives.Root\r\n    className={cn(\r\n      \"peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\r\n      className\r\n    )}\r\n    {...props}\r\n    ref={ref}\r\n  >\r\n    <SwitchPrimitives.Thumb\r\n      className={cn(\r\n        \"pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0\"\r\n      )}\r\n    />\r\n  </SwitchPrimitives.Root>\r\n))\r\nSwitch.displayName = SwitchPrimitives.Root.displayName\r\n\r\nexport { Switch }\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,uBAAS,2KAAgB,MAG7B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,6KAAqB;QACpB,WAAW,IAAA,4HAAE,EACX,sXACA;QAED,GAAG,KAAK;QACT,KAAK;kBAEL,cAAA,6LAAC,8KAAsB;YACrB,WAAW,IAAA,4HAAE,EACX;;;;;;;;;;;;AAKR,OAAO,WAAW,GAAG,6KAAqB,CAAC,WAAW"}},
    {"offset": {"line": 816, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/calendar.tsx"],"sourcesContent":["\r\nimport * as React from \"react\";\r\nimport { ChevronLeft, ChevronRight } from \"lucide-react\";\r\nimport { DayPicker } from \"react-day-picker\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\nimport { buttonVariants } from \"@/components/ui/button\";\r\n\r\nexport type CalendarProps = React.ComponentProps<typeof DayPicker>;\r\n\r\nfunction Calendar({\r\n  className,\r\n  classNames,\r\n  showOutsideDays = true,\r\n  ...props\r\n}: CalendarProps) {\r\n  return (\r\n    <DayPicker\r\n      showOutsideDays={showOutsideDays}\r\n      className={cn(\"p-3 pointer-events-auto\", className)}\r\n      classNames={{\r\n        months: \"flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0\",\r\n        month: \"space-y-4\",\r\n        caption: \"flex justify-center pt-1 relative items-center\",\r\n        caption_label: \"text-sm font-medium\",\r\n        caption_dropdowns: \"flex justify-center gap-1\",\r\n        nav: \"space-x-1 flex items-center\",\r\n        nav_button: cn(\r\n          buttonVariants({ variant: \"outline\" }),\r\n          \"h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100\"\r\n        ),\r\n        nav_button_previous: \"absolute left-1\",\r\n        nav_button_next: \"absolute right-1\",\r\n        table: \"w-full border-collapse space-y-1\",\r\n        head_row: \"flex\",\r\n        head_cell:\r\n          \"text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]\",\r\n        row: \"flex w-full mt-2\",\r\n        cell: \"h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20\",\r\n        day: cn(\r\n          buttonVariants({ variant: \"ghost\" }),\r\n          \"h-9 w-9 p-0 font-normal aria-selected:opacity-100\"\r\n        ),\r\n        day_range_end: \"day-range-end\",\r\n        day_selected:\r\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground\",\r\n        day_today: \"bg-accent text-accent-foreground\",\r\n        day_outside:\r\n          \"day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30\",\r\n        day_disabled: \"text-muted-foreground opacity-50\",\r\n        day_range_middle:\r\n          \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\r\n        day_hidden: \"invisible\",\r\n        dropdown: \"bg-background rounded-md border p-1 shadow-md\",\r\n        dropdown_month: \"w-[var(--rdp-caption-dropdown-month-width)]\",\r\n        dropdown_year: \"w-[var(--rdp-caption-dropdown-year-width)]\",\r\n        dropdown_icon: \"w-4 h-4\",\r\n        button_reset: \"appearance-none bg-transparent border-none p-0 m-0\",\r\n        vhidden: \"sr-only\",\r\n        ...classNames,\r\n      }}\r\n      components={{\r\n        IconLeft: ({ ..._props }) => <ChevronLeft className=\"h-4 w-4\" />,\r\n        IconRight: ({ ..._props }) => <ChevronRight className=\"h-4 w-4\" />,\r\n      }}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\nCalendar.displayName = \"Calendar\";\r\n\r\nexport { Calendar };\r\n"],"names":[],"mappings":";;;;;AAEA;AAAA;AACA;AAEA;AACA;;;;;;AAIA,SAAS,SAAS,EAChB,SAAS,EACT,UAAU,EACV,kBAAkB,IAAI,EACtB,GAAG,OACW;IACd,qBACE,6LAAC,8KAAS;QACR,iBAAiB;QACjB,WAAW,IAAA,4HAAE,EAAC,2BAA2B;QACzC,YAAY;YACV,QAAQ;YACR,OAAO;YACP,SAAS;YACT,eAAe;YACf,mBAAmB;YACnB,KAAK;YACL,YAAY,IAAA,4HAAE,EACZ,IAAA,uJAAc,EAAC;gBAAE,SAAS;YAAU,IACpC;YAEF,qBAAqB;YACrB,iBAAiB;YACjB,OAAO;YACP,UAAU;YACV,WACE;YACF,KAAK;YACL,MAAM;YACN,KAAK,IAAA,4HAAE,EACL,IAAA,uJAAc,EAAC;gBAAE,SAAS;YAAQ,IAClC;YAEF,eAAe;YACf,cACE;YACF,WAAW;YACX,aACE;YACF,cAAc;YACd,kBACE;YACF,YAAY;YACZ,UAAU;YACV,gBAAgB;YAChB,eAAe;YACf,eAAe;YACf,cAAc;YACd,SAAS;YACT,GAAG,UAAU;QACf;QACA,YAAY;YACV,UAAU,CAAC,EAAE,GAAG,QAAQ,iBAAK,6LAAC,sOAAW;oBAAC,WAAU;;;;;;YACpD,WAAW,CAAC,EAAE,GAAG,QAAQ,iBAAK,6LAAC,yOAAY;oBAAC,WAAU;;;;;;QACxD;QACC,GAAG,KAAK;;;;;;AAGf;KA1DS;AA2DT,SAAS,WAAW,GAAG"}},
    {"offset": {"line": 905, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/popover.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Popover = PopoverPrimitive.Root\r\n\r\nconst PopoverTrigger = PopoverPrimitive.Trigger\r\n\r\nconst PopoverContent = React.forwardRef<\r\n  React.ElementRef<typeof PopoverPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\r\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\r\n  <PopoverPrimitive.Portal>\r\n    <PopoverPrimitive.Content\r\n      ref={ref}\r\n      align={align}\r\n      sideOffset={sideOffset}\r\n      className={cn(\r\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\r\n        className\r\n      )}\r\n      {...props}\r\n    />\r\n  </PopoverPrimitive.Portal>\r\n))\r\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\r\n\r\nexport { Popover, PopoverTrigger, PopoverContent }\r\n"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,UAAU,8KAAqB;AAErC,MAAM,iBAAiB,iLAAwB;AAE/C,MAAM,+BAAiB,2KAAgB,MAGrC,CAAC,EAAE,SAAS,EAAE,QAAQ,QAAQ,EAAE,aAAa,CAAC,EAAE,GAAG,OAAO,EAAE,oBAC5D,6LAAC,gLAAuB;kBACtB,cAAA,6LAAC,iLAAwB;YACvB,KAAK;YACL,OAAO;YACP,YAAY;YACZ,WAAW,IAAA,4HAAE,EACX,8aACA;YAED,GAAG,KAAK;;;;;;;;;;;;AAIf,eAAe,WAAW,GAAG,iLAAwB,CAAC,WAAW"}},
    {"offset": {"line": 953, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/tasks/RecurrenceSettings.tsx"],"sourcesContent":["\r\nimport React from 'react';\r\nimport { Label } from '@/components/ui/label';\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\r\nimport { Switch } from '@/components/ui/switch';\r\nimport { Calendar } from '@/components/ui/calendar';\r\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';\r\nimport { Button } from '@/components/ui/button';\r\nimport { CalendarIcon } from 'lucide-react';\r\nimport { format, addMonths } from 'date-fns';\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface RecurrenceSettingsProps {\r\n  isRecurring: boolean;\r\n  recurrenceType: 'daily' | 'weekly' | 'monthly' | '';\r\n  recurrenceEndDate: Date | null;\r\n  dueDate: Date;\r\n  onRecurringChange: (enabled: boolean) => void;\r\n  onRecurrenceTypeChange: (type: 'daily' | 'weekly' | 'monthly' | '') => void;\r\n  onRecurrenceEndDateChange: (date: Date | null) => void;\r\n}\r\n\r\nconst RecurrenceSettings: React.FC<RecurrenceSettingsProps> = ({\r\n  isRecurring,\r\n  recurrenceType,\r\n  recurrenceEndDate,\r\n  dueDate,\r\n  onRecurringChange,\r\n  onRecurrenceTypeChange,\r\n  onRecurrenceEndDateChange,\r\n}) => {\r\n  const maxEndDate = addMonths(dueDate, 12);\r\n\r\n  return (\r\n    <div className=\"space-y-4\">\r\n      <div className=\"flex items-center space-x-2\">\r\n        <Switch\r\n          id=\"recurring\"\r\n          checked={isRecurring}\r\n          onCheckedChange={onRecurringChange}\r\n        />\r\n        <Label htmlFor=\"recurring\">Make this a recurring task</Label>\r\n      </div>\r\n\r\n      {isRecurring && (\r\n        <div className=\"space-y-4 pl-6 border-l-2 border-gray-100\">\r\n          <div className=\"space-y-2\">\r\n            <Label>Repeat frequency</Label>\r\n            <Select\r\n              value={recurrenceType}\r\n              onValueChange={(value: 'daily' | 'weekly' | 'monthly') => \r\n                onRecurrenceTypeChange(value)\r\n              }\r\n            >\r\n              <SelectTrigger>\r\n                <SelectValue placeholder=\"Select frequency\" />\r\n              </SelectTrigger>\r\n              <SelectContent>\r\n                <SelectItem value=\"daily\">Daily</SelectItem>\r\n                <SelectItem value=\"weekly\">Weekly</SelectItem>\r\n                <SelectItem value=\"monthly\">Monthly</SelectItem>\r\n              </SelectContent>\r\n            </Select>\r\n          </div>\r\n\r\n          {recurrenceType && (\r\n            <div className=\"space-y-2\">\r\n              <Label>End date (max 12 months)</Label>\r\n              <Popover>\r\n                <PopoverTrigger asChild>\r\n                  <Button\r\n                    variant=\"outline\"\r\n                    className={cn(\r\n                      \"w-full justify-start text-left font-normal\",\r\n                      !recurrenceEndDate && \"text-muted-foreground\"\r\n                    )}\r\n                  >\r\n                    <CalendarIcon className=\"mr-2 h-4 w-4\" />\r\n                    {recurrenceEndDate ? format(recurrenceEndDate, 'MMM dd, yyyy') : 'Select end date'}\r\n                  </Button>\r\n                </PopoverTrigger>\r\n                <PopoverContent className=\"w-auto p-0\">\r\n                  <Calendar\r\n                    mode=\"single\"\r\n                    selected={recurrenceEndDate || undefined}\r\n                    onSelect={(date) => onRecurrenceEndDateChange(date || null)}\r\n                    fromDate={dueDate}\r\n                    toDate={maxEndDate}\r\n                    initialFocus\r\n                  />\r\n                </PopoverContent>\r\n              </Popover>\r\n              <p className=\"text-xs text-gray-500\">\r\n                Recurring tasks can repeat for up to 12 months from the due date\r\n              </p>\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default RecurrenceSettings;\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;AAYA,MAAM,qBAAwD,CAAC,EAC7D,WAAW,EACX,cAAc,EACd,iBAAiB,EACjB,OAAO,EACP,iBAAiB,EACjB,sBAAsB,EACtB,yBAAyB,EAC1B;IACC,MAAM,aAAa,IAAA,wJAAS,EAAC,SAAS;IAEtC,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC;gBAAI,WAAU;;kCACb,6LAAC,+IAAM;wBACL,IAAG;wBACH,SAAS;wBACT,iBAAiB;;;;;;kCAEnB,6LAAC,6IAAK;wBAAC,SAAQ;kCAAY;;;;;;;;;;;;YAG5B,6BACC,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;wBAAI,WAAU;;0CACb,6LAAC,6IAAK;0CAAC;;;;;;0CACP,6LAAC,+IAAM;gCACL,OAAO;gCACP,eAAe,CAAC,QACd,uBAAuB;;kDAGzB,6LAAC,sJAAa;kDACZ,cAAA,6LAAC,oJAAW;4CAAC,aAAY;;;;;;;;;;;kDAE3B,6LAAC,sJAAa;;0DACZ,6LAAC,mJAAU;gDAAC,OAAM;0DAAQ;;;;;;0DAC1B,6LAAC,mJAAU;gDAAC,OAAM;0DAAS;;;;;;0DAC3B,6LAAC,mJAAU;gDAAC,OAAM;0DAAU;;;;;;;;;;;;;;;;;;;;;;;;oBAKjC,gCACC,6LAAC;wBAAI,WAAU;;0CACb,6LAAC,6IAAK;0CAAC;;;;;;0CACP,6LAAC,iJAAO;;kDACN,6LAAC,wJAAc;wCAAC,OAAO;kDACrB,cAAA,6LAAC,+IAAM;4CACL,SAAQ;4CACR,WAAW,IAAA,4HAAE,EACX,8CACA,CAAC,qBAAqB;;8DAGxB,6LAAC,iOAAY;oDAAC,WAAU;;;;;;gDACvB,oBAAoB,IAAA,kKAAM,EAAC,mBAAmB,kBAAkB;;;;;;;;;;;;kDAGrE,6LAAC,wJAAc;wCAAC,WAAU;kDACxB,cAAA,6LAAC,mJAAQ;4CACP,MAAK;4CACL,UAAU,qBAAqB;4CAC/B,UAAU,CAAC,OAAS,0BAA0B,QAAQ;4CACtD,UAAU;4CACV,QAAQ;4CACR,YAAY;;;;;;;;;;;;;;;;;0CAIlB,6LAAC;gCAAE,WAAU;0CAAwB;;;;;;;;;;;;;;;;;;;;;;;;AASnD;KA/EM;uCAiFS"}},
    {"offset": {"line": 1183, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/tasks/TaskForm.tsx"],"sourcesContent":["\r\nimport React, { useState, useEffect } from 'react';\r\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Label } from '@/components/ui/label';\r\nimport { Textarea } from '@/components/ui/textarea';\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\r\nimport { Switch } from '@/components/ui/switch';\r\nimport { Calendar } from '@/components/ui/calendar';\r\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';\r\nimport { CalendarIcon } from 'lucide-react';\r\nimport { format } from 'date-fns';\r\nimport { Task, CreateTaskData, TaskPriority } from '@/types/task';\r\nimport { useTaskCategories } from '@/hooks/useTaskCategories';\r\nimport RecurrenceSettings from './RecurrenceSettings';\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface TaskFormProps {\r\n  isOpen: boolean;\r\n  onClose: () => void;\r\n  onSubmit: (data: CreateTaskData) => Promise<void>;\r\n  task?: Task | null;\r\n  initialDate?: Date;\r\n}\r\n\r\nconst TaskForm: React.FC<TaskFormProps> = ({\r\n  isOpen,\r\n  onClose,\r\n  onSubmit,\r\n  task,\r\n  initialDate,\r\n}) => {\r\n  console.log('TaskForm rendering with props:', { isOpen, task, initialDate });\r\n\r\n  const [formData, setFormData] = useState<CreateTaskData>({\r\n    title: '',\r\n    description: '',\r\n    priority: 'Medium',\r\n    due_date: format(initialDate || new Date(), 'yyyy-MM-dd'),\r\n    category: '',\r\n    reminder_enabled: false,\r\n    reminder_time: '',\r\n    is_recurring: false,\r\n    recurrence_type: undefined,\r\n    recurrence_end_date: undefined,\r\n  });\r\n  const [isSubmitting, setIsSubmitting] = useState(false);\r\n  const [selectedDate, setSelectedDate] = useState<Date>(initialDate || new Date());\r\n  const [recurrenceEndDate, setRecurrenceEndDate] = useState<Date | null>(null);\r\n  \r\n  // Use a safe call to useTaskCategories with error handling\r\n  let categories: any[] = [];\r\n  try {\r\n    const taskCategoriesResult = useTaskCategories();\r\n    categories = taskCategoriesResult.categories || [];\r\n  } catch (error) {\r\n    console.error('Error loading task categories:', error);\r\n  }\r\n\r\n  useEffect(() => {\r\n    console.log('TaskForm useEffect - task changed:', task);\r\n    if (task) {\r\n      setFormData({\r\n        title: task.title,\r\n        description: task.description || '',\r\n        priority: task.priority,\r\n        due_date: task.due_date,\r\n        category: task.category || '',\r\n        reminder_enabled: task.reminder_enabled,\r\n        reminder_time: task.reminder_time || '',\r\n        is_recurring: task.is_recurring,\r\n        recurrence_type: task.recurrence_type || undefined,\r\n        recurrence_end_date: task.recurrence_end_date || undefined,\r\n      });\r\n      setSelectedDate(new Date(task.due_date));\r\n      setRecurrenceEndDate(task.recurrence_end_date ? new Date(task.recurrence_end_date) : null);\r\n    } else if (initialDate) {\r\n      setFormData(prev => ({\r\n        ...prev,\r\n        due_date: format(initialDate, 'yyyy-MM-dd'),\r\n      }));\r\n      setSelectedDate(initialDate);\r\n    }\r\n  }, [task, initialDate]);\r\n\r\n  const handleSubmit = async (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n    console.log('TaskForm handleSubmit called with data:', formData);\r\n    \r\n    if (!formData.title.trim()) {\r\n      console.log('TaskForm - title is empty, not submitting');\r\n      return;\r\n    }\r\n\r\n    setIsSubmitting(true);\r\n    try {\r\n      // Convert \"no-category\" back to empty string for the database\r\n      const submitData = {\r\n        ...formData,\r\n        category: formData.category === 'no-category' ? '' : formData.category,\r\n        recurrence_end_date: recurrenceEndDate ? format(recurrenceEndDate, 'yyyy-MM-dd') : undefined,\r\n      };\r\n      await onSubmit(submitData);\r\n      if (!task) {\r\n        // Reset form for new task\r\n        setFormData({\r\n          title: '',\r\n          description: '',\r\n          priority: 'Medium',\r\n          due_date: format(new Date(), 'yyyy-MM-dd'),\r\n          category: '',\r\n          reminder_enabled: false,\r\n          reminder_time: '',\r\n          is_recurring: false,\r\n          recurrence_type: undefined,\r\n          recurrence_end_date: undefined,\r\n        });\r\n        setSelectedDate(new Date());\r\n        setRecurrenceEndDate(null);\r\n      }\r\n      onClose();\r\n    } catch (error) {\r\n      console.error('Error submitting task:', error);\r\n    } finally {\r\n      setIsSubmitting(false);\r\n    }\r\n  };\r\n\r\n  const handleDateSelect = (date: Date | undefined) => {\r\n    console.log('TaskForm handleDateSelect called with:', date);\r\n    if (date) {\r\n      setSelectedDate(date);\r\n      setFormData(prev => ({\r\n        ...prev,\r\n        due_date: format(date, 'yyyy-MM-dd'),\r\n      }));\r\n    }\r\n  };\r\n\r\n  const priorityColors = {\r\n    Low: 'text-green-600',\r\n    Medium: 'text-yellow-600',\r\n    High: 'text-red-600',\r\n  };\r\n\r\n  console.log('TaskForm about to render dialog, isOpen:', isOpen);\r\n\r\n  return (\r\n    <Dialog open={isOpen} onOpenChange={onClose}>\r\n      <DialogContent className=\"sm:max-w-md max-h-[90vh] overflow-y-auto\">\r\n        <DialogHeader>\r\n          <DialogTitle>\r\n            {task ? 'Edit Task' : 'Create New Task'}\r\n          </DialogTitle>\r\n        </DialogHeader>\r\n        \r\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"title\">Task Title *</Label>\r\n            <Input\r\n              id=\"title\"\r\n              value={formData.title}\r\n              onChange={(e) => setFormData(prev => ({ ...prev, title: e.target.value }))}\r\n              placeholder=\"What needs to be done?\"\r\n              required\r\n            />\r\n          </div>\r\n\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"description\">Description</Label>\r\n            <Textarea\r\n              id=\"description\"\r\n              value={formData.description}\r\n              onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}\r\n              placeholder=\"Add more details...\"\r\n              rows={3}\r\n            />\r\n          </div>\r\n\r\n          <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-4\">\r\n            <div className=\"space-y-2\">\r\n              <Label>Priority</Label>\r\n              <Select\r\n                value={formData.priority}\r\n                onValueChange={(value: TaskPriority) => \r\n                  setFormData(prev => ({ ...prev, priority: value }))\r\n                }\r\n              >\r\n                <SelectTrigger>\r\n                  <SelectValue />\r\n                </SelectTrigger>\r\n                <SelectContent>\r\n                  <SelectItem value=\"Low\" className={priorityColors.Low}>Low Priority</SelectItem>\r\n                  <SelectItem value=\"Medium\" className={priorityColors.Medium}>Medium Priority</SelectItem>\r\n                  <SelectItem value=\"High\" className={priorityColors.High}>High Priority</SelectItem>\r\n                </SelectContent>\r\n              </Select>\r\n            </div>\r\n\r\n            <div className=\"space-y-2\">\r\n              <Label>Due Date</Label>\r\n              <Popover>\r\n                <PopoverTrigger asChild>\r\n                  <Button\r\n                    variant=\"outline\"\r\n                    className={cn(\r\n                      \"w-full justify-start text-left font-normal\",\r\n                      !selectedDate && \"text-muted-foreground\"\r\n                    )}\r\n                  >\r\n                    <CalendarIcon className=\"mr-2 h-4 w-4\" />\r\n                    {selectedDate ? format(selectedDate, 'MMM dd, yyyy') : 'Pick a date'}\r\n                  </Button>\r\n                </PopoverTrigger>\r\n                <PopoverContent className=\"w-auto p-0\">\r\n                  <Calendar\r\n                    mode=\"single\"\r\n                    selected={selectedDate}\r\n                    onSelect={handleDateSelect}\r\n                    initialFocus\r\n                  />\r\n                </PopoverContent>\r\n              </Popover>\r\n            </div>\r\n          </div>\r\n\r\n          {categories.length > 0 && (\r\n            <div className=\"space-y-2\">\r\n              <Label>Category</Label>\r\n              <Select\r\n                value={formData.category || 'no-category'}\r\n                onValueChange={(value) => \r\n                  setFormData(prev => ({ ...prev, category: value === 'no-category' ? '' : value }))\r\n                }\r\n              >\r\n                <SelectTrigger>\r\n                  <SelectValue placeholder=\"Select a category\" />\r\n                </SelectTrigger>\r\n                <SelectContent>\r\n                  <SelectItem value=\"no-category\">No Category</SelectItem>\r\n                  {categories.map((category) => (\r\n                    <SelectItem key={category.id} value={category.name}>\r\n                      {category.name}\r\n                    </SelectItem>\r\n                  ))}\r\n                </SelectContent>\r\n              </Select>\r\n            </div>\r\n          )}\r\n\r\n          <RecurrenceSettings\r\n            isRecurring={formData.is_recurring || false}\r\n            recurrenceType={formData.recurrence_type || ''}\r\n            recurrenceEndDate={recurrenceEndDate}\r\n            dueDate={selectedDate}\r\n            onRecurringChange={(enabled) => \r\n              setFormData(prev => ({ \r\n                ...prev, \r\n                is_recurring: enabled,\r\n                recurrence_type: enabled ? prev.recurrence_type : undefined,\r\n              }))\r\n            }\r\n            onRecurrenceTypeChange={(type) => \r\n              setFormData(prev => ({ ...prev, recurrence_type: type || undefined }))\r\n            }\r\n            onRecurrenceEndDateChange={setRecurrenceEndDate}\r\n          />\r\n\r\n          <div className=\"flex items-center space-x-2\">\r\n            <Switch\r\n              id=\"reminder\"\r\n              checked={formData.reminder_enabled}\r\n              onCheckedChange={(checked) => \r\n                setFormData(prev => ({ ...prev, reminder_enabled: checked }))\r\n              }\r\n            />\r\n            <Label htmlFor=\"reminder\">Enable reminder</Label>\r\n          </div>\r\n\r\n          {formData.reminder_enabled && (\r\n            <div className=\"space-y-2\">\r\n              <Label htmlFor=\"reminder-time\">Reminder Time</Label>\r\n              <Input\r\n                id=\"reminder-time\"\r\n                type=\"time\"\r\n                value={formData.reminder_time}\r\n                onChange={(e) => setFormData(prev => ({ ...prev, reminder_time: e.target.value }))}\r\n              />\r\n            </div>\r\n          )}\r\n\r\n          <div className=\"flex justify-end space-x-2 pt-4\">\r\n            <Button type=\"button\" variant=\"outline\" onClick={onClose}>\r\n              Cancel\r\n            </Button>\r\n            <Button type=\"submit\" disabled={isSubmitting || !formData.title.trim()}>\r\n              {isSubmitting ? 'Saving...' : task ? 'Update Task' : 'Create Task'}\r\n            </Button>\r\n          </div>\r\n        </form>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n};\r\n\r\nexport default TaskForm;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1776, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/tasks/TaskPageHeader.tsx"],"sourcesContent":["import React from 'react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Plus } from 'lucide-react';\r\n\r\ninterface TaskPageHeaderProps {\r\n  pendingTodayTasksCount: number;\r\n  totalTasksCount: number;\r\n  onCreateTask: () => void;\r\n  canCreate?: boolean;\r\n}\r\n\r\nconst TaskPageHeader: React.FC<TaskPageHeaderProps> = ({\r\n  pendingTodayTasksCount,\r\n  totalTasksCount,\r\n  onCreateTask,\r\n  canCreate = true,\r\n}) => {\r\n  return (\r\n    <div className=\"flex flex-col sm:flex-row sm:items-center sm:justify-between mb-6\">\r\n      <div>\r\n        <h1 className=\"text-2xl font-bold text-gray-900\">Tasks</h1>\r\n        <p className=\"text-gray-600 mt-1\">\r\n          {pendingTodayTasksCount > 0\r\n            ? `You have ${pendingTodayTasksCount} task${pendingTodayTasksCount === 1 ? '' : 's'} due today`\r\n            : totalTasksCount > 0\r\n              ? \"All clear for today! \"\r\n              : \"What's on your mind today?\"\r\n          }\r\n        </p>\r\n      </div>\r\n      {canCreate && (\r\n        <Button onClick={onCreateTask} className=\"mt-4 sm:mt-0\">\r\n          <Plus className=\"w-4 h-4 mr-2\" />\r\n          Create Task\r\n        </Button>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TaskPageHeader;"],"names":[],"mappings":";;;;;AACA;AACA;;;;AASA,MAAM,iBAAgD,CAAC,EACrD,sBAAsB,EACtB,eAAe,EACf,YAAY,EACZ,YAAY,IAAI,EACjB;IACC,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC;;kCACC,6LAAC;wBAAG,WAAU;kCAAmC;;;;;;kCACjD,6LAAC;wBAAE,WAAU;kCACV,yBAAyB,IACtB,CAAC,SAAS,EAAE,uBAAuB,KAAK,EAAE,2BAA2B,IAAI,KAAK,IAAI,UAAU,CAAC,GAC7F,kBAAkB,IAChB,4BACA;;;;;;;;;;;;YAIT,2BACC,6LAAC,+IAAM;gBAAC,SAAS;gBAAc,WAAU;;kCACvC,6LAAC,6MAAI;wBAAC,WAAU;;;;;;oBAAiB;;;;;;;;;;;;;AAM3C;KA3BM;uCA6BS"}},
    {"offset": {"line": 1850, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/tasks/TaskTabNavigation.tsx"],"sourcesContent":["import React from 'react';\r\nimport { TabsList, TabsTrigger } from '@/components/ui/tabs';\r\nimport { List, Calendar, BarChart3 } from 'lucide-react';\r\n\r\ninterface TaskTabNavigationProps {\r\n  activeTab: string;\r\n}\r\n\r\nconst TaskTabNavigation: React.FC<TaskTabNavigationProps> = ({ activeTab }) => {\r\n  return (\r\n    <TabsList className=\"grid w-full grid-cols-3 lg:w-auto lg:grid-cols-4\">\r\n      <TabsTrigger value=\"list\" className=\"flex items-center gap-2\">\r\n        <List className=\"w-4 h-4\" />\r\n        <span className=\"hidden sm:inline\">List</span>\r\n      </TabsTrigger>\r\n      <TabsTrigger value=\"calendar\" className=\"flex items-center gap-2\">\r\n        <Calendar className=\"w-4 h-4\" />\r\n        <span className=\"hidden sm:inline\">Calendar</span>\r\n      </TabsTrigger>\r\n      <TabsTrigger value=\"today\" className=\"flex items-center gap-2\">\r\n        <div className=\"w-4 h-4 bg-blue-500 rounded-full flex items-center justify-center\">\r\n          <span className=\"text-xs text-white font-bold\">T</span>\r\n        </div>\r\n        <span className=\"hidden sm:inline\">Today</span>\r\n      </TabsTrigger>\r\n      <TabsTrigger value=\"stats\" className=\"flex items-center gap-2\">\r\n        <BarChart3 className=\"w-4 h-4\" />\r\n        <span className=\"hidden sm:inline\">Stats</span>\r\n      </TabsTrigger>\r\n    </TabsList>\r\n  );\r\n};\r\n\r\nexport default TaskTabNavigation;"],"names":[],"mappings":";;;;;AACA;AACA;AAAA;AAAA;;;;AAMA,MAAM,oBAAsD,CAAC,EAAE,SAAS,EAAE;IACxE,qBACE,6LAAC,+IAAQ;QAAC,WAAU;;0BAClB,6LAAC,kJAAW;gBAAC,OAAM;gBAAO,WAAU;;kCAClC,6LAAC,6MAAI;wBAAC,WAAU;;;;;;kCAChB,6LAAC;wBAAK,WAAU;kCAAmB;;;;;;;;;;;;0BAErC,6LAAC,kJAAW;gBAAC,OAAM;gBAAW,WAAU;;kCACtC,6LAAC,yNAAQ;wBAAC,WAAU;;;;;;kCACpB,6LAAC;wBAAK,WAAU;kCAAmB;;;;;;;;;;;;0BAErC,6LAAC,kJAAW;gBAAC,OAAM;gBAAQ,WAAU;;kCACnC,6LAAC;wBAAI,WAAU;kCACb,cAAA,6LAAC;4BAAK,WAAU;sCAA+B;;;;;;;;;;;kCAEjD,6LAAC;wBAAK,WAAU;kCAAmB;;;;;;;;;;;;0BAErC,6LAAC,kJAAW;gBAAC,OAAM;gBAAQ,WAAU;;kCACnC,6LAAC,kOAAS;wBAAC,WAAU;;;;;;kCACrB,6LAAC;wBAAK,WAAU;kCAAmB;;;;;;;;;;;;;;;;;;AAI3C;KAvBM;uCAyBS"}},
    {"offset": {"line": 1992, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/tasks/TaskFilters.tsx"],"sourcesContent":["\r\nimport React from 'react';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Search } from 'lucide-react';\r\nimport { TaskFilters as TaskFiltersType } from '@/types/task';\r\n\r\ninterface TaskFiltersProps {\r\n  filters: TaskFiltersType;\r\n  onFiltersChange: (filters: TaskFiltersType) => void;\r\n  taskCategories: string[];\r\n  selectedTasks: string[];\r\n  onBulkComplete: () => void;\r\n  canEdit?: boolean;\r\n}\r\n\r\nconst TaskFilters: React.FC<TaskFiltersProps> = ({\r\n  filters,\r\n  onFiltersChange,\r\n  taskCategories,\r\n  selectedTasks,\r\n  onBulkComplete,\r\n  canEdit = true,\r\n}) => {\r\n  return (\r\n    <div className=\"bg-white p-4 rounded-lg border space-y-4\">\r\n      <div className=\"relative\">\r\n        <Search className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\r\n        <Input\r\n          placeholder=\"Search tasks...\"\r\n          value={filters.search}\r\n          onChange={(e) => onFiltersChange({ ...filters, search: e.target.value })}\r\n          className=\"pl-10\"\r\n        />\r\n      </div>\r\n\r\n      <div className=\"grid grid-cols-1 sm:grid-cols-3 gap-4\">\r\n        <Select\r\n          value={filters.status}\r\n          onValueChange={(value: any) => onFiltersChange({ ...filters, status: value })}\r\n        >\r\n          <SelectTrigger>\r\n            <SelectValue />\r\n          </SelectTrigger>\r\n          <SelectContent>\r\n            <SelectItem value=\"all\">All Tasks</SelectItem>\r\n            <SelectItem value=\"pending\">Pending</SelectItem>\r\n            <SelectItem value=\"completed\">Completed</SelectItem>\r\n          </SelectContent>\r\n        </Select>\r\n\r\n        <Select\r\n          value={filters.priority}\r\n          onValueChange={(value: any) => onFiltersChange({ ...filters, priority: value })}\r\n        >\r\n          <SelectTrigger>\r\n            <SelectValue />\r\n          </SelectTrigger>\r\n          <SelectContent>\r\n            <SelectItem value=\"all\">All Priorities</SelectItem>\r\n            <SelectItem value=\"High\">High Priority</SelectItem>\r\n            <SelectItem value=\"Medium\">Medium Priority</SelectItem>\r\n            <SelectItem value=\"Low\">Low Priority</SelectItem>\r\n          </SelectContent>\r\n        </Select>\r\n\r\n        <Select\r\n          value={filters.category}\r\n          onValueChange={(value) => onFiltersChange({ ...filters, category: value })}\r\n        >\r\n          <SelectTrigger>\r\n            <SelectValue />\r\n          </SelectTrigger>\r\n          <SelectContent>\r\n            <SelectItem value=\"all\">All Categories</SelectItem>\r\n            <SelectItem value=\"no-category\">No Category</SelectItem>\r\n            {taskCategories.map((category) => (\r\n              <SelectItem key={category} value={category}>\r\n                {category}\r\n              </SelectItem>\r\n            ))}\r\n          </SelectContent>\r\n        </Select>\r\n      </div>\r\n\r\n      {selectedTasks.length > 0 && (\r\n        <div className=\"flex items-center justify-between bg-blue-50 p-3 rounded-md\">\r\n          <span className=\"text-sm text-blue-700\">\r\n            {selectedTasks.length} task{selectedTasks.length === 1 ? '' : 's'} selected\r\n          </span>\r\n          {canEdit && (\r\n            <Button onClick={onBulkComplete} size=\"sm\">\r\n              Mark as Complete\r\n            </Button>\r\n          )}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TaskFilters;\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;;;;;;AAYA,MAAM,cAA0C,CAAC,EAC/C,OAAO,EACP,eAAe,EACf,cAAc,EACd,aAAa,EACb,cAAc,EACd,UAAU,IAAI,EACf;IACC,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC;gBAAI,WAAU;;kCACb,6LAAC,mNAAM;wBAAC,WAAU;;;;;;kCAClB,6LAAC,6IAAK;wBACJ,aAAY;wBACZ,OAAO,QAAQ,MAAM;wBACrB,UAAU,CAAC,IAAM,gBAAgB;gCAAE,GAAG,OAAO;gCAAE,QAAQ,EAAE,MAAM,CAAC,KAAK;4BAAC;wBACtE,WAAU;;;;;;;;;;;;0BAId,6LAAC;gBAAI,WAAU;;kCACb,6LAAC,+IAAM;wBACL,OAAO,QAAQ,MAAM;wBACrB,eAAe,CAAC,QAAe,gBAAgB;gCAAE,GAAG,OAAO;gCAAE,QAAQ;4BAAM;;0CAE3E,6LAAC,sJAAa;0CACZ,cAAA,6LAAC,oJAAW;;;;;;;;;;0CAEd,6LAAC,sJAAa;;kDACZ,6LAAC,mJAAU;wCAAC,OAAM;kDAAM;;;;;;kDACxB,6LAAC,mJAAU;wCAAC,OAAM;kDAAU;;;;;;kDAC5B,6LAAC,mJAAU;wCAAC,OAAM;kDAAY;;;;;;;;;;;;;;;;;;kCAIlC,6LAAC,+IAAM;wBACL,OAAO,QAAQ,QAAQ;wBACvB,eAAe,CAAC,QAAe,gBAAgB;gCAAE,GAAG,OAAO;gCAAE,UAAU;4BAAM;;0CAE7E,6LAAC,sJAAa;0CACZ,cAAA,6LAAC,oJAAW;;;;;;;;;;0CAEd,6LAAC,sJAAa;;kDACZ,6LAAC,mJAAU;wCAAC,OAAM;kDAAM;;;;;;kDACxB,6LAAC,mJAAU;wCAAC,OAAM;kDAAO;;;;;;kDACzB,6LAAC,mJAAU;wCAAC,OAAM;kDAAS;;;;;;kDAC3B,6LAAC,mJAAU;wCAAC,OAAM;kDAAM;;;;;;;;;;;;;;;;;;kCAI5B,6LAAC,+IAAM;wBACL,OAAO,QAAQ,QAAQ;wBACvB,eAAe,CAAC,QAAU,gBAAgB;gCAAE,GAAG,OAAO;gCAAE,UAAU;4BAAM;;0CAExE,6LAAC,sJAAa;0CACZ,cAAA,6LAAC,oJAAW;;;;;;;;;;0CAEd,6LAAC,sJAAa;;kDACZ,6LAAC,mJAAU;wCAAC,OAAM;kDAAM;;;;;;kDACxB,6LAAC,mJAAU;wCAAC,OAAM;kDAAc;;;;;;oCAC/B,eAAe,GAAG,CAAC,CAAC,yBACnB,6LAAC,mJAAU;4CAAgB,OAAO;sDAC/B;2CADc;;;;;;;;;;;;;;;;;;;;;;;YAQxB,cAAc,MAAM,GAAG,mBACtB,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;wBAAK,WAAU;;4BACb,cAAc,MAAM;4BAAC;4BAAM,cAAc,MAAM,KAAK,IAAI,KAAK;4BAAI;;;;;;;oBAEnE,yBACC,6LAAC,+IAAM;wBAAC,SAAS;wBAAgB,MAAK;kCAAK;;;;;;;;;;;;;;;;;;AAQvD;KAnFM;uCAqFS"}},
    {"offset": {"line": 2273, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/checkbox.tsx"],"sourcesContent":["import * as React from \"react\"\r\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\r\nimport { Check } from \"lucide-react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Checkbox = React.forwardRef<\r\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\r\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\r\n>(({ className, ...props }, ref) => (\r\n  <CheckboxPrimitive.Root\r\n    ref={ref}\r\n    className={cn(\r\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\r\n      className\r\n    )}\r\n    {...props}\r\n  >\r\n    <CheckboxPrimitive.Indicator\r\n      className={cn(\"flex items-center justify-center text-current\")}\r\n    >\r\n      <Check className=\"h-4 w-4\" />\r\n    </CheckboxPrimitive.Indicator>\r\n  </CheckboxPrimitive.Root>\r\n))\r\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\r\n\r\nexport { Checkbox }\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,yBAAW,2KAAgB,MAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,+KAAsB;QACrB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,kTACA;QAED,GAAG,KAAK;kBAET,cAAA,6LAAC,oLAA2B;YAC1B,WAAW,IAAA,4HAAE,EAAC;sBAEd,cAAA,6LAAC,gNAAK;gBAAC,WAAU;;;;;;;;;;;;;;;;;AAIvB,SAAS,WAAW,GAAG,+KAAsB,CAAC,WAAW"}},
    {"offset": {"line": 2323, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/badge.tsx"],"sourcesContent":["\r\nimport * as React from \"react\"\r\nimport { cva, type VariantProps } from \"class-variance-authority\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst badgeVariants = cva(\r\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default:\r\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\r\n        secondary:\r\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        destructive:\r\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\r\n        outline: \"text-foreground\",\r\n        warning:\r\n          \"border-transparent bg-amber-500 text-white hover:bg-amber-600\",\r\n        success:\r\n          \"border-transparent bg-green-600 text-white hover:bg-green-700\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n    },\r\n  }\r\n)\r\n\r\nexport interface BadgeProps\r\n  extends React.HTMLAttributes<HTMLDivElement>,\r\n    VariantProps<typeof badgeVariants> {}\r\n\r\nfunction Badge({ className, variant, ...props }: BadgeProps) {\r\n  return (\r\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\r\n  )\r\n}\r\n\r\nexport { Badge, badgeVariants }\r\n"],"names":[],"mappings":";;;;;;;AAEA;AAEA;;;;AAEA,MAAM,gBAAgB,IAAA,0KAAG,EACvB,0KACA;IACE,UAAU;QACR,SAAS;YACP,SACE;YACF,WACE;YACF,aACE;YACF,SAAS;YACT,SACE;YACF,SACE;QACJ;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAOF,SAAS,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAmB;IACzD,qBACE,6LAAC;QAAI,WAAW,IAAA,4HAAE,EAAC,cAAc;YAAE;QAAQ,IAAI;QAAa,GAAG,KAAK;;;;;;AAExE;KAJS"}},
    {"offset": {"line": 2373, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/tasks/TaskCard.tsx"],"sourcesContent":["\r\nimport React, { useState } from 'react';\r\nimport { Card, CardContent } from '@/components/ui/card';\r\nimport { Checkbox } from '@/components/ui/checkbox';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Edit, Trash2, Clock, Repeat } from 'lucide-react';\r\nimport { Task } from '@/types/task';\r\nimport { format, isToday, isTomorrow, isPast, differenceInDays } from 'date-fns';\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface TaskCardProps {\r\n  task: Task;\r\n  onToggleComplete: (id: string) => void;\r\n  onEdit: (task: Task) => void;\r\n  onDelete: (id: string) => void;\r\n  canEdit?: boolean;\r\n  canDelete?: boolean;\r\n}\r\n\r\nconst TaskCard: React.FC<TaskCardProps> = ({\r\n  task,\r\n  onToggleComplete,\r\n  onEdit,\r\n  onDelete,\r\n  canEdit = true,\r\n  canDelete = true,\r\n}) => {\r\n  const [isCompleting, setIsCompleting] = useState(false);\r\n\r\n  const handleToggleComplete = async () => {\r\n    setIsCompleting(true);\r\n    await onToggleComplete(task.id);\r\n    setIsCompleting(false);\r\n  };\r\n\r\n  const getDueDateDisplay = (dueDate: string) => {\r\n    const date = new Date(dueDate);\r\n\r\n    if (isToday(date)) return 'Today';\r\n    if (isTomorrow(date)) return 'Tomorrow';\r\n    if (isPast(date) && !isToday(date)) {\r\n      const daysAgo = Math.abs(differenceInDays(new Date(), date));\r\n      return `${daysAgo} day${daysAgo === 1 ? '' : 's'} ago`;\r\n    }\r\n\r\n    const daysUntil = differenceInDays(date, new Date());\r\n    if (daysUntil <= 7) {\r\n      return `In ${daysUntil} day${daysUntil === 1 ? '' : 's'}`;\r\n    }\r\n\r\n    return format(date, 'MMM dd, yyyy');\r\n  };\r\n\r\n  const getDueDateColor = (dueDate: string) => {\r\n    const date = new Date(dueDate);\r\n\r\n    if (task.completed) return 'text-gray-500';\r\n    if (isPast(date) && !isToday(date)) return 'text-red-500';\r\n    if (isToday(date)) return 'text-orange-500';\r\n    if (isTomorrow(date)) return 'text-yellow-500';\r\n\r\n    return 'text-gray-600';\r\n  };\r\n\r\n  const getPriorityColor = (priority: string) => {\r\n    if (task.completed) return 'border-gray-200';\r\n\r\n    switch (priority) {\r\n      case 'High': return 'border-red-300 bg-red-50';\r\n      case 'Medium': return 'border-yellow-300 bg-yellow-50';\r\n      case 'Low': return 'border-green-300 bg-green-50';\r\n      default: return 'border-gray-200';\r\n    }\r\n  };\r\n\r\n  const getPriorityBadgeColor = (priority: string) => {\r\n    switch (priority) {\r\n      case 'High': return 'bg-red-100 text-red-700 hover:bg-red-200';\r\n      case 'Medium': return 'bg-yellow-100 text-yellow-700 hover:bg-yellow-200';\r\n      case 'Low': return 'bg-green-100 text-green-700 hover:bg-green-200';\r\n      default: return 'bg-gray-100 text-gray-700 hover:bg-gray-200';\r\n    }\r\n  };\r\n\r\n  const getRecurrenceDisplay = () => {\r\n    if (!task.is_recurring || !task.recurrence_type) return null;\r\n\r\n    const typeMap = {\r\n      daily: 'Daily',\r\n      weekly: 'Weekly',\r\n      monthly: 'Monthly'\r\n    };\r\n\r\n    return typeMap[task.recurrence_type];\r\n  };\r\n\r\n  return (\r\n    <Card className={cn(\r\n      'transition-all duration-200 hover:shadow-md',\r\n      getPriorityColor(task.priority),\r\n      task.completed && 'opacity-75'\r\n    )}>\r\n      <CardContent className=\"p-4\">\r\n        <div className=\"flex items-start space-x-3\">\r\n          <Checkbox\r\n            checked={task.completed}\r\n            onCheckedChange={handleToggleComplete}\r\n            disabled={isCompleting || !canEdit}\r\n            className=\"mt-1\"\r\n          />\r\n\r\n          <div className=\"flex-1 min-w-0\">\r\n            <div className=\"flex items-start justify-between\">\r\n              <div className=\"flex-1\">\r\n                <div className=\"flex items-center space-x-2\">\r\n                  <h3 className={cn(\r\n                    'font-medium text-sm',\r\n                    task.completed && 'line-through text-gray-500'\r\n                  )}>\r\n                    {task.title}\r\n                  </h3>\r\n                  {task.is_recurring && (\r\n                    <Repeat className=\"w-3 h-3 text-blue-500\" />\r\n                  )}\r\n                </div>\r\n\r\n                {task.description && (\r\n                  <p className={cn(\r\n                    'text-xs text-gray-600 mt-1',\r\n                    task.completed && 'text-gray-400'\r\n                  )}>\r\n                    {task.description}\r\n                  </p>\r\n                )}\r\n\r\n                <div className=\"flex items-center space-x-2 mt-2\">\r\n                  <Badge variant=\"secondary\" className={getPriorityBadgeColor(task.priority)}>\r\n                    {task.priority}\r\n                  </Badge>\r\n\r\n                  {task.category && (\r\n                    <Badge variant=\"outline\" className=\"text-xs\">\r\n                      {task.category}\r\n                    </Badge>\r\n                  )}\r\n\r\n                  {task.is_recurring && (\r\n                    <Badge variant=\"outline\" className=\"text-xs bg-blue-50 text-blue-700\">\r\n                      {getRecurrenceDisplay()}\r\n                    </Badge>\r\n                  )}\r\n\r\n                  <div className={cn(\r\n                    'flex items-center text-xs',\r\n                    getDueDateColor(task.due_date)\r\n                  )}>\r\n                    <Clock className=\"w-3 h-3 mr-1\" />\r\n                    {getDueDateDisplay(task.due_date)}\r\n                  </div>\r\n                </div>\r\n\r\n                {task.parent_task_id && (\r\n                  <div className=\"mt-1\">\r\n                    <Badge variant=\"outline\" className=\"text-xs bg-gray-50\">\r\n                      Instance #{task.recurrence_count}\r\n                    </Badge>\r\n                  </div>\r\n                )}\r\n              </div>\r\n\r\n              <div className=\"flex items-center space-x-1 ml-2\">\r\n                {canEdit && (\r\n                  <Button\r\n                    variant=\"ghost\"\r\n                    size=\"sm\"\r\n                    onClick={() => onEdit(task)}\r\n                    className=\"h-7 w-7 p-0 hover:bg-gray-100\"\r\n                  >\r\n                    <Edit className=\"h-3 w-3\" />\r\n                  </Button>\r\n                )}\r\n\r\n                {canDelete && (\r\n                  <Button\r\n                    variant=\"ghost\"\r\n                    size=\"sm\"\r\n                    onClick={() => onDelete(task.id)}\r\n                    className=\"h-7 w-7 p-0 hover:bg-red-100 hover:text-red-600\"\r\n                  >\r\n                    <Trash2 className=\"h-3 w-3\" />\r\n                  </Button>\r\n                )}\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        {task.reminder_enabled && task.reminder_time && (\r\n          <div className=\"mt-2 flex items-center text-xs text-gray-500\">\r\n            <Clock className=\"w-3 h-3 mr-1\" />\r\n            Reminder at {task.reminder_time}\r\n          </div>\r\n        )}\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n};\r\n\r\nexport default TaskCard;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2705, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/tasks/TaskItems.tsx"],"sourcesContent":["\r\nimport React from 'react';\r\nimport { CheckCircle2 } from 'lucide-react';\r\nimport { Task } from '@/types/task';\r\nimport TaskCard from './TaskCard';\r\n\r\ninterface TaskItemsProps {\r\n  tasks: Task[];\r\n  onToggleComplete: (id: string) => void;\r\n  onEdit: (task: Task) => void;\r\n  onDelete: (id: string) => void;\r\n  canEdit?: boolean;\r\n  canDelete?: boolean;\r\n}\r\n\r\nconst TaskItems: React.FC<TaskItemsProps> = ({\r\n  tasks,\r\n  onToggleComplete,\r\n  onEdit,\r\n  onDelete,\r\n  canEdit = true,\r\n  canDelete = true,\r\n}) => {\r\n  const pendingTasks = tasks.filter(task => !task.completed);\r\n  const completedTasks = tasks.filter(task => task.completed);\r\n\r\n  if (tasks.length === 0) {\r\n    return (\r\n      <div className=\"text-center py-12\">\r\n        <div className=\"text-gray-400 mb-4\">\r\n          <CheckCircle2 className=\"w-16 h-16 mx-auto mb-4\" />\r\n          <p className=\"text-lg font-medium text-gray-600\">What's on your mind today?</p>\r\n          <p className=\"text-sm text-gray-500 mt-1\">Add your first task to get started!</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      {/* Pending Tasks */}\r\n      {pendingTasks.length > 0 && (\r\n        <div>\r\n          <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">\r\n            Pending ({pendingTasks.length})\r\n          </h3>\r\n          <div className=\"space-y-3\">\r\n            {pendingTasks.map((task) => (\r\n              <TaskCard\r\n                key={task.id}\r\n                task={task}\r\n                onToggleComplete={onToggleComplete}\r\n                onEdit={onEdit}\r\n                onDelete={onDelete}\r\n                canEdit={canEdit}\r\n                canDelete={canDelete}\r\n              />\r\n            ))}\r\n          </div>\r\n        </div>\r\n      )}\r\n\r\n      {/* Completed Tasks */}\r\n      {completedTasks.length > 0 && (\r\n        <div>\r\n          <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">\r\n            Completed ({completedTasks.length})\r\n          </h3>\r\n          <div className=\"space-y-3\">\r\n            {completedTasks.map((task) => (\r\n              <TaskCard\r\n                key={task.id}\r\n                task={task}\r\n                onToggleComplete={onToggleComplete}\r\n                onEdit={onEdit}\r\n                onDelete={onDelete}\r\n                canEdit={canEdit}\r\n                canDelete={canDelete}\r\n              />\r\n            ))}\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TaskItems;\r\n"],"names":[],"mappings":";;;;;AAEA;AAEA;;;;AAWA,MAAM,YAAsC,CAAC,EAC3C,KAAK,EACL,gBAAgB,EAChB,MAAM,EACN,QAAQ,EACR,UAAU,IAAI,EACd,YAAY,IAAI,EACjB;IACC,MAAM,eAAe,MAAM,MAAM,CAAC,CAAA,OAAQ,CAAC,KAAK,SAAS;IACzD,MAAM,iBAAiB,MAAM,MAAM,CAAC,CAAA,OAAQ,KAAK,SAAS;IAE1D,IAAI,MAAM,MAAM,KAAK,GAAG;QACtB,qBACE,6LAAC;YAAI,WAAU;sBACb,cAAA,6LAAC;gBAAI,WAAU;;kCACb,6LAAC,wOAAY;wBAAC,WAAU;;;;;;kCACxB,6LAAC;wBAAE,WAAU;kCAAoC;;;;;;kCACjD,6LAAC;wBAAE,WAAU;kCAA6B;;;;;;;;;;;;;;;;;IAIlD;IAEA,qBACE,6LAAC;QAAI,WAAU;;YAEZ,aAAa,MAAM,GAAG,mBACrB,6LAAC;;kCACC,6LAAC;wBAAG,WAAU;;4BAA2C;4BAC7C,aAAa,MAAM;4BAAC;;;;;;;kCAEhC,6LAAC;wBAAI,WAAU;kCACZ,aAAa,GAAG,CAAC,CAAC,qBACjB,6LAAC,qJAAQ;gCAEP,MAAM;gCACN,kBAAkB;gCAClB,QAAQ;gCACR,UAAU;gCACV,SAAS;gCACT,WAAW;+BANN,KAAK,EAAE;;;;;;;;;;;;;;;;YAcrB,eAAe,MAAM,GAAG,mBACvB,6LAAC;;kCACC,6LAAC;wBAAG,WAAU;;4BAA2C;4BAC3C,eAAe,MAAM;4BAAC;;;;;;;kCAEpC,6LAAC;wBAAI,WAAU;kCACZ,eAAe,GAAG,CAAC,CAAC,qBACnB,6LAAC,qJAAQ;gCAEP,MAAM;gCACN,kBAAkB;gCAClB,QAAQ;gCACR,UAAU;gCACV,SAAS;gCACT,WAAW;+BANN,KAAK,EAAE;;;;;;;;;;;;;;;;;;;;;;AAc5B;KAtEM;uCAwES"}},
    {"offset": {"line": 2858, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/tasks/TaskList.tsx"],"sourcesContent":["\r\nimport React, { useState, useMemo } from 'react';\r\nimport { Task, TaskFilters } from '@/types/task';\r\nimport { useTaskCategories } from '@/hooks/useTaskCategories';\r\nimport TaskFiltersComponent from './TaskFilters';\r\nimport TaskItems from './TaskItems';\r\n\r\ninterface TaskListProps {\r\n  tasks: Task[];\r\n  onToggleComplete: (id: string) => void;\r\n  onEdit: (task: Task) => void;\r\n  onDelete: (id: string) => void;\r\n  onBulkComplete?: (taskIds: string[]) => void;\r\n  canEdit?: boolean;\r\n  canDelete?: boolean;\r\n}\r\n\r\nconst TaskList: React.FC<TaskListProps> = ({\r\n  tasks,\r\n  onToggleComplete,\r\n  onEdit,\r\n  onDelete,\r\n  onBulkComplete,\r\n  canEdit = true,\r\n  canDelete = true,\r\n}) => {\r\n  const [filters, setFilters] = useState<TaskFilters>({\r\n    status: 'all',\r\n    priority: 'all',\r\n    category: 'all',\r\n    search: '',\r\n  });\r\n  const [selectedTasks, setSelectedTasks] = useState<string[]>([]);\r\n  const { categories } = useTaskCategories();\r\n\r\n  const filteredTasks = useMemo(() => {\r\n    return tasks.filter(task => {\r\n      // Status filter\r\n      if (filters.status === 'pending' && task.completed) return false;\r\n      if (filters.status === 'completed' && !task.completed) return false;\r\n\r\n      // Priority filter\r\n      if (filters.priority !== 'all' && task.priority !== filters.priority) return false;\r\n\r\n      // Category filter\r\n      if (filters.category !== 'all') {\r\n        if (filters.category === 'no-category' && task.category) return false;\r\n        if (filters.category !== 'no-category' && task.category !== filters.category) return false;\r\n      }\r\n\r\n      // Search filter\r\n      if (filters.search) {\r\n        const searchLower = filters.search.toLowerCase();\r\n        return (\r\n          task.title.toLowerCase().includes(searchLower) ||\r\n          (task.description && task.description.toLowerCase().includes(searchLower))\r\n        );\r\n      }\r\n\r\n      return true;\r\n    });\r\n  }, [tasks, filters]);\r\n\r\n  const handleBulkComplete = () => {\r\n    if (onBulkComplete && selectedTasks.length > 0) {\r\n      onBulkComplete(selectedTasks);\r\n      setSelectedTasks([]);\r\n    }\r\n  };\r\n\r\n  const taskCategories = [...new Set(tasks.map(task => task.category).filter(Boolean))];\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      {/* Filters */}\r\n      <TaskFiltersComponent\r\n        filters={filters}\r\n        onFiltersChange={setFilters}\r\n        taskCategories={taskCategories}\r\n        selectedTasks={selectedTasks}\r\n        onBulkComplete={handleBulkComplete}\r\n        canEdit={canEdit}\r\n      />\r\n\r\n      {/* Task Items */}\r\n      <TaskItems\r\n        tasks={filteredTasks}\r\n        onToggleComplete={onToggleComplete}\r\n        onEdit={onEdit}\r\n        onDelete={onDelete}\r\n        canEdit={canEdit}\r\n        canDelete={canDelete}\r\n      />\r\n\r\n      {filteredTasks.length === 0 && tasks.length > 0 && (\r\n        <div className=\"text-center py-8\">\r\n          <p className=\"text-gray-500\">No tasks match your current filters.</p>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TaskList;\r\n"],"names":[],"mappings":";;;;;AACA;AAEA;AACA;AACA;;;;;;;AAYA,MAAM,WAAoC,CAAC,EACzC,KAAK,EACL,gBAAgB,EAChB,MAAM,EACN,QAAQ,EACR,cAAc,EACd,UAAU,IAAI,EACd,YAAY,IAAI,EACjB;;IACC,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAc;QAClD,QAAQ;QACR,UAAU;QACV,UAAU;QACV,QAAQ;IACV;IACA,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,yKAAQ,EAAW,EAAE;IAC/D,MAAM,EAAE,UAAU,EAAE,GAAG,IAAA,yJAAiB;IAExC,MAAM,gBAAgB,IAAA,wKAAO;2CAAC;YAC5B,OAAO,MAAM,MAAM;mDAAC,CAAA;oBAClB,gBAAgB;oBAChB,IAAI,QAAQ,MAAM,KAAK,aAAa,KAAK,SAAS,EAAE,OAAO;oBAC3D,IAAI,QAAQ,MAAM,KAAK,eAAe,CAAC,KAAK,SAAS,EAAE,OAAO;oBAE9D,kBAAkB;oBAClB,IAAI,QAAQ,QAAQ,KAAK,SAAS,KAAK,QAAQ,KAAK,QAAQ,QAAQ,EAAE,OAAO;oBAE7E,kBAAkB;oBAClB,IAAI,QAAQ,QAAQ,KAAK,OAAO;wBAC9B,IAAI,QAAQ,QAAQ,KAAK,iBAAiB,KAAK,QAAQ,EAAE,OAAO;wBAChE,IAAI,QAAQ,QAAQ,KAAK,iBAAiB,KAAK,QAAQ,KAAK,QAAQ,QAAQ,EAAE,OAAO;oBACvF;oBAEA,gBAAgB;oBAChB,IAAI,QAAQ,MAAM,EAAE;wBAClB,MAAM,cAAc,QAAQ,MAAM,CAAC,WAAW;wBAC9C,OACE,KAAK,KAAK,CAAC,WAAW,GAAG,QAAQ,CAAC,gBACjC,KAAK,WAAW,IAAI,KAAK,WAAW,CAAC,WAAW,GAAG,QAAQ,CAAC;oBAEjE;oBAEA,OAAO;gBACT;;QACF;0CAAG;QAAC;QAAO;KAAQ;IAEnB,MAAM,qBAAqB;QACzB,IAAI,kBAAkB,cAAc,MAAM,GAAG,GAAG;YAC9C,eAAe;YACf,iBAAiB,EAAE;QACrB;IACF;IAEA,MAAM,iBAAiB;WAAI,IAAI,IAAI,MAAM,GAAG,CAAC,CAAA,OAAQ,KAAK,QAAQ,EAAE,MAAM,CAAC;KAAU;IAErF,qBACE,6LAAC;QAAI,WAAU;;0BAEb,6LAAC,wJAAoB;gBACnB,SAAS;gBACT,iBAAiB;gBACjB,gBAAgB;gBAChB,eAAe;gBACf,gBAAgB;gBAChB,SAAS;;;;;;0BAIX,6LAAC,sJAAS;gBACR,OAAO;gBACP,kBAAkB;gBAClB,QAAQ;gBACR,UAAU;gBACV,SAAS;gBACT,WAAW;;;;;;YAGZ,cAAc,MAAM,KAAK,KAAK,MAAM,MAAM,GAAG,mBAC5C,6LAAC;gBAAI,WAAU;0BACb,cAAA,6LAAC;oBAAE,WAAU;8BAAgB;;;;;;;;;;;;;;;;;AAKvC;GApFM;;QAgBmB,yJAAiB;;;KAhBpC;uCAsFS"}},
    {"offset": {"line": 2984, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/tasks/TaskCalendar.tsx"],"sourcesContent":["\r\nimport React, { useState, useMemo } from 'react';\r\nimport { Calendar } from '@/components/ui/calendar';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Button } from '@/components/ui/button';\r\nimport { ChevronLeft, ChevronRight } from 'lucide-react';\r\nimport { Task } from '@/types/task';\r\nimport { format, isSameDay, startOfMonth, endOfMonth, addMonths, subMonths } from 'date-fns';\r\nimport TaskCard from './TaskCard';\r\n\r\ninterface TaskCalendarProps {\r\n  tasks: Task[];\r\n  onToggleComplete: (id: string) => void;\r\n  onEdit: (task: Task) => void;\r\n  onDelete: (id: string) => void;\r\n  canEdit?: boolean;\r\n  canDelete?: boolean;\r\n}\r\n\r\nconst TaskCalendar: React.FC<TaskCalendarProps> = ({\r\n  tasks,\r\n  onToggleComplete,\r\n  onEdit,\r\n  onDelete,\r\n  canEdit = true,\r\n  canDelete = true,\r\n}) => {\r\n  const [selectedDate, setSelectedDate] = useState<Date>(new Date());\r\n  const [currentMonth, setCurrentMonth] = useState<Date>(new Date());\r\n\r\n  const tasksByDate = useMemo(() => {\r\n    const grouped: { [key: string]: Task[] } = {};\r\n    tasks.forEach(task => {\r\n      const dateKey = format(new Date(task.due_date), 'yyyy-MM-dd');\r\n      if (!grouped[dateKey]) {\r\n        grouped[dateKey] = [];\r\n      }\r\n      grouped[dateKey].push(task);\r\n    });\r\n    return grouped;\r\n  }, [tasks]);\r\n\r\n  const selectedDateTasks = useMemo(() => {\r\n    const dateKey = format(selectedDate, 'yyyy-MM-dd');\r\n    return tasksByDate[dateKey] || [];\r\n  }, [tasksByDate, selectedDate]);\r\n\r\n  const getDayTasks = (date: Date) => {\r\n    const dateKey = format(date, 'yyyy-MM-dd');\r\n    return tasksByDate[dateKey] || [];\r\n  };\r\n\r\n  const getDayIndicator = (date: Date) => {\r\n    const dayTasks = getDayTasks(date);\r\n    if (dayTasks.length === 0) return null;\r\n\r\n    const completedCount = dayTasks.filter(task => task.completed).length;\r\n    const totalCount = dayTasks.length;\r\n    const pendingCount = totalCount - completedCount;\r\n\r\n    const highPriorityCount = dayTasks.filter(task => task.priority === 'High' && !task.completed).length;\r\n\r\n    return (\r\n      <div className=\"flex items-center justify-center mt-1 space-x-1\">\r\n        {highPriorityCount > 0 && (\r\n          <div className=\"w-1.5 h-1.5 bg-red-500 rounded-full\"></div>\r\n        )}\r\n        {pendingCount > 0 && (\r\n          <div className=\"w-1.5 h-1.5 bg-blue-500 rounded-full\"></div>\r\n        )}\r\n        {completedCount > 0 && (\r\n          <div className=\"w-1.5 h-1.5 bg-green-500 rounded-full\"></div>\r\n        )}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  const handleDateSelect = (date: Date | undefined) => {\r\n    if (date) {\r\n      setSelectedDate(date);\r\n    }\r\n  };\r\n\r\n  const goToPreviousMonth = () => {\r\n    setCurrentMonth(prev => subMonths(prev, 1));\r\n  };\r\n\r\n  const goToNextMonth = () => {\r\n    setCurrentMonth(prev => addMonths(prev, 1));\r\n  };\r\n\r\n  const goToToday = () => {\r\n    const today = new Date();\r\n    setCurrentMonth(today);\r\n    setSelectedDate(today);\r\n  };\r\n\r\n  return (\r\n    <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-6\">\r\n      {/* Calendar */}\r\n      <Card className=\"lg:col-span-2\">\r\n        <CardHeader>\r\n          <div className=\"flex items-center justify-between\">\r\n            <CardTitle className=\"text-lg font-semibold\">\r\n              {format(currentMonth, 'MMMM yyyy')}\r\n            </CardTitle>\r\n            <div className=\"flex items-center space-x-2\">\r\n              <Button\r\n                variant=\"outline\"\r\n                size=\"sm\"\r\n                onClick={goToToday}\r\n                className=\"text-xs\"\r\n              >\r\n                Today\r\n              </Button>\r\n              <Button\r\n                variant=\"outline\"\r\n                size=\"sm\"\r\n                onClick={goToPreviousMonth}\r\n              >\r\n                <ChevronLeft className=\"h-4 w-4\" />\r\n              </Button>\r\n              <Button\r\n                variant=\"outline\"\r\n                size=\"sm\"\r\n                onClick={goToNextMonth}\r\n              >\r\n                <ChevronRight className=\"h-4 w-4\" />\r\n              </Button>\r\n            </div>\r\n          </div>\r\n        </CardHeader>\r\n        <CardContent>\r\n          <Calendar\r\n            mode=\"single\"\r\n            selected={selectedDate}\r\n            onSelect={handleDateSelect}\r\n            month={currentMonth}\r\n            onMonthChange={setCurrentMonth}\r\n            className=\"w-full\"\r\n            components={{\r\n              Day: ({ date, ...props }) => {\r\n                const dayTasks = getDayTasks(date);\r\n                const isSelected = isSameDay(date, selectedDate);\r\n\r\n                return (\r\n                  <div\r\n                    className={`relative p-2 hover:bg-gray-50 cursor-pointer rounded-md ${isSelected ? 'bg-blue-100' : ''\r\n                      }`}\r\n                    onClick={() => handleDateSelect(date)}\r\n                  >\r\n                    <div className=\"text-center\">\r\n                      <span className={`text-sm ${isSelected ? 'font-bold' : ''}`}>\r\n                        {format(date, 'd')}\r\n                      </span>\r\n                      {getDayIndicator(date)}\r\n                    </div>\r\n                  </div>\r\n                );\r\n              },\r\n            }}\r\n          />\r\n\r\n          {/* Legend */}\r\n          <div className=\"mt-4 flex items-center justify-center space-x-4 text-xs text-gray-600\">\r\n            <div className=\"flex items-center space-x-1\">\r\n              <div className=\"w-2 h-2 bg-red-500 rounded-full\"></div>\r\n              <span>High Priority</span>\r\n            </div>\r\n            <div className=\"flex items-center space-x-1\">\r\n              <div className=\"w-2 h-2 bg-blue-500 rounded-full\"></div>\r\n              <span>Pending</span>\r\n            </div>\r\n            <div className=\"flex items-center space-x-1\">\r\n              <div className=\"w-2 h-2 bg-green-500 rounded-full\"></div>\r\n              <span>Completed</span>\r\n            </div>\r\n          </div>\r\n        </CardContent>\r\n      </Card>\r\n\r\n      {/* Selected Date Tasks */}\r\n      <Card>\r\n        <CardHeader>\r\n          <CardTitle className=\"text-lg font-semibold\">\r\n            {format(selectedDate, 'MMM dd, yyyy')}\r\n          </CardTitle>\r\n          {selectedDateTasks.length > 0 && (\r\n            <div className=\"flex items-center space-x-2\">\r\n              <Badge variant=\"secondary\">\r\n                {selectedDateTasks.filter(task => !task.completed).length} pending\r\n              </Badge>\r\n              <Badge variant=\"secondary\">\r\n                {selectedDateTasks.filter(task => task.completed).length} completed\r\n              </Badge>\r\n            </div>\r\n          )}\r\n        </CardHeader>\r\n        <CardContent>\r\n          {selectedDateTasks.length === 0 ? (\r\n            <div className=\"text-center py-8\">\r\n              <p className=\"text-gray-500 text-sm\">\r\n                No tasks for this date.\r\n              </p>\r\n              <p className=\"text-gray-400 text-xs mt-1\">\r\n                All clear! Time for a coffee break \r\n              </p>\r\n            </div>\r\n          ) : (\r\n            <div className=\"space-y-3 max-h-96 overflow-y-auto\">\r\n              {selectedDateTasks.map((task) => (\r\n                <TaskCard\r\n                  key={task.id}\r\n                  task={task}\r\n                  onToggleComplete={onToggleComplete}\r\n                  onEdit={onEdit}\r\n                  onDelete={onDelete}\r\n                  canEdit={canEdit}\r\n                  canDelete={canDelete}\r\n                />\r\n              ))}\r\n            </div>\r\n          )}\r\n        </CardContent>\r\n      </Card>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TaskCalendar;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3439, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/ui/progress.tsx"],"sourcesContent":["\r\nimport * as React from \"react\"\r\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Progress = React.forwardRef<\r\n  React.ElementRef<typeof ProgressPrimitive.Root>,\r\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\r\n>(({ className, value, ...props }, ref) => (\r\n  <ProgressPrimitive.Root\r\n    ref={ref}\r\n    className={cn(\r\n      \"relative h-4 w-full overflow-hidden rounded-full bg-gray-200\",\r\n      className\r\n    )}\r\n    {...props}\r\n  >\r\n    <ProgressPrimitive.Indicator\r\n      className=\"h-full w-full flex-1 transition-all\"\r\n      style={{ \r\n        transform: `translateX(-${100 - (value || 0)}%)`,\r\n        backgroundColor: \"#16a34a\"\r\n      }}\r\n    />\r\n  </ProgressPrimitive.Root>\r\n))\r\nProgress.displayName = ProgressPrimitive.Root.displayName\r\n\r\nexport { Progress }\r\n"],"names":[],"mappings":";;;;;AACA;AACA;AAEA;;;;;AAEA,MAAM,yBAAW,2KAAgB,MAG/B,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG,OAAO,EAAE,oBACjC,6LAAC,+KAAsB;QACrB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,gEACA;QAED,GAAG,KAAK;kBAET,cAAA,6LAAC,oLAA2B;YAC1B,WAAU;YACV,OAAO;gBACL,WAAW,CAAC,YAAY,EAAE,MAAM,CAAC,SAAS,CAAC,EAAE,EAAE,CAAC;gBAChD,iBAAiB;YACnB;;;;;;;;;;;;AAIN,SAAS,WAAW,GAAG,+KAAsB,CAAC,WAAW"}},
    {"offset": {"line": 3484, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/tasks/TaskStats.tsx"],"sourcesContent":["\r\nimport React, { useMemo } from 'react';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Progress } from '@/components/ui/progress';\r\nimport { CheckCircle2, Clock, AlertTriangle, TrendingUp } from 'lucide-react';\r\nimport { Task } from '@/types/task';\r\nimport { isToday, isPast, isTomorrow } from 'date-fns';\r\n\r\ninterface TaskStatsProps {\r\n  tasks: Task[];\r\n}\r\n\r\nconst TaskStats: React.FC<TaskStatsProps> = ({ tasks }) => {\r\n  const stats = useMemo(() => {\r\n    const totalTasks = tasks.length;\r\n    const completedTasks = tasks.filter(task => task.completed).length;\r\n    const pendingTasks = totalTasks - completedTasks;\r\n    \r\n    const todayTasks = tasks.filter(task => isToday(new Date(task.due_date)));\r\n    const todayCompleted = todayTasks.filter(task => task.completed).length;\r\n    \r\n    const overdueTasks = tasks.filter(task => \r\n      isPast(new Date(task.due_date)) && \r\n      !task.completed && \r\n      !isToday(new Date(task.due_date))\r\n    ).length;\r\n    \r\n    const highPriorityPending = tasks.filter(task => \r\n      task.priority === 'High' && !task.completed\r\n    ).length;\r\n    \r\n    const completionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;\r\n    const todayCompletionRate = todayTasks.length > 0 ? Math.round((todayCompleted / todayTasks.length) * 100) : 0;\r\n    \r\n    return {\r\n      totalTasks,\r\n      completedTasks,\r\n      pendingTasks,\r\n      todayTasks: todayTasks.length,\r\n      todayCompleted,\r\n      overdueTasks,\r\n      highPriorityPending,\r\n      completionRate,\r\n      todayCompletionRate,\r\n    };\r\n  }, [tasks]);\r\n\r\n  const statCards = [\r\n    {\r\n      title: 'Total Tasks',\r\n      value: stats.totalTasks,\r\n      icon: Clock,\r\n      color: 'text-blue-600',\r\n      bgColor: 'bg-blue-50',\r\n    },\r\n    {\r\n      title: 'Completed',\r\n      value: stats.completedTasks,\r\n      icon: CheckCircle2,\r\n      color: 'text-green-600',\r\n      bgColor: 'bg-green-50',\r\n    },\r\n    {\r\n      title: 'Overdue',\r\n      value: stats.overdueTasks,\r\n      icon: AlertTriangle,\r\n      color: 'text-red-600',\r\n      bgColor: 'bg-red-50',\r\n    },\r\n    {\r\n      title: 'High Priority',\r\n      value: stats.highPriorityPending,\r\n      icon: TrendingUp,\r\n      color: 'text-orange-600',\r\n      bgColor: 'bg-orange-50',\r\n    },\r\n  ];\r\n\r\n  if (stats.totalTasks === 0) {\r\n    return (\r\n      <Card>\r\n        <CardContent className=\"p-6 text-center\">\r\n          <p className=\"text-gray-500\">No tasks yet. Create your first task to see statistics!</p>\r\n        </CardContent>\r\n      </Card>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      {/* Quick Stats Grid */}\r\n      <div className=\"grid grid-cols-2 lg:grid-cols-4 gap-4\">\r\n        {statCards.map((stat) => (\r\n          <Card key={stat.title}>\r\n            <CardContent className=\"p-4\">\r\n              <div className=\"flex items-center space-x-3\">\r\n                <div className={`p-2 rounded-lg ${stat.bgColor}`}>\r\n                  <stat.icon className={`h-4 w-4 ${stat.color}`} />\r\n                </div>\r\n                <div>\r\n                  <p className=\"text-2xl font-bold text-gray-900\">{stat.value}</p>\r\n                  <p className=\"text-xs text-gray-600\">{stat.title}</p>\r\n                </div>\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n        ))}\r\n      </div>\r\n\r\n      {/* Progress Cards */}\r\n      <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\r\n        {/* Overall Progress */}\r\n        <Card>\r\n          <CardHeader>\r\n            <CardTitle className=\"text-base\">Overall Progress</CardTitle>\r\n          </CardHeader>\r\n          <CardContent>\r\n            <div className=\"space-y-3\">\r\n              <div className=\"flex items-center justify-between text-sm\">\r\n                <span>Completion Rate</span>\r\n                <span className=\"font-semibold\">{stats.completionRate}%</span>\r\n              </div>\r\n              <Progress value={stats.completionRate} className=\"h-2\" />\r\n              <p className=\"text-xs text-gray-600\">\r\n                {stats.completedTasks} of {stats.totalTasks} tasks completed\r\n              </p>\r\n            </div>\r\n          </CardContent>\r\n        </Card>\r\n\r\n        {/* Today's Progress */}\r\n        <Card>\r\n          <CardHeader>\r\n            <CardTitle className=\"text-base\">Today's Progress</CardTitle>\r\n          </CardHeader>\r\n          <CardContent>\r\n            <div className=\"space-y-3\">\r\n              <div className=\"flex items-center justify-between text-sm\">\r\n                <span>Today's Completion</span>\r\n                <span className=\"font-semibold\">{stats.todayCompletionRate}%</span>\r\n              </div>\r\n              <Progress value={stats.todayCompletionRate} className=\"h-2\" />\r\n              <p className=\"text-xs text-gray-600\">\r\n                {stats.todayCompleted} of {stats.todayTasks} today's tasks completed\r\n              </p>\r\n            </div>\r\n          </CardContent>\r\n        </Card>\r\n      </div>\r\n\r\n      {/* Motivational Message */}\r\n      {stats.completionRate > 80 && (\r\n        <Card className=\"bg-green-50 border-green-200\">\r\n          <CardContent className=\"p-4 text-center\">\r\n            <p className=\"text-green-800 font-medium\"> Excellent work!</p>\r\n            <p className=\"text-green-700 text-sm mt-1\">\r\n              You're doing great with a {stats.completionRate}% completion rate!\r\n            </p>\r\n          </CardContent>\r\n        </Card>\r\n      )}\r\n\r\n      {stats.overdueTasks > 0 && (\r\n        <Card className=\"bg-orange-50 border-orange-200\">\r\n          <CardContent className=\"p-4 text-center\">\r\n            <p className=\"text-orange-800 font-medium\"> Heads up!</p>\r\n            <p className=\"text-orange-700 text-sm mt-1\">\r\n              You have {stats.overdueTasks} overdue task{stats.overdueTasks === 1 ? '' : 's'}. \r\n              Consider updating your schedule or completing them soon.\r\n            </p>\r\n          </CardContent>\r\n        </Card>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TaskStats;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3938, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/components/tasks/TaskPageContent.tsx"],"sourcesContent":["\r\nimport React from 'react';\r\nimport { TabsContent } from '@/components/ui/tabs';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Plus, Calendar } from 'lucide-react';\r\nimport { Task } from '@/types/task';\r\nimport TaskList from './TaskList';\r\nimport TaskCalendar from './TaskCalendar';\r\nimport TaskStats from './TaskStats';\r\nimport TaskItems from './TaskItems';\r\n\r\ninterface TaskPageContentProps {\r\n  tasks: Task[];\r\n  todayTasks: Task[];\r\n  onToggleComplete: (id: string) => Promise<boolean>;\r\n  onEdit: (task: Task) => void;\r\n  onDelete: (id: string) => Promise<boolean>;\r\n  onBulkComplete: (taskIds: string[]) => Promise<boolean>;\r\n  onCreateTask: () => void;\r\n  canCreate?: boolean;\r\n  canEdit?: boolean;\r\n  canDelete?: boolean;\r\n}\r\n\r\nconst TaskPageContent: React.FC<TaskPageContentProps> = ({\r\n  tasks,\r\n  todayTasks,\r\n  onToggleComplete,\r\n  onEdit,\r\n  onDelete,\r\n  onBulkComplete,\r\n  onCreateTask,\r\n  canCreate = true,\r\n  canEdit = true,\r\n  canDelete = true,\r\n}) => {\r\n  return (\r\n    <>\r\n      <TabsContent value=\"list\" className=\"space-y-6\">\r\n        <TaskList\r\n          tasks={tasks}\r\n          onToggleComplete={onToggleComplete}\r\n          onEdit={onEdit}\r\n          onDelete={onDelete}\r\n          onBulkComplete={onBulkComplete}\r\n          canEdit={canEdit}\r\n          canDelete={canDelete}\r\n        />\r\n      </TabsContent>\r\n\r\n      <TabsContent value=\"calendar\" className=\"space-y-6\">\r\n        <TaskCalendar\r\n          tasks={tasks}\r\n          onToggleComplete={onToggleComplete}\r\n          onEdit={onEdit}\r\n          onDelete={onDelete}\r\n          canEdit={canEdit}\r\n          canDelete={canDelete}\r\n        />\r\n      </TabsContent>\r\n\r\n      <TabsContent value=\"today\" className=\"space-y-6\">\r\n        <div className=\"bg-white rounded-lg border p-6\">\r\n          <div className=\"flex items-center justify-between mb-6\">\r\n            <h2 className=\"text-xl font-semibold\">Today's Tasks</h2>\r\n            {canCreate && (\r\n              <Button onClick={onCreateTask} variant=\"outline\" size=\"sm\">\r\n                <Plus className=\"w-4 h-4 mr-2\" />\r\n                Add Task\r\n              </Button>\r\n            )}\r\n          </div>\r\n\r\n          {todayTasks.length === 0 ? (\r\n            <div className=\"text-center py-12\">\r\n              <div className=\"text-gray-400 mb-4\">\r\n                <Calendar className=\"w-16 h-16 mx-auto mb-4\" />\r\n                <p className=\"text-lg font-medium text-gray-600\">No tasks for today</p>\r\n                <p className=\"text-sm text-gray-500 mt-1\">Time for a coffee break </p>\r\n              </div>\r\n            </div>\r\n          ) : (\r\n            <TaskItems\r\n              tasks={todayTasks}\r\n              onToggleComplete={onToggleComplete}\r\n              onEdit={onEdit}\r\n              onDelete={onDelete}\r\n              canEdit={canEdit}\r\n              canDelete={canDelete}\r\n            />\r\n          )}\r\n        </div>\r\n      </TabsContent>\r\n\r\n      <TabsContent value=\"stats\" className=\"space-y-6\">\r\n        <TaskStats tasks={tasks} />\r\n      </TabsContent>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default TaskPageContent;\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;;;;;;;;;AAeA,MAAM,kBAAkD,CAAC,EACvD,KAAK,EACL,UAAU,EACV,gBAAgB,EAChB,MAAM,EACN,QAAQ,EACR,cAAc,EACd,YAAY,EACZ,YAAY,IAAI,EAChB,UAAU,IAAI,EACd,YAAY,IAAI,EACjB;IACC,qBACE;;0BACE,6LAAC,kJAAW;gBAAC,OAAM;gBAAO,WAAU;0BAClC,cAAA,6LAAC,qJAAQ;oBACP,OAAO;oBACP,kBAAkB;oBAClB,QAAQ;oBACR,UAAU;oBACV,gBAAgB;oBAChB,SAAS;oBACT,WAAW;;;;;;;;;;;0BAIf,6LAAC,kJAAW;gBAAC,OAAM;gBAAW,WAAU;0BACtC,cAAA,6LAAC,yJAAY;oBACX,OAAO;oBACP,kBAAkB;oBAClB,QAAQ;oBACR,UAAU;oBACV,SAAS;oBACT,WAAW;;;;;;;;;;;0BAIf,6LAAC,kJAAW;gBAAC,OAAM;gBAAQ,WAAU;0BACnC,cAAA,6LAAC;oBAAI,WAAU;;sCACb,6LAAC;4BAAI,WAAU;;8CACb,6LAAC;oCAAG,WAAU;8CAAwB;;;;;;gCACrC,2BACC,6LAAC,+IAAM;oCAAC,SAAS;oCAAc,SAAQ;oCAAU,MAAK;;sDACpD,6LAAC,6MAAI;4CAAC,WAAU;;;;;;wCAAiB;;;;;;;;;;;;;wBAMtC,WAAW,MAAM,KAAK,kBACrB,6LAAC;4BAAI,WAAU;sCACb,cAAA,6LAAC;gCAAI,WAAU;;kDACb,6LAAC,yNAAQ;wCAAC,WAAU;;;;;;kDACpB,6LAAC;wCAAE,WAAU;kDAAoC;;;;;;kDACjD,6LAAC;wCAAE,WAAU;kDAA6B;;;;;;;;;;;;;;;;qFAI9C,6LAAC,sJAAS;4BACR,OAAO;4BACP,kBAAkB;4BAClB,QAAQ;4BACR,UAAU;4BACV,SAAS;4BACT,WAAW;;;;;;;;;;;;;;;;;0BAMnB,6LAAC,kJAAW;gBAAC,OAAM;gBAAQ,WAAU;0BACnC,cAAA,6LAAC,sJAAS;oBAAC,OAAO;;;;;;;;;;;;;AAI1B;KA3EM;uCA6ES"}},
    {"offset": {"line": 4135, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/FINAL/src/pages/Tasks.tsx"],"sourcesContent":["import React from 'react';\r\nimport { Tabs } from '@/components/ui/tabs';\r\nimport { useTasks } from '@/hooks/useTasks';\r\nimport { useTaskCategories } from '@/hooks/useTaskCategories';\r\nimport { useAuth } from '@/components/auth/AuthProvider';\r\nimport { useTaskPageLogic } from '@/hooks/useTaskPageLogic';\r\nimport TaskForm from '@/components/tasks/TaskForm';\r\nimport TaskPageHeader from '@/components/tasks/TaskPageHeader';\r\nimport TaskTabNavigation from '@/components/tasks/TaskTabNavigation';\r\nimport TaskPageContent from '@/components/tasks/TaskPageContent';\r\nimport { useProfiles } from '@/contexts/ProfileContext';\r\nimport { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';\r\nimport { AlertCircle, ArrowLeft } from 'lucide-react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { Button } from '@/components/ui/button';\r\n\r\nconst Tasks = () => {\r\n  const { user } = useAuth();\r\n  const { hasPermission, isLoading: profilesLoading } = useProfiles();\r\n  const navigate = useNavigate();\r\n\r\n  // Permissions\r\n  const canView = hasPermission('tasks', 'view');\r\n  const canCreate = hasPermission('tasks', 'create');\r\n  const canEdit = hasPermission('tasks', 'edit');\r\n  const canDelete = hasPermission('tasks', 'delete');\r\n\r\n  // Use error boundaries for hooks\r\n  let tasksData;\r\n  let categoriesData;\r\n\r\n  try {\r\n    tasksData = useTasks();\r\n  } catch (error) {\r\n    console.error('Error in useTasks:', error);\r\n    tasksData = { tasks: [], isLoading: false, createTask: async () => null, updateTask: async () => false, deleteTask: async () => false, toggleTaskCompletion: async () => false, bulkUpdateTasks: async () => false };\r\n  }\r\n\r\n  try {\r\n    categoriesData = useTaskCategories();\r\n  } catch (error) {\r\n    console.error('Error in useTaskCategories:', error);\r\n    categoriesData = { categories: [], createDefaultCategories: async () => { } };\r\n  }\r\n\r\n  const { tasks, isLoading, createTask, updateTask, deleteTask, toggleTaskCompletion, bulkUpdateTasks } = tasksData;\r\n  const { categories, createDefaultCategories } = categoriesData;\r\n\r\n  const taskPageLogic = useTaskPageLogic({\r\n    tasks,\r\n    createTask,\r\n    updateTask,\r\n    deleteTask,\r\n    toggleTaskCompletion,\r\n    bulkUpdateTasks,\r\n  });\r\n\r\n  // Create default categories on first load if none exist\r\n  React.useEffect(() => {\r\n    if (categories.length === 0 && !isLoading) {\r\n      createDefaultCategories();\r\n    }\r\n  }, [categories.length, isLoading, createDefaultCategories]);\r\n\r\n  if (!user) {\r\n    return (\r\n      <div className=\"max-w-4xl mx-auto p-6\">\r\n        <div className=\"bg-amber-50 border border-amber-200 p-4 rounded-md\">\r\n          <p className=\"text-amber-800\">\r\n            You need to be signed in to manage your tasks. All tasks are saved to your account.\r\n          </p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (profilesLoading || isLoading) {\r\n    return (\r\n      <div className=\"flex items-center justify-center min-h-[400px]\">\r\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600\"></div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!canView) {\r\n    return (\r\n      <div className=\"max-w-4xl mx-auto p-6\">\r\n        <Alert variant=\"destructive\">\r\n          <AlertCircle className=\"h-4 w-4\" />\r\n          <AlertTitle>Access Denied</AlertTitle>\r\n          <AlertDescription>\r\n            You do not have permission to view the tasks module.\r\n            Please contact your administrator if you believe this is an error.\r\n          </AlertDescription>\r\n        </Alert>\r\n        <div className=\"mt-4\">\r\n          <Button onClick={() => navigate('/')} variant=\"outline\" className=\"gap-2\">\r\n            <ArrowLeft className=\"h-4 w-4\" />\r\n            Back to Dashboard\r\n          </Button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"max-w-6xl mx-auto p-4 sm:p-6\">\r\n      <TaskPageHeader\r\n        pendingTodayTasksCount={taskPageLogic.pendingTodayTasks.length}\r\n        totalTasksCount={tasks.length}\r\n        onCreateTask={taskPageLogic.handleCreateTask}\r\n        canCreate={canCreate}\r\n      />\r\n\r\n      <Tabs value={taskPageLogic.activeTab} onValueChange={taskPageLogic.setActiveTab} className=\"space-y-6\">\r\n        <TaskTabNavigation activeTab={taskPageLogic.activeTab} />\r\n\r\n        <TaskPageContent\r\n          tasks={tasks}\r\n          todayTasks={taskPageLogic.todayTasks}\r\n          onToggleComplete={taskPageLogic.toggleTaskCompletion}\r\n          onEdit={taskPageLogic.handleEditTask}\r\n          onDelete={taskPageLogic.handleDeleteTask}\r\n          onBulkComplete={taskPageLogic.handleBulkComplete}\r\n          onCreateTask={taskPageLogic.handleCreateTask}\r\n          canCreate={canCreate}\r\n          canEdit={canEdit}\r\n          canDelete={canDelete}\r\n        />\r\n      </Tabs>\r\n\r\n      <TaskForm\r\n        isOpen={taskPageLogic.isTaskFormOpen}\r\n        onClose={taskPageLogic.handleFormClose}\r\n        onSubmit={taskPageLogic.handleFormSubmit}\r\n        task={taskPageLogic.editingTask}\r\n        initialDate={taskPageLogic.selectedDate || undefined}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Tasks;\r\n"],"names":[],"mappings":"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"}}]
}